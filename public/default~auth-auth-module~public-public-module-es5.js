function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~auth-auth-module~public-public-module"], {
  /***/
  "./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.component.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.component.js ***!
    \****************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAngular2Chartjs__ivy_ngcc__DistChartComponentJs(module, exports, __webpack_require__) {
    "use strict";

    var core_1 = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ɵngcc0 = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ChartComponent = function () {
      function ChartComponent(elementRef) {
        this.elementRef = elementRef;
      }

      ChartComponent.prototype.ngOnInit = function () {
        this.create();
      };

      ChartComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;

        if (this.chart) {
          if (changes['type'] || changes['options']) {
            this.create();
          } else if (changes['data']) {
            var currentValue_1 = changes['data'].currentValue;
            ['datasets', 'labels', 'xLabels', 'yLabels'].forEach(function (property) {
              _this.chart.data[property] = currentValue_1[property];
            });
            this.chart.update();
          }
        }
      };

      ChartComponent.prototype.create = function () {
        if (this.canvas) {
          this.elementRef.nativeElement.removeChild(this.canvas);
        }

        this.canvas = document.createElement('canvas');
        this.elementRef.nativeElement.appendChild(this.canvas);
        this.chart = new Chart(this.canvas, {
          type: this.type,
          data: this.data,
          options: this.options
        });
      };

      ChartComponent.ctorParameters = function () {
        return [{
          type: core_1.ElementRef
        }];
      };

      ChartComponent.propDecorators = {
        'type': [{
          type: core_1.Input
        }],
        'data': [{
          type: core_1.Input
        }],
        'options': [{
          type: core_1.Input
        }]
      };

      ChartComponent.ɵfac = function ChartComponent_Factory(t) {
        return new (t || ChartComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));
      };

      ChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
        type: ChartComponent,
        selectors: [["chart"]],
        inputs: {
          type: "type",
          data: "data",
          options: "options"
        },
        features: [ɵngcc0.ɵɵNgOnChangesFeature],
        decls: 0,
        vars: 0,
        template: function ChartComponent_Template(rf, ctx) {},
        styles: ["[_nghost-%COMP%] { display: block; }"]
      });
      /*@__PURE__*/

      (function () {
        ɵngcc0.ɵsetClassMetadata(ChartComponent, [{
          type: core_1.Component,
          args: [{
            selector: 'chart',
            template: '',
            styles: [':host { display: block; }']
          }]
        }], function () {
          return [{
            type: ɵngcc0.ElementRef
          }];
        }, {
          type: [{
            type: core_1.Input
          }],
          data: [{
            type: core_1.Input
          }],
          options: [{
            type: core_1.Input
          }]
        });
      })();

      return ChartComponent;
    }();

    exports.ChartComponent = ChartComponent; //# sourceMappingURL=chart.component.js.map

    /***/
  },

  /***/
  "./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.module.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.module.js ***!
    \*************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAngular2Chartjs__ivy_ngcc__DistChartModuleJs(module, exports, __webpack_require__) {
    "use strict";

    if (typeof window === 'object') {
      __webpack_require__(
      /*! chart.js */
      "./node_modules/chart.js/src/chart.js");
    }

    var core_1 = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var chart_component_1 = __webpack_require__(
    /*! ./chart.component */
    "./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.component.js");

    var ɵngcc0 = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var ɵngcc1 = __webpack_require__(
    /*! ./chart.component */
    "./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.component.js");

    var ChartModule = function () {
      function ChartModule() {}

      ChartModule.ctorParameters = function () {
        return [];
      };

      ChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({
        type: ChartModule
      });
      ChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
        factory: function ChartModule_Factory(t) {
          return new (t || ChartModule)();
        }
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartModule, {
          declarations: [ɵngcc1.ChartComponent],
          exports: [ɵngcc1.ChartComponent]
        });
      })();
      /*@__PURE__*/


      (function () {
        ɵngcc0.ɵsetClassMetadata(ChartModule, [{
          type: core_1.NgModule,
          args: [{
            declarations: [chart_component_1.ChartComponent],
            exports: [chart_component_1.ChartComponent]
          }]
        }], function () {
          return [];
        }, null);
      })();

      return ChartModule;
    }();

    exports.ChartModule = ChartModule; //# sourceMappingURL=chart.module.js.map

    /***/
  },

  /***/
  "./node_modules/angular2-chartjs/__ivy_ngcc__/dist/index.js":
  /*!******************************************************************!*\
    !*** ./node_modules/angular2-chartjs/__ivy_ngcc__/dist/index.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAngular2Chartjs__ivy_ngcc__DistIndexJs(module, exports, __webpack_require__) {
    "use strict";

    function __export(m) {
      for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
      }
    }

    __export(__webpack_require__(
    /*! ./chart.component */
    "./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.component.js"));

    __export(__webpack_require__(
    /*! ./chart.module */
    "./node_modules/angular2-chartjs/__ivy_ngcc__/dist/chart.module.js")); //# sourceMappingURL=index.js.map

    /***/

  },

  /***/
  "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json":
  /*!************************************************************************!*\
    !*** ./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json ***!
    \************************************************************************/

  /*! exports provided: version, metadata, operations, shapes, default */

  /***/
  function node_modulesAwsSdkApisCognitoIdentity20140630MinJson(module) {
    module.exports = JSON.parse("{\"version\":\"2.0\",\"metadata\":{\"apiVersion\":\"2014-06-30\",\"endpointPrefix\":\"cognito-identity\",\"jsonVersion\":\"1.1\",\"protocol\":\"json\",\"serviceFullName\":\"Amazon Cognito Identity\",\"serviceId\":\"Cognito Identity\",\"signatureVersion\":\"v4\",\"targetPrefix\":\"AWSCognitoIdentityService\",\"uid\":\"cognito-identity-2014-06-30\"},\"operations\":{\"CreateIdentityPool\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolName\",\"AllowUnauthenticatedIdentities\"],\"members\":{\"IdentityPoolName\":{},\"AllowUnauthenticatedIdentities\":{\"type\":\"boolean\"},\"AllowClassicFlow\":{\"type\":\"boolean\"},\"SupportedLoginProviders\":{\"shape\":\"S5\"},\"DeveloperProviderName\":{},\"OpenIdConnectProviderARNs\":{\"shape\":\"S9\"},\"CognitoIdentityProviders\":{\"shape\":\"Sb\"},\"SamlProviderARNs\":{\"shape\":\"Sg\"},\"IdentityPoolTags\":{\"shape\":\"Sh\"}}},\"output\":{\"shape\":\"Sk\"}},\"DeleteIdentities\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityIdsToDelete\"],\"members\":{\"IdentityIdsToDelete\":{\"type\":\"list\",\"member\":{}}}},\"output\":{\"type\":\"structure\",\"members\":{\"UnprocessedIdentityIds\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{},\"ErrorCode\":{}}}}}}},\"DeleteIdentityPool\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\"],\"members\":{\"IdentityPoolId\":{}}}},\"DescribeIdentity\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityId\"],\"members\":{\"IdentityId\":{}}},\"output\":{\"shape\":\"Sv\"}},\"DescribeIdentityPool\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\"],\"members\":{\"IdentityPoolId\":{}}},\"output\":{\"shape\":\"Sk\"}},\"GetCredentialsForIdentity\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityId\"],\"members\":{\"IdentityId\":{},\"Logins\":{\"shape\":\"S10\"},\"CustomRoleArn\":{}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{},\"Credentials\":{\"type\":\"structure\",\"members\":{\"AccessKeyId\":{},\"SecretKey\":{},\"SessionToken\":{},\"Expiration\":{\"type\":\"timestamp\"}}}}},\"authtype\":\"none\"},\"GetId\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\"],\"members\":{\"AccountId\":{},\"IdentityPoolId\":{},\"Logins\":{\"shape\":\"S10\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{}}},\"authtype\":\"none\"},\"GetIdentityPoolRoles\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\"],\"members\":{\"IdentityPoolId\":{}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityPoolId\":{},\"Roles\":{\"shape\":\"S1c\"},\"RoleMappings\":{\"shape\":\"S1e\"}}}},\"GetOpenIdToken\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityId\"],\"members\":{\"IdentityId\":{},\"Logins\":{\"shape\":\"S10\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{},\"Token\":{}}},\"authtype\":\"none\"},\"GetOpenIdTokenForDeveloperIdentity\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\",\"Logins\"],\"members\":{\"IdentityPoolId\":{},\"IdentityId\":{},\"Logins\":{\"shape\":\"S10\"},\"PrincipalTags\":{\"shape\":\"S1s\"},\"TokenDuration\":{\"type\":\"long\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{},\"Token\":{}}}},\"GetPrincipalTagAttributeMap\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\",\"IdentityProviderName\"],\"members\":{\"IdentityPoolId\":{},\"IdentityProviderName\":{}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityPoolId\":{},\"IdentityProviderName\":{},\"UseDefaults\":{\"type\":\"boolean\"},\"PrincipalTags\":{\"shape\":\"S1s\"}}}},\"ListIdentities\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\",\"MaxResults\"],\"members\":{\"IdentityPoolId\":{},\"MaxResults\":{\"type\":\"integer\"},\"NextToken\":{},\"HideDisabled\":{\"type\":\"boolean\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityPoolId\":{},\"Identities\":{\"type\":\"list\",\"member\":{\"shape\":\"Sv\"}},\"NextToken\":{}}}},\"ListIdentityPools\":{\"input\":{\"type\":\"structure\",\"required\":[\"MaxResults\"],\"members\":{\"MaxResults\":{\"type\":\"integer\"},\"NextToken\":{}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityPools\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"IdentityPoolId\":{},\"IdentityPoolName\":{}}}},\"NextToken\":{}}}},\"ListTagsForResource\":{\"input\":{\"type\":\"structure\",\"required\":[\"ResourceArn\"],\"members\":{\"ResourceArn\":{}}},\"output\":{\"type\":\"structure\",\"members\":{\"Tags\":{\"shape\":\"Sh\"}}}},\"LookupDeveloperIdentity\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\"],\"members\":{\"IdentityPoolId\":{},\"IdentityId\":{},\"DeveloperUserIdentifier\":{},\"MaxResults\":{\"type\":\"integer\"},\"NextToken\":{}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{},\"DeveloperUserIdentifierList\":{\"type\":\"list\",\"member\":{}},\"NextToken\":{}}}},\"MergeDeveloperIdentities\":{\"input\":{\"type\":\"structure\",\"required\":[\"SourceUserIdentifier\",\"DestinationUserIdentifier\",\"DeveloperProviderName\",\"IdentityPoolId\"],\"members\":{\"SourceUserIdentifier\":{},\"DestinationUserIdentifier\":{},\"DeveloperProviderName\":{},\"IdentityPoolId\":{}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{}}}},\"SetIdentityPoolRoles\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\",\"Roles\"],\"members\":{\"IdentityPoolId\":{},\"Roles\":{\"shape\":\"S1c\"},\"RoleMappings\":{\"shape\":\"S1e\"}}}},\"SetPrincipalTagAttributeMap\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\",\"IdentityProviderName\"],\"members\":{\"IdentityPoolId\":{},\"IdentityProviderName\":{},\"UseDefaults\":{\"type\":\"boolean\"},\"PrincipalTags\":{\"shape\":\"S1s\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IdentityPoolId\":{},\"IdentityProviderName\":{},\"UseDefaults\":{\"type\":\"boolean\"},\"PrincipalTags\":{\"shape\":\"S1s\"}}}},\"TagResource\":{\"input\":{\"type\":\"structure\",\"required\":[\"ResourceArn\",\"Tags\"],\"members\":{\"ResourceArn\":{},\"Tags\":{\"shape\":\"Sh\"}}},\"output\":{\"type\":\"structure\",\"members\":{}}},\"UnlinkDeveloperIdentity\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityId\",\"IdentityPoolId\",\"DeveloperProviderName\",\"DeveloperUserIdentifier\"],\"members\":{\"IdentityId\":{},\"IdentityPoolId\":{},\"DeveloperProviderName\":{},\"DeveloperUserIdentifier\":{}}}},\"UnlinkIdentity\":{\"input\":{\"type\":\"structure\",\"required\":[\"IdentityId\",\"Logins\",\"LoginsToRemove\"],\"members\":{\"IdentityId\":{},\"Logins\":{\"shape\":\"S10\"},\"LoginsToRemove\":{\"shape\":\"Sw\"}}},\"authtype\":\"none\"},\"UntagResource\":{\"input\":{\"type\":\"structure\",\"required\":[\"ResourceArn\",\"TagKeys\"],\"members\":{\"ResourceArn\":{},\"TagKeys\":{\"type\":\"list\",\"member\":{}}}},\"output\":{\"type\":\"structure\",\"members\":{}}},\"UpdateIdentityPool\":{\"input\":{\"shape\":\"Sk\"},\"output\":{\"shape\":\"Sk\"}}},\"shapes\":{\"S5\":{\"type\":\"map\",\"key\":{},\"value\":{}},\"S9\":{\"type\":\"list\",\"member\":{}},\"Sb\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"ProviderName\":{},\"ClientId\":{},\"ServerSideTokenCheck\":{\"type\":\"boolean\"}}}},\"Sg\":{\"type\":\"list\",\"member\":{}},\"Sh\":{\"type\":\"map\",\"key\":{},\"value\":{}},\"Sk\":{\"type\":\"structure\",\"required\":[\"IdentityPoolId\",\"IdentityPoolName\",\"AllowUnauthenticatedIdentities\"],\"members\":{\"IdentityPoolId\":{},\"IdentityPoolName\":{},\"AllowUnauthenticatedIdentities\":{\"type\":\"boolean\"},\"AllowClassicFlow\":{\"type\":\"boolean\"},\"SupportedLoginProviders\":{\"shape\":\"S5\"},\"DeveloperProviderName\":{},\"OpenIdConnectProviderARNs\":{\"shape\":\"S9\"},\"CognitoIdentityProviders\":{\"shape\":\"Sb\"},\"SamlProviderARNs\":{\"shape\":\"Sg\"},\"IdentityPoolTags\":{\"shape\":\"Sh\"}}},\"Sv\":{\"type\":\"structure\",\"members\":{\"IdentityId\":{},\"Logins\":{\"shape\":\"Sw\"},\"CreationDate\":{\"type\":\"timestamp\"},\"LastModifiedDate\":{\"type\":\"timestamp\"}}},\"Sw\":{\"type\":\"list\",\"member\":{}},\"S10\":{\"type\":\"map\",\"key\":{},\"value\":{}},\"S1c\":{\"type\":\"map\",\"key\":{},\"value\":{}},\"S1e\":{\"type\":\"map\",\"key\":{},\"value\":{\"type\":\"structure\",\"required\":[\"Type\"],\"members\":{\"Type\":{},\"AmbiguousRoleResolution\":{},\"RulesConfiguration\":{\"type\":\"structure\",\"required\":[\"Rules\"],\"members\":{\"Rules\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"Claim\",\"MatchType\",\"Value\",\"RoleARN\"],\"members\":{\"Claim\":{},\"MatchType\":{},\"Value\":{},\"RoleARN\":{}}}}}}}}},\"S1s\":{\"type\":\"map\",\"key\":{},\"value\":{}}}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json":
  /*!*******************************************************************************!*\
    !*** ./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json ***!
    \*******************************************************************************/

  /*! exports provided: pagination, default */

  /***/
  function node_modulesAwsSdkApisCognitoIdentity20140630PaginatorsJson(module) {
    module.exports = JSON.parse("{\"pagination\":{\"ListIdentityPools\":{\"input_token\":\"NextToken\",\"limit_key\":\"MaxResults\",\"output_token\":\"NextToken\",\"result_key\":\"IdentityPools\"}}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/apis/metadata.json":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/apis/metadata.json ***!
    \*************************************************/

  /*! exports provided: acm, apigateway, applicationautoscaling, appstream, autoscaling, batch, budgets, clouddirectory, cloudformation, cloudfront, cloudhsm, cloudsearch, cloudsearchdomain, cloudtrail, cloudwatch, cloudwatchevents, cloudwatchlogs, codebuild, codecommit, codedeploy, codepipeline, cognitoidentity, cognitoidentityserviceprovider, cognitosync, configservice, cur, datapipeline, devicefarm, directconnect, directoryservice, discovery, dms, dynamodb, dynamodbstreams, ec2, ecr, ecs, efs, elasticache, elasticbeanstalk, elb, elbv2, emr, es, elastictranscoder, firehose, gamelift, glacier, health, iam, importexport, inspector, iot, iotdata, kinesis, kinesisanalytics, kms, lambda, lexruntime, lightsail, machinelearning, marketplacecommerceanalytics, marketplacemetering, mturk, mobileanalytics, opsworks, opsworkscm, organizations, pinpoint, polly, rds, redshift, rekognition, resourcegroupstaggingapi, route53, route53domains, s3, s3control, servicecatalog, ses, shield, simpledb, sms, snowball, sns, sqs, ssm, storagegateway, stepfunctions, sts, support, swf, xray, waf, wafregional, workdocs, workspaces, codestar, lexmodelbuildingservice, marketplaceentitlementservice, athena, greengrass, dax, migrationhub, cloudhsmv2, glue, mobile, pricing, costexplorer, mediaconvert, medialive, mediapackage, mediastore, mediastoredata, appsync, guardduty, mq, comprehend, iotjobsdataplane, kinesisvideoarchivedmedia, kinesisvideomedia, kinesisvideo, sagemakerruntime, sagemaker, translate, resourcegroups, alexaforbusiness, cloud9, serverlessapplicationrepository, servicediscovery, workmail, autoscalingplans, transcribeservice, connect, acmpca, fms, secretsmanager, iotanalytics, iot1clickdevicesservice, iot1clickprojects, pi, neptune, mediatailor, eks, macie, dlm, signer, chime, pinpointemail, ram, route53resolver, pinpointsmsvoice, quicksight, rdsdataservice, amplify, datasync, robomaker, transfer, globalaccelerator, comprehendmedical, kinesisanalyticsv2, mediaconnect, fsx, securityhub, appmesh, licensemanager, kafka, apigatewaymanagementapi, apigatewayv2, docdb, backup, worklink, textract, managedblockchain, mediapackagevod, groundstation, iotthingsgraph, iotevents, ioteventsdata, personalize, personalizeevents, personalizeruntime, applicationinsights, servicequotas, ec2instanceconnect, eventbridge, lakeformation, forecastservice, forecastqueryservice, qldb, qldbsession, workmailmessageflow, codestarnotifications, savingsplans, sso, ssooidc, marketplacecatalog, dataexchange, sesv2, migrationhubconfig, connectparticipant, appconfig, iotsecuretunneling, wafv2, elasticinference, imagebuilder, schemas, accessanalyzer, codegurureviewer, codeguruprofiler, computeoptimizer, frauddetector, kendra, networkmanager, outposts, augmentedairuntime, ebs, kinesisvideosignalingchannels, detective, codestarconnections, synthetics, iotsitewise, macie2, codeartifact, honeycode, ivs, braket, identitystore, appflow, redshiftdata, ssoadmin, timestreamquery, timestreamwrite, s3outposts, databrew, servicecatalogappregistry, networkfirewall, mwaa, amplifybackend, appintegrations, connectcontactlens, devopsguru, ecrpublic, lookoutvision, sagemakerfeaturestoreruntime, customerprofiles, auditmanager, emrcontainers, healthlake, sagemakeredge, amp, greengrassv2, iotdeviceadvisor, iotfleethub, iotwireless, location, wellarchitected, default */

  /***/
  function node_modulesAwsSdkApisMetadataJson(module) {
    module.exports = JSON.parse("{\"acm\":{\"name\":\"ACM\",\"cors\":true},\"apigateway\":{\"name\":\"APIGateway\",\"cors\":true},\"applicationautoscaling\":{\"prefix\":\"application-autoscaling\",\"name\":\"ApplicationAutoScaling\",\"cors\":true},\"appstream\":{\"name\":\"AppStream\"},\"autoscaling\":{\"name\":\"AutoScaling\",\"cors\":true},\"batch\":{\"name\":\"Batch\"},\"budgets\":{\"name\":\"Budgets\"},\"clouddirectory\":{\"name\":\"CloudDirectory\",\"versions\":[\"2016-05-10*\"]},\"cloudformation\":{\"name\":\"CloudFormation\",\"cors\":true},\"cloudfront\":{\"name\":\"CloudFront\",\"versions\":[\"2013-05-12*\",\"2013-11-11*\",\"2014-05-31*\",\"2014-10-21*\",\"2014-11-06*\",\"2015-04-17*\",\"2015-07-27*\",\"2015-09-17*\",\"2016-01-13*\",\"2016-01-28*\",\"2016-08-01*\",\"2016-08-20*\",\"2016-09-07*\",\"2016-09-29*\",\"2016-11-25*\",\"2017-03-25*\",\"2017-10-30*\",\"2018-06-18*\",\"2018-11-05*\",\"2019-03-26*\"],\"cors\":true},\"cloudhsm\":{\"name\":\"CloudHSM\",\"cors\":true},\"cloudsearch\":{\"name\":\"CloudSearch\"},\"cloudsearchdomain\":{\"name\":\"CloudSearchDomain\"},\"cloudtrail\":{\"name\":\"CloudTrail\",\"cors\":true},\"cloudwatch\":{\"prefix\":\"monitoring\",\"name\":\"CloudWatch\",\"cors\":true},\"cloudwatchevents\":{\"prefix\":\"events\",\"name\":\"CloudWatchEvents\",\"versions\":[\"2014-02-03*\"],\"cors\":true},\"cloudwatchlogs\":{\"prefix\":\"logs\",\"name\":\"CloudWatchLogs\",\"cors\":true},\"codebuild\":{\"name\":\"CodeBuild\",\"cors\":true},\"codecommit\":{\"name\":\"CodeCommit\",\"cors\":true},\"codedeploy\":{\"name\":\"CodeDeploy\",\"cors\":true},\"codepipeline\":{\"name\":\"CodePipeline\",\"cors\":true},\"cognitoidentity\":{\"prefix\":\"cognito-identity\",\"name\":\"CognitoIdentity\",\"cors\":true},\"cognitoidentityserviceprovider\":{\"prefix\":\"cognito-idp\",\"name\":\"CognitoIdentityServiceProvider\",\"cors\":true},\"cognitosync\":{\"prefix\":\"cognito-sync\",\"name\":\"CognitoSync\",\"cors\":true},\"configservice\":{\"prefix\":\"config\",\"name\":\"ConfigService\",\"cors\":true},\"cur\":{\"name\":\"CUR\",\"cors\":true},\"datapipeline\":{\"name\":\"DataPipeline\"},\"devicefarm\":{\"name\":\"DeviceFarm\",\"cors\":true},\"directconnect\":{\"name\":\"DirectConnect\",\"cors\":true},\"directoryservice\":{\"prefix\":\"ds\",\"name\":\"DirectoryService\"},\"discovery\":{\"name\":\"Discovery\"},\"dms\":{\"name\":\"DMS\"},\"dynamodb\":{\"name\":\"DynamoDB\",\"cors\":true},\"dynamodbstreams\":{\"prefix\":\"streams.dynamodb\",\"name\":\"DynamoDBStreams\",\"cors\":true},\"ec2\":{\"name\":\"EC2\",\"versions\":[\"2013-06-15*\",\"2013-10-15*\",\"2014-02-01*\",\"2014-05-01*\",\"2014-06-15*\",\"2014-09-01*\",\"2014-10-01*\",\"2015-03-01*\",\"2015-04-15*\",\"2015-10-01*\",\"2016-04-01*\",\"2016-09-15*\"],\"cors\":true},\"ecr\":{\"name\":\"ECR\",\"cors\":true},\"ecs\":{\"name\":\"ECS\",\"cors\":true},\"efs\":{\"prefix\":\"elasticfilesystem\",\"name\":\"EFS\",\"cors\":true},\"elasticache\":{\"name\":\"ElastiCache\",\"versions\":[\"2012-11-15*\",\"2014-03-24*\",\"2014-07-15*\",\"2014-09-30*\"],\"cors\":true},\"elasticbeanstalk\":{\"name\":\"ElasticBeanstalk\",\"cors\":true},\"elb\":{\"prefix\":\"elasticloadbalancing\",\"name\":\"ELB\",\"cors\":true},\"elbv2\":{\"prefix\":\"elasticloadbalancingv2\",\"name\":\"ELBv2\",\"cors\":true},\"emr\":{\"prefix\":\"elasticmapreduce\",\"name\":\"EMR\",\"cors\":true},\"es\":{\"name\":\"ES\"},\"elastictranscoder\":{\"name\":\"ElasticTranscoder\",\"cors\":true},\"firehose\":{\"name\":\"Firehose\",\"cors\":true},\"gamelift\":{\"name\":\"GameLift\",\"cors\":true},\"glacier\":{\"name\":\"Glacier\"},\"health\":{\"name\":\"Health\"},\"iam\":{\"name\":\"IAM\",\"cors\":true},\"importexport\":{\"name\":\"ImportExport\"},\"inspector\":{\"name\":\"Inspector\",\"versions\":[\"2015-08-18*\"],\"cors\":true},\"iot\":{\"name\":\"Iot\",\"cors\":true},\"iotdata\":{\"prefix\":\"iot-data\",\"name\":\"IotData\",\"cors\":true},\"kinesis\":{\"name\":\"Kinesis\",\"cors\":true},\"kinesisanalytics\":{\"name\":\"KinesisAnalytics\"},\"kms\":{\"name\":\"KMS\",\"cors\":true},\"lambda\":{\"name\":\"Lambda\",\"cors\":true},\"lexruntime\":{\"prefix\":\"runtime.lex\",\"name\":\"LexRuntime\",\"cors\":true},\"lightsail\":{\"name\":\"Lightsail\"},\"machinelearning\":{\"name\":\"MachineLearning\",\"cors\":true},\"marketplacecommerceanalytics\":{\"name\":\"MarketplaceCommerceAnalytics\",\"cors\":true},\"marketplacemetering\":{\"prefix\":\"meteringmarketplace\",\"name\":\"MarketplaceMetering\"},\"mturk\":{\"prefix\":\"mturk-requester\",\"name\":\"MTurk\",\"cors\":true},\"mobileanalytics\":{\"name\":\"MobileAnalytics\",\"cors\":true},\"opsworks\":{\"name\":\"OpsWorks\",\"cors\":true},\"opsworkscm\":{\"name\":\"OpsWorksCM\"},\"organizations\":{\"name\":\"Organizations\"},\"pinpoint\":{\"name\":\"Pinpoint\"},\"polly\":{\"name\":\"Polly\",\"cors\":true},\"rds\":{\"name\":\"RDS\",\"versions\":[\"2014-09-01*\"],\"cors\":true},\"redshift\":{\"name\":\"Redshift\",\"cors\":true},\"rekognition\":{\"name\":\"Rekognition\",\"cors\":true},\"resourcegroupstaggingapi\":{\"name\":\"ResourceGroupsTaggingAPI\"},\"route53\":{\"name\":\"Route53\",\"cors\":true},\"route53domains\":{\"name\":\"Route53Domains\",\"cors\":true},\"s3\":{\"name\":\"S3\",\"dualstackAvailable\":true,\"cors\":true},\"s3control\":{\"name\":\"S3Control\",\"dualstackAvailable\":true,\"xmlNoDefaultLists\":true},\"servicecatalog\":{\"name\":\"ServiceCatalog\",\"cors\":true},\"ses\":{\"prefix\":\"email\",\"name\":\"SES\",\"cors\":true},\"shield\":{\"name\":\"Shield\"},\"simpledb\":{\"prefix\":\"sdb\",\"name\":\"SimpleDB\"},\"sms\":{\"name\":\"SMS\"},\"snowball\":{\"name\":\"Snowball\"},\"sns\":{\"name\":\"SNS\",\"cors\":true},\"sqs\":{\"name\":\"SQS\",\"cors\":true},\"ssm\":{\"name\":\"SSM\",\"cors\":true},\"storagegateway\":{\"name\":\"StorageGateway\",\"cors\":true},\"stepfunctions\":{\"prefix\":\"states\",\"name\":\"StepFunctions\"},\"sts\":{\"name\":\"STS\",\"cors\":true},\"support\":{\"name\":\"Support\"},\"swf\":{\"name\":\"SWF\"},\"xray\":{\"name\":\"XRay\",\"cors\":true},\"waf\":{\"name\":\"WAF\",\"cors\":true},\"wafregional\":{\"prefix\":\"waf-regional\",\"name\":\"WAFRegional\"},\"workdocs\":{\"name\":\"WorkDocs\",\"cors\":true},\"workspaces\":{\"name\":\"WorkSpaces\"},\"codestar\":{\"name\":\"CodeStar\"},\"lexmodelbuildingservice\":{\"prefix\":\"lex-models\",\"name\":\"LexModelBuildingService\",\"cors\":true},\"marketplaceentitlementservice\":{\"prefix\":\"entitlement.marketplace\",\"name\":\"MarketplaceEntitlementService\"},\"athena\":{\"name\":\"Athena\"},\"greengrass\":{\"name\":\"Greengrass\"},\"dax\":{\"name\":\"DAX\"},\"migrationhub\":{\"prefix\":\"AWSMigrationHub\",\"name\":\"MigrationHub\"},\"cloudhsmv2\":{\"name\":\"CloudHSMV2\"},\"glue\":{\"name\":\"Glue\"},\"mobile\":{\"name\":\"Mobile\"},\"pricing\":{\"name\":\"Pricing\",\"cors\":true},\"costexplorer\":{\"prefix\":\"ce\",\"name\":\"CostExplorer\",\"cors\":true},\"mediaconvert\":{\"name\":\"MediaConvert\"},\"medialive\":{\"name\":\"MediaLive\"},\"mediapackage\":{\"name\":\"MediaPackage\"},\"mediastore\":{\"name\":\"MediaStore\"},\"mediastoredata\":{\"prefix\":\"mediastore-data\",\"name\":\"MediaStoreData\",\"cors\":true},\"appsync\":{\"name\":\"AppSync\"},\"guardduty\":{\"name\":\"GuardDuty\"},\"mq\":{\"name\":\"MQ\"},\"comprehend\":{\"name\":\"Comprehend\",\"cors\":true},\"iotjobsdataplane\":{\"prefix\":\"iot-jobs-data\",\"name\":\"IoTJobsDataPlane\"},\"kinesisvideoarchivedmedia\":{\"prefix\":\"kinesis-video-archived-media\",\"name\":\"KinesisVideoArchivedMedia\",\"cors\":true},\"kinesisvideomedia\":{\"prefix\":\"kinesis-video-media\",\"name\":\"KinesisVideoMedia\",\"cors\":true},\"kinesisvideo\":{\"name\":\"KinesisVideo\",\"cors\":true},\"sagemakerruntime\":{\"prefix\":\"runtime.sagemaker\",\"name\":\"SageMakerRuntime\"},\"sagemaker\":{\"name\":\"SageMaker\"},\"translate\":{\"name\":\"Translate\",\"cors\":true},\"resourcegroups\":{\"prefix\":\"resource-groups\",\"name\":\"ResourceGroups\",\"cors\":true},\"alexaforbusiness\":{\"name\":\"AlexaForBusiness\"},\"cloud9\":{\"name\":\"Cloud9\"},\"serverlessapplicationrepository\":{\"prefix\":\"serverlessrepo\",\"name\":\"ServerlessApplicationRepository\"},\"servicediscovery\":{\"name\":\"ServiceDiscovery\"},\"workmail\":{\"name\":\"WorkMail\"},\"autoscalingplans\":{\"prefix\":\"autoscaling-plans\",\"name\":\"AutoScalingPlans\"},\"transcribeservice\":{\"prefix\":\"transcribe\",\"name\":\"TranscribeService\"},\"connect\":{\"name\":\"Connect\",\"cors\":true},\"acmpca\":{\"prefix\":\"acm-pca\",\"name\":\"ACMPCA\"},\"fms\":{\"name\":\"FMS\"},\"secretsmanager\":{\"name\":\"SecretsManager\",\"cors\":true},\"iotanalytics\":{\"name\":\"IoTAnalytics\",\"cors\":true},\"iot1clickdevicesservice\":{\"prefix\":\"iot1click-devices\",\"name\":\"IoT1ClickDevicesService\"},\"iot1clickprojects\":{\"prefix\":\"iot1click-projects\",\"name\":\"IoT1ClickProjects\"},\"pi\":{\"name\":\"PI\"},\"neptune\":{\"name\":\"Neptune\"},\"mediatailor\":{\"name\":\"MediaTailor\"},\"eks\":{\"name\":\"EKS\"},\"macie\":{\"name\":\"Macie\"},\"dlm\":{\"name\":\"DLM\"},\"signer\":{\"name\":\"Signer\"},\"chime\":{\"name\":\"Chime\"},\"pinpointemail\":{\"prefix\":\"pinpoint-email\",\"name\":\"PinpointEmail\"},\"ram\":{\"name\":\"RAM\"},\"route53resolver\":{\"name\":\"Route53Resolver\"},\"pinpointsmsvoice\":{\"prefix\":\"sms-voice\",\"name\":\"PinpointSMSVoice\"},\"quicksight\":{\"name\":\"QuickSight\"},\"rdsdataservice\":{\"prefix\":\"rds-data\",\"name\":\"RDSDataService\"},\"amplify\":{\"name\":\"Amplify\"},\"datasync\":{\"name\":\"DataSync\"},\"robomaker\":{\"name\":\"RoboMaker\"},\"transfer\":{\"name\":\"Transfer\"},\"globalaccelerator\":{\"name\":\"GlobalAccelerator\"},\"comprehendmedical\":{\"name\":\"ComprehendMedical\",\"cors\":true},\"kinesisanalyticsv2\":{\"name\":\"KinesisAnalyticsV2\"},\"mediaconnect\":{\"name\":\"MediaConnect\"},\"fsx\":{\"name\":\"FSx\"},\"securityhub\":{\"name\":\"SecurityHub\"},\"appmesh\":{\"name\":\"AppMesh\",\"versions\":[\"2018-10-01*\"]},\"licensemanager\":{\"prefix\":\"license-manager\",\"name\":\"LicenseManager\"},\"kafka\":{\"name\":\"Kafka\"},\"apigatewaymanagementapi\":{\"name\":\"ApiGatewayManagementApi\"},\"apigatewayv2\":{\"name\":\"ApiGatewayV2\"},\"docdb\":{\"name\":\"DocDB\"},\"backup\":{\"name\":\"Backup\"},\"worklink\":{\"name\":\"WorkLink\"},\"textract\":{\"name\":\"Textract\"},\"managedblockchain\":{\"name\":\"ManagedBlockchain\"},\"mediapackagevod\":{\"prefix\":\"mediapackage-vod\",\"name\":\"MediaPackageVod\"},\"groundstation\":{\"name\":\"GroundStation\"},\"iotthingsgraph\":{\"name\":\"IoTThingsGraph\"},\"iotevents\":{\"name\":\"IoTEvents\"},\"ioteventsdata\":{\"prefix\":\"iotevents-data\",\"name\":\"IoTEventsData\"},\"personalize\":{\"name\":\"Personalize\",\"cors\":true},\"personalizeevents\":{\"prefix\":\"personalize-events\",\"name\":\"PersonalizeEvents\",\"cors\":true},\"personalizeruntime\":{\"prefix\":\"personalize-runtime\",\"name\":\"PersonalizeRuntime\",\"cors\":true},\"applicationinsights\":{\"prefix\":\"application-insights\",\"name\":\"ApplicationInsights\"},\"servicequotas\":{\"prefix\":\"service-quotas\",\"name\":\"ServiceQuotas\"},\"ec2instanceconnect\":{\"prefix\":\"ec2-instance-connect\",\"name\":\"EC2InstanceConnect\"},\"eventbridge\":{\"name\":\"EventBridge\"},\"lakeformation\":{\"name\":\"LakeFormation\"},\"forecastservice\":{\"prefix\":\"forecast\",\"name\":\"ForecastService\",\"cors\":true},\"forecastqueryservice\":{\"prefix\":\"forecastquery\",\"name\":\"ForecastQueryService\",\"cors\":true},\"qldb\":{\"name\":\"QLDB\"},\"qldbsession\":{\"prefix\":\"qldb-session\",\"name\":\"QLDBSession\"},\"workmailmessageflow\":{\"name\":\"WorkMailMessageFlow\"},\"codestarnotifications\":{\"prefix\":\"codestar-notifications\",\"name\":\"CodeStarNotifications\"},\"savingsplans\":{\"name\":\"SavingsPlans\"},\"sso\":{\"name\":\"SSO\"},\"ssooidc\":{\"prefix\":\"sso-oidc\",\"name\":\"SSOOIDC\"},\"marketplacecatalog\":{\"prefix\":\"marketplace-catalog\",\"name\":\"MarketplaceCatalog\"},\"dataexchange\":{\"name\":\"DataExchange\"},\"sesv2\":{\"name\":\"SESV2\"},\"migrationhubconfig\":{\"prefix\":\"migrationhub-config\",\"name\":\"MigrationHubConfig\"},\"connectparticipant\":{\"name\":\"ConnectParticipant\"},\"appconfig\":{\"name\":\"AppConfig\"},\"iotsecuretunneling\":{\"name\":\"IoTSecureTunneling\"},\"wafv2\":{\"name\":\"WAFV2\"},\"elasticinference\":{\"prefix\":\"elastic-inference\",\"name\":\"ElasticInference\"},\"imagebuilder\":{\"name\":\"Imagebuilder\"},\"schemas\":{\"name\":\"Schemas\"},\"accessanalyzer\":{\"name\":\"AccessAnalyzer\"},\"codegurureviewer\":{\"prefix\":\"codeguru-reviewer\",\"name\":\"CodeGuruReviewer\"},\"codeguruprofiler\":{\"name\":\"CodeGuruProfiler\"},\"computeoptimizer\":{\"prefix\":\"compute-optimizer\",\"name\":\"ComputeOptimizer\"},\"frauddetector\":{\"name\":\"FraudDetector\"},\"kendra\":{\"name\":\"Kendra\"},\"networkmanager\":{\"name\":\"NetworkManager\"},\"outposts\":{\"name\":\"Outposts\"},\"augmentedairuntime\":{\"prefix\":\"sagemaker-a2i-runtime\",\"name\":\"AugmentedAIRuntime\"},\"ebs\":{\"name\":\"EBS\"},\"kinesisvideosignalingchannels\":{\"prefix\":\"kinesis-video-signaling\",\"name\":\"KinesisVideoSignalingChannels\",\"cors\":true},\"detective\":{\"name\":\"Detective\"},\"codestarconnections\":{\"prefix\":\"codestar-connections\",\"name\":\"CodeStarconnections\"},\"synthetics\":{\"name\":\"Synthetics\"},\"iotsitewise\":{\"name\":\"IoTSiteWise\"},\"macie2\":{\"name\":\"Macie2\"},\"codeartifact\":{\"name\":\"CodeArtifact\"},\"honeycode\":{\"name\":\"Honeycode\"},\"ivs\":{\"name\":\"IVS\"},\"braket\":{\"name\":\"Braket\"},\"identitystore\":{\"name\":\"IdentityStore\"},\"appflow\":{\"name\":\"Appflow\"},\"redshiftdata\":{\"prefix\":\"redshift-data\",\"name\":\"RedshiftData\"},\"ssoadmin\":{\"prefix\":\"sso-admin\",\"name\":\"SSOAdmin\"},\"timestreamquery\":{\"prefix\":\"timestream-query\",\"name\":\"TimestreamQuery\"},\"timestreamwrite\":{\"prefix\":\"timestream-write\",\"name\":\"TimestreamWrite\"},\"s3outposts\":{\"name\":\"S3Outposts\"},\"databrew\":{\"name\":\"DataBrew\"},\"servicecatalogappregistry\":{\"prefix\":\"servicecatalog-appregistry\",\"name\":\"ServiceCatalogAppRegistry\"},\"networkfirewall\":{\"prefix\":\"network-firewall\",\"name\":\"NetworkFirewall\"},\"mwaa\":{\"name\":\"MWAA\"},\"amplifybackend\":{\"name\":\"AmplifyBackend\"},\"appintegrations\":{\"name\":\"AppIntegrations\"},\"connectcontactlens\":{\"prefix\":\"connect-contact-lens\",\"name\":\"ConnectContactLens\"},\"devopsguru\":{\"prefix\":\"devops-guru\",\"name\":\"DevOpsGuru\"},\"ecrpublic\":{\"prefix\":\"ecr-public\",\"name\":\"ECRPUBLIC\"},\"lookoutvision\":{\"name\":\"LookoutVision\"},\"sagemakerfeaturestoreruntime\":{\"prefix\":\"sagemaker-featurestore-runtime\",\"name\":\"SageMakerFeatureStoreRuntime\"},\"customerprofiles\":{\"prefix\":\"customer-profiles\",\"name\":\"CustomerProfiles\"},\"auditmanager\":{\"name\":\"AuditManager\"},\"emrcontainers\":{\"prefix\":\"emr-containers\",\"name\":\"EMRcontainers\"},\"healthlake\":{\"name\":\"HealthLake\"},\"sagemakeredge\":{\"prefix\":\"sagemaker-edge\",\"name\":\"SagemakerEdge\"},\"amp\":{\"name\":\"Amp\"},\"greengrassv2\":{\"name\":\"GreengrassV2\"},\"iotdeviceadvisor\":{\"name\":\"IotDeviceAdvisor\"},\"iotfleethub\":{\"name\":\"IoTFleetHub\"},\"iotwireless\":{\"name\":\"IoTWireless\"},\"location\":{\"name\":\"Location\"},\"wellarchitected\":{\"name\":\"WellArchitected\"}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/apis/s3-2006-03-01.min.json":
  /*!**********************************************************!*\
    !*** ./node_modules/aws-sdk/apis/s3-2006-03-01.min.json ***!
    \**********************************************************/

  /*! exports provided: version, metadata, operations, shapes, default */

  /***/
  function node_modulesAwsSdkApisS320060301MinJson(module) {
    module.exports = JSON.parse("{\"version\":\"2.0\",\"metadata\":{\"apiVersion\":\"2006-03-01\",\"checksumFormat\":\"md5\",\"endpointPrefix\":\"s3\",\"globalEndpoint\":\"s3.amazonaws.com\",\"protocol\":\"rest-xml\",\"serviceAbbreviation\":\"Amazon S3\",\"serviceFullName\":\"Amazon Simple Storage Service\",\"serviceId\":\"S3\",\"signatureVersion\":\"s3\",\"uid\":\"s3-2006-03-01\"},\"operations\":{\"AbortMultipartUpload\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}/{Key+}\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\",\"UploadId\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"UploadId\":{\"location\":\"querystring\",\"locationName\":\"uploadId\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}}},\"CompleteMultipartUpload\":{\"http\":{\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\",\"UploadId\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"MultipartUpload\":{\"locationName\":\"CompleteMultipartUpload\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"members\":{\"Parts\":{\"locationName\":\"Part\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"ETag\":{},\"PartNumber\":{\"type\":\"integer\"}}},\"flattened\":true}}},\"UploadId\":{\"location\":\"querystring\",\"locationName\":\"uploadId\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"MultipartUpload\"},\"output\":{\"type\":\"structure\",\"members\":{\"Location\":{},\"Bucket\":{},\"Key\":{},\"Expiration\":{\"location\":\"header\",\"locationName\":\"x-amz-expiration\"},\"ETag\":{},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}}},\"CopyObject\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"CopySource\",\"Key\"],\"members\":{\"ACL\":{\"location\":\"header\",\"locationName\":\"x-amz-acl\"},\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"CacheControl\":{\"location\":\"header\",\"locationName\":\"Cache-Control\"},\"ContentDisposition\":{\"location\":\"header\",\"locationName\":\"Content-Disposition\"},\"ContentEncoding\":{\"location\":\"header\",\"locationName\":\"Content-Encoding\"},\"ContentLanguage\":{\"location\":\"header\",\"locationName\":\"Content-Language\"},\"ContentType\":{\"location\":\"header\",\"locationName\":\"Content-Type\"},\"CopySource\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source\"},\"CopySourceIfMatch\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-match\"},\"CopySourceIfModifiedSince\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-modified-since\",\"type\":\"timestamp\"},\"CopySourceIfNoneMatch\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-none-match\"},\"CopySourceIfUnmodifiedSince\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-unmodified-since\",\"type\":\"timestamp\"},\"Expires\":{\"location\":\"header\",\"locationName\":\"Expires\",\"type\":\"timestamp\"},\"GrantFullControl\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-full-control\"},\"GrantRead\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read\"},\"GrantReadACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read-acp\"},\"GrantWriteACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write-acp\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"Metadata\":{\"shape\":\"S13\",\"location\":\"headers\",\"locationName\":\"x-amz-meta-\"},\"MetadataDirective\":{\"location\":\"header\",\"locationName\":\"x-amz-metadata-directive\"},\"TaggingDirective\":{\"location\":\"header\",\"locationName\":\"x-amz-tagging-directive\"},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"StorageClass\":{\"location\":\"header\",\"locationName\":\"x-amz-storage-class\"},\"WebsiteRedirectLocation\":{\"location\":\"header\",\"locationName\":\"x-amz-website-redirect-location\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"SSEKMSEncryptionContext\":{\"shape\":\"S1d\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-context\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"CopySourceSSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-server-side-encryption-customer-algorithm\"},\"CopySourceSSECustomerKey\":{\"shape\":\"S1f\",\"location\":\"header\",\"locationName\":\"x-amz-copy-source-server-side-encryption-customer-key\"},\"CopySourceSSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-server-side-encryption-customer-key-MD5\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"Tagging\":{\"location\":\"header\",\"locationName\":\"x-amz-tagging\"},\"ObjectLockMode\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-mode\"},\"ObjectLockRetainUntilDate\":{\"shape\":\"S1j\",\"location\":\"header\",\"locationName\":\"x-amz-object-lock-retain-until-date\"},\"ObjectLockLegalHoldStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-legal-hold\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"},\"ExpectedSourceBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-source-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"CopyObjectResult\":{\"type\":\"structure\",\"members\":{\"ETag\":{},\"LastModified\":{\"type\":\"timestamp\"}}},\"Expiration\":{\"location\":\"header\",\"locationName\":\"x-amz-expiration\"},\"CopySourceVersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-version-id\"},\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"SSEKMSEncryptionContext\":{\"shape\":\"S1d\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-context\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}},\"payload\":\"CopyObjectResult\"},\"alias\":\"PutObjectCopy\"},\"CreateBucket\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"ACL\":{\"location\":\"header\",\"locationName\":\"x-amz-acl\"},\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"CreateBucketConfiguration\":{\"locationName\":\"CreateBucketConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"members\":{\"LocationConstraint\":{}}},\"GrantFullControl\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-full-control\"},\"GrantRead\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read\"},\"GrantReadACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read-acp\"},\"GrantWrite\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write\"},\"GrantWriteACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write-acp\"},\"ObjectLockEnabledForBucket\":{\"location\":\"header\",\"locationName\":\"x-amz-bucket-object-lock-enabled\",\"type\":\"boolean\"}},\"payload\":\"CreateBucketConfiguration\"},\"output\":{\"type\":\"structure\",\"members\":{\"Location\":{\"location\":\"header\",\"locationName\":\"Location\"}}},\"alias\":\"PutBucket\"},\"CreateMultipartUpload\":{\"http\":{\"requestUri\":\"/{Bucket}/{Key+}?uploads\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"ACL\":{\"location\":\"header\",\"locationName\":\"x-amz-acl\"},\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"CacheControl\":{\"location\":\"header\",\"locationName\":\"Cache-Control\"},\"ContentDisposition\":{\"location\":\"header\",\"locationName\":\"Content-Disposition\"},\"ContentEncoding\":{\"location\":\"header\",\"locationName\":\"Content-Encoding\"},\"ContentLanguage\":{\"location\":\"header\",\"locationName\":\"Content-Language\"},\"ContentType\":{\"location\":\"header\",\"locationName\":\"Content-Type\"},\"Expires\":{\"location\":\"header\",\"locationName\":\"Expires\",\"type\":\"timestamp\"},\"GrantFullControl\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-full-control\"},\"GrantRead\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read\"},\"GrantReadACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read-acp\"},\"GrantWriteACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write-acp\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"Metadata\":{\"shape\":\"S13\",\"location\":\"headers\",\"locationName\":\"x-amz-meta-\"},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"StorageClass\":{\"location\":\"header\",\"locationName\":\"x-amz-storage-class\"},\"WebsiteRedirectLocation\":{\"location\":\"header\",\"locationName\":\"x-amz-website-redirect-location\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"SSEKMSEncryptionContext\":{\"shape\":\"S1d\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-context\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"Tagging\":{\"location\":\"header\",\"locationName\":\"x-amz-tagging\"},\"ObjectLockMode\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-mode\"},\"ObjectLockRetainUntilDate\":{\"shape\":\"S1j\",\"location\":\"header\",\"locationName\":\"x-amz-object-lock-retain-until-date\"},\"ObjectLockLegalHoldStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-legal-hold\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"AbortDate\":{\"location\":\"header\",\"locationName\":\"x-amz-abort-date\",\"type\":\"timestamp\"},\"AbortRuleId\":{\"location\":\"header\",\"locationName\":\"x-amz-abort-rule-id\"},\"Bucket\":{\"locationName\":\"Bucket\"},\"Key\":{},\"UploadId\":{},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"SSEKMSEncryptionContext\":{\"shape\":\"S1d\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-context\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}},\"alias\":\"InitiateMultipartUpload\"},\"DeleteBucket\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketAnalyticsConfiguration\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?analytics\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketCors\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?cors\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketEncryption\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?encryption\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketIntelligentTieringConfiguration\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?intelligent-tiering\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"}}}},\"DeleteBucketInventoryConfiguration\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?inventory\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketLifecycle\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?lifecycle\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketMetricsConfiguration\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?metrics\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketOwnershipControls\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?ownershipControls\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketPolicy\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?policy\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketReplication\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?replication\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketTagging\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?tagging\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteBucketWebsite\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?website\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"DeleteObject\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}/{Key+}\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"MFA\":{\"location\":\"header\",\"locationName\":\"x-amz-mfa\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"BypassGovernanceRetention\":{\"location\":\"header\",\"locationName\":\"x-amz-bypass-governance-retention\",\"type\":\"boolean\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"DeleteMarker\":{\"location\":\"header\",\"locationName\":\"x-amz-delete-marker\",\"type\":\"boolean\"},\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}}},\"DeleteObjectTagging\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}/{Key+}?tagging\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"}}}},\"DeleteObjects\":{\"http\":{\"requestUri\":\"/{Bucket}?delete\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Delete\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Delete\":{\"locationName\":\"Delete\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"required\":[\"Objects\"],\"members\":{\"Objects\":{\"locationName\":\"Object\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"Key\"],\"members\":{\"Key\":{},\"VersionId\":{}}},\"flattened\":true},\"Quiet\":{\"type\":\"boolean\"}}},\"MFA\":{\"location\":\"header\",\"locationName\":\"x-amz-mfa\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"BypassGovernanceRetention\":{\"location\":\"header\",\"locationName\":\"x-amz-bypass-governance-retention\",\"type\":\"boolean\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"Delete\"},\"output\":{\"type\":\"structure\",\"members\":{\"Deleted\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"Key\":{},\"VersionId\":{},\"DeleteMarker\":{\"type\":\"boolean\"},\"DeleteMarkerVersionId\":{}}},\"flattened\":true},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"},\"Errors\":{\"locationName\":\"Error\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"Key\":{},\"VersionId\":{},\"Code\":{},\"Message\":{}}},\"flattened\":true}}},\"alias\":\"DeleteMultipleObjects\",\"httpChecksumRequired\":true},\"DeletePublicAccessBlock\":{\"http\":{\"method\":\"DELETE\",\"requestUri\":\"/{Bucket}?publicAccessBlock\",\"responseCode\":204},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"GetBucketAccelerateConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?accelerate\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Status\":{}}}},\"GetBucketAcl\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?acl\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Owner\":{\"shape\":\"S37\"},\"Grants\":{\"shape\":\"S3a\",\"locationName\":\"AccessControlList\"}}}},\"GetBucketAnalyticsConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?analytics\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"AnalyticsConfiguration\":{\"shape\":\"S3j\"}},\"payload\":\"AnalyticsConfiguration\"}},\"GetBucketCors\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?cors\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"CORSRules\":{\"shape\":\"S3y\",\"locationName\":\"CORSRule\"}}}},\"GetBucketEncryption\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?encryption\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"ServerSideEncryptionConfiguration\":{\"shape\":\"S4b\"}},\"payload\":\"ServerSideEncryptionConfiguration\"}},\"GetBucketIntelligentTieringConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?intelligent-tiering\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IntelligentTieringConfiguration\":{\"shape\":\"S4h\"}},\"payload\":\"IntelligentTieringConfiguration\"}},\"GetBucketInventoryConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?inventory\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"InventoryConfiguration\":{\"shape\":\"S4r\"}},\"payload\":\"InventoryConfiguration\"}},\"GetBucketLifecycle\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?lifecycle\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Rules\":{\"shape\":\"S57\",\"locationName\":\"Rule\"}}},\"deprecated\":true},\"GetBucketLifecycleConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?lifecycle\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Rules\":{\"shape\":\"S5m\",\"locationName\":\"Rule\"}}}},\"GetBucketLocation\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?location\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"LocationConstraint\":{}}}},\"GetBucketLogging\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?logging\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"LoggingEnabled\":{\"shape\":\"S5w\"}}}},\"GetBucketMetricsConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?metrics\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"MetricsConfiguration\":{\"shape\":\"S64\"}},\"payload\":\"MetricsConfiguration\"}},\"GetBucketNotification\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?notification\"},\"input\":{\"shape\":\"S67\"},\"output\":{\"shape\":\"S68\"},\"deprecated\":true},\"GetBucketNotificationConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?notification\"},\"input\":{\"shape\":\"S67\"},\"output\":{\"shape\":\"S6j\"}},\"GetBucketOwnershipControls\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?ownershipControls\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"OwnershipControls\":{\"shape\":\"S6z\"}},\"payload\":\"OwnershipControls\"}},\"GetBucketPolicy\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?policy\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Policy\":{}},\"payload\":\"Policy\"}},\"GetBucketPolicyStatus\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?policyStatus\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"PolicyStatus\":{\"type\":\"structure\",\"members\":{\"IsPublic\":{\"locationName\":\"IsPublic\",\"type\":\"boolean\"}}}},\"payload\":\"PolicyStatus\"}},\"GetBucketReplication\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?replication\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"ReplicationConfiguration\":{\"shape\":\"S7c\"}},\"payload\":\"ReplicationConfiguration\"}},\"GetBucketRequestPayment\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?requestPayment\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Payer\":{}}}},\"GetBucketTagging\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?tagging\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"required\":[\"TagSet\"],\"members\":{\"TagSet\":{\"shape\":\"S3p\"}}}},\"GetBucketVersioning\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?versioning\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Status\":{},\"MFADelete\":{\"locationName\":\"MfaDelete\"}}}},\"GetBucketWebsite\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?website\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"RedirectAllRequestsTo\":{\"shape\":\"S8f\"},\"IndexDocument\":{\"shape\":\"S8i\"},\"ErrorDocument\":{\"shape\":\"S8k\"},\"RoutingRules\":{\"shape\":\"S8l\"}}}},\"GetObject\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"IfMatch\":{\"location\":\"header\",\"locationName\":\"If-Match\"},\"IfModifiedSince\":{\"location\":\"header\",\"locationName\":\"If-Modified-Since\",\"type\":\"timestamp\"},\"IfNoneMatch\":{\"location\":\"header\",\"locationName\":\"If-None-Match\"},\"IfUnmodifiedSince\":{\"location\":\"header\",\"locationName\":\"If-Unmodified-Since\",\"type\":\"timestamp\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"Range\":{\"location\":\"header\",\"locationName\":\"Range\"},\"ResponseCacheControl\":{\"location\":\"querystring\",\"locationName\":\"response-cache-control\"},\"ResponseContentDisposition\":{\"location\":\"querystring\",\"locationName\":\"response-content-disposition\"},\"ResponseContentEncoding\":{\"location\":\"querystring\",\"locationName\":\"response-content-encoding\"},\"ResponseContentLanguage\":{\"location\":\"querystring\",\"locationName\":\"response-content-language\"},\"ResponseContentType\":{\"location\":\"querystring\",\"locationName\":\"response-content-type\"},\"ResponseExpires\":{\"location\":\"querystring\",\"locationName\":\"response-expires\",\"type\":\"timestamp\",\"timestampFormat\":\"rfc822\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"PartNumber\":{\"location\":\"querystring\",\"locationName\":\"partNumber\",\"type\":\"integer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Body\":{\"streaming\":true,\"type\":\"blob\"},\"DeleteMarker\":{\"location\":\"header\",\"locationName\":\"x-amz-delete-marker\",\"type\":\"boolean\"},\"AcceptRanges\":{\"location\":\"header\",\"locationName\":\"accept-ranges\"},\"Expiration\":{\"location\":\"header\",\"locationName\":\"x-amz-expiration\"},\"Restore\":{\"location\":\"header\",\"locationName\":\"x-amz-restore\"},\"LastModified\":{\"location\":\"header\",\"locationName\":\"Last-Modified\",\"type\":\"timestamp\"},\"ContentLength\":{\"location\":\"header\",\"locationName\":\"Content-Length\",\"type\":\"long\"},\"ETag\":{\"location\":\"header\",\"locationName\":\"ETag\"},\"MissingMeta\":{\"location\":\"header\",\"locationName\":\"x-amz-missing-meta\",\"type\":\"integer\"},\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"},\"CacheControl\":{\"location\":\"header\",\"locationName\":\"Cache-Control\"},\"ContentDisposition\":{\"location\":\"header\",\"locationName\":\"Content-Disposition\"},\"ContentEncoding\":{\"location\":\"header\",\"locationName\":\"Content-Encoding\"},\"ContentLanguage\":{\"location\":\"header\",\"locationName\":\"Content-Language\"},\"ContentRange\":{\"location\":\"header\",\"locationName\":\"Content-Range\"},\"ContentType\":{\"location\":\"header\",\"locationName\":\"Content-Type\"},\"Expires\":{\"location\":\"header\",\"locationName\":\"Expires\",\"type\":\"timestamp\"},\"WebsiteRedirectLocation\":{\"location\":\"header\",\"locationName\":\"x-amz-website-redirect-location\"},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"Metadata\":{\"shape\":\"S13\",\"location\":\"headers\",\"locationName\":\"x-amz-meta-\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"StorageClass\":{\"location\":\"header\",\"locationName\":\"x-amz-storage-class\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"},\"ReplicationStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-replication-status\"},\"PartsCount\":{\"location\":\"header\",\"locationName\":\"x-amz-mp-parts-count\",\"type\":\"integer\"},\"TagCount\":{\"location\":\"header\",\"locationName\":\"x-amz-tagging-count\",\"type\":\"integer\"},\"ObjectLockMode\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-mode\"},\"ObjectLockRetainUntilDate\":{\"shape\":\"S1j\",\"location\":\"header\",\"locationName\":\"x-amz-object-lock-retain-until-date\"},\"ObjectLockLegalHoldStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-legal-hold\"}},\"payload\":\"Body\"}},\"GetObjectAcl\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}/{Key+}?acl\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Owner\":{\"shape\":\"S37\"},\"Grants\":{\"shape\":\"S3a\",\"locationName\":\"AccessControlList\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}}},\"GetObjectLegalHold\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}/{Key+}?legal-hold\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"LegalHold\":{\"shape\":\"S9k\"}},\"payload\":\"LegalHold\"}},\"GetObjectLockConfiguration\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?object-lock\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"ObjectLockConfiguration\":{\"shape\":\"S9n\"}},\"payload\":\"ObjectLockConfiguration\"}},\"GetObjectRetention\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}/{Key+}?retention\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Retention\":{\"shape\":\"S9v\"}},\"payload\":\"Retention\"}},\"GetObjectTagging\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}/{Key+}?tagging\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"required\":[\"TagSet\"],\"members\":{\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"},\"TagSet\":{\"shape\":\"S3p\"}}}},\"GetObjectTorrent\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}/{Key+}?torrent\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Body\":{\"streaming\":true,\"type\":\"blob\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}},\"payload\":\"Body\"}},\"GetPublicAccessBlock\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?publicAccessBlock\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"PublicAccessBlockConfiguration\":{\"shape\":\"Sa2\"}},\"payload\":\"PublicAccessBlockConfiguration\"}},\"HeadBucket\":{\"http\":{\"method\":\"HEAD\",\"requestUri\":\"/{Bucket}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}}},\"HeadObject\":{\"http\":{\"method\":\"HEAD\",\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"IfMatch\":{\"location\":\"header\",\"locationName\":\"If-Match\"},\"IfModifiedSince\":{\"location\":\"header\",\"locationName\":\"If-Modified-Since\",\"type\":\"timestamp\"},\"IfNoneMatch\":{\"location\":\"header\",\"locationName\":\"If-None-Match\"},\"IfUnmodifiedSince\":{\"location\":\"header\",\"locationName\":\"If-Unmodified-Since\",\"type\":\"timestamp\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"Range\":{\"location\":\"header\",\"locationName\":\"Range\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"PartNumber\":{\"location\":\"querystring\",\"locationName\":\"partNumber\",\"type\":\"integer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"DeleteMarker\":{\"location\":\"header\",\"locationName\":\"x-amz-delete-marker\",\"type\":\"boolean\"},\"AcceptRanges\":{\"location\":\"header\",\"locationName\":\"accept-ranges\"},\"Expiration\":{\"location\":\"header\",\"locationName\":\"x-amz-expiration\"},\"Restore\":{\"location\":\"header\",\"locationName\":\"x-amz-restore\"},\"ArchiveStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-archive-status\"},\"LastModified\":{\"location\":\"header\",\"locationName\":\"Last-Modified\",\"type\":\"timestamp\"},\"ContentLength\":{\"location\":\"header\",\"locationName\":\"Content-Length\",\"type\":\"long\"},\"ETag\":{\"location\":\"header\",\"locationName\":\"ETag\"},\"MissingMeta\":{\"location\":\"header\",\"locationName\":\"x-amz-missing-meta\",\"type\":\"integer\"},\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"},\"CacheControl\":{\"location\":\"header\",\"locationName\":\"Cache-Control\"},\"ContentDisposition\":{\"location\":\"header\",\"locationName\":\"Content-Disposition\"},\"ContentEncoding\":{\"location\":\"header\",\"locationName\":\"Content-Encoding\"},\"ContentLanguage\":{\"location\":\"header\",\"locationName\":\"Content-Language\"},\"ContentType\":{\"location\":\"header\",\"locationName\":\"Content-Type\"},\"Expires\":{\"location\":\"header\",\"locationName\":\"Expires\",\"type\":\"timestamp\"},\"WebsiteRedirectLocation\":{\"location\":\"header\",\"locationName\":\"x-amz-website-redirect-location\"},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"Metadata\":{\"shape\":\"S13\",\"location\":\"headers\",\"locationName\":\"x-amz-meta-\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"StorageClass\":{\"location\":\"header\",\"locationName\":\"x-amz-storage-class\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"},\"ReplicationStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-replication-status\"},\"PartsCount\":{\"location\":\"header\",\"locationName\":\"x-amz-mp-parts-count\",\"type\":\"integer\"},\"ObjectLockMode\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-mode\"},\"ObjectLockRetainUntilDate\":{\"shape\":\"S1j\",\"location\":\"header\",\"locationName\":\"x-amz-object-lock-retain-until-date\"},\"ObjectLockLegalHoldStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-legal-hold\"}}}},\"ListBucketAnalyticsConfigurations\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?analytics\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContinuationToken\":{\"location\":\"querystring\",\"locationName\":\"continuation-token\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IsTruncated\":{\"type\":\"boolean\"},\"ContinuationToken\":{},\"NextContinuationToken\":{},\"AnalyticsConfigurationList\":{\"locationName\":\"AnalyticsConfiguration\",\"type\":\"list\",\"member\":{\"shape\":\"S3j\"},\"flattened\":true}}}},\"ListBucketIntelligentTieringConfigurations\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?intelligent-tiering\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContinuationToken\":{\"location\":\"querystring\",\"locationName\":\"continuation-token\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IsTruncated\":{\"type\":\"boolean\"},\"ContinuationToken\":{},\"NextContinuationToken\":{},\"IntelligentTieringConfigurationList\":{\"locationName\":\"IntelligentTieringConfiguration\",\"type\":\"list\",\"member\":{\"shape\":\"S4h\"},\"flattened\":true}}}},\"ListBucketInventoryConfigurations\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?inventory\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContinuationToken\":{\"location\":\"querystring\",\"locationName\":\"continuation-token\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"ContinuationToken\":{},\"InventoryConfigurationList\":{\"locationName\":\"InventoryConfiguration\",\"type\":\"list\",\"member\":{\"shape\":\"S4r\"},\"flattened\":true},\"IsTruncated\":{\"type\":\"boolean\"},\"NextContinuationToken\":{}}}},\"ListBucketMetricsConfigurations\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?metrics\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContinuationToken\":{\"location\":\"querystring\",\"locationName\":\"continuation-token\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IsTruncated\":{\"type\":\"boolean\"},\"ContinuationToken\":{},\"NextContinuationToken\":{},\"MetricsConfigurationList\":{\"locationName\":\"MetricsConfiguration\",\"type\":\"list\",\"member\":{\"shape\":\"S64\"},\"flattened\":true}}}},\"ListBuckets\":{\"http\":{\"method\":\"GET\"},\"output\":{\"type\":\"structure\",\"members\":{\"Buckets\":{\"type\":\"list\",\"member\":{\"locationName\":\"Bucket\",\"type\":\"structure\",\"members\":{\"Name\":{},\"CreationDate\":{\"type\":\"timestamp\"}}}},\"Owner\":{\"shape\":\"S37\"}}},\"alias\":\"GetService\"},\"ListMultipartUploads\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?uploads\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Delimiter\":{\"location\":\"querystring\",\"locationName\":\"delimiter\"},\"EncodingType\":{\"location\":\"querystring\",\"locationName\":\"encoding-type\"},\"KeyMarker\":{\"location\":\"querystring\",\"locationName\":\"key-marker\"},\"MaxUploads\":{\"location\":\"querystring\",\"locationName\":\"max-uploads\",\"type\":\"integer\"},\"Prefix\":{\"location\":\"querystring\",\"locationName\":\"prefix\"},\"UploadIdMarker\":{\"location\":\"querystring\",\"locationName\":\"upload-id-marker\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Bucket\":{},\"KeyMarker\":{},\"UploadIdMarker\":{},\"NextKeyMarker\":{},\"Prefix\":{},\"Delimiter\":{},\"NextUploadIdMarker\":{},\"MaxUploads\":{\"type\":\"integer\"},\"IsTruncated\":{\"type\":\"boolean\"},\"Uploads\":{\"locationName\":\"Upload\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"UploadId\":{},\"Key\":{},\"Initiated\":{\"type\":\"timestamp\"},\"StorageClass\":{},\"Owner\":{\"shape\":\"S37\"},\"Initiator\":{\"shape\":\"Sb3\"}}},\"flattened\":true},\"CommonPrefixes\":{\"shape\":\"Sb4\"},\"EncodingType\":{}}}},\"ListObjectVersions\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?versions\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Delimiter\":{\"location\":\"querystring\",\"locationName\":\"delimiter\"},\"EncodingType\":{\"location\":\"querystring\",\"locationName\":\"encoding-type\"},\"KeyMarker\":{\"location\":\"querystring\",\"locationName\":\"key-marker\"},\"MaxKeys\":{\"location\":\"querystring\",\"locationName\":\"max-keys\",\"type\":\"integer\"},\"Prefix\":{\"location\":\"querystring\",\"locationName\":\"prefix\"},\"VersionIdMarker\":{\"location\":\"querystring\",\"locationName\":\"version-id-marker\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IsTruncated\":{\"type\":\"boolean\"},\"KeyMarker\":{},\"VersionIdMarker\":{},\"NextKeyMarker\":{},\"NextVersionIdMarker\":{},\"Versions\":{\"locationName\":\"Version\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"ETag\":{},\"Size\":{\"type\":\"integer\"},\"StorageClass\":{},\"Key\":{},\"VersionId\":{},\"IsLatest\":{\"type\":\"boolean\"},\"LastModified\":{\"type\":\"timestamp\"},\"Owner\":{\"shape\":\"S37\"}}},\"flattened\":true},\"DeleteMarkers\":{\"locationName\":\"DeleteMarker\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"Owner\":{\"shape\":\"S37\"},\"Key\":{},\"VersionId\":{},\"IsLatest\":{\"type\":\"boolean\"},\"LastModified\":{\"type\":\"timestamp\"}}},\"flattened\":true},\"Name\":{},\"Prefix\":{},\"Delimiter\":{},\"MaxKeys\":{\"type\":\"integer\"},\"CommonPrefixes\":{\"shape\":\"Sb4\"},\"EncodingType\":{}}},\"alias\":\"GetBucketObjectVersions\"},\"ListObjects\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Delimiter\":{\"location\":\"querystring\",\"locationName\":\"delimiter\"},\"EncodingType\":{\"location\":\"querystring\",\"locationName\":\"encoding-type\"},\"Marker\":{\"location\":\"querystring\",\"locationName\":\"marker\"},\"MaxKeys\":{\"location\":\"querystring\",\"locationName\":\"max-keys\",\"type\":\"integer\"},\"Prefix\":{\"location\":\"querystring\",\"locationName\":\"prefix\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IsTruncated\":{\"type\":\"boolean\"},\"Marker\":{},\"NextMarker\":{},\"Contents\":{\"shape\":\"Sbm\"},\"Name\":{},\"Prefix\":{},\"Delimiter\":{},\"MaxKeys\":{\"type\":\"integer\"},\"CommonPrefixes\":{\"shape\":\"Sb4\"},\"EncodingType\":{}}},\"alias\":\"GetBucket\"},\"ListObjectsV2\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}?list-type=2\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Delimiter\":{\"location\":\"querystring\",\"locationName\":\"delimiter\"},\"EncodingType\":{\"location\":\"querystring\",\"locationName\":\"encoding-type\"},\"MaxKeys\":{\"location\":\"querystring\",\"locationName\":\"max-keys\",\"type\":\"integer\"},\"Prefix\":{\"location\":\"querystring\",\"locationName\":\"prefix\"},\"ContinuationToken\":{\"location\":\"querystring\",\"locationName\":\"continuation-token\"},\"FetchOwner\":{\"location\":\"querystring\",\"locationName\":\"fetch-owner\",\"type\":\"boolean\"},\"StartAfter\":{\"location\":\"querystring\",\"locationName\":\"start-after\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"IsTruncated\":{\"type\":\"boolean\"},\"Contents\":{\"shape\":\"Sbm\"},\"Name\":{},\"Prefix\":{},\"Delimiter\":{},\"MaxKeys\":{\"type\":\"integer\"},\"CommonPrefixes\":{\"shape\":\"Sb4\"},\"EncodingType\":{},\"KeyCount\":{\"type\":\"integer\"},\"ContinuationToken\":{},\"NextContinuationToken\":{},\"StartAfter\":{}}}},\"ListParts\":{\"http\":{\"method\":\"GET\",\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\",\"UploadId\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"MaxParts\":{\"location\":\"querystring\",\"locationName\":\"max-parts\",\"type\":\"integer\"},\"PartNumberMarker\":{\"location\":\"querystring\",\"locationName\":\"part-number-marker\",\"type\":\"integer\"},\"UploadId\":{\"location\":\"querystring\",\"locationName\":\"uploadId\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"AbortDate\":{\"location\":\"header\",\"locationName\":\"x-amz-abort-date\",\"type\":\"timestamp\"},\"AbortRuleId\":{\"location\":\"header\",\"locationName\":\"x-amz-abort-rule-id\"},\"Bucket\":{},\"Key\":{},\"UploadId\":{},\"PartNumberMarker\":{\"type\":\"integer\"},\"NextPartNumberMarker\":{\"type\":\"integer\"},\"MaxParts\":{\"type\":\"integer\"},\"IsTruncated\":{\"type\":\"boolean\"},\"Parts\":{\"locationName\":\"Part\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"PartNumber\":{\"type\":\"integer\"},\"LastModified\":{\"type\":\"timestamp\"},\"ETag\":{},\"Size\":{\"type\":\"integer\"}}},\"flattened\":true},\"Initiator\":{\"shape\":\"Sb3\"},\"Owner\":{\"shape\":\"S37\"},\"StorageClass\":{},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}}},\"PutBucketAccelerateConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?accelerate\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"AccelerateConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"AccelerateConfiguration\":{\"locationName\":\"AccelerateConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"members\":{\"Status\":{}}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"AccelerateConfiguration\"}},\"PutBucketAcl\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?acl\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"ACL\":{\"location\":\"header\",\"locationName\":\"x-amz-acl\"},\"AccessControlPolicy\":{\"shape\":\"Sc4\",\"locationName\":\"AccessControlPolicy\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"GrantFullControl\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-full-control\"},\"GrantRead\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read\"},\"GrantReadACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read-acp\"},\"GrantWrite\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write\"},\"GrantWriteACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write-acp\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"AccessControlPolicy\"},\"httpChecksumRequired\":true},\"PutBucketAnalyticsConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?analytics\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\",\"AnalyticsConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"AnalyticsConfiguration\":{\"shape\":\"S3j\",\"locationName\":\"AnalyticsConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"AnalyticsConfiguration\"}},\"PutBucketCors\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?cors\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"CORSConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"CORSConfiguration\":{\"locationName\":\"CORSConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"required\":[\"CORSRules\"],\"members\":{\"CORSRules\":{\"shape\":\"S3y\",\"locationName\":\"CORSRule\"}}},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"CORSConfiguration\"},\"httpChecksumRequired\":true},\"PutBucketEncryption\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?encryption\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"ServerSideEncryptionConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ServerSideEncryptionConfiguration\":{\"shape\":\"S4b\",\"locationName\":\"ServerSideEncryptionConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"ServerSideEncryptionConfiguration\"},\"httpChecksumRequired\":true},\"PutBucketIntelligentTieringConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?intelligent-tiering\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\",\"IntelligentTieringConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"IntelligentTieringConfiguration\":{\"shape\":\"S4h\",\"locationName\":\"IntelligentTieringConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}}},\"payload\":\"IntelligentTieringConfiguration\"}},\"PutBucketInventoryConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?inventory\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\",\"InventoryConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"InventoryConfiguration\":{\"shape\":\"S4r\",\"locationName\":\"InventoryConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"InventoryConfiguration\"}},\"PutBucketLifecycle\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?lifecycle\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"LifecycleConfiguration\":{\"locationName\":\"LifecycleConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"required\":[\"Rules\"],\"members\":{\"Rules\":{\"shape\":\"S57\",\"locationName\":\"Rule\"}}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"LifecycleConfiguration\"},\"deprecated\":true,\"httpChecksumRequired\":true},\"PutBucketLifecycleConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?lifecycle\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"LifecycleConfiguration\":{\"locationName\":\"LifecycleConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"required\":[\"Rules\"],\"members\":{\"Rules\":{\"shape\":\"S5m\",\"locationName\":\"Rule\"}}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"LifecycleConfiguration\"},\"httpChecksumRequired\":true},\"PutBucketLogging\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?logging\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"BucketLoggingStatus\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"BucketLoggingStatus\":{\"locationName\":\"BucketLoggingStatus\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"members\":{\"LoggingEnabled\":{\"shape\":\"S5w\"}}},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"BucketLoggingStatus\"},\"httpChecksumRequired\":true},\"PutBucketMetricsConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?metrics\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Id\",\"MetricsConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Id\":{\"location\":\"querystring\",\"locationName\":\"id\"},\"MetricsConfiguration\":{\"shape\":\"S64\",\"locationName\":\"MetricsConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"MetricsConfiguration\"}},\"PutBucketNotification\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?notification\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"NotificationConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"NotificationConfiguration\":{\"shape\":\"S68\",\"locationName\":\"NotificationConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"NotificationConfiguration\"},\"deprecated\":true,\"httpChecksumRequired\":true},\"PutBucketNotificationConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?notification\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"NotificationConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"NotificationConfiguration\":{\"shape\":\"S6j\",\"locationName\":\"NotificationConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"NotificationConfiguration\"}},\"PutBucketOwnershipControls\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?ownershipControls\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"OwnershipControls\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"},\"OwnershipControls\":{\"shape\":\"S6z\",\"locationName\":\"OwnershipControls\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}}},\"payload\":\"OwnershipControls\"},\"httpChecksumRequired\":true},\"PutBucketPolicy\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?policy\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Policy\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ConfirmRemoveSelfBucketAccess\":{\"location\":\"header\",\"locationName\":\"x-amz-confirm-remove-self-bucket-access\",\"type\":\"boolean\"},\"Policy\":{},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"Policy\"},\"httpChecksumRequired\":true},\"PutBucketReplication\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?replication\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"ReplicationConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ReplicationConfiguration\":{\"shape\":\"S7c\",\"locationName\":\"ReplicationConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"Token\":{\"location\":\"header\",\"locationName\":\"x-amz-bucket-object-lock-token\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"ReplicationConfiguration\"},\"httpChecksumRequired\":true},\"PutBucketRequestPayment\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?requestPayment\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"RequestPaymentConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"RequestPaymentConfiguration\":{\"locationName\":\"RequestPaymentConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"required\":[\"Payer\"],\"members\":{\"Payer\":{}}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"RequestPaymentConfiguration\"},\"httpChecksumRequired\":true},\"PutBucketTagging\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?tagging\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Tagging\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"Tagging\":{\"shape\":\"Sct\",\"locationName\":\"Tagging\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"Tagging\"},\"httpChecksumRequired\":true},\"PutBucketVersioning\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?versioning\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"VersioningConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"MFA\":{\"location\":\"header\",\"locationName\":\"x-amz-mfa\"},\"VersioningConfiguration\":{\"locationName\":\"VersioningConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"members\":{\"MFADelete\":{\"locationName\":\"MfaDelete\"},\"Status\":{}}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"VersioningConfiguration\"},\"httpChecksumRequired\":true},\"PutBucketWebsite\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?website\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"WebsiteConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"WebsiteConfiguration\":{\"locationName\":\"WebsiteConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"members\":{\"ErrorDocument\":{\"shape\":\"S8k\"},\"IndexDocument\":{\"shape\":\"S8i\"},\"RedirectAllRequestsTo\":{\"shape\":\"S8f\"},\"RoutingRules\":{\"shape\":\"S8l\"}}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"WebsiteConfiguration\"},\"httpChecksumRequired\":true},\"PutObject\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"ACL\":{\"location\":\"header\",\"locationName\":\"x-amz-acl\"},\"Body\":{\"streaming\":true,\"type\":\"blob\"},\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"CacheControl\":{\"location\":\"header\",\"locationName\":\"Cache-Control\"},\"ContentDisposition\":{\"location\":\"header\",\"locationName\":\"Content-Disposition\"},\"ContentEncoding\":{\"location\":\"header\",\"locationName\":\"Content-Encoding\"},\"ContentLanguage\":{\"location\":\"header\",\"locationName\":\"Content-Language\"},\"ContentLength\":{\"location\":\"header\",\"locationName\":\"Content-Length\",\"type\":\"long\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ContentType\":{\"location\":\"header\",\"locationName\":\"Content-Type\"},\"Expires\":{\"location\":\"header\",\"locationName\":\"Expires\",\"type\":\"timestamp\"},\"GrantFullControl\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-full-control\"},\"GrantRead\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read\"},\"GrantReadACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read-acp\"},\"GrantWriteACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write-acp\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"Metadata\":{\"shape\":\"S13\",\"location\":\"headers\",\"locationName\":\"x-amz-meta-\"},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"StorageClass\":{\"location\":\"header\",\"locationName\":\"x-amz-storage-class\"},\"WebsiteRedirectLocation\":{\"location\":\"header\",\"locationName\":\"x-amz-website-redirect-location\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"SSEKMSEncryptionContext\":{\"shape\":\"S1d\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-context\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"Tagging\":{\"location\":\"header\",\"locationName\":\"x-amz-tagging\"},\"ObjectLockMode\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-mode\"},\"ObjectLockRetainUntilDate\":{\"shape\":\"S1j\",\"location\":\"header\",\"locationName\":\"x-amz-object-lock-retain-until-date\"},\"ObjectLockLegalHoldStatus\":{\"location\":\"header\",\"locationName\":\"x-amz-object-lock-legal-hold\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"Body\"},\"output\":{\"type\":\"structure\",\"members\":{\"Expiration\":{\"location\":\"header\",\"locationName\":\"x-amz-expiration\"},\"ETag\":{\"location\":\"header\",\"locationName\":\"ETag\"},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"SSEKMSEncryptionContext\":{\"shape\":\"S1d\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-context\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}}},\"PutObjectAcl\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}?acl\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"ACL\":{\"location\":\"header\",\"locationName\":\"x-amz-acl\"},\"AccessControlPolicy\":{\"shape\":\"Sc4\",\"locationName\":\"AccessControlPolicy\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"GrantFullControl\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-full-control\"},\"GrantRead\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read\"},\"GrantReadACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-read-acp\"},\"GrantWrite\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write\"},\"GrantWriteACP\":{\"location\":\"header\",\"locationName\":\"x-amz-grant-write-acp\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"AccessControlPolicy\"},\"output\":{\"type\":\"structure\",\"members\":{\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}},\"httpChecksumRequired\":true},\"PutObjectLegalHold\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}?legal-hold\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"LegalHold\":{\"shape\":\"S9k\",\"locationName\":\"LegalHold\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"LegalHold\"},\"output\":{\"type\":\"structure\",\"members\":{\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}},\"httpChecksumRequired\":true},\"PutObjectLockConfiguration\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?object-lock\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ObjectLockConfiguration\":{\"shape\":\"S9n\",\"locationName\":\"ObjectLockConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"Token\":{\"location\":\"header\",\"locationName\":\"x-amz-bucket-object-lock-token\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"ObjectLockConfiguration\"},\"output\":{\"type\":\"structure\",\"members\":{\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}},\"httpChecksumRequired\":true},\"PutObjectRetention\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}?retention\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"Retention\":{\"shape\":\"S9v\",\"locationName\":\"Retention\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"BypassGovernanceRetention\":{\"location\":\"header\",\"locationName\":\"x-amz-bypass-governance-retention\",\"type\":\"boolean\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"Retention\"},\"output\":{\"type\":\"structure\",\"members\":{\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}},\"httpChecksumRequired\":true},\"PutObjectTagging\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}?tagging\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\",\"Tagging\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"Tagging\":{\"shape\":\"Sct\",\"locationName\":\"Tagging\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"Tagging\"},\"output\":{\"type\":\"structure\",\"members\":{\"VersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-version-id\"}}},\"httpChecksumRequired\":true},\"PutPublicAccessBlock\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}?publicAccessBlock\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"PublicAccessBlockConfiguration\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"PublicAccessBlockConfiguration\":{\"shape\":\"Sa2\",\"locationName\":\"PublicAccessBlockConfiguration\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"PublicAccessBlockConfiguration\"},\"httpChecksumRequired\":true},\"RestoreObject\":{\"http\":{\"requestUri\":\"/{Bucket}/{Key+}?restore\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"VersionId\":{\"location\":\"querystring\",\"locationName\":\"versionId\"},\"RestoreRequest\":{\"locationName\":\"RestoreRequest\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"members\":{\"Days\":{\"type\":\"integer\"},\"GlacierJobParameters\":{\"type\":\"structure\",\"required\":[\"Tier\"],\"members\":{\"Tier\":{}}},\"Type\":{},\"Tier\":{},\"Description\":{},\"SelectParameters\":{\"type\":\"structure\",\"required\":[\"InputSerialization\",\"ExpressionType\",\"Expression\",\"OutputSerialization\"],\"members\":{\"InputSerialization\":{\"shape\":\"Sdj\"},\"ExpressionType\":{},\"Expression\":{},\"OutputSerialization\":{\"shape\":\"Sdy\"}}},\"OutputLocation\":{\"type\":\"structure\",\"members\":{\"S3\":{\"type\":\"structure\",\"required\":[\"BucketName\",\"Prefix\"],\"members\":{\"BucketName\":{},\"Prefix\":{},\"Encryption\":{\"type\":\"structure\",\"required\":[\"EncryptionType\"],\"members\":{\"EncryptionType\":{},\"KMSKeyId\":{\"shape\":\"Sk\"},\"KMSContext\":{}}},\"CannedACL\":{},\"AccessControlList\":{\"shape\":\"S3a\"},\"Tagging\":{\"shape\":\"Sct\"},\"UserMetadata\":{\"type\":\"list\",\"member\":{\"locationName\":\"MetadataEntry\",\"type\":\"structure\",\"members\":{\"Name\":{},\"Value\":{}}}},\"StorageClass\":{}}}}}}},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"RestoreRequest\"},\"output\":{\"type\":\"structure\",\"members\":{\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"},\"RestoreOutputPath\":{\"location\":\"header\",\"locationName\":\"x-amz-restore-output-path\"}}},\"alias\":\"PostObjectRestore\"},\"SelectObjectContent\":{\"http\":{\"requestUri\":\"/{Bucket}/{Key+}?select&select-type=2\"},\"input\":{\"locationName\":\"SelectObjectContentRequest\",\"xmlNamespace\":{\"uri\":\"http://s3.amazonaws.com/doc/2006-03-01/\"},\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\",\"Expression\",\"ExpressionType\",\"InputSerialization\",\"OutputSerialization\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"Expression\":{},\"ExpressionType\":{},\"RequestProgress\":{\"type\":\"structure\",\"members\":{\"Enabled\":{\"type\":\"boolean\"}}},\"InputSerialization\":{\"shape\":\"Sdj\"},\"OutputSerialization\":{\"shape\":\"Sdy\"},\"ScanRange\":{\"type\":\"structure\",\"members\":{\"Start\":{\"type\":\"long\"},\"End\":{\"type\":\"long\"}}},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"Payload\":{\"type\":\"structure\",\"members\":{\"Records\":{\"type\":\"structure\",\"members\":{\"Payload\":{\"eventpayload\":true,\"type\":\"blob\"}},\"event\":true},\"Stats\":{\"type\":\"structure\",\"members\":{\"Details\":{\"eventpayload\":true,\"type\":\"structure\",\"members\":{\"BytesScanned\":{\"type\":\"long\"},\"BytesProcessed\":{\"type\":\"long\"},\"BytesReturned\":{\"type\":\"long\"}}}},\"event\":true},\"Progress\":{\"type\":\"structure\",\"members\":{\"Details\":{\"eventpayload\":true,\"type\":\"structure\",\"members\":{\"BytesScanned\":{\"type\":\"long\"},\"BytesProcessed\":{\"type\":\"long\"},\"BytesReturned\":{\"type\":\"long\"}}}},\"event\":true},\"Cont\":{\"type\":\"structure\",\"members\":{},\"event\":true},\"End\":{\"type\":\"structure\",\"members\":{},\"event\":true}},\"eventstream\":true}},\"payload\":\"Payload\"}},\"UploadPart\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Key\",\"PartNumber\",\"UploadId\"],\"members\":{\"Body\":{\"streaming\":true,\"type\":\"blob\"},\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ContentLength\":{\"location\":\"header\",\"locationName\":\"Content-Length\",\"type\":\"long\"},\"ContentMD5\":{\"location\":\"header\",\"locationName\":\"Content-MD5\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"PartNumber\":{\"location\":\"querystring\",\"locationName\":\"partNumber\",\"type\":\"integer\"},\"UploadId\":{\"location\":\"querystring\",\"locationName\":\"uploadId\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}},\"payload\":\"Body\"},\"output\":{\"type\":\"structure\",\"members\":{\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"ETag\":{\"location\":\"header\",\"locationName\":\"ETag\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}}}},\"UploadPartCopy\":{\"http\":{\"method\":\"PUT\",\"requestUri\":\"/{Bucket}/{Key+}\"},\"input\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"CopySource\",\"Key\",\"PartNumber\",\"UploadId\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"CopySource\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source\"},\"CopySourceIfMatch\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-match\"},\"CopySourceIfModifiedSince\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-modified-since\",\"type\":\"timestamp\"},\"CopySourceIfNoneMatch\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-none-match\"},\"CopySourceIfUnmodifiedSince\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-if-unmodified-since\",\"type\":\"timestamp\"},\"CopySourceRange\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-range\"},\"Key\":{\"location\":\"uri\",\"locationName\":\"Key\"},\"PartNumber\":{\"location\":\"querystring\",\"locationName\":\"partNumber\",\"type\":\"integer\"},\"UploadId\":{\"location\":\"querystring\",\"locationName\":\"uploadId\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKey\":{\"shape\":\"S1b\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"CopySourceSSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-server-side-encryption-customer-algorithm\"},\"CopySourceSSECustomerKey\":{\"shape\":\"S1f\",\"location\":\"header\",\"locationName\":\"x-amz-copy-source-server-side-encryption-customer-key\"},\"CopySourceSSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-server-side-encryption-customer-key-MD5\"},\"RequestPayer\":{\"location\":\"header\",\"locationName\":\"x-amz-request-payer\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"},\"ExpectedSourceBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-source-expected-bucket-owner\"}}},\"output\":{\"type\":\"structure\",\"members\":{\"CopySourceVersionId\":{\"location\":\"header\",\"locationName\":\"x-amz-copy-source-version-id\"},\"CopyPartResult\":{\"type\":\"structure\",\"members\":{\"ETag\":{},\"LastModified\":{\"type\":\"timestamp\"}}},\"ServerSideEncryption\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption\"},\"SSECustomerAlgorithm\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-algorithm\"},\"SSECustomerKeyMD5\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-customer-key-MD5\"},\"SSEKMSKeyId\":{\"shape\":\"Sk\",\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-aws-kms-key-id\"},\"BucketKeyEnabled\":{\"location\":\"header\",\"locationName\":\"x-amz-server-side-encryption-bucket-key-enabled\",\"type\":\"boolean\"},\"RequestCharged\":{\"location\":\"header\",\"locationName\":\"x-amz-request-charged\"}},\"payload\":\"CopyPartResult\"}}},\"shapes\":{\"Sk\":{\"type\":\"string\",\"sensitive\":true},\"S13\":{\"type\":\"map\",\"key\":{},\"value\":{}},\"S1b\":{\"type\":\"blob\",\"sensitive\":true},\"S1d\":{\"type\":\"string\",\"sensitive\":true},\"S1f\":{\"type\":\"blob\",\"sensitive\":true},\"S1j\":{\"type\":\"timestamp\",\"timestampFormat\":\"iso8601\"},\"S37\":{\"type\":\"structure\",\"members\":{\"DisplayName\":{},\"ID\":{}}},\"S3a\":{\"type\":\"list\",\"member\":{\"locationName\":\"Grant\",\"type\":\"structure\",\"members\":{\"Grantee\":{\"shape\":\"S3c\"},\"Permission\":{}}}},\"S3c\":{\"type\":\"structure\",\"required\":[\"Type\"],\"members\":{\"DisplayName\":{},\"EmailAddress\":{},\"ID\":{},\"Type\":{\"locationName\":\"xsi:type\",\"xmlAttribute\":true},\"URI\":{}},\"xmlNamespace\":{\"prefix\":\"xsi\",\"uri\":\"http://www.w3.org/2001/XMLSchema-instance\"}},\"S3j\":{\"type\":\"structure\",\"required\":[\"Id\",\"StorageClassAnalysis\"],\"members\":{\"Id\":{},\"Filter\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tag\":{\"shape\":\"S3m\"},\"And\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tags\":{\"shape\":\"S3p\",\"flattened\":true,\"locationName\":\"Tag\"}}}}},\"StorageClassAnalysis\":{\"type\":\"structure\",\"members\":{\"DataExport\":{\"type\":\"structure\",\"required\":[\"OutputSchemaVersion\",\"Destination\"],\"members\":{\"OutputSchemaVersion\":{},\"Destination\":{\"type\":\"structure\",\"required\":[\"S3BucketDestination\"],\"members\":{\"S3BucketDestination\":{\"type\":\"structure\",\"required\":[\"Format\",\"Bucket\"],\"members\":{\"Format\":{},\"BucketAccountId\":{},\"Bucket\":{},\"Prefix\":{}}}}}}}}}}},\"S3m\":{\"type\":\"structure\",\"required\":[\"Key\",\"Value\"],\"members\":{\"Key\":{},\"Value\":{}}},\"S3p\":{\"type\":\"list\",\"member\":{\"shape\":\"S3m\",\"locationName\":\"Tag\"}},\"S3y\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"AllowedMethods\",\"AllowedOrigins\"],\"members\":{\"AllowedHeaders\":{\"locationName\":\"AllowedHeader\",\"type\":\"list\",\"member\":{},\"flattened\":true},\"AllowedMethods\":{\"locationName\":\"AllowedMethod\",\"type\":\"list\",\"member\":{},\"flattened\":true},\"AllowedOrigins\":{\"locationName\":\"AllowedOrigin\",\"type\":\"list\",\"member\":{},\"flattened\":true},\"ExposeHeaders\":{\"locationName\":\"ExposeHeader\",\"type\":\"list\",\"member\":{},\"flattened\":true},\"MaxAgeSeconds\":{\"type\":\"integer\"}}},\"flattened\":true},\"S4b\":{\"type\":\"structure\",\"required\":[\"Rules\"],\"members\":{\"Rules\":{\"locationName\":\"Rule\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"ApplyServerSideEncryptionByDefault\":{\"type\":\"structure\",\"required\":[\"SSEAlgorithm\"],\"members\":{\"SSEAlgorithm\":{},\"KMSMasterKeyID\":{\"shape\":\"Sk\"}}},\"BucketKeyEnabled\":{\"type\":\"boolean\"}}},\"flattened\":true}}},\"S4h\":{\"type\":\"structure\",\"required\":[\"Id\",\"Status\",\"Tierings\"],\"members\":{\"Id\":{},\"Filter\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tag\":{\"shape\":\"S3m\"},\"And\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tags\":{\"shape\":\"S3p\",\"flattened\":true,\"locationName\":\"Tag\"}}}}},\"Status\":{},\"Tierings\":{\"locationName\":\"Tiering\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"Days\",\"AccessTier\"],\"members\":{\"Days\":{\"type\":\"integer\"},\"AccessTier\":{}}},\"flattened\":true}}},\"S4r\":{\"type\":\"structure\",\"required\":[\"Destination\",\"IsEnabled\",\"Id\",\"IncludedObjectVersions\",\"Schedule\"],\"members\":{\"Destination\":{\"type\":\"structure\",\"required\":[\"S3BucketDestination\"],\"members\":{\"S3BucketDestination\":{\"type\":\"structure\",\"required\":[\"Bucket\",\"Format\"],\"members\":{\"AccountId\":{},\"Bucket\":{},\"Format\":{},\"Prefix\":{},\"Encryption\":{\"type\":\"structure\",\"members\":{\"SSES3\":{\"locationName\":\"SSE-S3\",\"type\":\"structure\",\"members\":{}},\"SSEKMS\":{\"locationName\":\"SSE-KMS\",\"type\":\"structure\",\"required\":[\"KeyId\"],\"members\":{\"KeyId\":{\"shape\":\"Sk\"}}}}}}}}},\"IsEnabled\":{\"type\":\"boolean\"},\"Filter\":{\"type\":\"structure\",\"required\":[\"Prefix\"],\"members\":{\"Prefix\":{}}},\"Id\":{},\"IncludedObjectVersions\":{},\"OptionalFields\":{\"type\":\"list\",\"member\":{\"locationName\":\"Field\"}},\"Schedule\":{\"type\":\"structure\",\"required\":[\"Frequency\"],\"members\":{\"Frequency\":{}}}}},\"S57\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"Prefix\",\"Status\"],\"members\":{\"Expiration\":{\"shape\":\"S59\"},\"ID\":{},\"Prefix\":{},\"Status\":{},\"Transition\":{\"shape\":\"S5e\"},\"NoncurrentVersionTransition\":{\"shape\":\"S5g\"},\"NoncurrentVersionExpiration\":{\"shape\":\"S5h\"},\"AbortIncompleteMultipartUpload\":{\"shape\":\"S5i\"}}},\"flattened\":true},\"S59\":{\"type\":\"structure\",\"members\":{\"Date\":{\"shape\":\"S5a\"},\"Days\":{\"type\":\"integer\"},\"ExpiredObjectDeleteMarker\":{\"type\":\"boolean\"}}},\"S5a\":{\"type\":\"timestamp\",\"timestampFormat\":\"iso8601\"},\"S5e\":{\"type\":\"structure\",\"members\":{\"Date\":{\"shape\":\"S5a\"},\"Days\":{\"type\":\"integer\"},\"StorageClass\":{}}},\"S5g\":{\"type\":\"structure\",\"members\":{\"NoncurrentDays\":{\"type\":\"integer\"},\"StorageClass\":{}}},\"S5h\":{\"type\":\"structure\",\"members\":{\"NoncurrentDays\":{\"type\":\"integer\"}}},\"S5i\":{\"type\":\"structure\",\"members\":{\"DaysAfterInitiation\":{\"type\":\"integer\"}}},\"S5m\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"Status\"],\"members\":{\"Expiration\":{\"shape\":\"S59\"},\"ID\":{},\"Prefix\":{\"deprecated\":true},\"Filter\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tag\":{\"shape\":\"S3m\"},\"And\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tags\":{\"shape\":\"S3p\",\"flattened\":true,\"locationName\":\"Tag\"}}}}},\"Status\":{},\"Transitions\":{\"locationName\":\"Transition\",\"type\":\"list\",\"member\":{\"shape\":\"S5e\"},\"flattened\":true},\"NoncurrentVersionTransitions\":{\"locationName\":\"NoncurrentVersionTransition\",\"type\":\"list\",\"member\":{\"shape\":\"S5g\"},\"flattened\":true},\"NoncurrentVersionExpiration\":{\"shape\":\"S5h\"},\"AbortIncompleteMultipartUpload\":{\"shape\":\"S5i\"}}},\"flattened\":true},\"S5w\":{\"type\":\"structure\",\"required\":[\"TargetBucket\",\"TargetPrefix\"],\"members\":{\"TargetBucket\":{},\"TargetGrants\":{\"type\":\"list\",\"member\":{\"locationName\":\"Grant\",\"type\":\"structure\",\"members\":{\"Grantee\":{\"shape\":\"S3c\"},\"Permission\":{}}}},\"TargetPrefix\":{}}},\"S64\":{\"type\":\"structure\",\"required\":[\"Id\"],\"members\":{\"Id\":{},\"Filter\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tag\":{\"shape\":\"S3m\"},\"And\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tags\":{\"shape\":\"S3p\",\"flattened\":true,\"locationName\":\"Tag\"}}}}}}},\"S67\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{\"location\":\"uri\",\"locationName\":\"Bucket\"},\"ExpectedBucketOwner\":{\"location\":\"header\",\"locationName\":\"x-amz-expected-bucket-owner\"}}},\"S68\":{\"type\":\"structure\",\"members\":{\"TopicConfiguration\":{\"type\":\"structure\",\"members\":{\"Id\":{},\"Events\":{\"shape\":\"S6b\",\"locationName\":\"Event\"},\"Event\":{\"deprecated\":true},\"Topic\":{}}},\"QueueConfiguration\":{\"type\":\"structure\",\"members\":{\"Id\":{},\"Event\":{\"deprecated\":true},\"Events\":{\"shape\":\"S6b\",\"locationName\":\"Event\"},\"Queue\":{}}},\"CloudFunctionConfiguration\":{\"type\":\"structure\",\"members\":{\"Id\":{},\"Event\":{\"deprecated\":true},\"Events\":{\"shape\":\"S6b\",\"locationName\":\"Event\"},\"CloudFunction\":{},\"InvocationRole\":{}}}}},\"S6b\":{\"type\":\"list\",\"member\":{},\"flattened\":true},\"S6j\":{\"type\":\"structure\",\"members\":{\"TopicConfigurations\":{\"locationName\":\"TopicConfiguration\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"TopicArn\",\"Events\"],\"members\":{\"Id\":{},\"TopicArn\":{\"locationName\":\"Topic\"},\"Events\":{\"shape\":\"S6b\",\"locationName\":\"Event\"},\"Filter\":{\"shape\":\"S6m\"}}},\"flattened\":true},\"QueueConfigurations\":{\"locationName\":\"QueueConfiguration\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"QueueArn\",\"Events\"],\"members\":{\"Id\":{},\"QueueArn\":{\"locationName\":\"Queue\"},\"Events\":{\"shape\":\"S6b\",\"locationName\":\"Event\"},\"Filter\":{\"shape\":\"S6m\"}}},\"flattened\":true},\"LambdaFunctionConfigurations\":{\"locationName\":\"CloudFunctionConfiguration\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"LambdaFunctionArn\",\"Events\"],\"members\":{\"Id\":{},\"LambdaFunctionArn\":{\"locationName\":\"CloudFunction\"},\"Events\":{\"shape\":\"S6b\",\"locationName\":\"Event\"},\"Filter\":{\"shape\":\"S6m\"}}},\"flattened\":true}}},\"S6m\":{\"type\":\"structure\",\"members\":{\"Key\":{\"locationName\":\"S3Key\",\"type\":\"structure\",\"members\":{\"FilterRules\":{\"locationName\":\"FilterRule\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"Name\":{},\"Value\":{}}},\"flattened\":true}}}}},\"S6z\":{\"type\":\"structure\",\"required\":[\"Rules\"],\"members\":{\"Rules\":{\"locationName\":\"Rule\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"ObjectOwnership\"],\"members\":{\"ObjectOwnership\":{}}},\"flattened\":true}}},\"S7c\":{\"type\":\"structure\",\"required\":[\"Role\",\"Rules\"],\"members\":{\"Role\":{},\"Rules\":{\"locationName\":\"Rule\",\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"Status\",\"Destination\"],\"members\":{\"ID\":{},\"Priority\":{\"type\":\"integer\"},\"Prefix\":{\"deprecated\":true},\"Filter\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tag\":{\"shape\":\"S3m\"},\"And\":{\"type\":\"structure\",\"members\":{\"Prefix\":{},\"Tags\":{\"shape\":\"S3p\",\"flattened\":true,\"locationName\":\"Tag\"}}}}},\"Status\":{},\"SourceSelectionCriteria\":{\"type\":\"structure\",\"members\":{\"SseKmsEncryptedObjects\":{\"type\":\"structure\",\"required\":[\"Status\"],\"members\":{\"Status\":{}}},\"ReplicaModifications\":{\"type\":\"structure\",\"required\":[\"Status\"],\"members\":{\"Status\":{}}}}},\"ExistingObjectReplication\":{\"type\":\"structure\",\"required\":[\"Status\"],\"members\":{\"Status\":{}}},\"Destination\":{\"type\":\"structure\",\"required\":[\"Bucket\"],\"members\":{\"Bucket\":{},\"Account\":{},\"StorageClass\":{},\"AccessControlTranslation\":{\"type\":\"structure\",\"required\":[\"Owner\"],\"members\":{\"Owner\":{}}},\"EncryptionConfiguration\":{\"type\":\"structure\",\"members\":{\"ReplicaKmsKeyID\":{}}},\"ReplicationTime\":{\"type\":\"structure\",\"required\":[\"Status\",\"Time\"],\"members\":{\"Status\":{},\"Time\":{\"shape\":\"S7y\"}}},\"Metrics\":{\"type\":\"structure\",\"required\":[\"Status\"],\"members\":{\"Status\":{},\"EventThreshold\":{\"shape\":\"S7y\"}}}}},\"DeleteMarkerReplication\":{\"type\":\"structure\",\"members\":{\"Status\":{}}}}},\"flattened\":true}}},\"S7y\":{\"type\":\"structure\",\"members\":{\"Minutes\":{\"type\":\"integer\"}}},\"S8f\":{\"type\":\"structure\",\"required\":[\"HostName\"],\"members\":{\"HostName\":{},\"Protocol\":{}}},\"S8i\":{\"type\":\"structure\",\"required\":[\"Suffix\"],\"members\":{\"Suffix\":{}}},\"S8k\":{\"type\":\"structure\",\"required\":[\"Key\"],\"members\":{\"Key\":{}}},\"S8l\":{\"type\":\"list\",\"member\":{\"locationName\":\"RoutingRule\",\"type\":\"structure\",\"required\":[\"Redirect\"],\"members\":{\"Condition\":{\"type\":\"structure\",\"members\":{\"HttpErrorCodeReturnedEquals\":{},\"KeyPrefixEquals\":{}}},\"Redirect\":{\"type\":\"structure\",\"members\":{\"HostName\":{},\"HttpRedirectCode\":{},\"Protocol\":{},\"ReplaceKeyPrefixWith\":{},\"ReplaceKeyWith\":{}}}}}},\"S9k\":{\"type\":\"structure\",\"members\":{\"Status\":{}}},\"S9n\":{\"type\":\"structure\",\"members\":{\"ObjectLockEnabled\":{},\"Rule\":{\"type\":\"structure\",\"members\":{\"DefaultRetention\":{\"type\":\"structure\",\"members\":{\"Mode\":{},\"Days\":{\"type\":\"integer\"},\"Years\":{\"type\":\"integer\"}}}}}}},\"S9v\":{\"type\":\"structure\",\"members\":{\"Mode\":{},\"RetainUntilDate\":{\"shape\":\"S5a\"}}},\"Sa2\":{\"type\":\"structure\",\"members\":{\"BlockPublicAcls\":{\"locationName\":\"BlockPublicAcls\",\"type\":\"boolean\"},\"IgnorePublicAcls\":{\"locationName\":\"IgnorePublicAcls\",\"type\":\"boolean\"},\"BlockPublicPolicy\":{\"locationName\":\"BlockPublicPolicy\",\"type\":\"boolean\"},\"RestrictPublicBuckets\":{\"locationName\":\"RestrictPublicBuckets\",\"type\":\"boolean\"}}},\"Sb3\":{\"type\":\"structure\",\"members\":{\"ID\":{},\"DisplayName\":{}}},\"Sb4\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"Prefix\":{}}},\"flattened\":true},\"Sbm\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"Key\":{},\"LastModified\":{\"type\":\"timestamp\"},\"ETag\":{},\"Size\":{\"type\":\"integer\"},\"StorageClass\":{},\"Owner\":{\"shape\":\"S37\"}}},\"flattened\":true},\"Sc4\":{\"type\":\"structure\",\"members\":{\"Grants\":{\"shape\":\"S3a\",\"locationName\":\"AccessControlList\"},\"Owner\":{\"shape\":\"S37\"}}},\"Sct\":{\"type\":\"structure\",\"required\":[\"TagSet\"],\"members\":{\"TagSet\":{\"shape\":\"S3p\"}}},\"Sdj\":{\"type\":\"structure\",\"members\":{\"CSV\":{\"type\":\"structure\",\"members\":{\"FileHeaderInfo\":{},\"Comments\":{},\"QuoteEscapeCharacter\":{},\"RecordDelimiter\":{},\"FieldDelimiter\":{},\"QuoteCharacter\":{},\"AllowQuotedRecordDelimiter\":{\"type\":\"boolean\"}}},\"CompressionType\":{},\"JSON\":{\"type\":\"structure\",\"members\":{\"Type\":{}}},\"Parquet\":{\"type\":\"structure\",\"members\":{}}}},\"Sdy\":{\"type\":\"structure\",\"members\":{\"CSV\":{\"type\":\"structure\",\"members\":{\"QuoteFields\":{},\"QuoteEscapeCharacter\":{},\"RecordDelimiter\":{},\"FieldDelimiter\":{},\"QuoteCharacter\":{}}},\"JSON\":{\"type\":\"structure\",\"members\":{\"RecordDelimiter\":{}}}}}}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/apis/s3-2006-03-01.paginators.json":
  /*!*****************************************************************!*\
    !*** ./node_modules/aws-sdk/apis/s3-2006-03-01.paginators.json ***!
    \*****************************************************************/

  /*! exports provided: pagination, default */

  /***/
  function node_modulesAwsSdkApisS320060301PaginatorsJson(module) {
    module.exports = JSON.parse("{\"pagination\":{\"ListBuckets\":{\"result_key\":\"Buckets\"},\"ListMultipartUploads\":{\"input_token\":[\"KeyMarker\",\"UploadIdMarker\"],\"limit_key\":\"MaxUploads\",\"more_results\":\"IsTruncated\",\"output_token\":[\"NextKeyMarker\",\"NextUploadIdMarker\"],\"result_key\":[\"Uploads\",\"CommonPrefixes\"]},\"ListObjectVersions\":{\"input_token\":[\"KeyMarker\",\"VersionIdMarker\"],\"limit_key\":\"MaxKeys\",\"more_results\":\"IsTruncated\",\"output_token\":[\"NextKeyMarker\",\"NextVersionIdMarker\"],\"result_key\":[\"Versions\",\"DeleteMarkers\",\"CommonPrefixes\"]},\"ListObjects\":{\"input_token\":\"Marker\",\"limit_key\":\"MaxKeys\",\"more_results\":\"IsTruncated\",\"output_token\":\"NextMarker || Contents[-1].Key\",\"result_key\":[\"Contents\",\"CommonPrefixes\"]},\"ListObjectsV2\":{\"input_token\":\"ContinuationToken\",\"limit_key\":\"MaxKeys\",\"output_token\":\"NextContinuationToken\",\"result_key\":[\"Contents\",\"CommonPrefixes\"]},\"ListParts\":{\"input_token\":\"PartNumberMarker\",\"limit_key\":\"MaxParts\",\"more_results\":\"IsTruncated\",\"output_token\":\"NextPartNumberMarker\",\"result_key\":\"Parts\"}}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/apis/s3-2006-03-01.waiters2.json":
  /*!***************************************************************!*\
    !*** ./node_modules/aws-sdk/apis/s3-2006-03-01.waiters2.json ***!
    \***************************************************************/

  /*! exports provided: version, waiters, default */

  /***/
  function node_modulesAwsSdkApisS320060301Waiters2Json(module) {
    module.exports = JSON.parse("{\"version\":2,\"waiters\":{\"BucketExists\":{\"delay\":5,\"operation\":\"HeadBucket\",\"maxAttempts\":20,\"acceptors\":[{\"expected\":200,\"matcher\":\"status\",\"state\":\"success\"},{\"expected\":301,\"matcher\":\"status\",\"state\":\"success\"},{\"expected\":403,\"matcher\":\"status\",\"state\":\"success\"},{\"expected\":404,\"matcher\":\"status\",\"state\":\"retry\"}]},\"BucketNotExists\":{\"delay\":5,\"operation\":\"HeadBucket\",\"maxAttempts\":20,\"acceptors\":[{\"expected\":404,\"matcher\":\"status\",\"state\":\"success\"}]},\"ObjectExists\":{\"delay\":5,\"operation\":\"HeadObject\",\"maxAttempts\":20,\"acceptors\":[{\"expected\":200,\"matcher\":\"status\",\"state\":\"success\"},{\"expected\":404,\"matcher\":\"status\",\"state\":\"retry\"}]},\"ObjectNotExists\":{\"delay\":5,\"operation\":\"HeadObject\",\"maxAttempts\":20,\"acceptors\":[{\"expected\":404,\"matcher\":\"status\",\"state\":\"success\"}]}}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/apis/sts-2011-06-15.min.json":
  /*!***********************************************************!*\
    !*** ./node_modules/aws-sdk/apis/sts-2011-06-15.min.json ***!
    \***********************************************************/

  /*! exports provided: version, metadata, operations, shapes, default */

  /***/
  function node_modulesAwsSdkApisSts20110615MinJson(module) {
    module.exports = JSON.parse("{\"version\":\"2.0\",\"metadata\":{\"apiVersion\":\"2011-06-15\",\"endpointPrefix\":\"sts\",\"globalEndpoint\":\"sts.amazonaws.com\",\"protocol\":\"query\",\"serviceAbbreviation\":\"AWS STS\",\"serviceFullName\":\"AWS Security Token Service\",\"serviceId\":\"STS\",\"signatureVersion\":\"v4\",\"uid\":\"sts-2011-06-15\",\"xmlNamespace\":\"https://sts.amazonaws.com/doc/2011-06-15/\"},\"operations\":{\"AssumeRole\":{\"input\":{\"type\":\"structure\",\"required\":[\"RoleArn\",\"RoleSessionName\"],\"members\":{\"RoleArn\":{},\"RoleSessionName\":{},\"PolicyArns\":{\"shape\":\"S4\"},\"Policy\":{},\"DurationSeconds\":{\"type\":\"integer\"},\"Tags\":{\"shape\":\"S8\"},\"TransitiveTagKeys\":{\"type\":\"list\",\"member\":{}},\"ExternalId\":{},\"SerialNumber\":{},\"TokenCode\":{}}},\"output\":{\"resultWrapper\":\"AssumeRoleResult\",\"type\":\"structure\",\"members\":{\"Credentials\":{\"shape\":\"Sh\"},\"AssumedRoleUser\":{\"shape\":\"Sm\"},\"PackedPolicySize\":{\"type\":\"integer\"}}}},\"AssumeRoleWithSAML\":{\"input\":{\"type\":\"structure\",\"required\":[\"RoleArn\",\"PrincipalArn\",\"SAMLAssertion\"],\"members\":{\"RoleArn\":{},\"PrincipalArn\":{},\"SAMLAssertion\":{},\"PolicyArns\":{\"shape\":\"S4\"},\"Policy\":{},\"DurationSeconds\":{\"type\":\"integer\"}}},\"output\":{\"resultWrapper\":\"AssumeRoleWithSAMLResult\",\"type\":\"structure\",\"members\":{\"Credentials\":{\"shape\":\"Sh\"},\"AssumedRoleUser\":{\"shape\":\"Sm\"},\"PackedPolicySize\":{\"type\":\"integer\"},\"Subject\":{},\"SubjectType\":{},\"Issuer\":{},\"Audience\":{},\"NameQualifier\":{}}}},\"AssumeRoleWithWebIdentity\":{\"input\":{\"type\":\"structure\",\"required\":[\"RoleArn\",\"RoleSessionName\",\"WebIdentityToken\"],\"members\":{\"RoleArn\":{},\"RoleSessionName\":{},\"WebIdentityToken\":{},\"ProviderId\":{},\"PolicyArns\":{\"shape\":\"S4\"},\"Policy\":{},\"DurationSeconds\":{\"type\":\"integer\"}}},\"output\":{\"resultWrapper\":\"AssumeRoleWithWebIdentityResult\",\"type\":\"structure\",\"members\":{\"Credentials\":{\"shape\":\"Sh\"},\"SubjectFromWebIdentityToken\":{},\"AssumedRoleUser\":{\"shape\":\"Sm\"},\"PackedPolicySize\":{\"type\":\"integer\"},\"Provider\":{},\"Audience\":{}}}},\"DecodeAuthorizationMessage\":{\"input\":{\"type\":\"structure\",\"required\":[\"EncodedMessage\"],\"members\":{\"EncodedMessage\":{}}},\"output\":{\"resultWrapper\":\"DecodeAuthorizationMessageResult\",\"type\":\"structure\",\"members\":{\"DecodedMessage\":{}}}},\"GetAccessKeyInfo\":{\"input\":{\"type\":\"structure\",\"required\":[\"AccessKeyId\"],\"members\":{\"AccessKeyId\":{}}},\"output\":{\"resultWrapper\":\"GetAccessKeyInfoResult\",\"type\":\"structure\",\"members\":{\"Account\":{}}}},\"GetCallerIdentity\":{\"input\":{\"type\":\"structure\",\"members\":{}},\"output\":{\"resultWrapper\":\"GetCallerIdentityResult\",\"type\":\"structure\",\"members\":{\"UserId\":{},\"Account\":{},\"Arn\":{}}}},\"GetFederationToken\":{\"input\":{\"type\":\"structure\",\"required\":[\"Name\"],\"members\":{\"Name\":{},\"Policy\":{},\"PolicyArns\":{\"shape\":\"S4\"},\"DurationSeconds\":{\"type\":\"integer\"},\"Tags\":{\"shape\":\"S8\"}}},\"output\":{\"resultWrapper\":\"GetFederationTokenResult\",\"type\":\"structure\",\"members\":{\"Credentials\":{\"shape\":\"Sh\"},\"FederatedUser\":{\"type\":\"structure\",\"required\":[\"FederatedUserId\",\"Arn\"],\"members\":{\"FederatedUserId\":{},\"Arn\":{}}},\"PackedPolicySize\":{\"type\":\"integer\"}}}},\"GetSessionToken\":{\"input\":{\"type\":\"structure\",\"members\":{\"DurationSeconds\":{\"type\":\"integer\"},\"SerialNumber\":{},\"TokenCode\":{}}},\"output\":{\"resultWrapper\":\"GetSessionTokenResult\",\"type\":\"structure\",\"members\":{\"Credentials\":{\"shape\":\"Sh\"}}}}},\"shapes\":{\"S4\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"members\":{\"arn\":{}}}},\"S8\":{\"type\":\"list\",\"member\":{\"type\":\"structure\",\"required\":[\"Key\",\"Value\"],\"members\":{\"Key\":{},\"Value\":{}}}},\"Sh\":{\"type\":\"structure\",\"required\":[\"AccessKeyId\",\"SecretAccessKey\",\"SessionToken\",\"Expiration\"],\"members\":{\"AccessKeyId\":{},\"SecretAccessKey\":{},\"SessionToken\":{},\"Expiration\":{\"type\":\"timestamp\"}}},\"Sm\":{\"type\":\"structure\",\"required\":[\"AssumedRoleId\",\"Arn\"],\"members\":{\"AssumedRoleId\":{},\"Arn\":{}}}}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json":
  /*!******************************************************************!*\
    !*** ./node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json ***!
    \******************************************************************/

  /*! exports provided: pagination, default */

  /***/
  function node_modulesAwsSdkApisSts20110615PaginatorsJson(module) {
    module.exports = JSON.parse("{\"pagination\":{}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/clients/cognitoidentity.js":
  /*!*********************************************************!*\
    !*** ./node_modules/aws-sdk/clients/cognitoidentity.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkClientsCognitoidentityJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../lib/node_loader */
    "./node_modules/aws-sdk/lib/browser_loader.js");

    var AWS = __webpack_require__(
    /*! ../lib/core */
    "./node_modules/aws-sdk/lib/core.js");

    var Service = AWS.Service;
    var apiLoader = AWS.apiLoader;
    apiLoader.services['cognitoidentity'] = {};
    AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
    Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
      get: function get() {
        var model = __webpack_require__(
        /*! ../apis/cognito-identity-2014-06-30.min.json */
        "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json");

        model.paginators = __webpack_require__(
        /*! ../apis/cognito-identity-2014-06-30.paginators.json */
        "./node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json").pagination;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = AWS.CognitoIdentity;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/clients/s3.js":
  /*!********************************************!*\
    !*** ./node_modules/aws-sdk/clients/s3.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkClientsS3Js(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../lib/node_loader */
    "./node_modules/aws-sdk/lib/browser_loader.js");

    var AWS = __webpack_require__(
    /*! ../lib/core */
    "./node_modules/aws-sdk/lib/core.js");

    var Service = AWS.Service;
    var apiLoader = AWS.apiLoader;
    apiLoader.services['s3'] = {};
    AWS.S3 = Service.defineService('s3', ['2006-03-01']);

    __webpack_require__(
    /*! ../lib/services/s3 */
    "./node_modules/aws-sdk/lib/services/s3.js");

    Object.defineProperty(apiLoader.services['s3'], '2006-03-01', {
      get: function get() {
        var model = __webpack_require__(
        /*! ../apis/s3-2006-03-01.min.json */
        "./node_modules/aws-sdk/apis/s3-2006-03-01.min.json");

        model.paginators = __webpack_require__(
        /*! ../apis/s3-2006-03-01.paginators.json */
        "./node_modules/aws-sdk/apis/s3-2006-03-01.paginators.json").pagination;
        model.waiters = __webpack_require__(
        /*! ../apis/s3-2006-03-01.waiters2.json */
        "./node_modules/aws-sdk/apis/s3-2006-03-01.waiters2.json").waiters;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = AWS.S3;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/clients/sts.js":
  /*!*********************************************!*\
    !*** ./node_modules/aws-sdk/clients/sts.js ***!
    \*********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkClientsStsJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../lib/node_loader */
    "./node_modules/aws-sdk/lib/browser_loader.js");

    var AWS = __webpack_require__(
    /*! ../lib/core */
    "./node_modules/aws-sdk/lib/core.js");

    var Service = AWS.Service;
    var apiLoader = AWS.apiLoader;
    apiLoader.services['sts'] = {};
    AWS.STS = Service.defineService('sts', ['2011-06-15']);

    __webpack_require__(
    /*! ../lib/services/sts */
    "./node_modules/aws-sdk/lib/services/sts.js");

    Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
      get: function get() {
        var model = __webpack_require__(
        /*! ../apis/sts-2011-06-15.min.json */
        "./node_modules/aws-sdk/apis/sts-2011-06-15.min.json");

        model.paginators = __webpack_require__(
        /*! ../apis/sts-2011-06-15.paginators.json */
        "./node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json").pagination;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = AWS.STS;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/api_loader.js":
  /*!************************************************!*\
    !*** ./node_modules/aws-sdk/lib/api_loader.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibApi_loaderJs(module, exports) {
    function apiLoader(svc, version) {
      if (!apiLoader.services.hasOwnProperty(svc)) {
        throw new Error('InvalidService: Failed to load api for ' + svc);
      }

      return apiLoader.services[svc][version];
    }
    /**
     * @api private
     *
     * This member of AWS.apiLoader is private, but changing it will necessitate a
     * change to ../scripts/services-table-generator.ts
     */


    apiLoader.services = {};
    /**
     * @api private
     */

    module.exports = apiLoader;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/browserCryptoLib.js":
  /*!******************************************************!*\
    !*** ./node_modules/aws-sdk/lib/browserCryptoLib.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibBrowserCryptoLibJs(module, exports, __webpack_require__) {
    var Hmac = __webpack_require__(
    /*! ./browserHmac */
    "./node_modules/aws-sdk/lib/browserHmac.js");

    var Md5 = __webpack_require__(
    /*! ./browserMd5 */
    "./node_modules/aws-sdk/lib/browserMd5.js");

    var Sha1 = __webpack_require__(
    /*! ./browserSha1 */
    "./node_modules/aws-sdk/lib/browserSha1.js");

    var Sha256 = __webpack_require__(
    /*! ./browserSha256 */
    "./node_modules/aws-sdk/lib/browserSha256.js");
    /**
     * @api private
     */


    module.exports = exports = {
      createHash: function createHash(alg) {
        alg = alg.toLowerCase();

        if (alg === 'md5') {
          return new Md5();
        } else if (alg === 'sha256') {
          return new Sha256();
        } else if (alg === 'sha1') {
          return new Sha1();
        }

        throw new Error('Hash algorithm ' + alg + ' is not supported in the browser SDK');
      },
      createHmac: function createHmac(alg, key) {
        alg = alg.toLowerCase();

        if (alg === 'md5') {
          return new Hmac(Md5, key);
        } else if (alg === 'sha256') {
          return new Hmac(Sha256, key);
        } else if (alg === 'sha1') {
          return new Hmac(Sha1, key);
        }

        throw new Error('HMAC algorithm ' + alg + ' is not supported in the browser SDK');
      },
      createSign: function createSign() {
        throw new Error('createSign is not implemented in the browser');
      }
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/browserHashUtils.js":
  /*!******************************************************!*\
    !*** ./node_modules/aws-sdk/lib/browserHashUtils.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibBrowserHashUtilsJs(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(
    /*! buffer/ */
    "./node_modules/buffer/index.js").Buffer;
    /**
     * This is a polyfill for the static method `isView` of `ArrayBuffer`, which is
     * e.g. missing in IE 10.
     *
     * @api private
     */


    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'undefined') {
      ArrayBuffer.isView = function (arg) {
        return viewStrings.indexOf(Object.prototype.toString.call(arg)) > -1;
      };
    }
    /**
     * @api private
     */


    var viewStrings = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]', '[object DataView]'];
    /**
     * @api private
     */

    function isEmptyData(data) {
      if (typeof data === 'string') {
        return data.length === 0;
      }

      return data.byteLength === 0;
    }
    /**
     * @api private
     */


    function convertToBuffer(data) {
      if (typeof data === 'string') {
        data = new Buffer(data, 'utf8');
      }

      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }

      return new Uint8Array(data);
    }
    /**
     * @api private
     */


    module.exports = exports = {
      isEmptyData: isEmptyData,
      convertToBuffer: convertToBuffer
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/browserHmac.js":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/lib/browserHmac.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibBrowserHmacJs(module, exports, __webpack_require__) {
    var hashUtils = __webpack_require__(
    /*! ./browserHashUtils */
    "./node_modules/aws-sdk/lib/browserHashUtils.js");
    /**
     * @api private
     */


    function Hmac(hashCtor, secret) {
      this.hash = new hashCtor();
      this.outer = new hashCtor();
      var inner = bufferFromSecret(hashCtor, secret);
      var outer = new Uint8Array(hashCtor.BLOCK_SIZE);
      outer.set(inner);

      for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {
        inner[i] ^= 0x36;
        outer[i] ^= 0x5c;
      }

      this.hash.update(inner);
      this.outer.update(outer); // Zero out the copied key buffer.

      for (var i = 0; i < inner.byteLength; i++) {
        inner[i] = 0;
      }
    }
    /**
     * @api private
     */


    module.exports = exports = Hmac;

    Hmac.prototype.update = function (toHash) {
      if (hashUtils.isEmptyData(toHash) || this.error) {
        return this;
      }

      try {
        this.hash.update(hashUtils.convertToBuffer(toHash));
      } catch (e) {
        this.error = e;
      }

      return this;
    };

    Hmac.prototype.digest = function (encoding) {
      if (!this.outer.finished) {
        this.outer.update(this.hash.digest());
      }

      return this.outer.digest(encoding);
    };

    function bufferFromSecret(hashCtor, secret) {
      var input = hashUtils.convertToBuffer(secret);

      if (input.byteLength > hashCtor.BLOCK_SIZE) {
        var bufferHash = new hashCtor();
        bufferHash.update(input);
        input = bufferHash.digest();
      }

      var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);
      buffer.set(input);
      return buffer;
    }
    /***/

  },

  /***/
  "./node_modules/aws-sdk/lib/browserMd5.js":
  /*!************************************************!*\
    !*** ./node_modules/aws-sdk/lib/browserMd5.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibBrowserMd5Js(module, exports, __webpack_require__) {
    var hashUtils = __webpack_require__(
    /*! ./browserHashUtils */
    "./node_modules/aws-sdk/lib/browserHashUtils.js");

    var Buffer = __webpack_require__(
    /*! buffer/ */
    "./node_modules/buffer/index.js").Buffer;

    var BLOCK_SIZE = 64;
    var DIGEST_LENGTH = 16;
    var INIT = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];
    /**
     * @api private
     */

    function Md5() {
      this.state = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];
      this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
      this.bufferLength = 0;
      this.bytesHashed = 0;
      this.finished = false;
    }
    /**
     * @api private
     */


    module.exports = exports = Md5;
    Md5.BLOCK_SIZE = BLOCK_SIZE;

    Md5.prototype.update = function (sourceData) {
      if (hashUtils.isEmptyData(sourceData)) {
        return this;
      } else if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
      }

      var data = hashUtils.convertToBuffer(sourceData);
      var position = 0;
      var byteLength = data.byteLength;
      this.bytesHashed += byteLength;

      while (byteLength > 0) {
        this.buffer.setUint8(this.bufferLength++, data[position++]);
        byteLength--;

        if (this.bufferLength === BLOCK_SIZE) {
          this.hashBuffer();
          this.bufferLength = 0;
        }
      }

      return this;
    };

    Md5.prototype.digest = function (encoding) {
      if (!this.finished) {
        var _a = this,
            buffer = _a.buffer,
            undecoratedLength = _a.bufferLength,
            bytesHashed = _a.bytesHashed;

        var bitsHashed = bytesHashed * 8;
        buffer.setUint8(this.bufferLength++, 128); // Ensure the final block has enough room for the hashed length

        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
          for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
            buffer.setUint8(i, 0);
          }

          this.hashBuffer();
          this.bufferLength = 0;
        }

        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
          buffer.setUint8(i, 0);
        }

        buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
        buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 0x100000000), true);
        this.hashBuffer();
        this.finished = true;
      }

      var out = new DataView(new ArrayBuffer(DIGEST_LENGTH));

      for (var i = 0; i < 4; i++) {
        out.setUint32(i * 4, this.state[i], true);
      }

      var buff = new Buffer(out.buffer, out.byteOffset, out.byteLength);
      return encoding ? buff.toString(encoding) : buff;
    };

    Md5.prototype.hashBuffer = function () {
      var _a = this,
          buffer = _a.buffer,
          state = _a.state;

      var a = state[0],
          b = state[1],
          c = state[2],
          d = state[3];
      a = ff(a, b, c, d, buffer.getUint32(0, true), 7, 0xd76aa478);
      d = ff(d, a, b, c, buffer.getUint32(4, true), 12, 0xe8c7b756);
      c = ff(c, d, a, b, buffer.getUint32(8, true), 17, 0x242070db);
      b = ff(b, c, d, a, buffer.getUint32(12, true), 22, 0xc1bdceee);
      a = ff(a, b, c, d, buffer.getUint32(16, true), 7, 0xf57c0faf);
      d = ff(d, a, b, c, buffer.getUint32(20, true), 12, 0x4787c62a);
      c = ff(c, d, a, b, buffer.getUint32(24, true), 17, 0xa8304613);
      b = ff(b, c, d, a, buffer.getUint32(28, true), 22, 0xfd469501);
      a = ff(a, b, c, d, buffer.getUint32(32, true), 7, 0x698098d8);
      d = ff(d, a, b, c, buffer.getUint32(36, true), 12, 0x8b44f7af);
      c = ff(c, d, a, b, buffer.getUint32(40, true), 17, 0xffff5bb1);
      b = ff(b, c, d, a, buffer.getUint32(44, true), 22, 0x895cd7be);
      a = ff(a, b, c, d, buffer.getUint32(48, true), 7, 0x6b901122);
      d = ff(d, a, b, c, buffer.getUint32(52, true), 12, 0xfd987193);
      c = ff(c, d, a, b, buffer.getUint32(56, true), 17, 0xa679438e);
      b = ff(b, c, d, a, buffer.getUint32(60, true), 22, 0x49b40821);
      a = gg(a, b, c, d, buffer.getUint32(4, true), 5, 0xf61e2562);
      d = gg(d, a, b, c, buffer.getUint32(24, true), 9, 0xc040b340);
      c = gg(c, d, a, b, buffer.getUint32(44, true), 14, 0x265e5a51);
      b = gg(b, c, d, a, buffer.getUint32(0, true), 20, 0xe9b6c7aa);
      a = gg(a, b, c, d, buffer.getUint32(20, true), 5, 0xd62f105d);
      d = gg(d, a, b, c, buffer.getUint32(40, true), 9, 0x02441453);
      c = gg(c, d, a, b, buffer.getUint32(60, true), 14, 0xd8a1e681);
      b = gg(b, c, d, a, buffer.getUint32(16, true), 20, 0xe7d3fbc8);
      a = gg(a, b, c, d, buffer.getUint32(36, true), 5, 0x21e1cde6);
      d = gg(d, a, b, c, buffer.getUint32(56, true), 9, 0xc33707d6);
      c = gg(c, d, a, b, buffer.getUint32(12, true), 14, 0xf4d50d87);
      b = gg(b, c, d, a, buffer.getUint32(32, true), 20, 0x455a14ed);
      a = gg(a, b, c, d, buffer.getUint32(52, true), 5, 0xa9e3e905);
      d = gg(d, a, b, c, buffer.getUint32(8, true), 9, 0xfcefa3f8);
      c = gg(c, d, a, b, buffer.getUint32(28, true), 14, 0x676f02d9);
      b = gg(b, c, d, a, buffer.getUint32(48, true), 20, 0x8d2a4c8a);
      a = hh(a, b, c, d, buffer.getUint32(20, true), 4, 0xfffa3942);
      d = hh(d, a, b, c, buffer.getUint32(32, true), 11, 0x8771f681);
      c = hh(c, d, a, b, buffer.getUint32(44, true), 16, 0x6d9d6122);
      b = hh(b, c, d, a, buffer.getUint32(56, true), 23, 0xfde5380c);
      a = hh(a, b, c, d, buffer.getUint32(4, true), 4, 0xa4beea44);
      d = hh(d, a, b, c, buffer.getUint32(16, true), 11, 0x4bdecfa9);
      c = hh(c, d, a, b, buffer.getUint32(28, true), 16, 0xf6bb4b60);
      b = hh(b, c, d, a, buffer.getUint32(40, true), 23, 0xbebfbc70);
      a = hh(a, b, c, d, buffer.getUint32(52, true), 4, 0x289b7ec6);
      d = hh(d, a, b, c, buffer.getUint32(0, true), 11, 0xeaa127fa);
      c = hh(c, d, a, b, buffer.getUint32(12, true), 16, 0xd4ef3085);
      b = hh(b, c, d, a, buffer.getUint32(24, true), 23, 0x04881d05);
      a = hh(a, b, c, d, buffer.getUint32(36, true), 4, 0xd9d4d039);
      d = hh(d, a, b, c, buffer.getUint32(48, true), 11, 0xe6db99e5);
      c = hh(c, d, a, b, buffer.getUint32(60, true), 16, 0x1fa27cf8);
      b = hh(b, c, d, a, buffer.getUint32(8, true), 23, 0xc4ac5665);
      a = ii(a, b, c, d, buffer.getUint32(0, true), 6, 0xf4292244);
      d = ii(d, a, b, c, buffer.getUint32(28, true), 10, 0x432aff97);
      c = ii(c, d, a, b, buffer.getUint32(56, true), 15, 0xab9423a7);
      b = ii(b, c, d, a, buffer.getUint32(20, true), 21, 0xfc93a039);
      a = ii(a, b, c, d, buffer.getUint32(48, true), 6, 0x655b59c3);
      d = ii(d, a, b, c, buffer.getUint32(12, true), 10, 0x8f0ccc92);
      c = ii(c, d, a, b, buffer.getUint32(40, true), 15, 0xffeff47d);
      b = ii(b, c, d, a, buffer.getUint32(4, true), 21, 0x85845dd1);
      a = ii(a, b, c, d, buffer.getUint32(32, true), 6, 0x6fa87e4f);
      d = ii(d, a, b, c, buffer.getUint32(60, true), 10, 0xfe2ce6e0);
      c = ii(c, d, a, b, buffer.getUint32(24, true), 15, 0xa3014314);
      b = ii(b, c, d, a, buffer.getUint32(52, true), 21, 0x4e0811a1);
      a = ii(a, b, c, d, buffer.getUint32(16, true), 6, 0xf7537e82);
      d = ii(d, a, b, c, buffer.getUint32(44, true), 10, 0xbd3af235);
      c = ii(c, d, a, b, buffer.getUint32(8, true), 15, 0x2ad7d2bb);
      b = ii(b, c, d, a, buffer.getUint32(36, true), 21, 0xeb86d391);
      state[0] = a + state[0] & 0xFFFFFFFF;
      state[1] = b + state[1] & 0xFFFFFFFF;
      state[2] = c + state[2] & 0xFFFFFFFF;
      state[3] = d + state[3] & 0xFFFFFFFF;
    };

    function cmn(q, a, b, x, s, t) {
      a = (a + q & 0xFFFFFFFF) + (x + t & 0xFFFFFFFF) & 0xFFFFFFFF;
      return (a << s | a >>> 32 - s) + b & 0xFFFFFFFF;
    }

    function ff(a, b, c, d, x, s, t) {
      return cmn(b & c | ~b & d, a, b, x, s, t);
    }

    function gg(a, b, c, d, x, s, t) {
      return cmn(b & d | c & ~d, a, b, x, s, t);
    }

    function hh(a, b, c, d, x, s, t) {
      return cmn(b ^ c ^ d, a, b, x, s, t);
    }

    function ii(a, b, c, d, x, s, t) {
      return cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    /***/

  },

  /***/
  "./node_modules/aws-sdk/lib/browserSha1.js":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/lib/browserSha1.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibBrowserSha1Js(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(
    /*! buffer/ */
    "./node_modules/buffer/index.js").Buffer;

    var hashUtils = __webpack_require__(
    /*! ./browserHashUtils */
    "./node_modules/aws-sdk/lib/browserHashUtils.js");

    var BLOCK_SIZE = 64;
    var DIGEST_LENGTH = 20;
    var KEY = new Uint32Array([0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0]);
    var INIT = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    /**
     * @api private
     */

    function Sha1() {
      this.h0 = 0x67452301;
      this.h1 = 0xEFCDAB89;
      this.h2 = 0x98BADCFE;
      this.h3 = 0x10325476;
      this.h4 = 0xC3D2E1F0; // The first 64 bytes (16 words) is the data chunk

      this.block = new Uint32Array(80);
      this.offset = 0;
      this.shift = 24;
      this.totalLength = 0;
    }
    /**
     * @api private
     */


    module.exports = exports = Sha1;
    Sha1.BLOCK_SIZE = BLOCK_SIZE;

    Sha1.prototype.update = function (data) {
      if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
      }

      if (hashUtils.isEmptyData(data)) {
        return this;
      }

      data = hashUtils.convertToBuffer(data);
      var length = data.length;
      this.totalLength += length * 8;

      for (var i = 0; i < length; i++) {
        this.write(data[i]);
      }

      return this;
    };

    Sha1.prototype.write = function write(_byte) {
      this.block[this.offset] |= (_byte & 0xff) << this.shift;

      if (this.shift) {
        this.shift -= 8;
      } else {
        this.offset++;
        this.shift = 24;
      }

      if (this.offset === 16) this.processBlock();
    };

    Sha1.prototype.digest = function (encoding) {
      // Pad
      this.write(0x80);

      if (this.offset > 14 || this.offset === 14 && this.shift < 24) {
        this.processBlock();
      }

      this.offset = 14;
      this.shift = 24; // 64-bit length big-endian

      this.write(0x00); // numbers this big aren't accurate in javascript anyway

      this.write(0x00); // ..So just hard-code to zero.

      this.write(this.totalLength > 0xffffffffff ? this.totalLength / 0x10000000000 : 0x00);
      this.write(this.totalLength > 0xffffffff ? this.totalLength / 0x100000000 : 0x00);

      for (var s = 24; s >= 0; s -= 8) {
        this.write(this.totalLength >> s);
      } // The value in state is little-endian rather than big-endian, so flip
      // each word into a new Uint8Array


      var out = new Buffer(DIGEST_LENGTH);
      var outView = new DataView(out.buffer);
      outView.setUint32(0, this.h0, false);
      outView.setUint32(4, this.h1, false);
      outView.setUint32(8, this.h2, false);
      outView.setUint32(12, this.h3, false);
      outView.setUint32(16, this.h4, false);
      return encoding ? out.toString(encoding) : out;
    };

    Sha1.prototype.processBlock = function processBlock() {
      // Extend the sixteen 32-bit words into eighty 32-bit words:
      for (var i = 16; i < 80; i++) {
        var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];
        this.block[i] = w << 1 | w >>> 31;
      } // Initialize hash value for this chunk:


      var a = this.h0;
      var b = this.h1;
      var c = this.h2;
      var d = this.h3;
      var e = this.h4;
      var f, k; // Main loop:

      for (i = 0; i < 80; i++) {
        if (i < 20) {
          f = d ^ b & (c ^ d);
          k = 0x5A827999;
        } else if (i < 40) {
          f = b ^ c ^ d;
          k = 0x6ED9EBA1;
        } else if (i < 60) {
          f = b & c | d & (b | c);
          k = 0x8F1BBCDC;
        } else {
          f = b ^ c ^ d;
          k = 0xCA62C1D6;
        }

        var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i] | 0);
        e = d;
        d = c;
        c = b << 30 | b >>> 2;
        b = a;
        a = temp;
      } // Add this chunk's hash to result so far:


      this.h0 = this.h0 + a | 0;
      this.h1 = this.h1 + b | 0;
      this.h2 = this.h2 + c | 0;
      this.h3 = this.h3 + d | 0;
      this.h4 = this.h4 + e | 0; // The block is now reusable.

      this.offset = 0;

      for (i = 0; i < 16; i++) {
        this.block[i] = 0;
      }
    };
    /***/

  },

  /***/
  "./node_modules/aws-sdk/lib/browserSha256.js":
  /*!***************************************************!*\
    !*** ./node_modules/aws-sdk/lib/browserSha256.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibBrowserSha256Js(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(
    /*! buffer/ */
    "./node_modules/buffer/index.js").Buffer;

    var hashUtils = __webpack_require__(
    /*! ./browserHashUtils */
    "./node_modules/aws-sdk/lib/browserHashUtils.js");

    var BLOCK_SIZE = 64;
    var DIGEST_LENGTH = 32;
    var KEY = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
    var INIT = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    /**
     * @private
     */

    function Sha256() {
      this.state = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
      this.temp = new Int32Array(64);
      this.buffer = new Uint8Array(64);
      this.bufferLength = 0;
      this.bytesHashed = 0;
      /**
       * @private
       */

      this.finished = false;
    }
    /**
     * @api private
     */


    module.exports = exports = Sha256;
    Sha256.BLOCK_SIZE = BLOCK_SIZE;

    Sha256.prototype.update = function (data) {
      if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
      }

      if (hashUtils.isEmptyData(data)) {
        return this;
      }

      data = hashUtils.convertToBuffer(data);
      var position = 0;
      var byteLength = data.byteLength;
      this.bytesHashed += byteLength;

      if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
        throw new Error('Cannot hash more than 2^53 - 1 bits');
      }

      while (byteLength > 0) {
        this.buffer[this.bufferLength++] = data[position++];
        byteLength--;

        if (this.bufferLength === BLOCK_SIZE) {
          this.hashBuffer();
          this.bufferLength = 0;
        }
      }

      return this;
    };

    Sha256.prototype.digest = function (encoding) {
      if (!this.finished) {
        var bitsHashed = this.bytesHashed * 8;
        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        var undecoratedLength = this.bufferLength;
        bufferView.setUint8(this.bufferLength++, 0x80); // Ensure the final block has enough room for the hashed length

        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
          for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
            bufferView.setUint8(i, 0);
          }

          this.hashBuffer();
          this.bufferLength = 0;
        }

        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
          bufferView.setUint8(i, 0);
        }

        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
        this.hashBuffer();
        this.finished = true;
      } // The value in state is little-endian rather than big-endian, so flip
      // each word into a new Uint8Array


      var out = new Buffer(DIGEST_LENGTH);

      for (var i = 0; i < 8; i++) {
        out[i * 4] = this.state[i] >>> 24 & 0xff;
        out[i * 4 + 1] = this.state[i] >>> 16 & 0xff;
        out[i * 4 + 2] = this.state[i] >>> 8 & 0xff;
        out[i * 4 + 3] = this.state[i] >>> 0 & 0xff;
      }

      return encoding ? out.toString(encoding) : out;
    };

    Sha256.prototype.hashBuffer = function () {
      var _a = this,
          buffer = _a.buffer,
          state = _a.state;

      var state0 = state[0],
          state1 = state[1],
          state2 = state[2],
          state3 = state[3],
          state4 = state[4],
          state5 = state[5],
          state6 = state[6],
          state7 = state[7];

      for (var i = 0; i < BLOCK_SIZE; i++) {
        if (i < 16) {
          this.temp[i] = (buffer[i * 4] & 0xff) << 24 | (buffer[i * 4 + 1] & 0xff) << 16 | (buffer[i * 4 + 2] & 0xff) << 8 | buffer[i * 4 + 3] & 0xff;
        } else {
          var u = this.temp[i - 2];
          var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
          u = this.temp[i - 15];
          var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
          this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
        }

        var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i] + this.temp[i] | 0) | 0) | 0;
        var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
        state7 = state6;
        state6 = state5;
        state5 = state4;
        state4 = state3 + t1 | 0;
        state3 = state2;
        state2 = state1;
        state1 = state0;
        state0 = t1 + t2 | 0;
      }

      state[0] += state0;
      state[1] += state1;
      state[2] += state2;
      state[3] += state3;
      state[4] += state4;
      state[5] += state5;
      state[6] += state6;
      state[7] += state7;
    };
    /***/

  },

  /***/
  "./node_modules/aws-sdk/lib/browser_loader.js":
  /*!****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/browser_loader.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibBrowser_loaderJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ./util */
    "./node_modules/aws-sdk/lib/util.js"); // browser specific modules


    util.crypto.lib = __webpack_require__(
    /*! ./browserCryptoLib */
    "./node_modules/aws-sdk/lib/browserCryptoLib.js");
    util.Buffer = __webpack_require__(
    /*! buffer/ */
    "./node_modules/buffer/index.js").Buffer;
    util.url = __webpack_require__(
    /*! url/ */
    "./node_modules/url/url.js");
    util.querystring = __webpack_require__(
    /*! querystring/ */
    "./node_modules/querystring/index.js");
    util.realClock = __webpack_require__(
    /*! ./realclock/browserClock */
    "./node_modules/aws-sdk/lib/realclock/browserClock.js");
    util.environment = 'js';
    util.createEventStream = __webpack_require__(
    /*! ./event-stream/buffered-create-event-stream */
    "./node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js").createEventStream;

    util.isBrowser = function () {
      return true;
    };

    util.isNode = function () {
      return false;
    };

    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * @api private
     */


    module.exports = AWS;

    __webpack_require__(
    /*! ./credentials */
    "./node_modules/aws-sdk/lib/credentials.js");

    __webpack_require__(
    /*! ./credentials/credential_provider_chain */
    "./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js");

    __webpack_require__(
    /*! ./credentials/temporary_credentials */
    "./node_modules/aws-sdk/lib/credentials/temporary_credentials.js");

    __webpack_require__(
    /*! ./credentials/chainable_temporary_credentials */
    "./node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js");

    __webpack_require__(
    /*! ./credentials/web_identity_credentials */
    "./node_modules/aws-sdk/lib/credentials/web_identity_credentials.js");

    __webpack_require__(
    /*! ./credentials/cognito_identity_credentials */
    "./node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js");

    __webpack_require__(
    /*! ./credentials/saml_credentials */
    "./node_modules/aws-sdk/lib/credentials/saml_credentials.js"); // Load the DOMParser XML parser


    AWS.XML.Parser = __webpack_require__(
    /*! ./xml/browser_parser */
    "./node_modules/aws-sdk/lib/xml/browser_parser.js"); // Load the XHR HttpClient

    __webpack_require__(
    /*! ./http/xhr */
    "./node_modules/aws-sdk/lib/http/xhr.js");

    if (typeof process === 'undefined') {
      var process = {
        browser: true
      };
    }
    /***/

  },

  /***/
  "./node_modules/aws-sdk/lib/config.js":
  /*!********************************************!*\
    !*** ./node_modules/aws-sdk/lib/config.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibConfigJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    __webpack_require__(
    /*! ./credentials */
    "./node_modules/aws-sdk/lib/credentials.js");

    __webpack_require__(
    /*! ./credentials/credential_provider_chain */
    "./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js");

    var PromisesDependency;
    /**
     * The main configuration class used by all service objects to set
     * the region, credentials, and other options for requests.
     *
     * By default, credentials and region settings are left unconfigured.
     * This should be configured by the application before using any
     * AWS service APIs.
     *
     * In order to set global configuration options, properties should
     * be assigned to the global {AWS.config} object.
     *
     * @see AWS.config
     *
     * @!group General Configuration Options
     *
     * @!attribute credentials
     *   @return [AWS.Credentials] the AWS credentials to sign requests with.
     *
     * @!attribute region
     *   @example Set the global region setting to us-west-2
     *     AWS.config.update({region: 'us-west-2'});
     *   @return [AWS.Credentials] The region to send service requests to.
     *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
     *     A list of available endpoints for each AWS service
     *
     * @!attribute maxRetries
     *   @return [Integer] the maximum amount of retries to perform for a
     *     service request. By default this value is calculated by the specific
     *     service object that the request is being made to.
     *
     * @!attribute maxRedirects
     *   @return [Integer] the maximum amount of redirects to follow for a
     *     service request. Defaults to 10.
     *
     * @!attribute paramValidation
     *   @return [Boolean|map] whether input parameters should be validated against
     *     the operation description before sending the request. Defaults to true.
     *     Pass a map to enable any of the following specific validation features:
     *
     *     * **min** [Boolean] &mdash; Validates that a value meets the min
     *       constraint. This is enabled by default when paramValidation is set
     *       to `true`.
     *     * **max** [Boolean] &mdash; Validates that a value meets the max
     *       constraint.
     *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
     *       regular expression.
     *     * **enum** [Boolean] &mdash; Validates that a string value matches one
     *       of the allowable enum values.
     *
     * @!attribute computeChecksums
     *   @return [Boolean] whether to compute checksums for payload bodies when
     *     the service accepts it (currently supported in S3 only).
     *
     * @!attribute convertResponseTypes
     *   @return [Boolean] whether types are converted when parsing response data.
     *     Currently only supported for JSON based services. Turning this off may
     *     improve performance on large response payloads. Defaults to `true`.
     *
     * @!attribute correctClockSkew
     *   @return [Boolean] whether to apply a clock skew correction and retry
     *     requests that fail because of an skewed client clock. Defaults to
     *     `false`.
     *
     * @!attribute sslEnabled
     *   @return [Boolean] whether SSL is enabled for requests
     *
     * @!attribute s3ForcePathStyle
     *   @return [Boolean] whether to force path style URLs for S3 objects
     *
     * @!attribute s3BucketEndpoint
     *   @note Setting this configuration option requires an `endpoint` to be
     *     provided explicitly to the service constructor.
     *   @return [Boolean] whether the provided endpoint addresses an individual
     *     bucket (false if it addresses the root API endpoint).
     *
     * @!attribute s3DisableBodySigning
     *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
     *     Body signing can only be disabled when using https. Defaults to `true`.
     *
     * @!attribute s3UsEast1RegionalEndpoint
     *   @return ['legacy'|'regional'] when region is set to 'us-east-1', whether to send s3
     *     request to global endpoints or 'us-east-1' regional endpoints. This config is only
     *     applicable to S3 client;
     *     Defaults to 'legacy'
     * @!attribute s3UseArnRegion
     *   @return [Boolean] whether to override the request region with the region inferred
     *     from requested resource's ARN. Only available for S3 buckets
     *     Defaults to `true`
     *
     * @!attribute useAccelerateEndpoint
     *   @note This configuration option is only compatible with S3 while accessing
     *     dns-compatible buckets.
     *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
     *     Defaults to `false`.
     *
     * @!attribute retryDelayOptions
     *   @example Set the base retry delay for all services to 300 ms
     *     AWS.config.update({retryDelayOptions: {base: 300}});
     *     // Delays with maxRetries = 3: 300, 600, 1200
     *   @example Set a custom backoff function to provide delay values on retries
     *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount, err) {
     *       // returns delay in ms
     *     }}});
     *   @return [map] A set of options to configure the retry delay on retryable errors.
     *     Currently supported options are:
     *
     *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
     *       exponential backoff for operation retries. Defaults to 100 ms for all services except
     *       DynamoDB, where it defaults to 50ms.
     *
     *     * **customBackoff ** [function] &mdash; A custom function that accepts a
     *       retry count and error and returns the amount of time to delay in
     *       milliseconds. If the result is a non-zero negative value, no further
     *       retry attempts will be made. The `base` option will be ignored if this
     *       option is supplied. The function is only called for retryable errors.
     *
     * @!attribute httpOptions
     *   @return [map] A set of options to pass to the low-level HTTP request.
     *     Currently supported options are:
     *
     *     * **proxy** [String] &mdash; the URL to proxy requests through
     *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
     *       HTTP requests with. Used for connection pooling. Note that for
     *       SSL connections, a special Agent object is used in order to enable
     *       peer certificate verification. This feature is only supported in the
     *       Node.js environment.
     *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
     *       failing to establish a connection with the server after
     *       `connectTimeout` milliseconds. This timeout has no effect once a socket
     *       connection has been established.
     *     * **timeout** [Integer] &mdash; The number of milliseconds a request can
     *       take before automatically being terminated.
     *       Defaults to two minutes (120000).
     *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
     *       HTTP requests. Used in the browser environment only. Set to false to
     *       send requests synchronously. Defaults to true (async on).
     *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
     *       property of an XMLHttpRequest object. Used in the browser environment
     *       only. Defaults to false.
     * @!attribute logger
     *   @return [#write,#log] an object that responds to .write() (like a stream)
     *     or .log() (like the console object) in order to log information about
     *     requests
     *
     * @!attribute systemClockOffset
     *   @return [Number] an offset value in milliseconds to apply to all signing
     *     times. Use this to compensate for clock skew when your system may be
     *     out of sync with the service time. Note that this configuration option
     *     can only be applied to the global `AWS.config` object and cannot be
     *     overridden in service-specific configuration. Defaults to 0 milliseconds.
     *
     * @!attribute signatureVersion
     *   @return [String] the signature version to sign requests with (overriding
     *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
     *
     * @!attribute signatureCache
     *   @return [Boolean] whether the signature to sign requests with (overriding
     *     the API configuration) is cached. Only applies to the signature version 'v4'.
     *     Defaults to `true`.
     *
     * @!attribute endpointDiscoveryEnabled
     *   @return [Boolean|undefined] whether to call operations with endpoints
     *     given by service dynamically. Setting this config to `true` will enable
     *     endpoint discovery for all applicable operations. Setting it to `false`
     *     will explicitly disable endpoint discovery even though operations that
     *     require endpoint discovery will presumably fail. Leaving it to
     *     `undefined` means SDK only do endpoint discovery when it's required.
     *     Defaults to `undefined`
     *
     * @!attribute endpointCacheSize
     *   @return [Number] the size of the global cache storing endpoints from endpoint
     *     discovery operations. Once endpoint cache is created, updating this setting
     *     cannot change existing cache size.
     *     Defaults to 1000
     *
     * @!attribute hostPrefixEnabled
     *   @return [Boolean] whether to marshal request parameters to the prefix of
     *     hostname. Defaults to `true`.
     *
     * @!attribute stsRegionalEndpoints
     *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or
     *     regional endpoints.
     *     Defaults to 'legacy'
     */

    AWS.Config = AWS.util.inherit({
      /**
       * @!endgroup
       */

      /**
       * Creates a new configuration object. This is the object that passes
       * option data along to service requests, including credentials, security,
       * region information, and some service specific settings.
       *
       * @example Creating a new configuration object with credentials and region
       *   var config = new AWS.Config({
       *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
       *   });
       * @option options accessKeyId [String] your AWS access key ID.
       * @option options secretAccessKey [String] your AWS secret access key.
       * @option options sessionToken [AWS.Credentials] the optional AWS
       *   session token to sign requests with.
       * @option options credentials [AWS.Credentials] the AWS credentials
       *   to sign requests with. You can either specify this object, or
       *   specify the accessKeyId and secretAccessKey options directly.
       * @option options credentialProvider [AWS.CredentialProviderChain] the
       *   provider chain used to resolve credentials if no static `credentials`
       *   property is set.
       * @option options region [String] the region to send service requests to.
       *   See {region} for more information.
       * @option options maxRetries [Integer] the maximum amount of retries to
       *   attempt with a request. See {maxRetries} for more information.
       * @option options maxRedirects [Integer] the maximum amount of redirects to
       *   follow with a request. See {maxRedirects} for more information.
       * @option options sslEnabled [Boolean] whether to enable SSL for
       *   requests.
       * @option options paramValidation [Boolean|map] whether input parameters
       *   should be validated against the operation description before sending
       *   the request. Defaults to true. Pass a map to enable any of the
       *   following specific validation features:
       *
       *   * **min** [Boolean] &mdash; Validates that a value meets the min
       *     constraint. This is enabled by default when paramValidation is set
       *     to `true`.
       *   * **max** [Boolean] &mdash; Validates that a value meets the max
       *     constraint.
       *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
       *     regular expression.
       *   * **enum** [Boolean] &mdash; Validates that a string value matches one
       *     of the allowable enum values.
       * @option options computeChecksums [Boolean] whether to compute checksums
       *   for payload bodies when the service accepts it (currently supported
       *   in S3 only)
       * @option options convertResponseTypes [Boolean] whether types are converted
       *     when parsing response data. Currently only supported for JSON based
       *     services. Turning this off may improve performance on large response
       *     payloads. Defaults to `true`.
       * @option options correctClockSkew [Boolean] whether to apply a clock skew
       *     correction and retry requests that fail because of an skewed client
       *     clock. Defaults to `false`.
       * @option options s3ForcePathStyle [Boolean] whether to force path
       *   style URLs for S3 objects.
       * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
       *   addresses an individual bucket (false if it addresses the root API
       *   endpoint). Note that setting this configuration option requires an
       *   `endpoint` to be provided explicitly to the service constructor.
       * @option options s3DisableBodySigning [Boolean] whether S3 body signing
       *   should be disabled when using signature version `v4`. Body signing
       *   can only be disabled when using https. Defaults to `true`.
       * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
       *   is set to 'us-east-1', whether to send s3 request to global endpoints or
       *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
       *   Defaults to `legacy`
       * @option options s3UseArnRegion [Boolean] whether to override the request region
       *   with the region inferred from requested resource's ARN. Only available for S3 buckets
       *   Defaults to `true`
       *
       * @option options retryDelayOptions [map] A set of options to configure
       *   the retry delay on retryable errors. Currently supported options are:
       *
       *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
       *     exponential backoff for operation retries. Defaults to 100 ms for all
       *     services except DynamoDB, where it defaults to 50ms.
       *   * **customBackoff ** [function] &mdash; A custom function that accepts a
       *     retry count and error and returns the amount of time to delay in
       *     milliseconds. If the result is a non-zero negative value, no further
       *     retry attempts will be made. The `base` option will be ignored if this
       *     option is supplied. The function is only called for retryable errors.
       * @option options httpOptions [map] A set of options to pass to the low-level
       *   HTTP request. Currently supported options are:
       *
       *   * **proxy** [String] &mdash; the URL to proxy requests through
       *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
       *     HTTP requests with. Used for connection pooling. Defaults to the global
       *     agent (`http.globalAgent`) for non-SSL connections. Note that for
       *     SSL connections, a special Agent object is used in order to enable
       *     peer certificate verification. This feature is only available in the
       *     Node.js environment.
       *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
       *     failing to establish a connection with the server after
       *     `connectTimeout` milliseconds. This timeout has no effect once a socket
       *     connection has been established.
       *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
       *     milliseconds of inactivity on the socket. Defaults to two minutes
       *     (120000).
       *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
       *     HTTP requests. Used in the browser environment only. Set to false to
       *     send requests synchronously. Defaults to true (async on).
       *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
       *     property of an XMLHttpRequest object. Used in the browser environment
       *     only. Defaults to false.
       * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
       *   (or a date) that represents the latest possible API version that can be
       *   used in all services (unless overridden by `apiVersions`). Specify
       *   'latest' to use the latest possible version.
       * @option options apiVersions [map<String, String|Date>] a map of service
       *   identifiers (the lowercase service class name) with the API version to
       *   use when instantiating a service. Specify 'latest' for each individual
       *   that can use the latest available version.
       * @option options logger [#write,#log] an object that responds to .write()
       *   (like a stream) or .log() (like the console object) in order to log
       *   information about requests
       * @option options systemClockOffset [Number] an offset value in milliseconds
       *   to apply to all signing times. Use this to compensate for clock skew
       *   when your system may be out of sync with the service time. Note that
       *   this configuration option can only be applied to the global `AWS.config`
       *   object and cannot be overridden in service-specific configuration.
       *   Defaults to 0 milliseconds.
       * @option options signatureVersion [String] the signature version to sign
       *   requests with (overriding the API configuration). Possible values are:
       *   'v2', 'v3', 'v4'.
       * @option options signatureCache [Boolean] whether the signature to sign
       *   requests with (overriding the API configuration) is cached. Only applies
       *   to the signature version 'v4'. Defaults to `true`.
       * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
       *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
       * @option options useAccelerateEndpoint [Boolean] Whether to use the
       *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
       * @option options clientSideMonitoring [Boolean] whether to collect and
       *   publish this client's performance metrics of all its API requests.
       * @option options endpointDiscoveryEnabled [Boolean|undefined] whether to
       *   call operations with endpoints given by service dynamically. Setting this
       * config to `true` will enable endpoint discovery for all applicable operations.
       *   Setting it to `false` will explicitly disable endpoint discovery even though
       *   operations that require endpoint discovery will presumably fail. Leaving it
       *   to `undefined` means SDK will only do endpoint discovery when it's required.
       *   Defaults to `undefined`
       * @option options endpointCacheSize [Number] the size of the global cache storing
       *   endpoints from endpoint discovery operations. Once endpoint cache is created,
       *   updating this setting cannot change existing cache size.
       *   Defaults to 1000
       * @option options hostPrefixEnabled [Boolean] whether to marshal request
       *   parameters to the prefix of hostname.
       *   Defaults to `true`.
       * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
       *   to global endpoints or regional endpoints.
       *   Defaults to 'legacy'.
       */
      constructor: function Config(options) {
        if (options === undefined) options = {};
        options = this.extractCredentials(options);
        AWS.util.each.call(this, this.keys, function (key, value) {
          this.set(key, options[key], value);
        });
      },

      /**
       * @!group Managing Credentials
       */

      /**
       * Loads credentials from the configuration object. This is used internally
       * by the SDK to ensure that refreshable {Credentials} objects are properly
       * refreshed and loaded when sending a request. If you want to ensure that
       * your credentials are loaded prior to a request, you can use this method
       * directly to provide accurate credential data stored in the object.
       *
       * @note If you configure the SDK with static or environment credentials,
       *   the credential data should already be present in {credentials} attribute.
       *   This method is primarily necessary to load credentials from asynchronous
       *   sources, or sources that can refresh credentials periodically.
       * @example Getting your access key
       *   AWS.config.getCredentials(function(err) {
       *     if (err) console.log(err.stack); // credentials not loaded
       *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
       *   })
       * @callback callback function(err)
       *   Called when the {credentials} have been properly set on the configuration
       *   object.
       *
       *   @param err [Error] if this is set, credentials were not successfully
       *     loaded and this error provides information why.
       * @see credentials
       * @see Credentials
       */
      getCredentials: function getCredentials(callback) {
        var self = this;

        function finish(err) {
          callback(err, err ? null : self.credentials);
        }

        function credError(msg, err) {
          return new AWS.util.error(err || new Error(), {
            code: 'CredentialsError',
            message: msg,
            name: 'CredentialsError'
          });
        }

        function getAsyncCredentials() {
          self.credentials.get(function (err) {
            if (err) {
              var msg = 'Could not load credentials from ' + self.credentials.constructor.name;
              err = credError(msg, err);
            }

            finish(err);
          });
        }

        function getStaticCredentials() {
          var err = null;

          if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
            err = credError('Missing credentials');
          }

          finish(err);
        }

        if (self.credentials) {
          if (typeof self.credentials.get === 'function') {
            getAsyncCredentials();
          } else {
            // static credentials
            getStaticCredentials();
          }
        } else if (self.credentialProvider) {
          self.credentialProvider.resolve(function (err, creds) {
            if (err) {
              err = credError('Could not load credentials from any providers', err);
            }

            self.credentials = creds;
            finish(err);
          });
        } else {
          finish(credError('No credentials to load'));
        }
      },

      /**
       * @!group Loading and Setting Configuration Options
       */

      /**
       * @overload update(options, allowUnknownKeys = false)
       *   Updates the current configuration object with new options.
       *
       *   @example Update maxRetries property of a configuration object
       *     config.update({maxRetries: 10});
       *   @param [Object] options a map of option keys and values.
       *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
       *     the configuration object. Defaults to `false`.
       *   @see constructor
       */
      update: function update(options, allowUnknownKeys) {
        allowUnknownKeys = allowUnknownKeys || false;
        options = this.extractCredentials(options);
        AWS.util.each.call(this, options, function (key, value) {
          if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) || AWS.Service.hasService(key)) {
            this.set(key, value);
          }
        });
      },

      /**
       * Loads configuration data from a JSON file into this config object.
       * @note Loading configuration will reset all existing configuration
       *   on the object.
       * @!macro nobrowser
       * @param path [String] the path relative to your process's current
       *    working directory to load configuration from.
       * @return [AWS.Config] the same configuration object
       */
      loadFromPath: function loadFromPath(path) {
        this.clear();
        var options = JSON.parse(AWS.util.readFileSync(path));
        var fileSystemCreds = new AWS.FileSystemCredentials(path);
        var chain = new AWS.CredentialProviderChain();
        chain.providers.unshift(fileSystemCreds);
        chain.resolve(function (err, creds) {
          if (err) throw err;else options.credentials = creds;
        });
        this.constructor(options);
        return this;
      },

      /**
       * Clears configuration data on this object
       *
       * @api private
       */
      clear: function clear() {
        /*jshint forin:false */
        AWS.util.each.call(this, this.keys, function (key) {
          delete this[key];
        }); // reset credential provider

        this.set('credentials', undefined);
        this.set('credentialProvider', undefined);
      },

      /**
       * Sets a property on the configuration object, allowing for a
       * default value
       * @api private
       */
      set: function set(property, value, defaultValue) {
        if (value === undefined) {
          if (defaultValue === undefined) {
            defaultValue = this.keys[property];
          }

          if (typeof defaultValue === 'function') {
            this[property] = defaultValue.call(this);
          } else {
            this[property] = defaultValue;
          }
        } else if (property === 'httpOptions' && this[property]) {
          // deep merge httpOptions
          this[property] = AWS.util.merge(this[property], value);
        } else {
          this[property] = value;
        }
      },

      /**
       * All of the keys with their default values.
       *
       * @constant
       * @api private
       */
      keys: {
        credentials: null,
        credentialProvider: null,
        region: null,
        logger: null,
        apiVersions: {},
        apiVersion: null,
        endpoint: undefined,
        httpOptions: {
          timeout: 120000
        },
        maxRetries: undefined,
        maxRedirects: 10,
        paramValidation: true,
        sslEnabled: true,
        s3ForcePathStyle: false,
        s3BucketEndpoint: false,
        s3DisableBodySigning: true,
        s3UsEast1RegionalEndpoint: 'legacy',
        s3UseArnRegion: undefined,
        computeChecksums: true,
        convertResponseTypes: true,
        correctClockSkew: false,
        customUserAgent: null,
        dynamoDbCrc32: true,
        systemClockOffset: 0,
        signatureVersion: null,
        signatureCache: true,
        retryDelayOptions: {},
        useAccelerateEndpoint: false,
        clientSideMonitoring: false,
        endpointDiscoveryEnabled: undefined,
        endpointCacheSize: 1000,
        hostPrefixEnabled: true,
        stsRegionalEndpoints: 'legacy'
      },

      /**
       * Extracts accessKeyId, secretAccessKey and sessionToken
       * from a configuration hash.
       *
       * @api private
       */
      extractCredentials: function extractCredentials(options) {
        if (options.accessKeyId && options.secretAccessKey) {
          options = AWS.util.copy(options);
          options.credentials = new AWS.Credentials(options);
        }

        return options;
      },

      /**
       * Sets the promise dependency the SDK will use wherever Promises are returned.
       * Passing `null` will force the SDK to use native Promises if they are available.
       * If native Promises are not available, passing `null` will have no effect.
       * @param [Constructor] dep A reference to a Promise constructor
       */
      setPromisesDependency: function setPromisesDependency(dep) {
        PromisesDependency = dep; // if null was passed in, we should try to use native promises

        if (dep === null && typeof Promise === 'function') {
          PromisesDependency = Promise;
        }

        var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];

        if (AWS.S3) {
          constructors.push(AWS.S3);

          if (AWS.S3.ManagedUpload) {
            constructors.push(AWS.S3.ManagedUpload);
          }
        }

        AWS.util.addPromises(constructors, PromisesDependency);
      },

      /**
       * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
       */
      getPromisesDependency: function getPromisesDependency() {
        return PromisesDependency;
      }
    });
    /**
     * @return [AWS.Config] The global configuration object singleton instance
     * @readonly
     * @see AWS.Config
     */

    AWS.config = new AWS.Config();
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/config_regional_endpoint.js":
  /*!**************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/config_regional_endpoint.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibConfig_regional_endpointJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * @api private
     */


    function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
      if (typeof configValue !== 'string') return undefined;else if (['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {
        return configValue.toLowerCase();
      } else {
        throw AWS.util.error(new Error(), errorOptions);
      }
    }
    /**
     * Resolve the configuration value for regional endpoint from difference sources: client
     * config, environmental variable, shared config file. Value can be case-insensitive
     * 'legacy' or 'reginal'.
     * @param originalConfig user-supplied config object to resolve
     * @param options a map of config property names from individual configuration source
     *  - env: name of environmental variable that refers to the config
     *  - sharedConfig: name of shared configuration file property that refers to the config
     *  - clientConfig: name of client configuration property that refers to the config
     *
     * @api private
     */


    function resolveRegionalEndpointsFlag(originalConfig, options) {
      originalConfig = originalConfig || {}; //validate config value

      var resolved;

      if (originalConfig[options.clientConfig]) {
        resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
          code: 'InvalidConfiguration',
          message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy" ' + ' or "regional". Got "' + originalConfig[options.clientConfig] + '".'
        });
        if (resolved) return resolved;
      }

      if (!AWS.util.isNode()) return resolved; //validate environmental variable

      if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
        var envFlag = process.env[options.env];
        resolved = validateRegionalEndpointsFlagValue(envFlag, {
          code: 'InvalidEnvironmentalVariable',
          message: 'invalid ' + options.env + ' environmental variable. Expect "legacy" ' + ' or "regional". Got "' + process.env[options.env] + '".'
        });
        if (resolved) return resolved;
      } //validate shared config file


      var profile = {};

      try {
        var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
        profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
      } catch (e) {}

      ;

      if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
        var fileFlag = profile[options.sharedConfig];
        resolved = validateRegionalEndpointsFlagValue(fileFlag, {
          code: 'InvalidConfiguration',
          message: 'invalid ' + options.sharedConfig + ' profile config. Expect "legacy" ' + ' or "regional". Got "' + profile[options.sharedConfig] + '".'
        });
        if (resolved) return resolved;
      }

      return resolved;
    }

    module.exports = resolveRegionalEndpointsFlag;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/core.js":
  /*!******************************************!*\
    !*** ./node_modules/aws-sdk/lib/core.js ***!
    \******************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCoreJs(module, exports, __webpack_require__) {
    /**
     * The main AWS namespace
     */
    var AWS = {
      util: __webpack_require__(
      /*! ./util */
      "./node_modules/aws-sdk/lib/util.js")
    };
    /**
     * @api private
     * @!macro [new] nobrowser
     *   @note This feature is not supported in the browser environment of the SDK.
     */

    var _hidden = {};

    _hidden.toString(); // hack to parse macro

    /**
     * @api private
     */


    module.exports = AWS;
    AWS.util.update(AWS, {
      /**
       * @constant
       */
      VERSION: '2.828.0',

      /**
       * @api private
       */
      Signers: {},

      /**
       * @api private
       */
      Protocol: {
        Json: __webpack_require__(
        /*! ./protocol/json */
        "./node_modules/aws-sdk/lib/protocol/json.js"),
        Query: __webpack_require__(
        /*! ./protocol/query */
        "./node_modules/aws-sdk/lib/protocol/query.js"),
        Rest: __webpack_require__(
        /*! ./protocol/rest */
        "./node_modules/aws-sdk/lib/protocol/rest.js"),
        RestJson: __webpack_require__(
        /*! ./protocol/rest_json */
        "./node_modules/aws-sdk/lib/protocol/rest_json.js"),
        RestXml: __webpack_require__(
        /*! ./protocol/rest_xml */
        "./node_modules/aws-sdk/lib/protocol/rest_xml.js")
      },

      /**
       * @api private
       */
      XML: {
        Builder: __webpack_require__(
        /*! ./xml/builder */
        "./node_modules/aws-sdk/lib/xml/builder.js"),
        Parser: null // conditionally set based on environment

      },

      /**
       * @api private
       */
      JSON: {
        Builder: __webpack_require__(
        /*! ./json/builder */
        "./node_modules/aws-sdk/lib/json/builder.js"),
        Parser: __webpack_require__(
        /*! ./json/parser */
        "./node_modules/aws-sdk/lib/json/parser.js")
      },

      /**
       * @api private
       */
      Model: {
        Api: __webpack_require__(
        /*! ./model/api */
        "./node_modules/aws-sdk/lib/model/api.js"),
        Operation: __webpack_require__(
        /*! ./model/operation */
        "./node_modules/aws-sdk/lib/model/operation.js"),
        Shape: __webpack_require__(
        /*! ./model/shape */
        "./node_modules/aws-sdk/lib/model/shape.js"),
        Paginator: __webpack_require__(
        /*! ./model/paginator */
        "./node_modules/aws-sdk/lib/model/paginator.js"),
        ResourceWaiter: __webpack_require__(
        /*! ./model/resource_waiter */
        "./node_modules/aws-sdk/lib/model/resource_waiter.js")
      },

      /**
       * @api private
       */
      apiLoader: __webpack_require__(
      /*! ./api_loader */
      "./node_modules/aws-sdk/lib/api_loader.js"),

      /**
       * @api private
       */
      EndpointCache: __webpack_require__(
      /*! ../vendor/endpoint-cache */
      "./node_modules/aws-sdk/vendor/endpoint-cache/index.js").EndpointCache
    });

    __webpack_require__(
    /*! ./sequential_executor */
    "./node_modules/aws-sdk/lib/sequential_executor.js");

    __webpack_require__(
    /*! ./service */
    "./node_modules/aws-sdk/lib/service.js");

    __webpack_require__(
    /*! ./config */
    "./node_modules/aws-sdk/lib/config.js");

    __webpack_require__(
    /*! ./http */
    "./node_modules/aws-sdk/lib/http.js");

    __webpack_require__(
    /*! ./event_listeners */
    "./node_modules/aws-sdk/lib/event_listeners.js");

    __webpack_require__(
    /*! ./request */
    "./node_modules/aws-sdk/lib/request.js");

    __webpack_require__(
    /*! ./response */
    "./node_modules/aws-sdk/lib/response.js");

    __webpack_require__(
    /*! ./resource_waiter */
    "./node_modules/aws-sdk/lib/resource_waiter.js");

    __webpack_require__(
    /*! ./signers/request_signer */
    "./node_modules/aws-sdk/lib/signers/request_signer.js");

    __webpack_require__(
    /*! ./param_validator */
    "./node_modules/aws-sdk/lib/param_validator.js");
    /**
     * @readonly
     * @return [AWS.SequentialExecutor] a collection of global event listeners that
     *   are attached to every sent request.
     * @see AWS.Request AWS.Request for a list of events to listen for
     * @example Logging the time taken to send a request
     *   AWS.events.on('send', function startSend(resp) {
     *     resp.startTime = new Date().getTime();
     *   }).on('complete', function calculateTime(resp) {
     *     var time = (new Date().getTime() - resp.startTime) / 1000;
     *     console.log('Request took ' + time + ' seconds');
     *   });
     *
     *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
     */


    AWS.events = new AWS.SequentialExecutor(); //create endpoint cache lazily

    AWS.util.memoizedProperty(AWS, 'endpointCache', function () {
      return new AWS.EndpointCache(AWS.config.endpointCacheSize);
    }, true);
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/credentials.js":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/lib/credentials.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCredentialsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * Represents your AWS security credentials, specifically the
     * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
     * Creating a `Credentials` object allows you to pass around your
     * security information to configuration and service objects.
     *
     * Note that this class typically does not need to be constructed manually,
     * as the {AWS.Config} and {AWS.Service} classes both accept simple
     * options hashes with the three keys. These structures will be converted
     * into Credentials objects automatically.
     *
     * ## Expiring and Refreshing Credentials
     *
     * Occasionally credentials can expire in the middle of a long-running
     * application. In this case, the SDK will automatically attempt to
     * refresh the credentials from the storage location if the Credentials
     * class implements the {refresh} method.
     *
     * If you are implementing a credential storage location, you
     * will want to create a subclass of the `Credentials` class and
     * override the {refresh} method. This method allows credentials to be
     * retrieved from the backing store, be it a file system, database, or
     * some network storage. The method should reset the credential attributes
     * on the object.
     *
     * @!attribute expired
     *   @return [Boolean] whether the credentials have been expired and
     *     require a refresh. Used in conjunction with {expireTime}.
     * @!attribute expireTime
     *   @return [Date] a time when credentials should be considered expired. Used
     *     in conjunction with {expired}.
     * @!attribute accessKeyId
     *   @return [String] the AWS access key ID
     * @!attribute secretAccessKey
     *   @return [String] the AWS secret access key
     * @!attribute sessionToken
     *   @return [String] an optional AWS session token
     */


    AWS.Credentials = AWS.util.inherit({
      /**
       * A credentials object can be created using positional arguments or an options
       * hash.
       *
       * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
       *   Creates a Credentials object with a given set of credential information
       *   as positional arguments.
       *   @param accessKeyId [String] the AWS access key ID
       *   @param secretAccessKey [String] the AWS secret access key
       *   @param sessionToken [String] the optional AWS session token
       *   @example Create a credentials object with AWS credentials
       *     var creds = new AWS.Credentials('akid', 'secret', 'session');
       * @overload AWS.Credentials(options)
       *   Creates a Credentials object with a given set of credential information
       *   as an options hash.
       *   @option options accessKeyId [String] the AWS access key ID
       *   @option options secretAccessKey [String] the AWS secret access key
       *   @option options sessionToken [String] the optional AWS session token
       *   @example Create a credentials object with AWS credentials
       *     var creds = new AWS.Credentials({
       *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
       *     });
       */
      constructor: function Credentials() {
        // hide secretAccessKey from being displayed with util.inspect
        AWS.util.hideProperties(this, ['secretAccessKey']);
        this.expired = false;
        this.expireTime = null;
        this.refreshCallbacks = [];

        if (arguments.length === 1 && typeof arguments[0] === 'object') {
          var creds = arguments[0].credentials || arguments[0];
          this.accessKeyId = creds.accessKeyId;
          this.secretAccessKey = creds.secretAccessKey;
          this.sessionToken = creds.sessionToken;
        } else {
          this.accessKeyId = arguments[0];
          this.secretAccessKey = arguments[1];
          this.sessionToken = arguments[2];
        }
      },

      /**
       * @return [Integer] the number of seconds before {expireTime} during which
       *   the credentials will be considered expired.
       */
      expiryWindow: 15,

      /**
       * @return [Boolean] whether the credentials object should call {refresh}
       * @note Subclasses should override this method to provide custom refresh
       *   logic.
       */
      needsRefresh: function needsRefresh() {
        var currentTime = AWS.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

        if (this.expireTime && adjustedTime > this.expireTime) {
          return true;
        } else {
          return this.expired || !this.accessKeyId || !this.secretAccessKey;
        }
      },

      /**
       * Gets the existing credentials, refreshing them if they are not yet loaded
       * or have expired. Users should call this method before using {refresh},
       * as this will not attempt to reload credentials when they are already
       * loaded into the object.
       *
       * @callback callback function(err)
       *   When this callback is called with no error, it means either credentials
       *   do not need to be refreshed or refreshed credentials information has
       *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
       *   and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       */
      get: function get(callback) {
        var self = this;

        if (this.needsRefresh()) {
          this.refresh(function (err) {
            if (!err) self.expired = false; // reset expired flag

            if (callback) callback(err);
          });
        } else if (callback) {
          callback();
        }
      },

      /**
       * @!method  getPromise()
       *   Returns a 'thenable' promise.
       *   Gets the existing credentials, refreshing them if they are not yet loaded
       *   or have expired. Users should call this method before using {refresh},
       *   as this will not attempt to reload credentials when they are already
       *   loaded into the object.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function()
       *     Called if the promise is fulfilled. When this callback is called, it
       *     means either credentials do not need to be refreshed or refreshed
       *     credentials information has been loaded into the object (as the
       *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] if an error occurred, this value will be filled
       *   @return [Promise] A promise that represents the state of the `get` call.
       *   @example Calling the `getPromise` method.
       *     var promise = credProvider.getPromise();
       *     promise.then(function() { ... }, function(err) { ... });
       */

      /**
       * @!method  refreshPromise()
       *   Returns a 'thenable' promise.
       *   Refreshes the credentials. Users should call {get} before attempting
       *   to forcibly refresh credentials.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function()
       *     Called if the promise is fulfilled. When this callback is called, it
       *     means refreshed credentials information has been loaded into the object
       *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] if an error occurred, this value will be filled
       *   @return [Promise] A promise that represents the state of the `refresh` call.
       *   @example Calling the `refreshPromise` method.
       *     var promise = credProvider.refreshPromise();
       *     promise.then(function() { ... }, function(err) { ... });
       */

      /**
       * Refreshes the credentials. Users should call {get} before attempting
       * to forcibly refresh credentials.
       *
       * @callback callback function(err)
       *   When this callback is called with no error, it means refreshed
       *   credentials information has been loaded into the object (as the
       *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @note Subclasses should override this class to reset the
       *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
       *   on the credentials object and then call the callback with
       *   any error information.
       * @see get
       */
      refresh: function refresh(callback) {
        this.expired = false;
        callback();
      },

      /**
       * @api private
       * @param callback
       */
      coalesceRefresh: function coalesceRefresh(callback, sync) {
        var self = this;

        if (self.refreshCallbacks.push(callback) === 1) {
          self.load(function onLoad(err) {
            AWS.util.arrayEach(self.refreshCallbacks, function (callback) {
              if (sync) {
                callback(err);
              } else {
                // callback could throw, so defer to ensure all callbacks are notified
                AWS.util.defer(function () {
                  callback(err);
                });
              }
            });
            self.refreshCallbacks.length = 0;
          });
        }
      },

      /**
       * @api private
       * @param callback
       */
      load: function load(callback) {
        callback();
      }
    });
    /**
     * @api private
     */

    AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
      this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
    };
    /**
     * @api private
     */


    AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getPromise;
      delete this.prototype.refreshPromise;
    };

    AWS.util.addPromises(AWS.Credentials);
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js ***!
    \*********************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCredentialsChainable_temporary_credentialsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var STS = __webpack_require__(
    /*! ../../clients/sts */
    "./node_modules/aws-sdk/clients/sts.js");
    /**
     * Represents temporary credentials retrieved from {AWS.STS}. Without any
     * extra parameters, credentials will be fetched from the
     * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
     * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
     * role instead.
     *
     * AWS.ChainableTemporaryCredentials differs from AWS.TemporaryCredentials in
     * the way masterCredentials and refreshes are handled.
     * AWS.ChainableTemporaryCredentials refreshes expired credentials using the
     * masterCredentials passed by the user to support chaining of STS credentials.
     * However, AWS.TemporaryCredentials recursively collapses the masterCredentials
     * during instantiation, precluding the ability to refresh credentials which
     * require intermediate, temporary credentials.
     *
     * For example, if the application should use RoleA, which must be assumed from
     * RoleB, and the environment provides credentials which can assume RoleB, then
     * AWS.ChainableTemporaryCredentials must be used to support refreshing the
     * temporary credentials for RoleA:
     *
     * ```javascript
     * var roleACreds = new AWS.ChainableTemporaryCredentials({
     *   params: {RoleArn: 'RoleA'},
     *   masterCredentials: new AWS.ChainableTemporaryCredentials({
     *     params: {RoleArn: 'RoleB'},
     *     masterCredentials: new AWS.EnvironmentCredentials('AWS')
     *   })
     * });
     * ```
     *
     * If AWS.TemporaryCredentials had been used in the previous example,
     * `roleACreds` would fail to refresh because `roleACreds` would
     * use the environment credentials for the AssumeRole request.
     *
     * Another difference is that AWS.ChainableTemporaryCredentials creates the STS
     * service instance during instantiation while AWS.TemporaryCredentials creates
     * the STS service instance during the first refresh. Creating the service
     * instance during instantiation effectively captures the master credentials
     * from the global config, so that subsequent changes to the global config do
     * not affect the master credentials used to refresh the temporary credentials.
     *
     * This allows an instance of AWS.ChainableTemporaryCredentials to be assigned
     * to AWS.config.credentials:
     *
     * ```javascript
     * var envCreds = new AWS.EnvironmentCredentials('AWS');
     * AWS.config.credentials = envCreds;
     * // masterCredentials will be envCreds
     * AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
     *   params: {RoleArn: '...'}
     * });
     * ```
     *
     * Similarly, to use the CredentialProviderChain's default providers as the
     * master credentials, simply create a new instance of
     * AWS.ChainableTemporaryCredentials:
     *
     * ```javascript
     * AWS.config.credentials = new ChainableTemporaryCredentials({
     *   params: {RoleArn: '...'}
     * });
     * ```
     *
     * @!attribute service
     *   @return [AWS.STS] the STS service instance used to
     *     get and refresh temporary credentials from AWS STS.
     * @note (see constructor)
     */


    AWS.ChainableTemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
      /**
       * Creates a new temporary credentials object.
       *
       * @param options [map] a set of options
       * @option options params [map] ({}) a map of options that are passed to the
       *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
       *   If a `RoleArn` parameter is passed in, credentials will be based on the
       *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
       *   also be passed in or an error will be thrown.
       * @option options masterCredentials [AWS.Credentials] the master credentials
       *   used to get and refresh temporary credentials from AWS STS. By default,
       *   AWS.config.credentials or AWS.config.credentialProvider will be used.
       * @option options tokenCodeFn [Function] (null) Function to provide
       *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
       *   is called with value of `SerialNumber` and `callback`, and should provide
       *   the `TokenCode` or an error to the callback in the format
       *   `callback(err, token)`.
       * @example Creating a new credentials object for generic temporary credentials
       *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
       * @example Creating a new credentials object for an IAM role
       *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
       *     params: {
       *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
       *     }
       *   });
       * @see AWS.STS.assumeRole
       * @see AWS.STS.getSessionToken
       */
      constructor: function ChainableTemporaryCredentials(options) {
        AWS.Credentials.call(this);
        options = options || {};
        this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';
        this.expired = true;
        this.tokenCodeFn = null;
        var params = AWS.util.copy(options.params) || {};

        if (params.RoleArn) {
          params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';
        }

        if (params.SerialNumber) {
          if (!options.tokenCodeFn || typeof options.tokenCodeFn !== 'function') {
            throw new AWS.util.error(new Error('tokenCodeFn must be a function when params.SerialNumber is given'), {
              code: this.errorCode
            });
          } else {
            this.tokenCodeFn = options.tokenCodeFn;
          }
        }

        var config = AWS.util.merge({
          params: params,
          credentials: options.masterCredentials || AWS.config.credentials
        }, options.stsConfig || {});
        this.service = new STS(config);
      },

      /**
       * Refreshes credentials using {AWS.STS.assumeRole} or
       * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
       * to the credentials {constructor}.
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see AWS.Credentials.get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS.util.fn.callback);
      },

      /**
       * @api private
       * @param callback
       */
      load: function load(callback) {
        var self = this;
        var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';
        this.getTokenCode(function (err, tokenCode) {
          var params = {};

          if (err) {
            callback(err);
            return;
          }

          if (tokenCode) {
            params.TokenCode = tokenCode;
          }

          self.service[operation](params, function (err, data) {
            if (!err) {
              self.service.credentialsFrom(data, self);
            }

            callback(err);
          });
        });
      },

      /**
       * @api private
       */
      getTokenCode: function getTokenCode(callback) {
        var self = this;

        if (this.tokenCodeFn) {
          this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {
            if (err) {
              var message = err;

              if (err instanceof Error) {
                message = err.message;
              }

              callback(AWS.util.error(new Error('Error fetching MFA token: ' + message), {
                code: self.errorCode
              }));
              return;
            }

            callback(null, token);
          });
        } else {
          callback(null);
        }
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js":
  /*!******************************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js ***!
    \******************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCredentialsCognito_identity_credentialsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var CognitoIdentity = __webpack_require__(
    /*! ../../clients/cognitoidentity */
    "./node_modules/aws-sdk/clients/cognitoidentity.js");

    var STS = __webpack_require__(
    /*! ../../clients/sts */
    "./node_modules/aws-sdk/clients/sts.js");
    /**
     * Represents credentials retrieved from STS Web Identity Federation using
     * the Amazon Cognito Identity service.
     *
     * By default this provider gets credentials using the
     * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
     * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
     * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
     * obtain an `IdentityId`. If the identity or identity pool is not configured in
     * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
     * then additionally a `RoleArn` is required containing the ARN of the IAM trust
     * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
     * is provided, then this provider gets credentials using the
     * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
     * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
     *
     * In addition, if this credential provider is used to provide authenticated
     * login, the `Logins` map may be set to the tokens provided by the respective
     * identity providers. See {constructor} for an example on creating a credentials
     * object with proper property values.
     *
     * ## Refreshing Credentials from Identity Service
     *
     * In addition to AWS credentials expiring after a given amount of time, the
     * login token from the identity provider will also expire. Once this token
     * expires, it will not be usable to refresh AWS credentials, and another
     * token will be needed. The SDK does not manage refreshing of the token value,
     * but this can be done through a "refresh token" supported by most identity
     * providers. Consult the documentation for the identity provider for refreshing
     * tokens. Once the refreshed token is acquired, you should make sure to update
     * this new token in the credentials object's {params} property. The following
     * code will update the WebIdentityToken, assuming you have retrieved an updated
     * token from the identity provider:
     *
     * ```javascript
     * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
     * ```
     *
     * Future calls to `credentials.refresh()` will now use the new token.
     *
     * @!attribute params
     *   @return [map] the map of params passed to
     *     {AWS.CognitoIdentity.getId},
     *     {AWS.CognitoIdentity.getOpenIdToken}, and
     *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
     *     `params.WebIdentityToken` property.
     * @!attribute data
     *   @return [map] the raw data response from the call to
     *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
     *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
     *     access to other properties from the response.
     * @!attribute identityId
     *   @return [String] the Cognito ID returned by the last call to
     *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
     *     final resolved identity ID from Amazon Cognito.
     */


    AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
      /**
       * @api private
       */
      localStorageKey: {
        id: 'aws.cognito.identity-id.',
        providers: 'aws.cognito.identity-providers.'
      },

      /**
       * Creates a new credentials object.
       * @example Creating a new credentials object
       *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
       *
       *     // either IdentityPoolId or IdentityId is required
       *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
       *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
       *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
       *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
       *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
       *
       *     // optional, only necessary when the identity pool is not configured
       *     // to use IAM roles in the Amazon Cognito Console
       *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
       *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
       *
       *     // optional tokens, used for authenticated login
       *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
       *     Logins: {
       *       'graph.facebook.com': 'FBTOKEN',
       *       'www.amazon.com': 'AMAZONTOKEN',
       *       'accounts.google.com': 'GOOGLETOKEN',
       *       'api.twitter.com': 'TWITTERTOKEN',
       *       'www.digits.com': 'DIGITSTOKEN'
       *     },
       *
       *     // optional name, defaults to web-identity
       *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
       *     RoleSessionName: 'web',
       *
       *     // optional, only necessary when application runs in a browser
       *     // and multiple users are signed in at once, used for caching
       *     LoginId: 'example@gmail.com'
       *
       *   }, {
       *      // optionally provide configuration to apply to the underlying service clients
       *      // if configuration is not provided, then configuration will be pulled from AWS.config
       *
       *      // region should match the region your identity pool is located in
       *      region: 'us-east-1',
       *
       *      // specify timeout options
       *      httpOptions: {
       *        timeout: 100
       *      }
       *   });
       * @see AWS.CognitoIdentity.getId
       * @see AWS.CognitoIdentity.getCredentialsForIdentity
       * @see AWS.STS.assumeRoleWithWebIdentity
       * @see AWS.CognitoIdentity.getOpenIdToken
       * @see AWS.Config
       * @note If a region is not provided in the global AWS.config, or
       *   specified in the `clientConfig` to the CognitoIdentityCredentials
       *   constructor, you may encounter a 'Missing credentials in config' error
       *   when calling making a service call.
       */
      constructor: function CognitoIdentityCredentials(params, clientConfig) {
        AWS.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.data = null;
        this._identityId = null;
        this._clientConfig = AWS.util.copy(clientConfig || {});
        this.loadCachedId();
        var self = this;
        Object.defineProperty(this, 'identityId', {
          get: function get() {
            self.loadCachedId();
            return self._identityId || self.params.IdentityId;
          },
          set: function set(identityId) {
            self._identityId = identityId;
          }
        });
      },

      /**
       * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
       * or {AWS.STS.assumeRoleWithWebIdentity}.
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see AWS.Credentials.get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS.util.fn.callback);
      },

      /**
       * @api private
       * @param callback
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.data = null;
        self._identityId = null;
        self.getId(function (err) {
          if (!err) {
            if (!self.params.RoleArn) {
              self.getCredentialsForIdentity(callback);
            } else {
              self.getCredentialsFromSTS(callback);
            }
          } else {
            self.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },

      /**
       * Clears the cached Cognito ID associated with the currently configured
       * identity pool ID. Use this to manually invalidate your cache if
       * the identity pool ID was deleted.
       */
      clearCachedId: function clearCache() {
        this._identityId = null;
        delete this.params.IdentityId;
        var poolId = this.params.IdentityPoolId;
        var loginId = this.params.LoginId || '';
        delete this.storage[this.localStorageKey.id + poolId + loginId];
        delete this.storage[this.localStorageKey.providers + poolId + loginId];
      },

      /**
       * @api private
       */
      clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
        var self = this;

        if (err.code == 'NotAuthorizedException') {
          self.clearCachedId();
        }
      },

      /**
       * Retrieves a Cognito ID, loading from cache if it was already retrieved
       * on this device.
       *
       * @callback callback function(err, identityId)
       *   @param err [Error, null] an error object if the call failed or null if
       *     it succeeded.
       *   @param identityId [String, null] if successful, the callback will return
       *     the Cognito ID.
       * @note If not loaded explicitly, the Cognito ID is loaded and stored in
       *   localStorage in the browser environment of a device.
       * @api private
       */
      getId: function getId(callback) {
        var self = this;

        if (typeof self.params.IdentityId === 'string') {
          return callback(null, self.params.IdentityId);
        }

        self.cognito.getId(function (err, data) {
          if (!err && data.IdentityId) {
            self.params.IdentityId = data.IdentityId;
            callback(null, data.IdentityId);
          } else {
            callback(err);
          }
        });
      },

      /**
       * @api private
       */
      loadCredentials: function loadCredentials(data, credentials) {
        if (!data || !credentials) return;
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
      },

      /**
       * @api private
       */
      getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
        var self = this;
        self.cognito.getCredentialsForIdentity(function (err, data) {
          if (!err) {
            self.cacheId(data);
            self.data = data;
            self.loadCredentials(self.data, self);
          } else {
            self.clearIdOnNotAuthorized(err);
          }

          callback(err);
        });
      },

      /**
       * @api private
       */
      getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
        var self = this;
        self.cognito.getOpenIdToken(function (err, data) {
          if (!err) {
            self.cacheId(data);
            self.params.WebIdentityToken = data.Token;
            self.webIdentityCredentials.refresh(function (webErr) {
              if (!webErr) {
                self.data = self.webIdentityCredentials.data;
                self.sts.credentialsFrom(self.data, self);
              }

              callback(webErr);
            });
          } else {
            self.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },

      /**
       * @api private
       */
      loadCachedId: function loadCachedId() {
        var self = this; // in the browser we source default IdentityId from localStorage

        if (AWS.util.isBrowser() && !self.params.IdentityId) {
          var id = self.getStorage('id');

          if (id && self.params.Logins) {
            var actualProviders = Object.keys(self.params.Logins);
            var cachedProviders = (self.getStorage('providers') || '').split(','); // only load ID if at least one provider used this ID before

            var intersect = cachedProviders.filter(function (n) {
              return actualProviders.indexOf(n) !== -1;
            });

            if (intersect.length !== 0) {
              self.params.IdentityId = id;
            }
          } else if (id) {
            self.params.IdentityId = id;
          }
        }
      },

      /**
       * @api private
       */
      createClients: function createClients() {
        var clientConfig = this._clientConfig;
        this.webIdentityCredentials = this.webIdentityCredentials || new AWS.WebIdentityCredentials(this.params, clientConfig);

        if (!this.cognito) {
          var cognitoConfig = AWS.util.merge({}, clientConfig);
          cognitoConfig.params = this.params;
          this.cognito = new CognitoIdentity(cognitoConfig);
        }

        this.sts = this.sts || new STS(clientConfig);
      },

      /**
       * @api private
       */
      cacheId: function cacheId(data) {
        this._identityId = data.IdentityId;
        this.params.IdentityId = this._identityId; // cache this IdentityId in browser localStorage if possible

        if (AWS.util.isBrowser()) {
          this.setStorage('id', data.IdentityId);

          if (this.params.Logins) {
            this.setStorage('providers', Object.keys(this.params.Logins).join(','));
          }
        }
      },

      /**
       * @api private
       */
      getStorage: function getStorage(key) {
        return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
      },

      /**
       * @api private
       */
      setStorage: function setStorage(key, val) {
        try {
          this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
        } catch (_) {}
      },

      /**
       * @api private
       */
      storage: function () {
        try {
          var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ? window.localStorage : {}; // Test set/remove which would throw an error in Safari's private browsing

          storage['aws.test-storage'] = 'foobar';
          delete storage['aws.test-storage'];
          return storage;
        } catch (_) {
          return {};
        }
      }()
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js":
  /*!***************************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/credentials/credential_provider_chain.js ***!
    \***************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCredentialsCredential_provider_chainJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * Creates a credential provider chain that searches for AWS credentials
     * in a list of credential providers specified by the {providers} property.
     *
     * By default, the chain will use the {defaultProviders} to resolve credentials.
     * These providers will look in the environment using the
     * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
     *
     * ## Setting Providers
     *
     * Each provider in the {providers} list should be a function that returns
     * a {AWS.Credentials} object, or a hardcoded credentials object. The function
     * form allows for delayed execution of the credential construction.
     *
     * ## Resolving Credentials from a Chain
     *
     * Call {resolve} to return the first valid credential object that can be
     * loaded by the provider chain.
     *
     * For example, to resolve a chain with a custom provider that checks a file
     * on disk after the set of {defaultProviders}:
     *
     * ```javascript
     * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
     * var chain = new AWS.CredentialProviderChain();
     * chain.providers.push(diskProvider);
     * chain.resolve();
     * ```
     *
     * The above code will return the `diskProvider` object if the
     * file contains credentials and the `defaultProviders` do not contain
     * any credential settings.
     *
     * @!attribute providers
     *   @return [Array<AWS.Credentials, Function>]
     *     a list of credentials objects or functions that return credentials
     *     objects. If the provider is a function, the function will be
     *     executed lazily when the provider needs to be checked for valid
     *     credentials. By default, this object will be set to the
     *     {defaultProviders}.
     *   @see defaultProviders
     */


    AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {
      /**
       * Creates a new CredentialProviderChain with a default set of providers
       * specified by {defaultProviders}.
       */
      constructor: function CredentialProviderChain(providers) {
        if (providers) {
          this.providers = providers;
        } else {
          this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
        }

        this.resolveCallbacks = [];
      },

      /**
       * @!method  resolvePromise()
       *   Returns a 'thenable' promise.
       *   Resolves the provider chain by searching for the first set of
       *   credentials in {providers}.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function(credentials)
       *     Called if the promise is fulfilled and the provider resolves the chain
       *     to a credentials object
       *     @param credentials [AWS.Credentials] the credentials object resolved
       *       by the provider chain.
       *   @callback rejectedCallback function(error)
       *     Called if the promise is rejected.
       *     @param err [Error] the error object returned if no credentials are found.
       *   @return [Promise] A promise that represents the state of the `resolve` method call.
       *   @example Calling the `resolvePromise` method.
       *     var promise = chain.resolvePromise();
       *     promise.then(function(credentials) { ... }, function(err) { ... });
       */

      /**
       * Resolves the provider chain by searching for the first set of
       * credentials in {providers}.
       *
       * @callback callback function(err, credentials)
       *   Called when the provider resolves the chain to a credentials object
       *   or null if no credentials can be found.
       *
       *   @param err [Error] the error object returned if no credentials are
       *     found.
       *   @param credentials [AWS.Credentials] the credentials object resolved
       *     by the provider chain.
       * @return [AWS.CredentialProviderChain] the provider, for chaining.
       */
      resolve: function resolve(callback) {
        var self = this;

        if (self.providers.length === 0) {
          callback(new Error('No providers'));
          return self;
        }

        if (self.resolveCallbacks.push(callback) === 1) {
          var resolveNext = function resolveNext(err, creds) {
            if (!err && creds || index === providers.length) {
              AWS.util.arrayEach(self.resolveCallbacks, function (callback) {
                callback(err, creds);
              });
              self.resolveCallbacks.length = 0;
              return;
            }

            var provider = providers[index++];

            if (typeof provider === 'function') {
              creds = provider.call();
            } else {
              creds = provider;
            }

            if (creds.get) {
              creds.get(function (getErr) {
                resolveNext(getErr, getErr ? null : creds);
              });
            } else {
              resolveNext(null, creds);
            }
          };

          var index = 0;
          var providers = self.providers.slice(0);
          resolveNext();
        }

        return self;
      }
    });
    /**
     * The default set of providers used by a vanilla CredentialProviderChain.
     *
     * In the browser:
     *
     * ```javascript
     * AWS.CredentialProviderChain.defaultProviders = []
     * ```
     *
     * In Node.js:
     *
     * ```javascript
     * AWS.CredentialProviderChain.defaultProviders = [
     *   function () { return new AWS.EnvironmentCredentials('AWS'); },
     *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
     *   function () { return new AWS.SharedIniFileCredentials(); },
     *   function () { return new AWS.ECSCredentials(); },
     *   function () { return new AWS.ProcessCredentials(); },
     *   function () { return new AWS.TokenFileWebIdentityCredentials(); },
     *   function () { return new AWS.EC2MetadataCredentials() }
     * ]
     * ```
     */

    AWS.CredentialProviderChain.defaultProviders = [];
    /**
     * @api private
     */

    AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
    };
    /**
     * @api private
     */


    AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.resolvePromise;
    };

    AWS.util.addPromises(AWS.CredentialProviderChain);
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/credentials/saml_credentials.js":
  /*!******************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/credentials/saml_credentials.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCredentialsSaml_credentialsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var STS = __webpack_require__(
    /*! ../../clients/sts */
    "./node_modules/aws-sdk/clients/sts.js");
    /**
     * Represents credentials retrieved from STS SAML support.
     *
     * By default this provider gets credentials using the
     * {AWS.STS.assumeRoleWithSAML} service operation. This operation
     * requires a `RoleArn` containing the ARN of the IAM trust policy for the
     * application for which credentials will be given, as well as a `PrincipalArn`
     * representing the ARN for the SAML identity provider. In addition, the
     * `SAMLAssertion` must be set to the token provided by the identity
     * provider. See {constructor} for an example on creating a credentials
     * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
     *
     * ## Refreshing Credentials from Identity Service
     *
     * In addition to AWS credentials expiring after a given amount of time, the
     * login token from the identity provider will also expire. Once this token
     * expires, it will not be usable to refresh AWS credentials, and another
     * token will be needed. The SDK does not manage refreshing of the token value,
     * but this can be done through a "refresh token" supported by most identity
     * providers. Consult the documentation for the identity provider for refreshing
     * tokens. Once the refreshed token is acquired, you should make sure to update
     * this new token in the credentials object's {params} property. The following
     * code will update the SAMLAssertion, assuming you have retrieved an updated
     * token from the identity provider:
     *
     * ```javascript
     * AWS.config.credentials.params.SAMLAssertion = updatedToken;
     * ```
     *
     * Future calls to `credentials.refresh()` will now use the new token.
     *
     * @!attribute params
     *   @return [map] the map of params passed to
     *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
     *     `params.SAMLAssertion` property.
     */


    AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
      /**
       * Creates a new credentials object.
       * @param (see AWS.STS.assumeRoleWithSAML)
       * @example Creating a new credentials object
       *   AWS.config.credentials = new AWS.SAMLCredentials({
       *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
       *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
       *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
       *   });
       * @see AWS.STS.assumeRoleWithSAML
       */
      constructor: function SAMLCredentials(params) {
        AWS.Credentials.call(this);
        this.expired = true;
        this.params = params;
      },

      /**
       * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS.util.fn.callback);
      },

      /**
       * @api private
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.service.assumeRoleWithSAML(function (err, data) {
          if (!err) {
            self.service.credentialsFrom(data, self);
          }

          callback(err);
        });
      },

      /**
       * @api private
       */
      createClients: function createClients() {
        this.service = this.service || new STS({
          params: this.params
        });
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/credentials/temporary_credentials.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/credentials/temporary_credentials.js ***!
    \***********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCredentialsTemporary_credentialsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var STS = __webpack_require__(
    /*! ../../clients/sts */
    "./node_modules/aws-sdk/clients/sts.js");
    /**
     * Represents temporary credentials retrieved from {AWS.STS}. Without any
     * extra parameters, credentials will be fetched from the
     * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
     * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
     * role instead.
     *
     * @note AWS.TemporaryCredentials is deprecated, but remains available for
     *   backwards compatibility. {AWS.ChainableTemporaryCredentials} is the
     *   preferred class for temporary credentials.
     *
     * To setup temporary credentials, configure a set of master credentials
     * using the standard credentials providers (environment, EC2 instance metadata,
     * or from the filesystem), then set the global credentials to a new
     * temporary credentials object:
     *
     * ```javascript
     * // Note that environment credentials are loaded by default,
     * // the following line is shown for clarity:
     * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
     *
     * // Now set temporary credentials seeded from the master credentials
     * AWS.config.credentials = new AWS.TemporaryCredentials();
     *
     * // subsequent requests will now use temporary credentials from AWS STS.
     * new AWS.S3().listBucket(function(err, data) { ... });
     * ```
     *
     * @!attribute masterCredentials
     *   @return [AWS.Credentials] the master (non-temporary) credentials used to
     *     get and refresh temporary credentials from AWS STS.
     * @note (see constructor)
     */


    AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
      /**
       * Creates a new temporary credentials object.
       *
       * @note In order to create temporary credentials, you first need to have
       *   "master" credentials configured in {AWS.Config.credentials}. These
       *   master credentials are necessary to retrieve the temporary credentials,
       *   as well as refresh the credentials when they expire.
       * @param params [map] a map of options that are passed to the
       *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
       *   If a `RoleArn` parameter is passed in, credentials will be based on the
       *   IAM role.
       * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
       *  used to get and refresh temporary credentials from AWS STS.
       * @example Creating a new credentials object for generic temporary credentials
       *   AWS.config.credentials = new AWS.TemporaryCredentials();
       * @example Creating a new credentials object for an IAM role
       *   AWS.config.credentials = new AWS.TemporaryCredentials({
       *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
       *   });
       * @see AWS.STS.assumeRole
       * @see AWS.STS.getSessionToken
       */
      constructor: function TemporaryCredentials(params, masterCredentials) {
        AWS.Credentials.call(this);
        this.loadMasterCredentials(masterCredentials);
        this.expired = true;
        this.params = params || {};

        if (this.params.RoleArn) {
          this.params.RoleSessionName = this.params.RoleSessionName || 'temporary-credentials';
        }
      },

      /**
       * Refreshes credentials using {AWS.STS.assumeRole} or
       * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
       * to the credentials {constructor}.
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS.util.fn.callback);
      },

      /**
       * @api private
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.masterCredentials.get(function () {
          self.service.config.credentials = self.masterCredentials;
          var operation = self.params.RoleArn ? self.service.assumeRole : self.service.getSessionToken;
          operation.call(self.service, function (err, data) {
            if (!err) {
              self.service.credentialsFrom(data, self);
            }

            callback(err);
          });
        });
      },

      /**
       * @api private
       */
      loadMasterCredentials: function loadMasterCredentials(masterCredentials) {
        this.masterCredentials = masterCredentials || AWS.config.credentials;

        while (this.masterCredentials.masterCredentials) {
          this.masterCredentials = this.masterCredentials.masterCredentials;
        }

        if (typeof this.masterCredentials.get !== 'function') {
          this.masterCredentials = new AWS.Credentials(this.masterCredentials);
        }
      },

      /**
       * @api private
       */
      createClients: function createClients() {
        this.service = this.service || new STS({
          params: this.params
        });
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/credentials/web_identity_credentials.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/credentials/web_identity_credentials.js ***!
    \**************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibCredentialsWeb_identity_credentialsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var STS = __webpack_require__(
    /*! ../../clients/sts */
    "./node_modules/aws-sdk/clients/sts.js");
    /**
     * Represents credentials retrieved from STS Web Identity Federation support.
     *
     * By default this provider gets credentials using the
     * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
     * requires a `RoleArn` containing the ARN of the IAM trust policy for the
     * application for which credentials will be given. In addition, the
     * `WebIdentityToken` must be set to the token provided by the identity
     * provider. See {constructor} for an example on creating a credentials
     * object with proper `RoleArn` and `WebIdentityToken` values.
     *
     * ## Refreshing Credentials from Identity Service
     *
     * In addition to AWS credentials expiring after a given amount of time, the
     * login token from the identity provider will also expire. Once this token
     * expires, it will not be usable to refresh AWS credentials, and another
     * token will be needed. The SDK does not manage refreshing of the token value,
     * but this can be done through a "refresh token" supported by most identity
     * providers. Consult the documentation for the identity provider for refreshing
     * tokens. Once the refreshed token is acquired, you should make sure to update
     * this new token in the credentials object's {params} property. The following
     * code will update the WebIdentityToken, assuming you have retrieved an updated
     * token from the identity provider:
     *
     * ```javascript
     * AWS.config.credentials.params.WebIdentityToken = updatedToken;
     * ```
     *
     * Future calls to `credentials.refresh()` will now use the new token.
     *
     * @!attribute params
     *   @return [map] the map of params passed to
     *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
     *     `params.WebIdentityToken` property.
     * @!attribute data
     *   @return [map] the raw data response from the call to
     *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
     *     access to other properties from the response.
     */


    AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
      /**
       * Creates a new credentials object.
       * @param (see AWS.STS.assumeRoleWithWebIdentity)
       * @example Creating a new credentials object
       *   AWS.config.credentials = new AWS.WebIdentityCredentials({
       *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
       *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
       *     RoleSessionName: 'web' // optional name, defaults to web-identity
       *   }, {
       *     // optionally provide configuration to apply to the underlying AWS.STS service client
       *     // if configuration is not provided, then configuration will be pulled from AWS.config
       *
       *     // specify timeout options
       *     httpOptions: {
       *       timeout: 100
       *     }
       *   });
       * @see AWS.STS.assumeRoleWithWebIdentity
       * @see AWS.Config
       */
      constructor: function WebIdentityCredentials(params, clientConfig) {
        AWS.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
        this.data = null;
        this._clientConfig = AWS.util.copy(clientConfig || {});
      },

      /**
       * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS.util.fn.callback);
      },

      /**
       * @api private
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.service.assumeRoleWithWebIdentity(function (err, data) {
          self.data = null;

          if (!err) {
            self.data = data;
            self.service.credentialsFrom(data, self);
          }

          callback(err);
        });
      },

      /**
       * @api private
       */
      createClients: function createClients() {
        if (!this.service) {
          var stsConfig = AWS.util.merge({}, this._clientConfig);
          stsConfig.params = this.params;
          this.service = new STS(stsConfig);
        }
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/discover_endpoint.js":
  /*!*******************************************************!*\
    !*** ./node_modules/aws-sdk/lib/discover_endpoint.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibDiscover_endpointJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    var util = __webpack_require__(
    /*! ./util */
    "./node_modules/aws-sdk/lib/util.js");

    var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];
    /**
     * Generate key (except resources and operation part) to index the endpoints in the cache
     * If input shape has endpointdiscoveryid trait then use
     *   accessKey + operation + resources + region + service as cache key
     * If input shape doesn't have endpointdiscoveryid trait then use
     *   accessKey + region + service as cache key
     * @return [map<String,String>] object with keys to index endpoints.
     * @api private
     */

    function getCacheKey(request) {
      var service = request.service;
      var api = service.api || {};
      var operations = api.operations;
      var identifiers = {};

      if (service.config.region) {
        identifiers.region = service.config.region;
      }

      if (api.serviceId) {
        identifiers.serviceId = api.serviceId;
      }

      if (service.config.credentials.accessKeyId) {
        identifiers.accessKeyId = service.config.credentials.accessKeyId;
      }

      return identifiers;
    }
    /**
     * Recursive helper for marshallCustomIdentifiers().
     * Looks for required string input members that have 'endpointdiscoveryid' trait.
     * @api private
     */


    function marshallCustomIdentifiersHelper(result, params, shape) {
      if (!shape || params === undefined || params === null) return;

      if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
        util.arrayEach(shape.required, function (name) {
          var memberShape = shape.members[name];

          if (memberShape.endpointDiscoveryId === true) {
            var locationName = memberShape.isLocationName ? memberShape.name : name;
            result[locationName] = String(params[name]);
          } else {
            marshallCustomIdentifiersHelper(result, params[name], memberShape);
          }
        });
      }
    }
    /**
     * Get custom identifiers for cache key.
     * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.
     * @param [object] request object
     * @param [object] input shape of the given operation's api
     * @api private
     */


    function marshallCustomIdentifiers(request, shape) {
      var identifiers = {};
      marshallCustomIdentifiersHelper(identifiers, request.params, shape);
      return identifiers;
    }
    /**
     * Call endpoint discovery operation when it's optional.
     * When endpoint is available in cache then use the cached endpoints. If endpoints
     * are unavailable then use regional endpoints and call endpoint discovery operation
     * asynchronously. This is turned off by default.
     * @param [object] request object
     * @api private
     */


    function optionalDiscoverEndpoint(request) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : undefined;
      var inputShape = operationModel ? operationModel.input : undefined;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);

      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel) cacheKey.operation = operationModel.name;
      }

      var endpoints = AWS.endpointCache.get(cacheKey);

      if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
        //endpoint operation is being made but response not yet received
        //or endpoint operation just failed in 1 minute
        return;
      } else if (endpoints && endpoints.length > 0) {
        //found endpoint record from cache
        request.httpRequest.updateEndpoint(endpoints[0].Address);
      } else {
        //endpoint record not in cache or outdated. make discovery operation
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        addApiVersionHeader(endpointRequest);
        endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
        endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK); //put in a placeholder for endpoints already requested, prevent
        //too much in-flight calls

        AWS.endpointCache.put(cacheKey, [{
          Address: '',
          CachePeriodInMinutes: 1
        }]);
        endpointRequest.send(function (err, data) {
          if (data && data.Endpoints) {
            AWS.endpointCache.put(cacheKey, data.Endpoints);
          } else if (err) {
            AWS.endpointCache.put(cacheKey, [{
              Address: '',
              CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute

            }]);
          }
        });
      }
    }

    var requestQueue = {};
    /**
     * Call endpoint discovery operation when it's required.
     * When endpoint is available in cache then use cached ones. If endpoints are
     * unavailable then SDK should call endpoint operation then use returned new
     * endpoint for the api call. SDK will automatically attempt to do endpoint
     * discovery. This is turned off by default
     * @param [object] request object
     * @api private
     */

    function requiredDiscoverEndpoint(request, done) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : undefined;
      var inputShape = operationModel ? operationModel.input : undefined;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);

      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel) cacheKey.operation = operationModel.name;
      }

      var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);
      var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys

      if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
        //endpoint operation is being made but response not yet received
        //push request object to a pending queue
        if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
        requestQueue[cacheKeyStr].push({
          request: request,
          callback: done
        });
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
        done();
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
        addApiVersionHeader(endpointRequest); //put in a placeholder for endpoints already requested, prevent
        //too much in-flight calls

        AWS.endpointCache.put(cacheKeyStr, [{
          Address: '',
          CachePeriodInMinutes: 60 //long-live cache

        }]);
        endpointRequest.send(function (err, data) {
          if (err) {
            request.response.error = util.error(err, {
              retryable: false
            });
            AWS.endpointCache.remove(cacheKey); //fail all the pending requests in batch

            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function (requestContext) {
                requestContext.request.response.error = util.error(err, {
                  retryable: false
                });
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          } else if (data) {
            AWS.endpointCache.put(cacheKeyStr, data.Endpoints);
            request.httpRequest.updateEndpoint(data.Endpoints[0].Address); //update the endpoint for all the pending requests in batch

            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function (requestContext) {
                requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          }

          done();
        });
      }
    }
    /**
     * add api version header to endpoint operation
     * @api private
     */


    function addApiVersionHeader(endpointRequest) {
      var api = endpointRequest.service.api;
      var apiVersion = api.apiVersion;

      if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
        endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;
      }
    }
    /**
     * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid
     * endpoint from cache.
     * @api private
     */


    function invalidateCachedEndpoints(response) {
      var error = response.error;
      var httpResponse = response.httpResponse;

      if (error && (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)) {
        var request = response.request;
        var operations = request.service.api.operations || {};
        var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;
        var identifiers = marshallCustomIdentifiers(request, inputShape);
        var cacheKey = getCacheKey(request);

        if (Object.keys(identifiers).length > 0) {
          cacheKey = util.update(cacheKey, identifiers);
          if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
        }

        AWS.endpointCache.remove(cacheKey);
      }
    }
    /**
     * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.
     * @param [object] client Service client object.
     * @api private
     */


    function hasCustomEndpoint(client) {
      //if set endpoint is set for specific client, enable endpoint discovery will raise an error.
      if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
        throw util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'
        });
      }

      ;
      var svcConfig = AWS.config[client.serviceIdentifier] || {};
      return Boolean(AWS.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);
    }
    /**
     * @api private
     */


    function isFalsy(value) {
      return ['false', '0'].indexOf(value) >= 0;
    }
    /**
     * If endpoint discovery should perform for this request when no operation requires endpoint
     * discovery for the given service.
     * SDK performs config resolution in order like below:
     * 1. If set in client configuration.
     * 2. If set in env AWS_ENABLE_ENDPOINT_DISCOVERY.
     * 3. If set in shared ini config file with key 'endpoint_discovery_enabled'.
     * @param [object] request request object.
     * @returns [boolean|undefined] if endpoint discovery config is not set in any source, this
     *  function returns undefined
     * @api private
     */


    function resolveEndpointDiscoveryConfig(request) {
      var service = request.service || {};

      if (service.config.endpointDiscoveryEnabled !== undefined) {
        return service.config.endpointDiscoveryEnabled;
      } //shared ini file is only available in Node
      //not to check env in browser


      if (util.isBrowser()) return undefined; // If any of recognized endpoint discovery config env is set

      for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
        var env = endpointDiscoveryEnabledEnvs[i];

        if (Object.prototype.hasOwnProperty.call(process.env, env)) {
          if (process.env[env] === '' || process.env[env] === undefined) {
            throw util.error(new Error(), {
              code: 'ConfigurationException',
              message: 'environmental variable ' + env + ' cannot be set to nothing'
            });
          }

          return !isFalsy(process.env[env]);
        }
      }

      var configFile = {};

      try {
        configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[AWS.util.sharedConfigFileEnv]
        }) : {};
      } catch (e) {}

      var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS.util.defaultProfile] || {};

      if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
        if (sharedFileConfig.endpoint_discovery_enabled === undefined) {
          throw util.error(new Error(), {
            code: 'ConfigurationException',
            message: 'config file entry \'endpoint_discovery_enabled\' cannot be set to nothing'
          });
        }

        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
      }

      return undefined;
    }
    /**
     * attach endpoint discovery logic to request object
     * @param [object] request
     * @api private
     */


    function discoverEndpoint(request, done) {
      var service = request.service || {};
      if (hasCustomEndpoint(service) || request.isPresigned()) return done();
      var operations = service.api.operations || {};
      var operationModel = operations[request.operation];
      var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
      var isEnabled = resolveEndpointDiscoveryConfig(request);
      var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;

      if (isEnabled || hasRequiredEndpointDiscovery) {
        // Once a customer enables endpoint discovery, the SDK should start appending
        // the string endpoint-discovery to the user-agent on all requests.
        request.httpRequest.appendToUserAgent('endpoint-discovery');
      }

      switch (isEndpointDiscoveryRequired) {
        case 'OPTIONAL':
          if (isEnabled || hasRequiredEndpointDiscovery) {
            // For a given service; if at least one operation requires endpoint discovery then the SDK must enable endpoint discovery
            // by default for all operations of that service, including operations where endpoint discovery is optional.
            optionalDiscoverEndpoint(request);
            request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
          }

          done();
          break;

        case 'REQUIRED':
          if (isEnabled === false) {
            // For a given operation; if endpoint discovery is required and it has been disabled on the SDK client,
            // then the SDK must return a clear and actionable exception.
            request.response.error = util.error(new Error(), {
              code: 'ConfigurationException',
              message: 'Endpoint Discovery is disabled but ' + service.api.className + '.' + request.operation + '() requires it. Please check your configurations.'
            });
            done();
            break;
          }

          request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
          requiredDiscoverEndpoint(request, done);
          break;

        case 'NULL':
        default:
          done();
          break;
      }
    }

    module.exports = {
      discoverEndpoint: discoverEndpoint,
      requiredDiscoverEndpoint: requiredDiscoverEndpoint,
      optionalDiscoverEndpoint: optionalDiscoverEndpoint,
      marshallCustomIdentifiers: marshallCustomIdentifiers,
      getCacheKey: getCacheKey,
      invalidateCachedEndpoint: invalidateCachedEndpoints
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js ***!
    \*******************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibEventStreamBufferedCreateEventStreamJs(module, exports, __webpack_require__) {
    var eventMessageChunker = __webpack_require__(
    /*! ../event-stream/event-message-chunker */
    "./node_modules/aws-sdk/lib/event-stream/event-message-chunker.js").eventMessageChunker;

    var parseEvent = __webpack_require__(
    /*! ./parse-event */
    "./node_modules/aws-sdk/lib/event-stream/parse-event.js").parseEvent;

    function createEventStream(body, parser, model) {
      var eventMessages = eventMessageChunker(body);
      var events = [];

      for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
      }

      return events;
    }
    /**
     * @api private
     */


    module.exports = {
      createEventStream: createEventStream
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/event-stream/event-message-chunker.js":
  /*!************************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/event-stream/event-message-chunker.js ***!
    \************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibEventStreamEventMessageChunkerJs(module, exports) {
    /**
     * Takes in a buffer of event messages and splits them into individual messages.
     * @param {Buffer} buffer
     * @api private
     */
    function eventMessageChunker(buffer) {
      /** @type Buffer[] */
      var messages = [];
      var offset = 0;

      while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset); // create new buffer for individual message (shares memory with original)

        var message = buffer.slice(offset, totalLength + offset); // increment offset to it starts at the next message

        offset += totalLength;
        messages.push(message);
      }

      return messages;
    }
    /**
     * @api private
     */


    module.exports = {
      eventMessageChunker: eventMessageChunker
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/event-stream/int64.js":
  /*!********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/event-stream/int64.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibEventStreamInt64Js(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js").util;

    var toBuffer = util.buffer.toBuffer;
    /**
     * A lossless representation of a signed, 64-bit integer. Instances of this
     * class may be used in arithmetic expressions as if they were numeric
     * primitives, but the binary representation will be preserved unchanged as the
     * `bytes` property of the object. The bytes should be encoded as big-endian,
     * two's complement integers.
     * @param {Buffer} bytes
     *
     * @api private
     */

    function Int64(bytes) {
      if (bytes.length !== 8) {
        throw new Error('Int64 buffers must be exactly 8 bytes');
      }

      if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);
      this.bytes = bytes;
    }
    /**
     * @param {number} number
     * @returns {Int64}
     *
     * @api private
     */


    Int64.fromNumber = function (number) {
      if (number > 9223372036854775807 || number < -9223372036854775808) {
        throw new Error(number + ' is too large (or, if negative, too small) to represent as an Int64');
      }

      var bytes = new Uint8Array(8);

      for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
        bytes[i] = remaining;
      }

      if (number < 0) {
        negate(bytes);
      }

      return new Int64(bytes);
    };
    /**
     * @returns {number}
     *
     * @api private
     */


    Int64.prototype.valueOf = function () {
      var bytes = this.bytes.slice(0);
      var negative = bytes[0] & 128;

      if (negative) {
        negate(bytes);
      }

      return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
    };

    Int64.prototype.toString = function () {
      return String(this.valueOf());
    };
    /**
     * @param {Buffer} bytes
     *
     * @api private
     */


    function negate(bytes) {
      for (var i = 0; i < 8; i++) {
        bytes[i] ^= 0xFF;
      }

      for (var i = 7; i > -1; i--) {
        bytes[i]++;

        if (bytes[i] !== 0) {
          break;
        }
      }
    }
    /**
     * @api private
     */


    module.exports = {
      Int64: Int64
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/event-stream/parse-event.js":
  /*!**************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/event-stream/parse-event.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibEventStreamParseEventJs(module, exports, __webpack_require__) {
    var parseMessage = __webpack_require__(
    /*! ./parse-message */
    "./node_modules/aws-sdk/lib/event-stream/parse-message.js").parseMessage;
    /**
     *
     * @param {*} parser
     * @param {Buffer} message
     * @param {*} shape
     * @api private
     */


    function parseEvent(parser, message, shape) {
      var parsedMessage = parseMessage(message); // check if message is an event or error

      var messageType = parsedMessage.headers[':message-type'];

      if (messageType) {
        if (messageType.value === 'error') {
          throw parseError(parsedMessage);
        } else if (messageType.value !== 'event') {
          // not sure how to parse non-events/non-errors, ignore for now
          return;
        }
      } // determine event type


      var eventType = parsedMessage.headers[':event-type']; // check that the event type is modeled

      var eventModel = shape.members[eventType.value];

      if (!eventModel) {
        return;
      }

      var result = {}; // check if an event payload exists

      var eventPayloadMemberName = eventModel.eventPayloadMemberName;

      if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName]; // if the shape is binary, return the byte array

        if (payloadShape.type === 'binary') {
          result[eventPayloadMemberName] = parsedMessage.body;
        } else {
          result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
      } // read event headers


      var eventHeaderNames = eventModel.eventHeaderMemberNames;

      for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];

        if (parsedMessage.headers[name]) {
          // parse the header!
          result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
      }

      var output = {};
      output[eventType.value] = result;
      return output;
    }

    function parseError(message) {
      var errorCode = message.headers[':error-code'];
      var errorMessage = message.headers[':error-message'];
      var error = new Error(errorMessage.value || errorMessage);
      error.code = error.name = errorCode.value || errorCode;
      return error;
    }
    /**
     * @api private
     */


    module.exports = {
      parseEvent: parseEvent
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/event-stream/parse-message.js":
  /*!****************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/event-stream/parse-message.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibEventStreamParseMessageJs(module, exports, __webpack_require__) {
    var Int64 = __webpack_require__(
    /*! ./int64 */
    "./node_modules/aws-sdk/lib/event-stream/int64.js").Int64;

    var splitMessage = __webpack_require__(
    /*! ./split-message */
    "./node_modules/aws-sdk/lib/event-stream/split-message.js").splitMessage;

    var BOOLEAN_TAG = 'boolean';
    var BYTE_TAG = 'byte';
    var SHORT_TAG = 'short';
    var INT_TAG = 'integer';
    var LONG_TAG = 'long';
    var BINARY_TAG = 'binary';
    var STRING_TAG = 'string';
    var TIMESTAMP_TAG = 'timestamp';
    var UUID_TAG = 'uuid';
    /**
     * @api private
     *
     * @param {Buffer} headers
     */

    function parseHeaders(headers) {
      var out = {};
      var position = 0;

      while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;

        switch (headers.readUInt8(position++)) {
          case 0
          /* boolTrue */
          :
            out[name] = {
              type: BOOLEAN_TAG,
              value: true
            };
            break;

          case 1
          /* boolFalse */
          :
            out[name] = {
              type: BOOLEAN_TAG,
              value: false
            };
            break;

          case 2
          /* byte */
          :
            out[name] = {
              type: BYTE_TAG,
              value: headers.readInt8(position++)
            };
            break;

          case 3
          /* short */
          :
            out[name] = {
              type: SHORT_TAG,
              value: headers.readInt16BE(position)
            };
            position += 2;
            break;

          case 4
          /* integer */
          :
            out[name] = {
              type: INT_TAG,
              value: headers.readInt32BE(position)
            };
            position += 4;
            break;

          case 5
          /* long */
          :
            out[name] = {
              type: LONG_TAG,
              value: new Int64(headers.slice(position, position + 8))
            };
            position += 8;
            break;

          case 6
          /* byteArray */
          :
            var binaryLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: headers.slice(position, position + binaryLength)
            };
            position += binaryLength;
            break;

          case 7
          /* string */
          :
            var stringLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: headers.slice(position, position + stringLength).toString()
            };
            position += stringLength;
            break;

          case 8
          /* timestamp */
          :
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(new Int64(headers.slice(position, position + 8)).valueOf())
            };
            position += 8;
            break;

          case 9
          /* uuid */
          :
            var uuidChars = headers.slice(position, position + 16).toString('hex');
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value: uuidChars.substr(0, 8) + '-' + uuidChars.substr(8, 4) + '-' + uuidChars.substr(12, 4) + '-' + uuidChars.substr(16, 4) + '-' + uuidChars.substr(20)
            };
            break;

          default:
            throw new Error('Unrecognized header type tag');
        }
      }

      return out;
    }

    function parseMessage(message) {
      var parsed = splitMessage(message);
      return {
        headers: parseHeaders(parsed.headers),
        body: parsed.body
      };
    }
    /**
     * @api private
     */


    module.exports = {
      parseMessage: parseMessage
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/event-stream/split-message.js":
  /*!****************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/event-stream/split-message.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibEventStreamSplitMessageJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js").util;

    var toBuffer = util.buffer.toBuffer; // All prelude components are unsigned, 32-bit integers

    var PRELUDE_MEMBER_LENGTH = 4; // The prelude consists of two components

    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2; // Checksums are always CRC32 hashes.

    var CHECKSUM_LENGTH = 4; // Messages must include a full prelude, a prelude checksum, and a message checksum

    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
    /**
     * @api private
     *
     * @param {Buffer} message
     */

    function splitMessage(message) {
      if (!util.Buffer.isBuffer(message)) message = toBuffer(message);

      if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error('Provided message too short to accommodate event stream message overhead');
      }

      if (message.length !== message.readUInt32BE(0)) {
        throw new Error('Reported message length does not match received message length');
      }

      var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);

      if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {
        throw new Error('The prelude checksum specified in the message (' + expectedPreludeChecksum + ') does not match the calculated CRC32 checksum.');
      }

      var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);

      if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {
        throw new Error('The message checksum did not match the expected value of ' + expectedMessageChecksum);
      }

      var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
      var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);
      return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)
      };
    }
    /**
     * @api private
     */


    module.exports = {
      splitMessage: splitMessage
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/event_listeners.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/event_listeners.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibEvent_listenersJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    var SequentialExecutor = __webpack_require__(
    /*! ./sequential_executor */
    "./node_modules/aws-sdk/lib/sequential_executor.js");

    var DISCOVER_ENDPOINT = __webpack_require__(
    /*! ./discover_endpoint */
    "./node_modules/aws-sdk/lib/discover_endpoint.js").discoverEndpoint;
    /**
     * The namespace used to register global event listeners for request building
     * and sending.
     */


    AWS.EventListeners = {
      /**
       * @!attribute VALIDATE_CREDENTIALS
       *   A request listener that validates whether the request is being
       *   sent with credentials.
       *   Handles the {AWS.Request~validate 'validate' Request event}
       *   @example Sending a request without validating credentials
       *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
       *     request.removeListener('validate', listener);
       *   @readonly
       *   @return [Function]
       * @!attribute VALIDATE_REGION
       *   A request listener that validates whether the region is set
       *   for a request.
       *   Handles the {AWS.Request~validate 'validate' Request event}
       *   @example Sending a request without validating region configuration
       *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
       *     request.removeListener('validate', listener);
       *   @readonly
       *   @return [Function]
       * @!attribute VALIDATE_PARAMETERS
       *   A request listener that validates input parameters in a request.
       *   Handles the {AWS.Request~validate 'validate' Request event}
       *   @example Sending a request without validating parameters
       *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
       *     request.removeListener('validate', listener);
       *   @example Disable parameter validation globally
       *     AWS.EventListeners.Core.removeListener('validate',
       *       AWS.EventListeners.Core.VALIDATE_REGION);
       *   @readonly
       *   @return [Function]
       * @!attribute SEND
       *   A request listener that initiates the HTTP connection for a
       *   request being sent. Handles the {AWS.Request~send 'send' Request event}
       *   @example Replacing the HTTP handler
       *     var listener = AWS.EventListeners.Core.SEND;
       *     request.removeListener('send', listener);
       *     request.on('send', function(response) {
       *       customHandler.send(response);
       *     });
       *   @return [Function]
       *   @readonly
       * @!attribute HTTP_DATA
       *   A request listener that reads data from the HTTP connection in order
       *   to build the response data.
       *   Handles the {AWS.Request~httpData 'httpData' Request event}.
       *   Remove this handler if you are overriding the 'httpData' event and
       *   do not want extra data processing and buffering overhead.
       *   @example Disabling default data processing
       *     var listener = AWS.EventListeners.Core.HTTP_DATA;
       *     request.removeListener('httpData', listener);
       *   @return [Function]
       *   @readonly
       */
      Core: {}
      /* doc hack */

    };
    /**
     * @api private
     */

    function getOperationAuthtype(req) {
      if (!req.service.api.operations) {
        return '';
      }

      var operation = req.service.api.operations[req.operation];
      return operation ? operation.authtype : '';
    }

    AWS.EventListeners = {
      Core: new SequentialExecutor().addNamedListeners(function (add, addAsync) {
        addAsync('VALIDATE_CREDENTIALS', 'validate', function VALIDATE_CREDENTIALS(req, done) {
          if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none

          req.service.config.getCredentials(function (err) {
            if (err) {
              req.response.error = AWS.util.error(err, {
                code: 'CredentialsError',
                message: 'Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1'
              });
            }

            done();
          });
        });
        add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
          if (!req.service.isGlobalEndpoint) {
            var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);

            if (!req.service.config.region) {
              req.response.error = AWS.util.error(new Error(), {
                code: 'ConfigError',
                message: 'Missing region in config'
              });
            } else if (!dnsHostRegex.test(req.service.config.region)) {
              req.response.error = AWS.util.error(new Error(), {
                code: 'ConfigError',
                message: 'Invalid region in config'
              });
            }
          }
        });
        add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
          if (!req.service.api.operations) {
            return;
          }

          var operation = req.service.api.operations[req.operation];

          if (!operation) {
            return;
          }

          var idempotentMembers = operation.idempotentMembers;

          if (!idempotentMembers.length) {
            return;
          } // creates a copy of params so user's param object isn't mutated


          var params = AWS.util.copy(req.params);

          for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
            if (!params[idempotentMembers[i]]) {
              // add the member
              params[idempotentMembers[i]] = AWS.util.uuid.v4();
            }
          }

          req.params = params;
        });
        add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
          if (!req.service.api.operations) {
            return;
          }

          var rules = req.service.api.operations[req.operation].input;
          var validation = req.service.config.paramValidation;
          new AWS.ParamValidator(validation).validate(rules, req.params);
        });
        addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
          req.haltHandlersOnError();

          if (!req.service.api.operations) {
            return;
          }

          var operation = req.service.api.operations[req.operation];
          var authtype = operation ? operation.authtype : '';
          if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none

          if (req.service.getSignerClass(req) === AWS.Signers.V4) {
            var body = req.httpRequest.body || '';

            if (authtype.indexOf('unsigned-body') >= 0) {
              req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
              return done();
            }

            AWS.util.computeSha256(body, function (err, sha) {
              if (err) {
                done(err);
              } else {
                req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
                done();
              }
            });
          } else {
            done();
          }
        });
        add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
          var authtype = getOperationAuthtype(req);
          var payloadMember = AWS.util.getRequestPayloadShape(req);

          if (req.httpRequest.headers['Content-Length'] === undefined) {
            try {
              var length = AWS.util.string.byteLength(req.httpRequest.body);
              req.httpRequest.headers['Content-Length'] = length;
            } catch (err) {
              if (payloadMember && payloadMember.isStreaming) {
                if (payloadMember.requiresLength) {
                  //streaming payload requires length(s3, glacier)
                  throw err;
                } else if (authtype.indexOf('unsigned-body') >= 0) {
                  //unbounded streaming payload(lex, mediastore)
                  req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
                  return;
                } else {
                  throw err;
                }
              }

              throw err;
            }
          }
        });
        add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
          req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
        });
        add('RESTART', 'restart', function RESTART() {
          var err = this.response.error;
          if (!err || !err.retryable) return;
          this.httpRequest = new AWS.HttpRequest(this.service.endpoint, this.service.region);

          if (this.response.retryCount < this.service.config.maxRetries) {
            this.response.retryCount++;
          } else {
            this.response.error = null;
          }
        });
        var addToHead = true;
        addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);
        addAsync('SIGN', 'sign', function SIGN(req, done) {
          var service = req.service;
          var operations = req.service.api.operations || {};
          var operation = operations[req.operation];
          var authtype = operation ? operation.authtype : '';
          if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none

          service.config.getCredentials(function (err, credentials) {
            if (err) {
              req.response.error = err;
              return done();
            }

            try {
              var date = service.getSkewCorrectedDate();
              var SignerClass = service.getSignerClass(req);
              var signer = new SignerClass(req.httpRequest, service.getSigningName(), {
                signatureCache: service.config.signatureCache,
                operation: operation,
                signatureVersion: service.api.signatureVersion
              });
              signer.setServiceClientId(service._clientId); // clear old authorization headers

              delete req.httpRequest.headers['Authorization'];
              delete req.httpRequest.headers['Date'];
              delete req.httpRequest.headers['X-Amz-Date']; // add new authorization

              signer.addAuthorization(credentials, date);
              req.signedAt = date;
            } catch (e) {
              req.response.error = e;
            }

            done();
          });
        });
        add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
          if (this.service.successfulResponse(resp, this)) {
            resp.data = {};
            resp.error = null;
          } else {
            resp.data = null;
            resp.error = AWS.util.error(new Error(), {
              code: 'UnknownError',
              message: 'An unknown error occurred.'
            });
          }
        });
        addAsync('SEND', 'send', function SEND(resp, done) {
          resp.httpResponse._abortCallback = done;
          resp.error = null;
          resp.data = null;

          function callback(httpResp) {
            resp.httpResponse.stream = httpResp;
            var stream = resp.request.httpRequest.stream;
            var service = resp.request.service;
            var api = service.api;
            var operationName = resp.request.operation;
            var operation = api.operations[operationName] || {};
            httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
              resp.request.emit('httpHeaders', [statusCode, headers, resp, statusMessage]);

              if (!resp.httpResponse.streaming) {
                if (AWS.HttpClient.streamsApiVersion === 2) {
                  // streams2 API check
                  // if we detect event streams, we're going to have to
                  // return the stream immediately
                  if (operation.hasEventOutput && service.successfulResponse(resp)) {
                    // skip reading the IncomingStream
                    resp.request.emit('httpDone');
                    done();
                    return;
                  }

                  httpResp.on('readable', function onReadable() {
                    var data = httpResp.read();

                    if (data !== null) {
                      resp.request.emit('httpData', [data, resp]);
                    }
                  });
                } else {
                  // legacy streams API
                  httpResp.on('data', function onData(data) {
                    resp.request.emit('httpData', [data, resp]);
                  });
                }
              }
            });
            httpResp.on('end', function onEnd() {
              if (!stream || !stream.didCallback) {
                if (AWS.HttpClient.streamsApiVersion === 2 && operation.hasEventOutput && service.successfulResponse(resp)) {
                  // don't concatenate response chunks when streaming event stream data when response is successful
                  return;
                }

                resp.request.emit('httpDone');
                done();
              }
            });
          }

          function progress(httpResp) {
            httpResp.on('sendProgress', function onSendProgress(value) {
              resp.request.emit('httpUploadProgress', [value, resp]);
            });
            httpResp.on('receiveProgress', function onReceiveProgress(value) {
              resp.request.emit('httpDownloadProgress', [value, resp]);
            });
          }

          function error(err) {
            if (err.code !== 'RequestAbortedError') {
              var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
              err = AWS.util.error(err, {
                code: errCode,
                region: resp.request.httpRequest.region,
                hostname: resp.request.httpRequest.endpoint.hostname,
                retryable: true
              });
            }

            resp.error = err;
            resp.request.emit('httpError', [resp.error, resp], function () {
              done();
            });
          }

          function executeSend() {
            var http = AWS.HttpClient.getInstance();
            var httpOptions = resp.request.service.config.httpOptions || {};

            try {
              var stream = http.handleRequest(resp.request.httpRequest, httpOptions, callback, error);
              progress(stream);
            } catch (err) {
              error(err);
            }
          }

          var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;

          if (timeDiff >= 60 * 10) {
            // if we signed 10min ago, re-sign
            this.emit('sign', [this], function (err) {
              if (err) done(err);else executeSend();
            });
          } else {
            executeSend();
          }
        });
        add('HTTP_HEADERS', 'httpHeaders', function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
          resp.httpResponse.statusCode = statusCode;
          resp.httpResponse.statusMessage = statusMessage;
          resp.httpResponse.headers = headers;
          resp.httpResponse.body = AWS.util.buffer.toBuffer('');
          resp.httpResponse.buffers = [];
          resp.httpResponse.numBytes = 0;
          var dateHeader = headers.date || headers.Date;
          var service = resp.request.service;

          if (dateHeader) {
            var serverTime = Date.parse(dateHeader);

            if (service.config.correctClockSkew && service.isClockSkewed(serverTime)) {
              service.applyClockOffset(serverTime);
            }
          }
        });
        add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
          if (chunk) {
            if (AWS.util.isNode()) {
              resp.httpResponse.numBytes += chunk.length;
              var total = resp.httpResponse.headers['content-length'];
              var progress = {
                loaded: resp.httpResponse.numBytes,
                total: total
              };
              resp.request.emit('httpDownloadProgress', [progress, resp]);
            }

            resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));
          }
        });
        add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
          // convert buffers array into single buffer
          if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
            var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
            resp.httpResponse.body = body;
          }

          delete resp.httpResponse.numBytes;
          delete resp.httpResponse.buffers;
        });
        add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
          if (resp.httpResponse.statusCode) {
            resp.error.statusCode = resp.httpResponse.statusCode;

            if (resp.error.retryable === undefined) {
              resp.error.retryable = this.service.retryableError(resp.error, this);
            }
          }
        });
        add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
          if (!resp.error) return;

          switch (resp.error.code) {
            case 'RequestExpired': // EC2 only

            case 'ExpiredTokenException':
            case 'ExpiredToken':
              resp.error.retryable = true;
              resp.request.service.config.credentials.expired = true;
          }
        });
        add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
          var err = resp.error;
          if (!err) return;

          if (typeof err.code === 'string' && typeof err.message === 'string') {
            if (err.code.match(/Signature/) && err.message.match(/expired/)) {
              resp.error.retryable = true;
            }
          }
        });
        add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
          if (!resp.error) return;

          if (this.service.clockSkewError(resp.error) && this.service.config.correctClockSkew) {
            resp.error.retryable = true;
          }
        });
        add('REDIRECT', 'retry', function REDIRECT(resp) {
          if (resp.error && resp.error.statusCode >= 300 && resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
            this.httpRequest.endpoint = new AWS.Endpoint(resp.httpResponse.headers['location']);
            this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
            resp.error.redirect = true;
            resp.error.retryable = true;
          }
        });
        add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
          if (resp.error) {
            if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.error.retryDelay = 0;
            } else if (resp.retryCount < resp.maxRetries) {
              resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
            }
          }
        });
        addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
          var delay,
              willRetry = false;

          if (resp.error) {
            delay = resp.error.retryDelay || 0;

            if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
              resp.retryCount++;
              willRetry = true;
            } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.redirectCount++;
              willRetry = true;
            }
          } // delay < 0 is a signal from customBackoff to skip retries


          if (willRetry && delay >= 0) {
            resp.error = null;
            setTimeout(done, delay);
          } else {
            done();
          }
        });
      }),
      CorePost: new SequentialExecutor().addNamedListeners(function (add) {
        add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
        add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);
        add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
          function isDNSError(err) {
            return err.errno === 'ENOTFOUND' || typeof err.errno === 'number' && typeof AWS.util.getSystemErrorName === 'function' && ['EAI_NONAME', 'EAI_NODATA'].indexOf(AWS.util.getSystemErrorName(err.errno) >= 0);
          }

          if (err.code === 'NetworkingError' && isDNSError(err)) {
            var message = 'Inaccessible host: `' + err.hostname + '\'. This service may not be available in the `' + err.region + '\' region.';
            this.response.error = AWS.util.error(new Error(message), {
              code: 'UnknownEndpoint',
              region: err.region,
              hostname: err.hostname,
              retryable: true,
              originalError: err
            });
          }
        });
      }),
      Logger: new SequentialExecutor().addNamedListeners(function (add) {
        add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
          var req = resp.request;
          var logger = req.service.config.logger;
          if (!logger) return;

          function filterSensitiveLog(inputShape, shape) {
            if (!shape) {
              return shape;
            }

            if (inputShape.isSensitive) {
              return '***SensitiveInformation***';
            }

            switch (inputShape.type) {
              case 'structure':
                var struct = {};
                AWS.util.each(shape, function (subShapeName, subShape) {
                  if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                    struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
                  } else {
                    struct[subShapeName] = subShape;
                  }
                });
                return struct;

              case 'list':
                var list = [];
                AWS.util.arrayEach(shape, function (subShape, index) {
                  list.push(filterSensitiveLog(inputShape.member, subShape));
                });
                return list;

              case 'map':
                var map = {};
                AWS.util.each(shape, function (key, value) {
                  map[key] = filterSensitiveLog(inputShape.value, value);
                });
                return map;

              default:
                return shape;
            }
          }

          function buildMessage() {
            var time = resp.request.service.getSkewCorrectedDate().getTime();
            var delta = (time - req.startTime.getTime()) / 1000;
            var ansi = logger.isTTY ? true : false;
            var status = resp.httpResponse.statusCode;
            var censoredParams = req.params;

            if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {
              var inputShape = req.service.api.operations[req.operation].input;
              censoredParams = filterSensitiveLog(inputShape, req.params);
            }

            var params = __webpack_require__(
            /*! util */
            "./node_modules/util/util.js").inspect(censoredParams, true, null);

            var message = '';
            if (ansi) message += '\x1B[33m';
            message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
            message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
            if (ansi) message += '\x1B[0;1m';
            message += ' ' + AWS.util.string.lowerFirst(req.operation);
            message += '(' + params + ')';
            if (ansi) message += '\x1B[0m';
            return message;
          }

          var line = buildMessage();

          if (typeof logger.log === 'function') {
            logger.log(line);
          } else if (typeof logger.write === 'function') {
            logger.write(line + '\n');
          }
        });
      }),
      Json: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = __webpack_require__(
        /*! ./protocol/json */
        "./node_modules/aws-sdk/lib/protocol/json.js");

        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
      Rest: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = __webpack_require__(
        /*! ./protocol/rest */
        "./node_modules/aws-sdk/lib/protocol/rest.js");

        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
      RestJson: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = __webpack_require__(
        /*! ./protocol/rest_json */
        "./node_modules/aws-sdk/lib/protocol/rest_json.js");

        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
      RestXml: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = __webpack_require__(
        /*! ./protocol/rest_xml */
        "./node_modules/aws-sdk/lib/protocol/rest_xml.js");

        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      }),
      Query: new SequentialExecutor().addNamedListeners(function (add) {
        var svc = __webpack_require__(
        /*! ./protocol/query */
        "./node_modules/aws-sdk/lib/protocol/query.js");

        add('BUILD', 'build', svc.buildRequest);
        add('EXTRACT_DATA', 'extractData', svc.extractData);
        add('EXTRACT_ERROR', 'extractError', svc.extractError);
      })
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/http.js":
  /*!******************************************!*\
    !*** ./node_modules/aws-sdk/lib/http.js ***!
    \******************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibHttpJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;
    /**
     * The endpoint that a service will talk to, for example,
     * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
     * you need to override an endpoint for a service, you can
     * set the endpoint on a service by passing the endpoint
     * object with the `endpoint` option key:
     *
     * ```javascript
     * var ep = new AWS.Endpoint('awsproxy.example.com');
     * var s3 = new AWS.S3({endpoint: ep});
     * s3.service.endpoint.hostname == 'awsproxy.example.com'
     * ```
     *
     * Note that if you do not specify a protocol, the protocol will
     * be selected based on your current {AWS.config} configuration.
     *
     * @!attribute protocol
     *   @return [String] the protocol (http or https) of the endpoint
     *     URL
     * @!attribute hostname
     *   @return [String] the host portion of the endpoint, e.g.,
     *     example.com
     * @!attribute host
     *   @return [String] the host portion of the endpoint including
     *     the port, e.g., example.com:80
     * @!attribute port
     *   @return [Integer] the port of the endpoint
     * @!attribute href
     *   @return [String] the full URL of the endpoint
     */

    AWS.Endpoint = inherit({
      /**
       * @overload Endpoint(endpoint)
       *   Constructs a new endpoint given an endpoint URL. If the
       *   URL omits a protocol (http or https), the default protocol
       *   set in the global {AWS.config} will be used.
       *   @param endpoint [String] the URL to construct an endpoint from
       */
      constructor: function Endpoint(endpoint, config) {
        AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

        if (typeof endpoint === 'undefined' || endpoint === null) {
          throw new Error('Invalid endpoint: ' + endpoint);
        } else if (typeof endpoint !== 'string') {
          return AWS.util.copy(endpoint);
        }

        if (!endpoint.match(/^http/)) {
          var useSSL = config && config.sslEnabled !== undefined ? config.sslEnabled : AWS.config.sslEnabled;
          endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
        }

        AWS.util.update(this, AWS.util.urlParse(endpoint)); // Ensure the port property is set as an integer

        if (this.port) {
          this.port = parseInt(this.port, 10);
        } else {
          this.port = this.protocol === 'https:' ? 443 : 80;
        }
      }
    });
    /**
     * The low level HTTP request object, encapsulating all HTTP header
     * and body data sent by a service request.
     *
     * @!attribute method
     *   @return [String] the HTTP method of the request
     * @!attribute path
     *   @return [String] the path portion of the URI, e.g.,
     *     "/list/?start=5&num=10"
     * @!attribute headers
     *   @return [map<String,String>]
     *     a map of header keys and their respective values
     * @!attribute body
     *   @return [String] the request body payload
     * @!attribute endpoint
     *   @return [AWS.Endpoint] the endpoint for the request
     * @!attribute region
     *   @api private
     *   @return [String] the region, for signing purposes only.
     */

    AWS.HttpRequest = inherit({
      /**
       * @api private
       */
      constructor: function HttpRequest(endpoint, region) {
        endpoint = new AWS.Endpoint(endpoint);
        this.method = 'POST';
        this.path = endpoint.path || '/';
        this.headers = {};
        this.body = '';
        this.endpoint = endpoint;
        this.region = region;
        this._userAgent = '';
        this.setUserAgent();
      },

      /**
       * @api private
       */
      setUserAgent: function setUserAgent() {
        this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
      },
      getUserAgentHeaderName: function getUserAgentHeaderName() {
        var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
        return prefix + 'User-Agent';
      },

      /**
       * @api private
       */
      appendToUserAgent: function appendToUserAgent(agentPartial) {
        if (typeof agentPartial === 'string' && agentPartial) {
          this._userAgent += ' ' + agentPartial;
        }

        this.headers[this.getUserAgentHeaderName()] = this._userAgent;
      },

      /**
       * @api private
       */
      getUserAgent: function getUserAgent() {
        return this._userAgent;
      },

      /**
       * @return [String] the part of the {path} excluding the
       *   query string
       */
      pathname: function pathname() {
        return this.path.split('?', 1)[0];
      },

      /**
       * @return [String] the query string portion of the {path}
       */
      search: function search() {
        var query = this.path.split('?', 2)[1];

        if (query) {
          query = AWS.util.queryStringParse(query);
          return AWS.util.queryParamsToString(query);
        }

        return '';
      },

      /**
       * @api private
       * update httpRequest endpoint with endpoint string
       */
      updateEndpoint: function updateEndpoint(endpointStr) {
        var newEndpoint = new AWS.Endpoint(endpointStr);
        this.endpoint = newEndpoint;
        this.path = newEndpoint.path || '/';

        if (this.headers['Host']) {
          this.headers['Host'] = newEndpoint.host;
        }
      }
    });
    /**
     * The low level HTTP response object, encapsulating all HTTP header
     * and body data returned from the request.
     *
     * @!attribute statusCode
     *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
     * @!attribute headers
     *   @return [map<String,String>]
     *      a map of response header keys and their respective values
     * @!attribute body
     *   @return [String] the response body payload
     * @!attribute [r] streaming
     *   @return [Boolean] whether this response is being streamed at a low-level.
     *     Defaults to `false` (buffered reads). Do not modify this manually, use
     *     {createUnbufferedStream} to convert the stream to unbuffered mode
     *     instead.
     */

    AWS.HttpResponse = inherit({
      /**
       * @api private
       */
      constructor: function HttpResponse() {
        this.statusCode = undefined;
        this.headers = {};
        this.body = undefined;
        this.streaming = false;
        this.stream = null;
      },

      /**
       * Disables buffering on the HTTP response and returns the stream for reading.
       * @return [Stream, XMLHttpRequest, null] the underlying stream object.
       *   Use this object to directly read data off of the stream.
       * @note This object is only available after the {AWS.Request~httpHeaders}
       *   event has fired. This method must be called prior to
       *   {AWS.Request~httpData}.
       * @example Taking control of a stream
       *   request.on('httpHeaders', function(statusCode, headers) {
       *     if (statusCode < 300) {
       *       if (headers.etag === 'xyz') {
       *         // pipe the stream, disabling buffering
       *         var stream = this.response.httpResponse.createUnbufferedStream();
       *         stream.pipe(process.stdout);
       *       } else { // abort this request and set a better error message
       *         this.abort();
       *         this.response.error = new Error('Invalid ETag');
       *       }
       *     }
       *   }).send(console.log);
       */
      createUnbufferedStream: function createUnbufferedStream() {
        this.streaming = true;
        return this.stream;
      }
    });
    AWS.HttpClient = inherit({});
    /**
     * @api private
     */

    AWS.HttpClient.getInstance = function getInstance() {
      if (this.singleton === undefined) {
        this.singleton = new this();
      }

      return this.singleton;
    };
    /***/

  },

  /***/
  "./node_modules/aws-sdk/lib/http/xhr.js":
  /*!**********************************************!*\
    !*** ./node_modules/aws-sdk/lib/http/xhr.js ***!
    \**********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibHttpXhrJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var EventEmitter = __webpack_require__(
    /*! events */
    "./node_modules/events/events.js").EventEmitter;

    __webpack_require__(
    /*! ../http */
    "./node_modules/aws-sdk/lib/http.js");
    /**
     * @api private
     */


    AWS.XHRClient = AWS.util.inherit({
      handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
        var self = this;
        var endpoint = httpRequest.endpoint;
        var emitter = new EventEmitter();
        var href = endpoint.protocol + '//' + endpoint.hostname;

        if (endpoint.port !== 80 && endpoint.port !== 443) {
          href += ':' + endpoint.port;
        }

        href += httpRequest.path;
        var xhr = new XMLHttpRequest(),
            headersEmitted = false;
        httpRequest.stream = xhr;
        xhr.addEventListener('readystatechange', function () {
          try {
            if (xhr.status === 0) return; // 0 code is invalid
          } catch (e) {
            return;
          }

          if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
            emitter.statusCode = xhr.status;
            emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());
            emitter.emit('headers', emitter.statusCode, emitter.headers, xhr.statusText);
            headersEmitted = true;
          }

          if (this.readyState === this.DONE) {
            self.finishRequest(xhr, emitter);
          }
        }, false);
        xhr.upload.addEventListener('progress', function (evt) {
          emitter.emit('sendProgress', evt);
        });
        xhr.addEventListener('progress', function (evt) {
          emitter.emit('receiveProgress', evt);
        }, false);
        xhr.addEventListener('timeout', function () {
          errCallback(AWS.util.error(new Error('Timeout'), {
            code: 'TimeoutError'
          }));
        }, false);
        xhr.addEventListener('error', function () {
          errCallback(AWS.util.error(new Error('Network Failure'), {
            code: 'NetworkingError'
          }));
        }, false);
        xhr.addEventListener('abort', function () {
          errCallback(AWS.util.error(new Error('Request aborted'), {
            code: 'RequestAbortedError'
          }));
        }, false);
        callback(emitter);
        xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
        AWS.util.each(httpRequest.headers, function (key, value) {
          if (key !== 'Content-Length' && key !== 'User-Agent' && key !== 'Host') {
            xhr.setRequestHeader(key, value);
          }
        });

        if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
          xhr.timeout = httpOptions.timeout;
        }

        if (httpOptions.xhrWithCredentials) {
          xhr.withCredentials = true;
        }

        try {
          xhr.responseType = 'arraybuffer';
        } catch (e) {}

        try {
          if (httpRequest.body) {
            xhr.send(httpRequest.body);
          } else {
            xhr.send();
          }
        } catch (err) {
          if (httpRequest.body && typeof httpRequest.body.buffer === 'object') {
            xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly
          } else {
            throw err;
          }
        }

        return emitter;
      },
      parseHeaders: function parseHeaders(rawHeaders) {
        var headers = {};
        AWS.util.arrayEach(rawHeaders.split(/\r?\n/), function (line) {
          var key = line.split(':', 1)[0];
          var value = line.substring(key.length + 2);
          if (key.length > 0) headers[key.toLowerCase()] = value;
        });
        return headers;
      },
      finishRequest: function finishRequest(xhr, emitter) {
        var buffer;

        if (xhr.responseType === 'arraybuffer' && xhr.response) {
          var ab = xhr.response;
          buffer = new AWS.util.Buffer(ab.byteLength);
          var view = new Uint8Array(ab);

          for (var i = 0; i < buffer.length; ++i) {
            buffer[i] = view[i];
          }
        }

        try {
          if (!buffer && typeof xhr.responseText === 'string') {
            buffer = new AWS.util.Buffer(xhr.responseText);
          }
        } catch (e) {}

        if (buffer) emitter.emit('data', buffer);
        emitter.emit('end');
      }
    });
    /**
     * @api private
     */

    AWS.HttpClient.prototype = AWS.XHRClient.prototype;
    /**
     * @api private
     */

    AWS.HttpClient.streamsApiVersion = 1;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/json/builder.js":
  /*!**************************************************!*\
    !*** ./node_modules/aws-sdk/lib/json/builder.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibJsonBuilderJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    function JsonBuilder() {}

    JsonBuilder.prototype.build = function (value, shape) {
      return JSON.stringify(translate(value, shape));
    };

    function translate(value, shape) {
      if (!shape || value === undefined || value === null) return undefined;

      switch (shape.type) {
        case 'structure':
          return translateStructure(value, shape);

        case 'map':
          return translateMap(value, shape);

        case 'list':
          return translateList(value, shape);

        default:
          return translateScalar(value, shape);
      }
    }

    function translateStructure(structure, shape) {
      var struct = {};
      util.each(structure, function (name, value) {
        var memberShape = shape.members[name];

        if (memberShape) {
          if (memberShape.location !== 'body') return;
          var locationName = memberShape.isLocationName ? memberShape.name : name;
          var result = translate(value, memberShape);
          if (result !== undefined) struct[locationName] = result;
        }
      });
      return struct;
    }

    function translateList(list, shape) {
      var out = [];
      util.arrayEach(list, function (value) {
        var result = translate(value, shape.member);
        if (result !== undefined) out.push(result);
      });
      return out;
    }

    function translateMap(map, shape) {
      var out = {};
      util.each(map, function (key, value) {
        var result = translate(value, shape.value);
        if (result !== undefined) out[key] = result;
      });
      return out;
    }

    function translateScalar(value, shape) {
      return shape.toWireFormat(value);
    }
    /**
     * @api private
     */


    module.exports = JsonBuilder;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/json/parser.js":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/lib/json/parser.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibJsonParserJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    function JsonParser() {}

    JsonParser.prototype.parse = function (value, shape) {
      return translate(JSON.parse(value), shape);
    };

    function translate(value, shape) {
      if (!shape || value === undefined) return undefined;

      switch (shape.type) {
        case 'structure':
          return translateStructure(value, shape);

        case 'map':
          return translateMap(value, shape);

        case 'list':
          return translateList(value, shape);

        default:
          return translateScalar(value, shape);
      }
    }

    function translateStructure(structure, shape) {
      if (structure == null) return undefined;
      var struct = {};
      var shapeMembers = shape.members;
      util.each(shapeMembers, function (name, memberShape) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;

        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
          var value = structure[locationName];
          var result = translate(value, memberShape);
          if (result !== undefined) struct[name] = result;
        }
      });
      return struct;
    }

    function translateList(list, shape) {
      if (list == null) return undefined;
      var out = [];
      util.arrayEach(list, function (value) {
        var result = translate(value, shape.member);
        if (result === undefined) out.push(null);else out.push(result);
      });
      return out;
    }

    function translateMap(map, shape) {
      if (map == null) return undefined;
      var out = {};
      util.each(map, function (key, value) {
        var result = translate(value, shape.value);
        if (result === undefined) out[key] = null;else out[key] = result;
      });
      return out;
    }

    function translateScalar(value, shape) {
      return shape.toType(value);
    }
    /**
     * @api private
     */


    module.exports = JsonParser;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/model/api.js":
  /*!***********************************************!*\
    !*** ./node_modules/aws-sdk/lib/model/api.js ***!
    \***********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibModelApiJs(module, exports, __webpack_require__) {
    var Collection = __webpack_require__(
    /*! ./collection */
    "./node_modules/aws-sdk/lib/model/collection.js");

    var Operation = __webpack_require__(
    /*! ./operation */
    "./node_modules/aws-sdk/lib/model/operation.js");

    var Shape = __webpack_require__(
    /*! ./shape */
    "./node_modules/aws-sdk/lib/model/shape.js");

    var Paginator = __webpack_require__(
    /*! ./paginator */
    "./node_modules/aws-sdk/lib/model/paginator.js");

    var ResourceWaiter = __webpack_require__(
    /*! ./resource_waiter */
    "./node_modules/aws-sdk/lib/model/resource_waiter.js");

    var metadata = __webpack_require__(
    /*! ../../apis/metadata.json */
    "./node_modules/aws-sdk/apis/metadata.json");

    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var property = util.property;
    var memoizedProperty = util.memoizedProperty;

    function Api(api, options) {
      var self = this;
      api = api || {};
      options = options || {};
      options.api = this;
      api.metadata = api.metadata || {};
      var serviceIdentifier = options.serviceIdentifier;
      delete options.serviceIdentifier;
      property(this, 'isApi', true, false);
      property(this, 'apiVersion', api.metadata.apiVersion);
      property(this, 'endpointPrefix', api.metadata.endpointPrefix);
      property(this, 'signingName', api.metadata.signingName);
      property(this, 'globalEndpoint', api.metadata.globalEndpoint);
      property(this, 'signatureVersion', api.metadata.signatureVersion);
      property(this, 'jsonVersion', api.metadata.jsonVersion);
      property(this, 'targetPrefix', api.metadata.targetPrefix);
      property(this, 'protocol', api.metadata.protocol);
      property(this, 'timestampFormat', api.metadata.timestampFormat);
      property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
      property(this, 'abbreviation', api.metadata.serviceAbbreviation);
      property(this, 'fullName', api.metadata.serviceFullName);
      property(this, 'serviceId', api.metadata.serviceId);

      if (serviceIdentifier && metadata[serviceIdentifier]) {
        property(this, 'xmlNoDefaultLists', metadata[serviceIdentifier].xmlNoDefaultLists, false);
      }

      memoizedProperty(this, 'className', function () {
        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
        if (!name) return null;
        name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
        if (name === 'ElasticLoadBalancing') name = 'ELB';
        return name;
      });

      function addEndpointOperation(name, operation) {
        if (operation.endpointoperation === true) {
          property(self, 'endpointOperation', util.string.lowerFirst(name));
        }

        if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {
          property(self, 'hasRequiredEndpointDiscovery', operation.endpointdiscovery.required === true);
        }
      }

      property(this, 'operations', new Collection(api.operations, options, function (name, operation) {
        return new Operation(name, operation, options);
      }, util.string.lowerFirst, addEndpointOperation));
      property(this, 'shapes', new Collection(api.shapes, options, function (name, shape) {
        return Shape.create(shape, options);
      }));
      property(this, 'paginators', new Collection(api.paginators, options, function (name, paginator) {
        return new Paginator(name, paginator, options);
      }));
      property(this, 'waiters', new Collection(api.waiters, options, function (name, waiter) {
        return new ResourceWaiter(name, waiter, options);
      }, util.string.lowerFirst));

      if (options.documentation) {
        property(this, 'documentation', api.documentation);
        property(this, 'documentationUrl', api.documentationUrl);
      }
    }
    /**
     * @api private
     */


    module.exports = Api;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/model/collection.js":
  /*!******************************************************!*\
    !*** ./node_modules/aws-sdk/lib/model/collection.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibModelCollectionJs(module, exports, __webpack_require__) {
    var memoizedProperty = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js").memoizedProperty;

    function memoize(name, value, factory, nameTr) {
      memoizedProperty(this, nameTr(name), function () {
        return factory(name, value);
      });
    }

    function Collection(iterable, options, factory, nameTr, callback) {
      nameTr = nameTr || String;
      var self = this;

      for (var id in iterable) {
        if (Object.prototype.hasOwnProperty.call(iterable, id)) {
          memoize.call(self, id, iterable[id], factory, nameTr);
          if (callback) callback(id, iterable[id]);
        }
      }
    }
    /**
     * @api private
     */


    module.exports = Collection;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/model/operation.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/model/operation.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibModelOperationJs(module, exports, __webpack_require__) {
    var Shape = __webpack_require__(
    /*! ./shape */
    "./node_modules/aws-sdk/lib/model/shape.js");

    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var property = util.property;
    var memoizedProperty = util.memoizedProperty;

    function Operation(name, operation, options) {
      var self = this;
      options = options || {};
      property(this, 'name', operation.name || name);
      property(this, 'api', options.api, false);
      operation.http = operation.http || {};
      property(this, 'endpoint', operation.endpoint);
      property(this, 'httpMethod', operation.http.method || 'POST');
      property(this, 'httpPath', operation.http.requestUri || '/');
      property(this, 'authtype', operation.authtype || '');
      property(this, 'endpointDiscoveryRequired', operation.endpointdiscovery ? operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL' : 'NULL');
      memoizedProperty(this, 'input', function () {
        if (!operation.input) {
          return new Shape.create({
            type: 'structure'
          }, options);
        }

        return Shape.create(operation.input, options);
      });
      memoizedProperty(this, 'output', function () {
        if (!operation.output) {
          return new Shape.create({
            type: 'structure'
          }, options);
        }

        return Shape.create(operation.output, options);
      });
      memoizedProperty(this, 'errors', function () {
        var list = [];
        if (!operation.errors) return null;

        for (var i = 0; i < operation.errors.length; i++) {
          list.push(Shape.create(operation.errors[i], options));
        }

        return list;
      });
      memoizedProperty(this, 'paginator', function () {
        return options.api.paginators[name];
      });

      if (options.documentation) {
        property(this, 'documentation', operation.documentation);
        property(this, 'documentationUrl', operation.documentationUrl);
      } // idempotentMembers only tracks top-level input shapes


      memoizedProperty(this, 'idempotentMembers', function () {
        var idempotentMembers = [];
        var input = self.input;
        var members = input.members;

        if (!input.members) {
          return idempotentMembers;
        }

        for (var name in members) {
          if (!members.hasOwnProperty(name)) {
            continue;
          }

          if (members[name].isIdempotent === true) {
            idempotentMembers.push(name);
          }
        }

        return idempotentMembers;
      });
      memoizedProperty(this, 'hasEventOutput', function () {
        var output = self.output;
        return hasEventStream(output);
      });
    }

    function hasEventStream(topLevelShape) {
      var members = topLevelShape.members;
      var payload = topLevelShape.payload;

      if (!topLevelShape.members) {
        return false;
      }

      if (payload) {
        var payloadMember = members[payload];
        return payloadMember.isEventStream;
      } // check if any member is an event stream


      for (var name in members) {
        if (!members.hasOwnProperty(name)) {
          if (members[name].isEventStream === true) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * @api private
     */


    module.exports = Operation;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/model/paginator.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/model/paginator.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibModelPaginatorJs(module, exports, __webpack_require__) {
    var property = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js").property;

    function Paginator(name, paginator) {
      property(this, 'inputToken', paginator.input_token);
      property(this, 'limitKey', paginator.limit_key);
      property(this, 'moreResults', paginator.more_results);
      property(this, 'outputToken', paginator.output_token);
      property(this, 'resultKey', paginator.result_key);
    }
    /**
     * @api private
     */


    module.exports = Paginator;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/model/resource_waiter.js":
  /*!***********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/model/resource_waiter.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibModelResource_waiterJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var property = util.property;

    function ResourceWaiter(name, waiter, options) {
      options = options || {};
      property(this, 'name', name);
      property(this, 'api', options.api, false);

      if (waiter.operation) {
        property(this, 'operation', util.string.lowerFirst(waiter.operation));
      }

      var self = this;
      var keys = ['type', 'description', 'delay', 'maxAttempts', 'acceptors'];
      keys.forEach(function (key) {
        var value = waiter[key];

        if (value) {
          property(self, key, value);
        }
      });
    }
    /**
     * @api private
     */


    module.exports = ResourceWaiter;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/model/shape.js":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/lib/model/shape.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibModelShapeJs(module, exports, __webpack_require__) {
    var Collection = __webpack_require__(
    /*! ./collection */
    "./node_modules/aws-sdk/lib/model/collection.js");

    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    function property(obj, name, value) {
      if (value !== null && value !== undefined) {
        util.property.apply(this, arguments);
      }
    }

    function memoizedProperty(obj, name) {
      if (!obj.constructor.prototype[name]) {
        util.memoizedProperty.apply(this, arguments);
      }
    }

    function Shape(shape, options, memberName) {
      options = options || {};
      property(this, 'shape', shape.shape);
      property(this, 'api', options.api, false);
      property(this, 'type', shape.type);
      property(this, 'enum', shape["enum"]);
      property(this, 'min', shape.min);
      property(this, 'max', shape.max);
      property(this, 'pattern', shape.pattern);
      property(this, 'location', shape.location || this.location || 'body');
      property(this, 'name', this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);
      property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
      property(this, 'requiresLength', shape.requiresLength, false);
      property(this, 'isComposite', shape.isComposite || false);
      property(this, 'isShape', true, false);
      property(this, 'isQueryName', Boolean(shape.queryName), false);
      property(this, 'isLocationName', Boolean(shape.locationName), false);
      property(this, 'isIdempotent', shape.idempotencyToken === true);
      property(this, 'isJsonValue', shape.jsonvalue === true);
      property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
      property(this, 'isEventStream', Boolean(shape.eventstream), false);
      property(this, 'isEvent', Boolean(shape.event), false);
      property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
      property(this, 'isEventHeader', Boolean(shape.eventheader), false);
      property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
      property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
      property(this, 'hostLabel', Boolean(shape.hostLabel), false);

      if (options.documentation) {
        property(this, 'documentation', shape.documentation);
        property(this, 'documentationUrl', shape.documentationUrl);
      }

      if (shape.xmlAttribute) {
        property(this, 'isXmlAttribute', shape.xmlAttribute || false);
      } // type conversion and parsing


      property(this, 'defaultValue', null);

      this.toWireFormat = function (value) {
        if (value === null || value === undefined) return '';
        return value;
      };

      this.toType = function (value) {
        return value;
      };
    }
    /**
     * @api private
     */


    Shape.normalizedTypes = {
      character: 'string',
      "double": 'float',
      "long": 'integer',
      "short": 'integer',
      biginteger: 'integer',
      bigdecimal: 'float',
      blob: 'binary'
    };
    /**
     * @api private
     */

    Shape.types = {
      'structure': StructureShape,
      'list': ListShape,
      'map': MapShape,
      'boolean': BooleanShape,
      'timestamp': TimestampShape,
      'float': FloatShape,
      'integer': IntegerShape,
      'string': StringShape,
      'base64': Base64Shape,
      'binary': BinaryShape
    };

    Shape.resolve = function resolve(shape, options) {
      if (shape.shape) {
        var refShape = options.api.shapes[shape.shape];

        if (!refShape) {
          throw new Error('Cannot find shape reference: ' + shape.shape);
        }

        return refShape;
      } else {
        return null;
      }
    };

    Shape.create = function create(shape, options, memberName) {
      if (shape.isShape) return shape;
      var refShape = Shape.resolve(shape, options);

      if (refShape) {
        var filteredKeys = Object.keys(shape);

        if (!options.documentation) {
          filteredKeys = filteredKeys.filter(function (name) {
            return !name.match(/documentation/);
          });
        } // create an inline shape with extra members


        var InlineShape = function InlineShape() {
          refShape.constructor.call(this, shape, options, memberName);
        };

        InlineShape.prototype = refShape;
        return new InlineShape();
      } else {
        // set type if not set
        if (!shape.type) {
          if (shape.members) shape.type = 'structure';else if (shape.member) shape.type = 'list';else if (shape.key) shape.type = 'map';else shape.type = 'string';
        } // normalize types


        var origType = shape.type;

        if (Shape.normalizedTypes[shape.type]) {
          shape.type = Shape.normalizedTypes[shape.type];
        }

        if (Shape.types[shape.type]) {
          return new Shape.types[shape.type](shape, options, memberName);
        } else {
          throw new Error('Unrecognized shape type: ' + origType);
        }
      }
    };

    function CompositeShape(shape) {
      Shape.apply(this, arguments);
      property(this, 'isComposite', true);

      if (shape.flattened) {
        property(this, 'flattened', shape.flattened || false);
      }
    }

    function StructureShape(shape, options) {
      var self = this;
      var requiredMap = null,
          firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);

      if (firstInit) {
        property(this, 'defaultValue', function () {
          return {};
        });
        property(this, 'members', {});
        property(this, 'memberNames', []);
        property(this, 'required', []);
        property(this, 'isRequired', function () {
          return false;
        });
      }

      if (shape.members) {
        property(this, 'members', new Collection(shape.members, options, function (name, member) {
          return Shape.create(member, options, name);
        }));
        memoizedProperty(this, 'memberNames', function () {
          return shape.xmlOrder || Object.keys(shape.members);
        });

        if (shape.event) {
          memoizedProperty(this, 'eventPayloadMemberName', function () {
            var members = self.members;
            var memberNames = self.memberNames; // iterate over members to find ones that are event payloads

            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventPayload) {
                return memberNames[i];
              }
            }
          });
          memoizedProperty(this, 'eventHeaderMemberNames', function () {
            var members = self.members;
            var memberNames = self.memberNames;
            var eventHeaderMemberNames = []; // iterate over members to find ones that are event headers

            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventHeader) {
                eventHeaderMemberNames.push(memberNames[i]);
              }
            }

            return eventHeaderMemberNames;
          });
        }
      }

      if (shape.required) {
        property(this, 'required', shape.required);
        property(this, 'isRequired', function (name) {
          if (!requiredMap) {
            requiredMap = {};

            for (var i = 0; i < shape.required.length; i++) {
              requiredMap[shape.required[i]] = true;
            }
          }

          return requiredMap[name];
        }, false, true);
      }

      property(this, 'resultWrapper', shape.resultWrapper || null);

      if (shape.payload) {
        property(this, 'payload', shape.payload);
      }

      if (typeof shape.xmlNamespace === 'string') {
        property(this, 'xmlNamespaceUri', shape.xmlNamespace);
      } else if (typeof shape.xmlNamespace === 'object') {
        property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
        property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
      }
    }

    function ListShape(shape, options) {
      var self = this,
          firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);

      if (firstInit) {
        property(this, 'defaultValue', function () {
          return [];
        });
      }

      if (shape.member) {
        memoizedProperty(this, 'member', function () {
          return Shape.create(shape.member, options);
        });
      }

      if (this.flattened) {
        var oldName = this.name;
        memoizedProperty(this, 'name', function () {
          return self.member.name || oldName;
        });
      }
    }

    function MapShape(shape, options) {
      var firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);

      if (firstInit) {
        property(this, 'defaultValue', function () {
          return {};
        });
        property(this, 'key', Shape.create({
          type: 'string'
        }, options));
        property(this, 'value', Shape.create({
          type: 'string'
        }, options));
      }

      if (shape.key) {
        memoizedProperty(this, 'key', function () {
          return Shape.create(shape.key, options);
        });
      }

      if (shape.value) {
        memoizedProperty(this, 'value', function () {
          return Shape.create(shape.value, options);
        });
      }
    }

    function TimestampShape(shape) {
      var self = this;
      Shape.apply(this, arguments);

      if (shape.timestampFormat) {
        property(this, 'timestampFormat', shape.timestampFormat);
      } else if (self.isTimestampFormatSet && this.timestampFormat) {
        property(this, 'timestampFormat', this.timestampFormat);
      } else if (this.location === 'header') {
        property(this, 'timestampFormat', 'rfc822');
      } else if (this.location === 'querystring') {
        property(this, 'timestampFormat', 'iso8601');
      } else if (this.api) {
        switch (this.api.protocol) {
          case 'json':
          case 'rest-json':
            property(this, 'timestampFormat', 'unixTimestamp');
            break;

          case 'rest-xml':
          case 'query':
          case 'ec2':
            property(this, 'timestampFormat', 'iso8601');
            break;
        }
      }

      this.toType = function (value) {
        if (value === null || value === undefined) return null;
        if (typeof value.toUTCString === 'function') return value;
        return typeof value === 'string' || typeof value === 'number' ? util.date.parseTimestamp(value) : null;
      };

      this.toWireFormat = function (value) {
        return util.date.format(value, self.timestampFormat);
      };
    }

    function StringShape() {
      Shape.apply(this, arguments);
      var nullLessProtocols = ['rest-xml', 'query', 'ec2'];

      this.toType = function (value) {
        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || '' : value;

        if (this.isJsonValue) {
          return JSON.parse(value);
        }

        return value && typeof value.toString === 'function' ? value.toString() : value;
      };

      this.toWireFormat = function (value) {
        return this.isJsonValue ? JSON.stringify(value) : value;
      };
    }

    function FloatShape() {
      Shape.apply(this, arguments);

      this.toType = function (value) {
        if (value === null || value === undefined) return null;
        return parseFloat(value);
      };

      this.toWireFormat = this.toType;
    }

    function IntegerShape() {
      Shape.apply(this, arguments);

      this.toType = function (value) {
        if (value === null || value === undefined) return null;
        return parseInt(value, 10);
      };

      this.toWireFormat = this.toType;
    }

    function BinaryShape() {
      Shape.apply(this, arguments);

      this.toType = function (value) {
        var buf = util.base64.decode(value);

        if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
          /* Node.js can create a Buffer that is not isolated.
           * i.e. buf.byteLength !== buf.buffer.byteLength
           * This means that the sensitive data is accessible to anyone with access to buf.buffer.
           * If this is the node shared Buffer, then other code within this process _could_ find this secret.
           * Copy sensitive data to an isolated Buffer and zero the sensitive data.
           * While this is safe to do here, copying this code somewhere else may produce unexpected results.
           */
          var secureBuf = util.Buffer.alloc(buf.length, buf);
          buf.fill(0);
          buf = secureBuf;
        }

        return buf;
      };

      this.toWireFormat = util.base64.encode;
    }

    function Base64Shape() {
      BinaryShape.apply(this, arguments);
    }

    function BooleanShape() {
      Shape.apply(this, arguments);

      this.toType = function (value) {
        if (typeof value === 'boolean') return value;
        if (value === null || value === undefined) return null;
        return value === 'true';
      };
    }
    /**
     * @api private
     */


    Shape.shapes = {
      StructureShape: StructureShape,
      ListShape: ListShape,
      MapShape: MapShape,
      StringShape: StringShape,
      BooleanShape: BooleanShape,
      Base64Shape: Base64Shape
    };
    /**
     * @api private
     */

    module.exports = Shape;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/param_validator.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/param_validator.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibParam_validatorJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * @api private
     */


    AWS.ParamValidator = AWS.util.inherit({
      /**
       * Create a new validator object.
       *
       * @param validation [Boolean|map] whether input parameters should be
       *     validated against the operation description before sending the
       *     request. Pass a map to enable any of the following specific
       *     validation features:
       *
       *     * **min** [Boolean] &mdash; Validates that a value meets the min
       *       constraint. This is enabled by default when paramValidation is set
       *       to `true`.
       *     * **max** [Boolean] &mdash; Validates that a value meets the max
       *       constraint.
       *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
       *       regular expression.
       *     * **enum** [Boolean] &mdash; Validates that a string value matches one
       *       of the allowable enum values.
       */
      constructor: function ParamValidator(validation) {
        if (validation === true || validation === undefined) {
          validation = {
            'min': true
          };
        }

        this.validation = validation;
      },
      validate: function validate(shape, params, context) {
        this.errors = [];
        this.validateMember(shape, params || {}, context || 'params');

        if (this.errors.length > 1) {
          var msg = this.errors.join('\n* ');
          msg = 'There were ' + this.errors.length + ' validation errors:\n* ' + msg;
          throw AWS.util.error(new Error(msg), {
            code: 'MultipleValidationErrors',
            errors: this.errors
          });
        } else if (this.errors.length === 1) {
          throw this.errors[0];
        } else {
          return true;
        }
      },
      fail: function fail(code, message) {
        this.errors.push(AWS.util.error(new Error(message), {
          code: code
        }));
      },
      validateStructure: function validateStructure(shape, params, context) {
        this.validateType(params, context, ['object'], 'structure');
        var paramName;

        for (var i = 0; shape.required && i < shape.required.length; i++) {
          paramName = shape.required[i];
          var value = params[paramName];

          if (value === undefined || value === null) {
            this.fail('MissingRequiredParameter', 'Missing required key \'' + paramName + '\' in ' + context);
          }
        } // validate hash members


        for (paramName in params) {
          if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;
          var paramValue = params[paramName],
              memberShape = shape.members[paramName];

          if (memberShape !== undefined) {
            var memberContext = [context, paramName].join('.');
            this.validateMember(memberShape, paramValue, memberContext);
          } else if (paramValue !== undefined && paramValue !== null) {
            this.fail('UnexpectedParameter', 'Unexpected key \'' + paramName + '\' found in ' + context);
          }
        }

        return true;
      },
      validateMember: function validateMember(shape, param, context) {
        switch (shape.type) {
          case 'structure':
            return this.validateStructure(shape, param, context);

          case 'list':
            return this.validateList(shape, param, context);

          case 'map':
            return this.validateMap(shape, param, context);

          default:
            return this.validateScalar(shape, param, context);
        }
      },
      validateList: function validateList(shape, params, context) {
        if (this.validateType(params, context, [Array])) {
          this.validateRange(shape, params.length, context, 'list member count'); // validate array members

          for (var i = 0; i < params.length; i++) {
            this.validateMember(shape.member, params[i], context + '[' + i + ']');
          }
        }
      },
      validateMap: function validateMap(shape, params, context) {
        if (this.validateType(params, context, ['object'], 'map')) {
          // Build up a count of map members to validate range traits.
          var mapCount = 0;

          for (var param in params) {
            if (!Object.prototype.hasOwnProperty.call(params, param)) continue; // Validate any map key trait constraints

            this.validateMember(shape.key, param, context + '[key=\'' + param + '\']');
            this.validateMember(shape.value, params[param], context + '[\'' + param + '\']');
            mapCount++;
          }

          this.validateRange(shape, mapCount, context, 'map member count');
        }
      },
      validateScalar: function validateScalar(shape, value, context) {
        switch (shape.type) {
          case null:
          case undefined:
          case 'string':
            return this.validateString(shape, value, context);

          case 'base64':
          case 'binary':
            return this.validatePayload(value, context);

          case 'integer':
          case 'float':
            return this.validateNumber(shape, value, context);

          case 'boolean':
            return this.validateType(value, context, ['boolean']);

          case 'timestamp':
            return this.validateType(value, context, [Date, /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'], 'Date object, ISO-8601 string, or a UNIX timestamp');

          default:
            return this.fail('UnkownType', 'Unhandled type ' + shape.type + ' for ' + context);
        }
      },
      validateString: function validateString(shape, value, context) {
        var validTypes = ['string'];

        if (shape.isJsonValue) {
          validTypes = validTypes.concat(['number', 'object', 'boolean']);
        }

        if (value !== null && this.validateType(value, context, validTypes)) {
          this.validateEnum(shape, value, context);
          this.validateRange(shape, value.length, context, 'string length');
          this.validatePattern(shape, value, context);
          this.validateUri(shape, value, context);
        }
      },
      validateUri: function validateUri(shape, value, context) {
        if (shape['location'] === 'uri') {
          if (value.length === 0) {
            this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,' + ' but found "' + value + '" for ' + context);
          }
        }
      },
      validatePattern: function validatePattern(shape, value, context) {
        if (this.validation['pattern'] && shape['pattern'] !== undefined) {
          if (!new RegExp(shape['pattern']).test(value)) {
            this.fail('PatternMatchError', 'Provided value "' + value + '" ' + 'does not match regex pattern /' + shape['pattern'] + '/ for ' + context);
          }
        }
      },
      validateRange: function validateRange(shape, value, context, descriptor) {
        if (this.validation['min']) {
          if (shape['min'] !== undefined && value < shape['min']) {
            this.fail('MinRangeError', 'Expected ' + descriptor + ' >= ' + shape['min'] + ', but found ' + value + ' for ' + context);
          }
        }

        if (this.validation['max']) {
          if (shape['max'] !== undefined && value > shape['max']) {
            this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= ' + shape['max'] + ', but found ' + value + ' for ' + context);
          }
        }
      },
      validateEnum: function validateRange(shape, value, context) {
        if (this.validation['enum'] && shape['enum'] !== undefined) {
          // Fail if the string value is not present in the enum list
          if (shape['enum'].indexOf(value) === -1) {
            this.fail('EnumError', 'Found string value of ' + value + ', but ' + 'expected ' + shape['enum'].join('|') + ' for ' + context);
          }
        }
      },
      validateType: function validateType(value, context, acceptedTypes, type) {
        // We will not log an error for null or undefined, but we will return
        // false so that callers know that the expected type was not strictly met.
        if (value === null || value === undefined) return false;
        var foundInvalidType = false;

        for (var i = 0; i < acceptedTypes.length; i++) {
          if (typeof acceptedTypes[i] === 'string') {
            if (typeof value === acceptedTypes[i]) return true;
          } else if (acceptedTypes[i] instanceof RegExp) {
            if ((value || '').toString().match(acceptedTypes[i])) return true;
          } else {
            if (value instanceof acceptedTypes[i]) return true;
            if (AWS.util.isType(value, acceptedTypes[i])) return true;
            if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
            acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
          }

          foundInvalidType = true;
        }

        var acceptedType = type;

        if (!acceptedType) {
          acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
        }

        var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
        this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' + vowel + ' ' + acceptedType);
        return false;
      },
      validateNumber: function validateNumber(shape, value, context) {
        if (value === null || value === undefined) return;

        if (typeof value === 'string') {
          var castedValue = parseFloat(value);
          if (castedValue.toString() === value) value = castedValue;
        }

        if (this.validateType(value, context, ['number'])) {
          this.validateRange(shape, value, context, 'numeric value');
        }
      },
      validatePayload: function validatePayload(value, context) {
        if (value === null || value === undefined) return;
        if (typeof value === 'string') return;
        if (value && typeof value.byteLength === 'number') return; // typed arrays

        if (AWS.util.isNode()) {
          // special check for buffer/stream in Node.js
          var Stream = AWS.util.stream.Stream;
          if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
        } else {
          if (typeof Blob !== void 0 && value instanceof Blob) return;
        }

        var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];

        if (value) {
          for (var i = 0; i < types.length; i++) {
            if (AWS.util.isType(value, types[i])) return;
            if (AWS.util.typeName(value.constructor) === types[i]) return;
          }
        }

        this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' + 'string, Buffer, Stream, Blob, or typed array object');
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/protocol/helpers.js":
  /*!******************************************************!*\
    !*** ./node_modules/aws-sdk/lib/protocol/helpers.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibProtocolHelpersJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * Prepend prefix defined by API model to endpoint that's already
     * constructed. This feature does not apply to operations using
     * endpoint discovery and can be disabled.
     * @api private
     */


    function populateHostPrefix(request) {
      var enabled = request.service.config.hostPrefixEnabled;
      if (!enabled) return request;
      var operationModel = request.service.api.operations[request.operation]; //don't marshal host prefix when operation has endpoint discovery traits

      if (hasEndpointDiscover(request)) return request;

      if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
        var hostPrefixNotation = operationModel.endpoint.hostPrefix;
        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
        validateHostname(request.httpRequest.endpoint.hostname);
      }

      return request;
    }
    /**
     * @api private
     */


    function hasEndpointDiscover(request) {
      var api = request.service.api;
      var operationModel = api.operations[request.operation];
      var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);
      return operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true;
    }
    /**
     * @api private
     */


    function expandHostPrefix(hostPrefixNotation, params, shape) {
      util.each(shape.members, function (name, member) {
        if (member.hostLabel === true) {
          if (typeof params[name] !== 'string' || params[name] === '') {
            throw util.error(new Error(), {
              message: 'Parameter ' + name + ' should be a non-empty string.',
              code: 'InvalidParameter'
            });
          }

          var regex = new RegExp('\\{' + name + '\\}', 'g');
          hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
        }
      });
      return hostPrefixNotation;
    }
    /**
     * @api private
     */


    function prependEndpointPrefix(endpoint, prefix) {
      if (endpoint.host) {
        endpoint.host = prefix + endpoint.host;
      }

      if (endpoint.hostname) {
        endpoint.hostname = prefix + endpoint.hostname;
      }
    }
    /**
     * @api private
     */


    function validateHostname(hostname) {
      var labels = hostname.split('.'); //Reference: https://tools.ietf.org/html/rfc1123#section-2

      var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
      util.arrayEach(labels, function (label) {
        if (!label.length || label.length < 1 || label.length > 63) {
          throw util.error(new Error(), {
            code: 'ValidationError',
            message: 'Hostname label length should be between 1 to 63 characters, inclusive.'
          });
        }

        if (!hostPattern.test(label)) {
          throw AWS.util.error(new Error(), {
            code: 'ValidationError',
            message: label + ' is not hostname compatible.'
          });
        }
      });
    }

    module.exports = {
      populateHostPrefix: populateHostPrefix
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/protocol/json.js":
  /*!***************************************************!*\
    !*** ./node_modules/aws-sdk/lib/protocol/json.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibProtocolJsonJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var JsonBuilder = __webpack_require__(
    /*! ../json/builder */
    "./node_modules/aws-sdk/lib/json/builder.js");

    var JsonParser = __webpack_require__(
    /*! ../json/parser */
    "./node_modules/aws-sdk/lib/json/parser.js");

    var populateHostPrefix = __webpack_require__(
    /*! ./helpers */
    "./node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix;

    function buildRequest(req) {
      var httpRequest = req.httpRequest;
      var api = req.service.api;
      var target = api.targetPrefix + '.' + api.operations[req.operation].name;
      var version = api.jsonVersion || '1.0';
      var input = api.operations[req.operation].input;
      var builder = new JsonBuilder();
      if (version === 1) version = '1.0';
      httpRequest.body = builder.build(req.params || {}, input);
      httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
      httpRequest.headers['X-Amz-Target'] = target;
      populateHostPrefix(req);
    }

    function extractError(resp) {
      var error = {};
      var httpResponse = resp.httpResponse;
      error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';

      if (typeof error.code === 'string') {
        error.code = error.code.split(':')[0];
      }

      if (httpResponse.body.length > 0) {
        try {
          var e = JSON.parse(httpResponse.body.toString());
          var code = e.__type || e.code || e.Code;

          if (code) {
            error.code = code.split('#').pop();
          }

          if (error.code === 'RequestEntityTooLarge') {
            error.message = 'Request body must be less than 1 MB';
          } else {
            error.message = e.message || e.Message || null;
          }
        } catch (e) {
          error.statusCode = httpResponse.statusCode;
          error.message = httpResponse.statusMessage;
        }
      } else {
        error.statusCode = httpResponse.statusCode;
        error.message = httpResponse.statusCode.toString();
      }

      resp.error = util.error(new Error(), error);
    }

    function extractData(resp) {
      var body = resp.httpResponse.body.toString() || '{}';

      if (resp.request.service.config.convertResponseTypes === false) {
        resp.data = JSON.parse(body);
      } else {
        var operation = resp.request.service.api.operations[resp.request.operation];
        var shape = operation.output || {};
        var parser = new JsonParser();
        resp.data = parser.parse(body, shape);
      }
    }
    /**
     * @api private
     */


    module.exports = {
      buildRequest: buildRequest,
      extractError: extractError,
      extractData: extractData
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/protocol/query.js":
  /*!****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/protocol/query.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibProtocolQueryJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var QueryParamSerializer = __webpack_require__(
    /*! ../query/query_param_serializer */
    "./node_modules/aws-sdk/lib/query/query_param_serializer.js");

    var Shape = __webpack_require__(
    /*! ../model/shape */
    "./node_modules/aws-sdk/lib/model/shape.js");

    var populateHostPrefix = __webpack_require__(
    /*! ./helpers */
    "./node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix;

    function buildRequest(req) {
      var operation = req.service.api.operations[req.operation];
      var httpRequest = req.httpRequest;
      httpRequest.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8';
      httpRequest.params = {
        Version: req.service.api.apiVersion,
        Action: operation.name
      }; // convert the request parameters into a list of query params,
      // e.g. Deeply.NestedParam.0.Name=value

      var builder = new QueryParamSerializer();
      builder.serialize(req.params, operation.input, function (name, value) {
        httpRequest.params[name] = value;
      });
      httpRequest.body = util.queryParamsToString(httpRequest.params);
      populateHostPrefix(req);
    }

    function extractError(resp) {
      var data,
          body = resp.httpResponse.body.toString();

      if (body.match('<UnknownOperationException')) {
        data = {
          Code: 'UnknownOperation',
          Message: 'Unknown operation ' + resp.request.operation
        };
      } else {
        try {
          data = new AWS.XML.Parser().parse(body);
        } catch (e) {
          data = {
            Code: resp.httpResponse.statusCode,
            Message: resp.httpResponse.statusMessage
          };
        }
      }

      if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
      if (data.Errors) data = data.Errors;
      if (data.Error) data = data.Error;

      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }

    function extractData(resp) {
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var shape = operation.output || {};
      var origRules = shape;

      if (origRules.resultWrapper) {
        var tmp = Shape.create({
          type: 'structure'
        });
        tmp.members[origRules.resultWrapper] = shape;
        tmp.memberNames = [origRules.resultWrapper];
        util.property(shape, 'name', shape.resultWrapper);
        shape = tmp;
      }

      var parser = new AWS.XML.Parser(); // TODO: Refactor XML Parser to parse RequestId from response.

      if (shape && shape.members && !shape.members._XAMZRequestId) {
        var requestIdShape = Shape.create({
          type: 'string'
        }, {
          api: {
            protocol: 'query'
          }
        }, 'requestId');
        shape.members._XAMZRequestId = requestIdShape;
      }

      var data = parser.parse(resp.httpResponse.body.toString(), shape);
      resp.requestId = data._XAMZRequestId || data.requestId;
      if (data._XAMZRequestId) delete data._XAMZRequestId;

      if (origRules.resultWrapper) {
        if (data[origRules.resultWrapper]) {
          util.update(data, data[origRules.resultWrapper]);
          delete data[origRules.resultWrapper];
        }
      }

      resp.data = data;
    }
    /**
     * @api private
     */


    module.exports = {
      buildRequest: buildRequest,
      extractError: extractError,
      extractData: extractData
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/protocol/rest.js":
  /*!***************************************************!*\
    !*** ./node_modules/aws-sdk/lib/protocol/rest.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibProtocolRestJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var populateHostPrefix = __webpack_require__(
    /*! ./helpers */
    "./node_modules/aws-sdk/lib/protocol/helpers.js").populateHostPrefix;

    function populateMethod(req) {
      req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
    }

    function generateURI(endpointPath, operationPath, input, params) {
      var uri = [endpointPath, operationPath].join('/');
      uri = uri.replace(/\/+/g, '/');
      var queryString = {},
          queryStringSet = false;
      util.each(input.members, function (name, member) {
        var paramValue = params[name];
        if (paramValue === null || paramValue === undefined) return;

        if (member.location === 'uri') {
          var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
          uri = uri.replace(regex, function (_, plus) {
            var fn = plus ? util.uriEscapePath : util.uriEscape;
            return fn(String(paramValue));
          });
        } else if (member.location === 'querystring') {
          queryStringSet = true;

          if (member.type === 'list') {
            queryString[member.name] = paramValue.map(function (val) {
              return util.uriEscape(member.member.toWireFormat(val).toString());
            });
          } else if (member.type === 'map') {
            util.each(paramValue, function (key, value) {
              if (Array.isArray(value)) {
                queryString[key] = value.map(function (val) {
                  return util.uriEscape(String(val));
                });
              } else {
                queryString[key] = util.uriEscape(String(value));
              }
            });
          } else {
            queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
          }
        }
      });

      if (queryStringSet) {
        uri += uri.indexOf('?') >= 0 ? '&' : '?';
        var parts = [];
        util.arrayEach(Object.keys(queryString).sort(), function (key) {
          if (!Array.isArray(queryString[key])) {
            queryString[key] = [queryString[key]];
          }

          for (var i = 0; i < queryString[key].length; i++) {
            parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
          }
        });
        uri += parts.join('&');
      }

      return uri;
    }

    function populateURI(req) {
      var operation = req.service.api.operations[req.operation];
      var input = operation.input;
      var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
      req.httpRequest.path = uri;
    }

    function populateHeaders(req) {
      var operation = req.service.api.operations[req.operation];
      util.each(operation.input.members, function (name, member) {
        var value = req.params[name];
        if (value === null || value === undefined) return;

        if (member.location === 'headers' && member.type === 'map') {
          util.each(value, function (key, memberValue) {
            req.httpRequest.headers[member.name + key] = memberValue;
          });
        } else if (member.location === 'header') {
          value = member.toWireFormat(value).toString();

          if (member.isJsonValue) {
            value = util.base64.encode(value);
          }

          req.httpRequest.headers[member.name] = value;
        }
      });
    }

    function buildRequest(req) {
      populateMethod(req);
      populateURI(req);
      populateHeaders(req);
      populateHostPrefix(req);
    }

    function extractError() {}

    function extractData(resp) {
      var req = resp.request;
      var data = {};
      var r = resp.httpResponse;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output; // normalize headers names to lower-cased keys for matching

      var headers = {};
      util.each(r.headers, function (k, v) {
        headers[k.toLowerCase()] = v;
      });
      util.each(output.members, function (name, member) {
        var header = (member.name || name).toLowerCase();

        if (member.location === 'headers' && member.type === 'map') {
          data[name] = {};
          var location = member.isLocationName ? member.name : '';
          var pattern = new RegExp('^' + location + '(.+)', 'i');
          util.each(r.headers, function (k, v) {
            var result = k.match(pattern);

            if (result !== null) {
              data[name][result[1]] = v;
            }
          });
        } else if (member.location === 'header') {
          if (headers[header] !== undefined) {
            var value = member.isJsonValue ? util.base64.decode(headers[header]) : headers[header];
            data[name] = member.toType(value);
          }
        } else if (member.location === 'statusCode') {
          data[name] = parseInt(r.statusCode, 10);
        }
      });
      resp.data = data;
    }
    /**
     * @api private
     */


    module.exports = {
      buildRequest: buildRequest,
      extractError: extractError,
      extractData: extractData,
      generateURI: generateURI
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/protocol/rest_json.js":
  /*!********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/protocol/rest_json.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibProtocolRest_jsonJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var Rest = __webpack_require__(
    /*! ./rest */
    "./node_modules/aws-sdk/lib/protocol/rest.js");

    var Json = __webpack_require__(
    /*! ./json */
    "./node_modules/aws-sdk/lib/protocol/json.js");

    var JsonBuilder = __webpack_require__(
    /*! ../json/builder */
    "./node_modules/aws-sdk/lib/json/builder.js");

    var JsonParser = __webpack_require__(
    /*! ../json/parser */
    "./node_modules/aws-sdk/lib/json/parser.js");

    function populateBody(req) {
      var builder = new JsonBuilder();
      var input = req.service.api.operations[req.operation].input;

      if (input.payload) {
        var params = {};
        var payloadShape = input.members[input.payload];
        params = req.params[input.payload];
        if (params === undefined) return;

        if (payloadShape.type === 'structure') {
          req.httpRequest.body = builder.build(params, payloadShape);
          applyContentTypeHeader(req);
        } else {
          // non-JSON payload
          req.httpRequest.body = params;

          if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
            applyContentTypeHeader(req, true);
          }
        }
      } else {
        var body = builder.build(req.params, input);

        if (body !== '{}' || req.httpRequest.method !== 'GET') {
          //don't send empty body for GET method
          req.httpRequest.body = body;
        }

        applyContentTypeHeader(req);
      }
    }

    function applyContentTypeHeader(req, isBinary) {
      var operation = req.service.api.operations[req.operation];
      var input = operation.input;

      if (!req.httpRequest.headers['Content-Type']) {
        var type = isBinary ? 'binary/octet-stream' : 'application/json';
        req.httpRequest.headers['Content-Type'] = type;
      }
    }

    function buildRequest(req) {
      Rest.buildRequest(req); // never send body payload on HEAD/DELETE

      if (['HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }

    function extractError(resp) {
      Json.extractError(resp);
    }

    function extractData(resp) {
      Rest.extractData(resp);
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var rules = req.service.api.operations[req.operation].output || {};
      var parser;
      var hasEventOutput = operation.hasEventOutput;

      if (rules.payload) {
        var payloadMember = rules.members[rules.payload];
        var body = resp.httpResponse.body;

        if (payloadMember.isEventStream) {
          parser = new JsonParser();
          resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body, parser, payloadMember);
        } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
          var parser = new JsonParser();
          resp.data[rules.payload] = parser.parse(body, payloadMember);
        } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
          resp.data[rules.payload] = body;
        } else {
          resp.data[rules.payload] = payloadMember.toType(body);
        }
      } else {
        var data = resp.data;
        Json.extractData(resp);
        resp.data = util.merge(data, resp.data);
      }
    }
    /**
     * @api private
     */


    module.exports = {
      buildRequest: buildRequest,
      extractError: extractError,
      extractData: extractData
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/protocol/rest_xml.js":
  /*!*******************************************************!*\
    !*** ./node_modules/aws-sdk/lib/protocol/rest_xml.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibProtocolRest_xmlJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var Rest = __webpack_require__(
    /*! ./rest */
    "./node_modules/aws-sdk/lib/protocol/rest.js");

    function populateBody(req) {
      var input = req.service.api.operations[req.operation].input;
      var builder = new AWS.XML.Builder();
      var params = req.params;
      var payload = input.payload;

      if (payload) {
        var payloadMember = input.members[payload];
        params = params[payload];
        if (params === undefined) return;

        if (payloadMember.type === 'structure') {
          var rootElement = payloadMember.name;
          req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
        } else {
          // non-xml payload
          req.httpRequest.body = params;
        }
      } else {
        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + 'Request');
      }
    }

    function buildRequest(req) {
      Rest.buildRequest(req); // never send body payload on GET/HEAD

      if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }

    function extractError(resp) {
      Rest.extractError(resp);
      var data;

      try {
        data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
      } catch (e) {
        data = {
          Code: resp.httpResponse.statusCode,
          Message: resp.httpResponse.statusMessage
        };
      }

      if (data.Errors) data = data.Errors;
      if (data.Error) data = data.Error;

      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }

    function extractData(resp) {
      Rest.extractData(resp);
      var parser;
      var req = resp.request;
      var body = resp.httpResponse.body;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var hasEventOutput = operation.hasEventOutput;
      var payload = output.payload;

      if (payload) {
        var payloadMember = output.members[payload];

        if (payloadMember.isEventStream) {
          parser = new AWS.XML.Parser();
          resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body, parser, payloadMember);
        } else if (payloadMember.type === 'structure') {
          parser = new AWS.XML.Parser();
          resp.data[payload] = parser.parse(body.toString(), payloadMember);
        } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
          resp.data[payload] = body;
        } else {
          resp.data[payload] = payloadMember.toType(body);
        }
      } else if (body.length > 0) {
        parser = new AWS.XML.Parser();
        var data = parser.parse(body.toString(), output);
        util.update(resp.data, data);
      }
    }
    /**
     * @api private
     */


    module.exports = {
      buildRequest: buildRequest,
      extractError: extractError,
      extractData: extractData
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/query/query_param_serializer.js":
  /*!******************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/query/query_param_serializer.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibQueryQuery_param_serializerJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    function QueryParamSerializer() {}

    QueryParamSerializer.prototype.serialize = function (params, shape, fn) {
      serializeStructure('', params, shape, fn);
    };

    function ucfirst(shape) {
      if (shape.isQueryName || shape.api.protocol !== 'ec2') {
        return shape.name;
      } else {
        return shape.name[0].toUpperCase() + shape.name.substr(1);
      }
    }

    function serializeStructure(prefix, struct, rules, fn) {
      util.each(rules.members, function (name, member) {
        var value = struct[name];
        if (value === null || value === undefined) return;
        var memberName = ucfirst(member);
        memberName = prefix ? prefix + '.' + memberName : memberName;
        serializeMember(memberName, value, member, fn);
      });
    }

    function serializeMap(name, map, rules, fn) {
      var i = 1;
      util.each(map, function (key, value) {
        var prefix = rules.flattened ? '.' : '.entry.';
        var position = prefix + i++ + '.';
        var keyName = position + (rules.key.name || 'key');
        var valueName = position + (rules.value.name || 'value');
        serializeMember(name + keyName, key, rules.key, fn);
        serializeMember(name + valueName, value, rules.value, fn);
      });
    }

    function serializeList(name, list, rules, fn) {
      var memberRules = rules.member || {};

      if (list.length === 0) {
        fn.call(this, name, null);
        return;
      }

      util.arrayEach(list, function (v, n) {
        var suffix = '.' + (n + 1);

        if (rules.api.protocol === 'ec2') {
          // Do nothing for EC2
          suffix = suffix + ''; // make linter happy
        } else if (rules.flattened) {
          if (memberRules.name) {
            var parts = name.split('.');
            parts.pop();
            parts.push(ucfirst(memberRules));
            name = parts.join('.');
          }
        } else {
          suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
        }

        serializeMember(name + suffix, v, memberRules, fn);
      });
    }

    function serializeMember(name, value, rules, fn) {
      if (value === null || value === undefined) return;

      if (rules.type === 'structure') {
        serializeStructure(name, value, rules, fn);
      } else if (rules.type === 'list') {
        serializeList(name, value, rules, fn);
      } else if (rules.type === 'map') {
        serializeMap(name, value, rules, fn);
      } else {
        fn(name, rules.toWireFormat(value).toString());
      }
    }
    /**
     * @api private
     */


    module.exports = QueryParamSerializer;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/realclock/browserClock.js":
  /*!************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/realclock/browserClock.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibRealclockBrowserClockJs(module, exports) {
    module.exports = {
      //provide realtime clock for performance measurement
      now: function now() {
        if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
          return performance.now();
        }

        return Date.now();
      }
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/region_config.js":
  /*!***************************************************!*\
    !*** ./node_modules/aws-sdk/lib/region_config.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibRegion_configJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ./util */
    "./node_modules/aws-sdk/lib/util.js");

    var regionConfig = __webpack_require__(
    /*! ./region_config_data.json */
    "./node_modules/aws-sdk/lib/region_config_data.json");

    function generateRegionPrefix(region) {
      if (!region) return null;
      var parts = region.split('-');
      if (parts.length < 3) return null;
      return parts.slice(0, parts.length - 2).join('-') + '-*';
    }

    function derivedKeys(service) {
      var region = service.config.region;
      var regionPrefix = generateRegionPrefix(region);
      var endpointPrefix = service.api.endpointPrefix;
      return [[region, endpointPrefix], [regionPrefix, endpointPrefix], [region, '*'], [regionPrefix, '*'], ['*', endpointPrefix], ['*', '*']].map(function (item) {
        return item[0] && item[1] ? item.join('/') : null;
      });
    }

    function applyConfig(service, config) {
      util.each(config, function (key, value) {
        if (key === 'globalEndpoint') return;

        if (service.config[key] === undefined || service.config[key] === null) {
          service.config[key] = value;
        }
      });
    }

    function configureEndpoint(service) {
      var keys = derivedKeys(service);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!key) continue;

        if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {
          var config = regionConfig.rules[key];

          if (typeof config === 'string') {
            config = regionConfig.patterns[config];
          } // set dualstack endpoint


          if (service.config.useDualstack && util.isDualstackAvailable(service)) {
            config = util.copy(config);
            config.endpoint = config.endpoint.replace(/{service}\.({region}\.)?/, '{service}.dualstack.{region}.');
          } // set global endpoint


          service.isGlobalEndpoint = !!config.globalEndpoint;

          if (config.signingRegion) {
            service.signingRegion = config.signingRegion;
          } // signature version


          if (!config.signatureVersion) config.signatureVersion = 'v4'; // merge config

          applyConfig(service, config);
          return;
        }
      }
    }

    function getEndpointSuffix(region) {
      var regionRegexes = {
        '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
        '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
        '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
        '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
        '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov'
      };
      var defaultSuffix = 'amazonaws.com';
      var regexes = Object.keys(regionRegexes);

      for (var i = 0; i < regexes.length; i++) {
        var regionPattern = RegExp(regexes[i]);
        var dnsSuffix = regionRegexes[regexes[i]];
        if (regionPattern.test(region)) return dnsSuffix;
      }

      return defaultSuffix;
    }
    /**
     * @api private
     */


    module.exports = {
      configureEndpoint: configureEndpoint,
      getEndpointSuffix: getEndpointSuffix
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/region_config_data.json":
  /*!**********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/region_config_data.json ***!
    \**********************************************************/

  /*! exports provided: rules, patterns, default */

  /***/
  function node_modulesAwsSdkLibRegion_config_dataJson(module) {
    module.exports = JSON.parse("{\"rules\":{\"*/*\":{\"endpoint\":\"{service}.{region}.amazonaws.com\"},\"cn-*/*\":{\"endpoint\":\"{service}.{region}.amazonaws.com.cn\"},\"us-iso-*/*\":{\"endpoint\":\"{service}.{region}.c2s.ic.gov\"},\"us-isob-*/*\":{\"endpoint\":\"{service}.{region}.sc2s.sgov.gov\"},\"*/budgets\":\"globalSSL\",\"*/cloudfront\":\"globalSSL\",\"*/sts\":\"globalSSL\",\"*/importexport\":{\"endpoint\":\"{service}.amazonaws.com\",\"signatureVersion\":\"v2\",\"globalEndpoint\":true},\"*/route53\":\"globalSSL\",\"cn-*/route53\":{\"endpoint\":\"{service}.amazonaws.com.cn\",\"globalEndpoint\":true,\"signingRegion\":\"cn-northwest-1\"},\"us-gov-*/route53\":\"globalGovCloud\",\"*/waf\":\"globalSSL\",\"*/iam\":\"globalSSL\",\"cn-*/iam\":{\"endpoint\":\"{service}.cn-north-1.amazonaws.com.cn\",\"globalEndpoint\":true,\"signingRegion\":\"cn-north-1\"},\"us-gov-*/iam\":\"globalGovCloud\",\"us-gov-*/sts\":{\"endpoint\":\"{service}.{region}.amazonaws.com\"},\"us-gov-west-1/s3\":\"s3signature\",\"us-west-1/s3\":\"s3signature\",\"us-west-2/s3\":\"s3signature\",\"eu-west-1/s3\":\"s3signature\",\"ap-southeast-1/s3\":\"s3signature\",\"ap-southeast-2/s3\":\"s3signature\",\"ap-northeast-1/s3\":\"s3signature\",\"sa-east-1/s3\":\"s3signature\",\"us-east-1/s3\":{\"endpoint\":\"{service}.amazonaws.com\",\"signatureVersion\":\"s3\"},\"us-east-1/sdb\":{\"endpoint\":\"{service}.amazonaws.com\",\"signatureVersion\":\"v2\"},\"*/sdb\":{\"endpoint\":\"{service}.{region}.amazonaws.com\",\"signatureVersion\":\"v2\"}},\"patterns\":{\"globalSSL\":{\"endpoint\":\"https://{service}.amazonaws.com\",\"globalEndpoint\":true,\"signingRegion\":\"us-east-1\"},\"globalGovCloud\":{\"endpoint\":\"{service}.us-gov.amazonaws.com\",\"globalEndpoint\":true,\"signingRegion\":\"us-gov-west-1\"},\"s3signature\":{\"endpoint\":\"{service}.{region}.amazonaws.com\",\"signatureVersion\":\"s3\"}}}");
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/request.js":
  /*!*********************************************!*\
    !*** ./node_modules/aws-sdk/lib/request.js ***!
    \*********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibRequestJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    var AcceptorStateMachine = __webpack_require__(
    /*! ./state_machine */
    "./node_modules/aws-sdk/lib/state_machine.js");

    var inherit = AWS.util.inherit;
    var domain = AWS.util.domain;

    var jmespath = __webpack_require__(
    /*! jmespath */
    "./node_modules/jmespath/jmespath.js");
    /**
     * @api private
     */


    var hardErrorStates = {
      success: 1,
      error: 1,
      complete: 1
    };

    function isTerminalState(machine) {
      return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
    }

    var fsm = new AcceptorStateMachine();

    fsm.setupStates = function () {
      var transition = function transition(_, done) {
        var self = this;
        self._haltHandlersOnError = false;
        self.emit(self._asm.currentState, function (err) {
          if (err) {
            if (isTerminalState(self)) {
              if (domain && self.domain instanceof domain.Domain) {
                err.domainEmitter = self;
                err.domain = self.domain;
                err.domainThrown = false;
                self.domain.emit('error', err);
              } else {
                throw err;
              }
            } else {
              self.response.error = err;
              done(err);
            }
          } else {
            done(self.response.error);
          }
        });
      };

      this.addState('validate', 'build', 'error', transition);
      this.addState('build', 'afterBuild', 'restart', transition);
      this.addState('afterBuild', 'sign', 'restart', transition);
      this.addState('sign', 'send', 'retry', transition);
      this.addState('retry', 'afterRetry', 'afterRetry', transition);
      this.addState('afterRetry', 'sign', 'error', transition);
      this.addState('send', 'validateResponse', 'retry', transition);
      this.addState('validateResponse', 'extractData', 'extractError', transition);
      this.addState('extractError', 'extractData', 'retry', transition);
      this.addState('extractData', 'success', 'retry', transition);
      this.addState('restart', 'build', 'error', transition);
      this.addState('success', 'complete', 'complete', transition);
      this.addState('error', 'complete', 'complete', transition);
      this.addState('complete', null, null, transition);
    };

    fsm.setupStates();
    /**
     * ## Asynchronous Requests
     *
     * All requests made through the SDK are asynchronous and use a
     * callback interface. Each service method that kicks off a request
     * returns an `AWS.Request` object that you can use to register
     * callbacks.
     *
     * For example, the following service method returns the request
     * object as "request", which can be used to register callbacks:
     *
     * ```javascript
     * // request is an AWS.Request object
     * var request = ec2.describeInstances();
     *
     * // register callbacks on request to retrieve response data
     * request.on('success', function(response) {
     *   console.log(response.data);
     * });
     * ```
     *
     * When a request is ready to be sent, the {send} method should
     * be called:
     *
     * ```javascript
     * request.send();
     * ```
     *
     * Since registered callbacks may or may not be idempotent, requests should only
     * be sent once. To perform the same operation multiple times, you will need to
     * create multiple request objects, each with its own registered callbacks.
     *
     * ## Removing Default Listeners for Events
     *
     * Request objects are built with default listeners for the various events,
     * depending on the service type. In some cases, you may want to remove
     * some built-in listeners to customize behaviour. Doing this requires
     * access to the built-in listener functions, which are exposed through
     * the {AWS.EventListeners.Core} namespace. For instance, you may
     * want to customize the HTTP handler used when sending a request. In this
     * case, you can remove the built-in listener associated with the 'send'
     * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
     *
     * ## Multiple Callbacks and Chaining
     *
     * You can register multiple callbacks on any request object. The
     * callbacks can be registered for different events, or all for the
     * same event. In addition, you can chain callback registration, for
     * example:
     *
     * ```javascript
     * request.
     *   on('success', function(response) {
     *     console.log("Success!");
     *   }).
     *   on('error', function(error, response) {
     *     console.log("Error!");
     *   }).
     *   on('complete', function(response) {
     *     console.log("Always!");
     *   }).
     *   send();
     * ```
     *
     * The above example will print either "Success! Always!", or "Error! Always!",
     * depending on whether the request succeeded or not.
     *
     * @!attribute httpRequest
     *   @readonly
     *   @!group HTTP Properties
     *   @return [AWS.HttpRequest] the raw HTTP request object
     *     containing request headers and body information
     *     sent by the service.
     *
     * @!attribute startTime
     *   @readonly
     *   @!group Operation Properties
     *   @return [Date] the time that the request started
     *
     * @!group Request Building Events
     *
     * @!event validate(request)
     *   Triggered when a request is being validated. Listeners
     *   should throw an error if the request should not be sent.
     *   @param request [Request] the request object being sent
     *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
     *   @see AWS.EventListeners.Core.VALIDATE_REGION
     *   @example Ensuring that a certain parameter is set before sending a request
     *     var req = s3.putObject(params);
     *     req.on('validate', function() {
     *       if (!req.params.Body.match(/^Hello\s/)) {
     *         throw new Error('Body must start with "Hello "');
     *       }
     *     });
     *     req.send(function(err, data) { ... });
     *
     * @!event build(request)
     *   Triggered when the request payload is being built. Listeners
     *   should fill the necessary information to send the request
     *   over HTTP.
     *   @param (see AWS.Request~validate)
     *   @example Add a custom HTTP header to a request
     *     var req = s3.putObject(params);
     *     req.on('build', function() {
     *       req.httpRequest.headers['Custom-Header'] = 'value';
     *     });
     *     req.send(function(err, data) { ... });
     *
     * @!event sign(request)
     *   Triggered when the request is being signed. Listeners should
     *   add the correct authentication headers and/or adjust the body,
     *   depending on the authentication mechanism being used.
     *   @param (see AWS.Request~validate)
     *
     * @!group Request Sending Events
     *
     * @!event send(response)
     *   Triggered when the request is ready to be sent. Listeners
     *   should call the underlying transport layer to initiate
     *   the sending of the request.
     *   @param response [Response] the response object
     *   @context [Request] the request object that was sent
     *   @see AWS.EventListeners.Core.SEND
     *
     * @!event retry(response)
     *   Triggered when a request failed and might need to be retried or redirected.
     *   If the response is retryable, the listener should set the
     *   `response.error.retryable` property to `true`, and optionally set
     *   `response.error.retryDelay` to the millisecond delay for the next attempt.
     *   In the case of a redirect, `response.error.redirect` should be set to
     *   `true` with `retryDelay` set to an optional delay on the next request.
     *
     *   If a listener decides that a request should not be retried,
     *   it should set both `retryable` and `redirect` to false.
     *
     *   Note that a retryable error will be retried at most
     *   {AWS.Config.maxRetries} times (based on the service object's config).
     *   Similarly, a request that is redirected will only redirect at most
     *   {AWS.Config.maxRedirects} times.
     *
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *   @example Adding a custom retry for a 404 response
     *     request.on('retry', function(response) {
     *       // this resource is not yet available, wait 10 seconds to get it again
     *       if (response.httpResponse.statusCode === 404 && response.error) {
     *         response.error.retryable = true;   // retry this error
     *         response.error.retryDelay = 10000; // wait 10 seconds
     *       }
     *     });
     *
     * @!group Data Parsing Events
     *
     * @!event extractError(response)
     *   Triggered on all non-2xx requests so that listeners can extract
     *   error details from the response body. Listeners to this event
     *   should set the `response.error` property.
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *
     * @!event extractData(response)
     *   Triggered in successful requests to allow listeners to
     *   de-serialize the response body into `response.data`.
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *
     * @!group Completion Events
     *
     * @!event success(response)
     *   Triggered when the request completed successfully.
     *   `response.data` will contain the response data and
     *   `response.error` will be null.
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *
     * @!event error(error, response)
     *   Triggered when an error occurs at any point during the
     *   request. `response.error` will contain details about the error
     *   that occurred. `response.data` will be null.
     *   @param error [Error] the error object containing details about
     *     the error that occurred.
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *
     * @!event complete(response)
     *   Triggered whenever a request cycle completes. `response.error`
     *   should be checked, since the request may have failed.
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *
     * @!group HTTP Events
     *
     * @!event httpHeaders(statusCode, headers, response, statusMessage)
     *   Triggered when headers are sent by the remote server
     *   @param statusCode [Integer] the HTTP response code
     *   @param headers [map<String,String>] the response headers
     *   @param (see AWS.Request~send)
     *   @param statusMessage [String] A status message corresponding to the HTTP
     *                                 response code
     *   @context (see AWS.Request~send)
     *
     * @!event httpData(chunk, response)
     *   Triggered when data is sent by the remote server
     *   @param chunk [Buffer] the buffer data containing the next data chunk
     *     from the server
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *   @see AWS.EventListeners.Core.HTTP_DATA
     *
     * @!event httpUploadProgress(progress, response)
     *   Triggered when the HTTP request has uploaded more data
     *   @param progress [map] An object containing the `loaded` and `total` bytes
     *     of the request.
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *   @note This event will not be emitted in Node.js 0.8.x.
     *
     * @!event httpDownloadProgress(progress, response)
     *   Triggered when the HTTP request has downloaded more data
     *   @param progress [map] An object containing the `loaded` and `total` bytes
     *     of the request.
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *   @note This event will not be emitted in Node.js 0.8.x.
     *
     * @!event httpError(error, response)
     *   Triggered when the HTTP request failed
     *   @param error [Error] the error object that was thrown
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *
     * @!event httpDone(response)
     *   Triggered when the server is finished sending data
     *   @param (see AWS.Request~send)
     *   @context (see AWS.Request~send)
     *
     * @see AWS.Response
     */

    AWS.Request = inherit({
      /**
       * Creates a request for an operation on a given service with
       * a set of input parameters.
       *
       * @param service [AWS.Service] the service to perform the operation on
       * @param operation [String] the operation to perform on the service
       * @param params [Object] parameters to send to the operation.
       *   See the operation's documentation for the format of the
       *   parameters.
       */
      constructor: function Request(service, operation, params) {
        var endpoint = service.endpoint;
        var region = service.config.region;
        var customUserAgent = service.config.customUserAgent;

        if (service.isGlobalEndpoint) {
          if (service.signingRegion) {
            region = service.signingRegion;
          } else {
            region = 'us-east-1';
          }
        }

        this.domain = domain && domain.active;
        this.service = service;
        this.operation = operation;
        this.params = params || {};
        this.httpRequest = new AWS.HttpRequest(endpoint, region);
        this.httpRequest.appendToUserAgent(customUserAgent);
        this.startTime = service.getSkewCorrectedDate();
        this.response = new AWS.Response(this);
        this._asm = new AcceptorStateMachine(fsm.states, 'validate');
        this._haltHandlersOnError = false;
        AWS.SequentialExecutor.call(this);
        this.emit = this.emitEvent;
      },

      /**
       * @!group Sending a Request
       */

      /**
       * @overload send(callback = null)
       *   Sends the request object.
       *
       *   @callback callback function(err, data)
       *     If a callback is supplied, it is called when a response is returned
       *     from the service.
       *     @context [AWS.Request] the request object being sent.
       *     @param err [Error] the error object returned from the request.
       *       Set to `null` if the request is successful.
       *     @param data [Object] the de-serialized data returned from
       *       the request. Set to `null` if a request error occurs.
       *   @example Sending a request with a callback
       *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
       *     request.send(function(err, data) { console.log(err, data); });
       *   @example Sending a request with no callback (using event handlers)
       *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
       *     request.on('complete', function(response) { ... }); // register a callback
       *     request.send();
       */
      send: function send(callback) {
        if (callback) {
          // append to user agent
          this.httpRequest.appendToUserAgent('callback');
          this.on('complete', function (resp) {
            callback.call(resp, resp.error, resp.data);
          });
        }

        this.runTo();
        return this.response;
      },

      /**
       * @!method  promise()
       *   Sends the request and returns a 'thenable' promise.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function(data)
       *     Called if the promise is fulfilled.
       *     @param data [Object] the de-serialized data returned from the request.
       *   @callback rejectedCallback function(error)
       *     Called if the promise is rejected.
       *     @param error [Error] the error object returned from the request.
       *   @return [Promise] A promise that represents the state of the request.
       *   @example Sending a request using promises.
       *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
       *     var result = request.promise();
       *     result.then(function(data) { ... }, function(error) { ... });
       */

      /**
       * @api private
       */
      build: function build(callback) {
        return this.runTo('send', callback);
      },

      /**
       * @api private
       */
      runTo: function runTo(state, done) {
        this._asm.runTo(state, done, this);

        return this;
      },

      /**
       * Aborts a request, emitting the error and complete events.
       *
       * @!macro nobrowser
       * @example Aborting a request after sending
       *   var params = {
       *     Bucket: 'bucket', Key: 'key',
       *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
       *   };
       *   var request = s3.putObject(params);
       *   request.send(function (err, data) {
       *     if (err) console.log("Error:", err.code, err.message);
       *     else console.log(data);
       *   });
       *
       *   // abort request in 1 second
       *   setTimeout(request.abort.bind(request), 1000);
       *
       *   // prints "Error: RequestAbortedError Request aborted by user"
       * @return [AWS.Request] the same request object, for chaining.
       * @since v1.4.0
       */
      abort: function abort() {
        this.removeAllListeners('validateResponse');
        this.removeAllListeners('extractError');
        this.on('validateResponse', function addAbortedError(resp) {
          resp.error = AWS.util.error(new Error('Request aborted by user'), {
            code: 'RequestAbortedError',
            retryable: false
          });
        });

        if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {
          // abort HTTP stream
          this.httpRequest.stream.abort();

          if (this.httpRequest._abortCallback) {
            this.httpRequest._abortCallback();
          } else {
            this.removeAllListeners('send'); // haven't sent yet, so let's not
          }
        }

        return this;
      },

      /**
       * Iterates over each page of results given a pageable request, calling
       * the provided callback with each page of data. After all pages have been
       * retrieved, the callback is called with `null` data.
       *
       * @note This operation can generate multiple requests to a service.
       * @example Iterating over multiple pages of objects in an S3 bucket
       *   var pages = 1;
       *   s3.listObjects().eachPage(function(err, data) {
       *     if (err) return;
       *     console.log("Page", pages++);
       *     console.log(data);
       *   });
       * @example Iterating over multiple pages with an asynchronous callback
       *   s3.listObjects(params).eachPage(function(err, data, done) {
       *     doSomethingAsyncAndOrExpensive(function() {
       *       // The next page of results isn't fetched until done is called
       *       done();
       *     });
       *   });
       * @callback callback function(err, data, [doneCallback])
       *   Called with each page of resulting data from the request. If the
       *   optional `doneCallback` is provided in the function, it must be called
       *   when the callback is complete.
       *
       *   @param err [Error] an error object, if an error occurred.
       *   @param data [Object] a single page of response data. If there is no
       *     more data, this object will be `null`.
       *   @param doneCallback [Function] an optional done callback. If this
       *     argument is defined in the function declaration, it should be called
       *     when the next page is ready to be retrieved. This is useful for
       *     controlling serial pagination across asynchronous operations.
       *   @return [Boolean] if the callback returns `false`, pagination will
       *     stop.
       *
       * @see AWS.Request.eachItem
       * @see AWS.Response.nextPage
       * @since v1.4.0
       */
      eachPage: function eachPage(callback) {
        // Make all callbacks async-ish
        callback = AWS.util.fn.makeAsync(callback, 3);

        function wrappedCallback(response) {
          callback.call(response, response.error, response.data, function (result) {
            if (result === false) return;

            if (response.hasNextPage()) {
              response.nextPage().on('complete', wrappedCallback).send();
            } else {
              callback.call(response, null, null, AWS.util.fn.noop);
            }
          });
        }

        this.on('complete', wrappedCallback).send();
      },

      /**
       * Enumerates over individual items of a request, paging the responses if
       * necessary.
       *
       * @api experimental
       * @since v1.4.0
       */
      eachItem: function eachItem(callback) {
        var self = this;

        function wrappedCallback(err, data) {
          if (err) return callback(err, null);
          if (data === null) return callback(null, null);
          var config = self.service.paginationConfig(self.operation);
          var resultKey = config.resultKey;
          if (Array.isArray(resultKey)) resultKey = resultKey[0];
          var items = jmespath.search(data, resultKey);
          var continueIteration = true;
          AWS.util.arrayEach(items, function (item) {
            continueIteration = callback(null, item);

            if (continueIteration === false) {
              return AWS.util.abort;
            }
          });
          return continueIteration;
        }

        this.eachPage(wrappedCallback);
      },

      /**
       * @return [Boolean] whether the operation can return multiple pages of
       *   response data.
       * @see AWS.Response.eachPage
       * @since v1.4.0
       */
      isPageable: function isPageable() {
        return this.service.paginationConfig(this.operation) ? true : false;
      },

      /**
       * Sends the request and converts the request object into a readable stream
       * that can be read from or piped into a writable stream.
       *
       * @note The data read from a readable stream contains only
       *   the raw HTTP body contents.
       * @example Manually reading from a stream
       *   request.createReadStream().on('data', function(data) {
       *     console.log("Got data:", data.toString());
       *   });
       * @example Piping a request body into a file
       *   var out = fs.createWriteStream('/path/to/outfile.jpg');
       *   s3.service.getObject(params).createReadStream().pipe(out);
       * @return [Stream] the readable stream object that can be piped
       *   or read from (by registering 'data' event listeners).
       * @!macro nobrowser
       */
      createReadStream: function createReadStream() {
        var streams = AWS.util.stream;
        var req = this;
        var stream = null;

        if (AWS.HttpClient.streamsApiVersion === 2) {
          stream = new streams.PassThrough();
          process.nextTick(function () {
            req.send();
          });
        } else {
          stream = new streams.Stream();
          stream.readable = true;
          stream.sent = false;
          stream.on('newListener', function (event) {
            if (!stream.sent && event === 'data') {
              stream.sent = true;
              process.nextTick(function () {
                req.send();
              });
            }
          });
        }

        this.on('error', function (err) {
          stream.emit('error', err);
        });
        this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
          if (statusCode < 300) {
            req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
            req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
            req.on('httpError', function streamHttpError(error) {
              resp.error = error;
              resp.error.retryable = false;
            });
            var shouldCheckContentLength = false;
            var expectedLen;

            if (req.httpRequest.method !== 'HEAD') {
              expectedLen = parseInt(headers['content-length'], 10);
            }

            if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
              shouldCheckContentLength = true;
              var receivedLen = 0;
            }

            var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
              if (shouldCheckContentLength && receivedLen !== expectedLen) {
                stream.emit('error', AWS.util.error(new Error('Stream content length mismatch. Received ' + receivedLen + ' of ' + expectedLen + ' bytes.'), {
                  code: 'StreamContentLengthMismatch'
                }));
              } else if (AWS.HttpClient.streamsApiVersion === 2) {
                stream.end();
              } else {
                stream.emit('end');
              }
            };

            var httpStream = resp.httpResponse.createUnbufferedStream();

            if (AWS.HttpClient.streamsApiVersion === 2) {
              if (shouldCheckContentLength) {
                var lengthAccumulator = new streams.PassThrough();

                lengthAccumulator._write = function (chunk) {
                  if (chunk && chunk.length) {
                    receivedLen += chunk.length;
                  }

                  return streams.PassThrough.prototype._write.apply(this, arguments);
                };

                lengthAccumulator.on('end', checkContentLengthAndEmit);
                stream.on('error', function (err) {
                  shouldCheckContentLength = false;
                  httpStream.unpipe(lengthAccumulator);
                  lengthAccumulator.emit('end');
                  lengthAccumulator.end();
                });
                httpStream.pipe(lengthAccumulator).pipe(stream, {
                  end: false
                });
              } else {
                httpStream.pipe(stream);
              }
            } else {
              if (shouldCheckContentLength) {
                httpStream.on('data', function (arg) {
                  if (arg && arg.length) {
                    receivedLen += arg.length;
                  }
                });
              }

              httpStream.on('data', function (arg) {
                stream.emit('data', arg);
              });
              httpStream.on('end', checkContentLengthAndEmit);
            }

            httpStream.on('error', function (err) {
              shouldCheckContentLength = false;
              stream.emit('error', err);
            });
          }
        });
        return stream;
      },

      /**
       * @param [Array,Response] args This should be the response object,
       *   or an array of args to send to the event.
       * @api private
       */
      emitEvent: function emit(eventName, args, done) {
        if (typeof args === 'function') {
          done = args;
          args = null;
        }

        if (!done) done = function done() {};
        if (!args) args = this.eventParameters(eventName, this.response);
        var origEmit = AWS.SequentialExecutor.prototype.emit;
        origEmit.call(this, eventName, args, function (err) {
          if (err) this.response.error = err;
          done.call(this, err);
        });
      },

      /**
       * @api private
       */
      eventParameters: function eventParameters(eventName) {
        switch (eventName) {
          case 'restart':
          case 'validate':
          case 'sign':
          case 'build':
          case 'afterValidate':
          case 'afterBuild':
            return [this];

          case 'error':
            return [this.response.error, this.response];

          default:
            return [this.response];
        }
      },

      /**
       * @api private
       */
      presign: function presign(expires, callback) {
        if (!callback && typeof expires === 'function') {
          callback = expires;
          expires = null;
        }

        return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
      },

      /**
       * @api private
       */
      isPresigned: function isPresigned() {
        return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
      },

      /**
       * @api private
       */
      toUnauthenticated: function toUnauthenticated() {
        this._unAuthenticated = true;
        this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
        this.removeListener('sign', AWS.EventListeners.Core.SIGN);
        return this;
      },

      /**
       * @api private
       */
      toGet: function toGet() {
        if (this.service.api.protocol === 'query' || this.service.api.protocol === 'ec2') {
          this.removeListener('build', this.buildAsGet);
          this.addListener('build', this.buildAsGet);
        }

        return this;
      },

      /**
       * @api private
       */
      buildAsGet: function buildAsGet(request) {
        request.httpRequest.method = 'GET';
        request.httpRequest.path = request.service.endpoint.path + '?' + request.httpRequest.body;
        request.httpRequest.body = ''; // don't need these headers on a GET request

        delete request.httpRequest.headers['Content-Length'];
        delete request.httpRequest.headers['Content-Type'];
      },

      /**
       * @api private
       */
      haltHandlersOnError: function haltHandlersOnError() {
        this._haltHandlersOnError = true;
      }
    });
    /**
     * @api private
     */

    AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = function promise() {
        var self = this; // append to user agent

        this.httpRequest.appendToUserAgent('promise');
        return new PromiseDependency(function (resolve, reject) {
          self.on('complete', function (resp) {
            if (resp.error) {
              reject(resp.error);
            } else {
              // define $response property so that it is not enumerable
              // this prevents circular reference errors when stringifying the JSON object
              resolve(Object.defineProperty(resp.data || {}, '$response', {
                value: resp
              }));
            }
          });
          self.runTo();
        });
      };
    };
    /**
     * @api private
     */


    AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.promise;
    };

    AWS.util.addPromises(AWS.Request);
    AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/resource_waiter.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/resource_waiter.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibResource_waiterJs(module, exports, __webpack_require__) {
    /**
     * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License"). You
     * may not use this file except in compliance with the License. A copy of
     * the License is located at
     *
     *     http://aws.amazon.com/apache2.0/
     *
     * or in the "license" file accompanying this file. This file is
     * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
     * ANY KIND, either express or implied. See the License for the specific
     * language governing permissions and limitations under the License.
     */
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;

    var jmespath = __webpack_require__(
    /*! jmespath */
    "./node_modules/jmespath/jmespath.js");
    /**
     * @api private
     */


    function CHECK_ACCEPTORS(resp) {
      var waiter = resp.request._waiter;
      var acceptors = waiter.config.acceptors;
      var acceptorMatched = false;
      var state = 'retry';
      acceptors.forEach(function (acceptor) {
        if (!acceptorMatched) {
          var matcher = waiter.matchers[acceptor.matcher];

          if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
            acceptorMatched = true;
            state = acceptor.state;
          }
        }
      });
      if (!acceptorMatched && resp.error) state = 'failure';

      if (state === 'success') {
        waiter.setSuccess(resp);
      } else {
        waiter.setError(resp, state === 'retry');
      }
    }
    /**
     * @api private
     */


    AWS.ResourceWaiter = inherit({
      /**
       * Waits for a given state on a service object
       * @param service [Service] the service object to wait on
       * @param state [String] the state (defined in waiter configuration) to wait
       *   for.
       * @example Create a waiter for running EC2 instances
       *   var ec2 = new AWS.EC2;
       *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
       */
      constructor: function constructor(service, state) {
        this.service = service;
        this.state = state;
        this.loadWaiterConfig(this.state);
      },
      service: null,
      state: null,
      config: null,
      matchers: {
        path: function path(resp, expected, argument) {
          try {
            var result = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }

          return jmespath.strictDeepEqual(result, expected);
        },
        pathAll: function pathAll(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }

          if (!Array.isArray(results)) results = [results];
          var numResults = results.length;
          if (!numResults) return false;

          for (var ind = 0; ind < numResults; ind++) {
            if (!jmespath.strictDeepEqual(results[ind], expected)) {
              return false;
            }
          }

          return true;
        },
        pathAny: function pathAny(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }

          if (!Array.isArray(results)) results = [results];
          var numResults = results.length;

          for (var ind = 0; ind < numResults; ind++) {
            if (jmespath.strictDeepEqual(results[ind], expected)) {
              return true;
            }
          }

          return false;
        },
        status: function status(resp, expected) {
          var statusCode = resp.httpResponse.statusCode;
          return typeof statusCode === 'number' && statusCode === expected;
        },
        error: function error(resp, expected) {
          if (typeof expected === 'string' && resp.error) {
            return expected === resp.error.code;
          } // if expected is not string, can be boolean indicating presence of error


          return expected === !!resp.error;
        }
      },
      listeners: new AWS.SequentialExecutor().addNamedListeners(function (add) {
        add('RETRY_CHECK', 'retry', function (resp) {
          var waiter = resp.request._waiter;

          if (resp.error && resp.error.code === 'ResourceNotReady') {
            resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
          }
        });
        add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);
        add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
      }),

      /**
       * @return [AWS.Request]
       */
      wait: function wait(params, callback) {
        if (typeof params === 'function') {
          callback = params;
          params = undefined;
        }

        if (params && params.$waiter) {
          params = AWS.util.copy(params);

          if (typeof params.$waiter.delay === 'number') {
            this.config.delay = params.$waiter.delay;
          }

          if (typeof params.$waiter.maxAttempts === 'number') {
            this.config.maxAttempts = params.$waiter.maxAttempts;
          }

          delete params.$waiter;
        }

        var request = this.service.makeRequest(this.config.operation, params);
        request._waiter = this;
        request.response.maxRetries = this.config.maxAttempts;
        request.addListeners(this.listeners);
        if (callback) request.send(callback);
        return request;
      },
      setSuccess: function setSuccess(resp) {
        resp.error = null;
        resp.data = resp.data || {};
        resp.request.removeAllListeners('extractData');
      },
      setError: function setError(resp, retryable) {
        resp.data = null;
        resp.error = AWS.util.error(resp.error || new Error(), {
          code: 'ResourceNotReady',
          message: 'Resource is not in the state ' + this.state,
          retryable: retryable
        });
      },

      /**
       * Loads waiter configuration from API configuration
       *
       * @api private
       */
      loadWaiterConfig: function loadWaiterConfig(state) {
        if (!this.service.api.waiters[state]) {
          throw new AWS.util.error(new Error(), {
            code: 'StateNotFoundError',
            message: 'State ' + state + ' not found.'
          });
        }

        this.config = AWS.util.copy(this.service.api.waiters[state]);
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/response.js":
  /*!**********************************************!*\
    !*** ./node_modules/aws-sdk/lib/response.js ***!
    \**********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibResponseJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;

    var jmespath = __webpack_require__(
    /*! jmespath */
    "./node_modules/jmespath/jmespath.js");
    /**
     * This class encapsulates the response information
     * from a service request operation sent through {AWS.Request}.
     * The response object has two main properties for getting information
     * back from a request:
     *
     * ## The `data` property
     *
     * The `response.data` property contains the serialized object data
     * retrieved from the service request. For instance, for an
     * Amazon DynamoDB `listTables` method call, the response data might
     * look like:
     *
     * ```
     * > resp.data
     * { TableNames:
     *    [ 'table1', 'table2', ... ] }
     * ```
     *
     * The `data` property can be null if an error occurs (see below).
     *
     * ## The `error` property
     *
     * In the event of a service error (or transfer error), the
     * `response.error` property will be filled with the given
     * error data in the form:
     *
     * ```
     * { code: 'SHORT_UNIQUE_ERROR_CODE',
     *   message: 'Some human readable error message' }
     * ```
     *
     * In the case of an error, the `data` property will be `null`.
     * Note that if you handle events that can be in a failure state,
     * you should always check whether `response.error` is set
     * before attempting to access the `response.data` property.
     *
     * @!attribute data
     *   @readonly
     *   @!group Data Properties
     *   @note Inside of a {AWS.Request~httpData} event, this
     *     property contains a single raw packet instead of the
     *     full de-serialized service response.
     *   @return [Object] the de-serialized response data
     *     from the service.
     *
     * @!attribute error
     *   An structure containing information about a service
     *   or networking error.
     *   @readonly
     *   @!group Data Properties
     *   @note This attribute is only filled if a service or
     *     networking error occurs.
     *   @return [Error]
     *     * code [String] a unique short code representing the
     *       error that was emitted.
     *     * message [String] a longer human readable error message
     *     * retryable [Boolean] whether the error message is
     *       retryable.
     *     * statusCode [Numeric] in the case of a request that reached the service,
     *       this value contains the response status code.
     *     * time [Date] the date time object when the error occurred.
     *     * hostname [String] set when a networking error occurs to easily
     *       identify the endpoint of the request.
     *     * region [String] set when a networking error occurs to easily
     *       identify the region of the request.
     *
     * @!attribute requestId
     *   @readonly
     *   @!group Data Properties
     *   @return [String] the unique request ID associated with the response.
     *     Log this value when debugging requests for AWS support.
     *
     * @!attribute retryCount
     *   @readonly
     *   @!group Operation Properties
     *   @return [Integer] the number of retries that were
     *     attempted before the request was completed.
     *
     * @!attribute redirectCount
     *   @readonly
     *   @!group Operation Properties
     *   @return [Integer] the number of redirects that were
     *     followed before the request was completed.
     *
     * @!attribute httpResponse
     *   @readonly
     *   @!group HTTP Properties
     *   @return [AWS.HttpResponse] the raw HTTP response object
     *     containing the response headers and body information
     *     from the server.
     *
     * @see AWS.Request
     */


    AWS.Response = inherit({
      /**
       * @api private
       */
      constructor: function Response(request) {
        this.request = request;
        this.data = null;
        this.error = null;
        this.retryCount = 0;
        this.redirectCount = 0;
        this.httpResponse = new AWS.HttpResponse();

        if (request) {
          this.maxRetries = request.service.numRetries();
          this.maxRedirects = request.service.config.maxRedirects;
        }
      },

      /**
       * Creates a new request for the next page of response data, calling the
       * callback with the page data if a callback is provided.
       *
       * @callback callback function(err, data)
       *   Called when a page of data is returned from the next request.
       *
       *   @param err [Error] an error object, if an error occurred in the request
       *   @param data [Object] the next page of data, or null, if there are no
       *     more pages left.
       * @return [AWS.Request] the request object for the next page of data
       * @return [null] if no callback is provided and there are no pages left
       *   to retrieve.
       * @since v1.4.0
       */
      nextPage: function nextPage(callback) {
        var config;
        var service = this.request.service;
        var operation = this.request.operation;

        try {
          config = service.paginationConfig(operation, true);
        } catch (e) {
          this.error = e;
        }

        if (!this.hasNextPage()) {
          if (callback) callback(this.error, null);else if (this.error) throw this.error;
          return null;
        }

        var params = AWS.util.copy(this.request.params);

        if (!this.nextPageTokens) {
          return callback ? callback(null, null) : null;
        } else {
          var inputTokens = config.inputToken;
          if (typeof inputTokens === 'string') inputTokens = [inputTokens];

          for (var i = 0; i < inputTokens.length; i++) {
            params[inputTokens[i]] = this.nextPageTokens[i];
          }

          return service.makeRequest(this.request.operation, params, callback);
        }
      },

      /**
       * @return [Boolean] whether more pages of data can be returned by further
       *   requests
       * @since v1.4.0
       */
      hasNextPage: function hasNextPage() {
        this.cacheNextPageTokens();
        if (this.nextPageTokens) return true;
        if (this.nextPageTokens === undefined) return undefined;else return false;
      },

      /**
       * @api private
       */
      cacheNextPageTokens: function cacheNextPageTokens() {
        if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
        this.nextPageTokens = undefined;
        var config = this.request.service.paginationConfig(this.request.operation);
        if (!config) return this.nextPageTokens;
        this.nextPageTokens = null;

        if (config.moreResults) {
          if (!jmespath.search(this.data, config.moreResults)) {
            return this.nextPageTokens;
          }
        }

        var exprs = config.outputToken;
        if (typeof exprs === 'string') exprs = [exprs];
        AWS.util.arrayEach.call(this, exprs, function (expr) {
          var output = jmespath.search(this.data, expr);

          if (output) {
            this.nextPageTokens = this.nextPageTokens || [];
            this.nextPageTokens.push(output);
          }
        });
        return this.nextPageTokens;
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/s3/managed_upload.js":
  /*!*******************************************************!*\
    !*** ./node_modules/aws-sdk/lib/s3/managed_upload.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibS3Managed_uploadJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var byteLength = AWS.util.string.byteLength;
    var Buffer = AWS.util.Buffer;
    /**
     * The managed uploader allows for easy and efficient uploading of buffers,
     * blobs, or streams, using a configurable amount of concurrency to perform
     * multipart uploads where possible. This abstraction also enables uploading
     * streams of unknown size due to the use of multipart uploads.
     *
     * To construct a managed upload object, see the {constructor} function.
     *
     * ## Tracking upload progress
     *
     * The managed upload object can also track progress by attaching an
     * 'httpUploadProgress' listener to the upload manager. This event is similar
     * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress
     * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more
     * information.
     *
     * ## Handling Multipart Cleanup
     *
     * By default, this class will automatically clean up any multipart uploads
     * when an individual part upload fails. This behavior can be disabled in order
     * to manually handle failures by setting the `leavePartsOnError` configuration
     * option to `true` when initializing the upload object.
     *
     * @!event httpUploadProgress(progress)
     *   Triggered when the uploader has uploaded more data.
     *   @note The `total` property may not be set if the stream being uploaded has
     *     not yet finished chunking. In this case the `total` will be undefined
     *     until the total stream size is known.
     *   @note This event will not be emitted in Node.js 0.8.x.
     *   @param progress [map] An object containing the `loaded` and `total` bytes
     *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload
     *     size is known.
     *   @context (see AWS.Request~send)
     */

    AWS.S3.ManagedUpload = AWS.util.inherit({
      /**
       * Creates a managed upload object with a set of configuration options.
       *
       * @note A "Body" parameter is required to be set prior to calling {send}.
       * @note In Node.js, sending "Body" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}
       *   may result in upload hangs. Using buffer stream is preferable.
       * @option options params [map] a map of parameters to pass to the upload
       *   requests. The "Body" parameter is required to be specified either on
       *   the service or in the params option.
       * @note ContentMD5 should not be provided when using the managed upload object.
       *   Instead, setting "computeChecksums" to true will enable automatic ContentMD5 generation
       *   by the managed upload object.
       * @option options queueSize [Number] (4) the size of the concurrent queue
       *   manager to upload parts in parallel. Set to 1 for synchronous uploading
       *   of parts. Note that the uploader will buffer at most queueSize * partSize
       *   bytes into memory at any given time.
       * @option options partSize [Number] (5mb) the size in bytes for each
       *   individual part to be uploaded. Adjust the part size to ensure the number
       *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the
       *   minimum allowed part size.
       * @option options leavePartsOnError [Boolean] (false) whether to abort the
       *   multipart upload if an error occurs. Set to true if you want to handle
       *   failures manually.
       * @option options service [AWS.S3] an optional S3 service object to use for
       *   requests. This object might have bound parameters used by the uploader.
       * @option options tags [Array<map>] The tags to apply to the uploaded object.
       *   Each tag should have a `Key` and `Value` keys.
       * @example Creating a default uploader for a stream object
       *   var upload = new AWS.S3.ManagedUpload({
       *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
       *   });
       * @example Creating an uploader with concurrency of 1 and partSize of 10mb
       *   var upload = new AWS.S3.ManagedUpload({
       *     partSize: 10 * 1024 * 1024, queueSize: 1,
       *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
       *   });
       * @example Creating an uploader with tags
       *   var upload = new AWS.S3.ManagedUpload({
       *     params: {Bucket: 'bucket', Key: 'key', Body: stream},
       *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]
       *   });
       * @see send
       */
      constructor: function ManagedUpload(options) {
        var self = this;
        AWS.SequentialExecutor.call(self);
        self.body = null;
        self.sliceFn = null;
        self.callback = null;
        self.parts = {};
        self.completeInfo = [];

        self.fillQueue = function () {
          self.callback(new Error('Unsupported body payload ' + typeof self.body));
        };

        self.configure(options);
      },

      /**
       * @api private
       */
      configure: function configure(options) {
        options = options || {};
        this.partSize = this.minPartSize;
        if (options.queueSize) this.queueSize = options.queueSize;
        if (options.partSize) this.partSize = options.partSize;
        if (options.leavePartsOnError) this.leavePartsOnError = true;

        if (options.tags) {
          if (!Array.isArray(options.tags)) {
            throw new Error('Tags must be specified as an array; ' + typeof options.tags + ' provided.');
          }

          this.tags = options.tags;
        }

        if (this.partSize < this.minPartSize) {
          throw new Error('partSize must be greater than ' + this.minPartSize);
        }

        this.service = options.service;
        this.bindServiceObject(options.params);
        this.validateBody();
        this.adjustTotalBytes();
      },

      /**
       * @api private
       */
      leavePartsOnError: false,

      /**
       * @api private
       */
      queueSize: 4,

      /**
       * @api private
       */
      partSize: null,

      /**
       * @readonly
       * @return [Number] the minimum number of bytes for an individual part
       *   upload.
       */
      minPartSize: 1024 * 1024 * 5,

      /**
       * @readonly
       * @return [Number] the maximum allowed number of parts in a multipart upload.
       */
      maxTotalParts: 10000,

      /**
       * Initiates the managed upload for the payload.
       *
       * @callback callback function(err, data)
       *   @param err [Error] an error or null if no error occurred.
       *   @param data [map] The response data from the successful upload:
       *     * `Location` (String) the URL of the uploaded object
       *     * `ETag` (String) the ETag of the uploaded object
       *     * `Bucket` (String) the bucket to which the object was uploaded
       *     * `Key` (String) the key to which the object was uploaded
       * @example Sending a managed upload object
       *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};
       *   var upload = new AWS.S3.ManagedUpload({params: params});
       *   upload.send(function(err, data) {
       *     console.log(err, data);
       *   });
       */
      send: function send(callback) {
        var self = this;
        self.failed = false;

        self.callback = callback || function (err) {
          if (err) throw err;
        };

        var runFill = true;

        if (self.sliceFn) {
          self.fillQueue = self.fillBuffer;
        } else if (AWS.util.isNode()) {
          var Stream = AWS.util.stream.Stream;

          if (self.body instanceof Stream) {
            runFill = false;
            self.fillQueue = self.fillStream;
            self.partBuffers = [];
            self.body.on('error', function (err) {
              self.cleanup(err);
            }).on('readable', function () {
              self.fillQueue();
            }).on('end', function () {
              self.isDoneChunking = true;
              self.numParts = self.totalPartNumbers;
              self.fillQueue.call(self);

              if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {
                self.finishMultiPart();
              }
            });
          }
        }

        if (runFill) self.fillQueue.call(self);
      },

      /**
       * @!method  promise()
       *   Returns a 'thenable' promise.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function(data)
       *     Called if the promise is fulfilled.
       *     @param data [map] The response data from the successful upload:
       *       `Location` (String) the URL of the uploaded object
       *       `ETag` (String) the ETag of the uploaded object
       *       `Bucket` (String) the bucket to which the object was uploaded
       *       `Key` (String) the key to which the object was uploaded
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] an error or null if no error occurred.
       *   @return [Promise] A promise that represents the state of the upload request.
       *   @example Sending an upload request using promises.
       *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});
       *     var promise = upload.promise();
       *     promise.then(function(data) { ... }, function(err) { ... });
       */

      /**
       * Aborts a managed upload, including all concurrent upload requests.
       * @note By default, calling this function will cleanup a multipart upload
       *   if one was created. To leave the multipart upload around after aborting
       *   a request, configure `leavePartsOnError` to `true` in the {constructor}.
       * @note Calling {abort} in the browser environment will not abort any requests
       *   that are already in flight. If a multipart upload was created, any parts
       *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.
       * @example Aborting an upload
       *   var params = {
       *     Bucket: 'bucket', Key: 'key',
       *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload
       *   };
       *   var upload = s3.upload(params);
       *   upload.send(function (err, data) {
       *     if (err) console.log("Error:", err.code, err.message);
       *     else console.log(data);
       *   });
       *
       *   // abort request in 1 second
       *   setTimeout(upload.abort.bind(upload), 1000);
       */
      abort: function abort() {
        var self = this; //abort putObject request

        if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {
          self.singlePart.abort();
        } else {
          self.cleanup(AWS.util.error(new Error('Request aborted by user'), {
            code: 'RequestAbortedError',
            retryable: false
          }));
        }
      },

      /**
       * @api private
       */
      validateBody: function validateBody() {
        var self = this;
        self.body = self.service.config.params.Body;

        if (typeof self.body === 'string') {
          self.body = AWS.util.buffer.toBuffer(self.body);
        } else if (!self.body) {
          throw new Error('params.Body is required');
        }

        self.sliceFn = AWS.util.arraySliceFn(self.body);
      },

      /**
       * @api private
       */
      bindServiceObject: function bindServiceObject(params) {
        params = params || {};
        var self = this; // bind parameters to new service object

        if (!self.service) {
          self.service = new AWS.S3({
            params: params
          });
        } else {
          var service = self.service;
          var config = AWS.util.copy(service._originalConfig || {});
          config.signatureVersion = service.getSignatureVersion();
          self.service = new service.constructor.__super__(config);
          self.service.config.params = AWS.util.merge(self.service.config.params || {}, params);
        }
      },

      /**
       * @api private
       */
      adjustTotalBytes: function adjustTotalBytes() {
        var self = this;

        try {
          // try to get totalBytes
          self.totalBytes = byteLength(self.body);
        } catch (e) {} // try to adjust partSize if we know payload length


        if (self.totalBytes) {
          var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);
          if (newPartSize > self.partSize) self.partSize = newPartSize;
        } else {
          self.totalBytes = undefined;
        }
      },

      /**
       * @api private
       */
      isDoneChunking: false,

      /**
       * @api private
       */
      partPos: 0,

      /**
       * @api private
       */
      totalChunkedBytes: 0,

      /**
       * @api private
       */
      totalUploadedBytes: 0,

      /**
       * @api private
       */
      totalBytes: undefined,

      /**
       * @api private
       */
      numParts: 0,

      /**
       * @api private
       */
      totalPartNumbers: 0,

      /**
       * @api private
       */
      activeParts: 0,

      /**
       * @api private
       */
      doneParts: 0,

      /**
       * @api private
       */
      parts: null,

      /**
       * @api private
       */
      completeInfo: null,

      /**
       * @api private
       */
      failed: false,

      /**
       * @api private
       */
      multipartReq: null,

      /**
       * @api private
       */
      partBuffers: null,

      /**
       * @api private
       */
      partBufferLength: 0,

      /**
       * @api private
       */
      fillBuffer: function fillBuffer() {
        var self = this;
        var bodyLen = byteLength(self.body);

        if (bodyLen === 0) {
          self.isDoneChunking = true;
          self.numParts = 1;
          self.nextChunk(self.body);
          return;
        }

        while (self.activeParts < self.queueSize && self.partPos < bodyLen) {
          var endPos = Math.min(self.partPos + self.partSize, bodyLen);
          var buf = self.sliceFn.call(self.body, self.partPos, endPos);
          self.partPos += self.partSize;

          if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {
            self.isDoneChunking = true;
            self.numParts = self.totalPartNumbers + 1;
          }

          self.nextChunk(buf);
        }
      },

      /**
       * @api private
       */
      fillStream: function fillStream() {
        var self = this;
        if (self.activeParts >= self.queueSize) return;
        var buf = self.body.read(self.partSize - self.partBufferLength) || self.body.read();

        if (buf) {
          self.partBuffers.push(buf);
          self.partBufferLength += buf.length;
          self.totalChunkedBytes += buf.length;
        }

        if (self.partBufferLength >= self.partSize) {
          // if we have single buffer we avoid copyfull concat
          var pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);
          self.partBuffers = [];
          self.partBufferLength = 0; // if we have more than partSize, push the rest back on the queue

          if (pbuf.length > self.partSize) {
            var rest = pbuf.slice(self.partSize);
            self.partBuffers.push(rest);
            self.partBufferLength += rest.length;
            pbuf = pbuf.slice(0, self.partSize);
          }

          self.nextChunk(pbuf);
        }

        if (self.isDoneChunking && !self.isDoneSending) {
          // if we have single buffer we avoid copyfull concat
          pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);
          self.partBuffers = [];
          self.partBufferLength = 0;
          self.totalBytes = self.totalChunkedBytes;
          self.isDoneSending = true;

          if (self.numParts === 0 || pbuf.length > 0) {
            self.numParts++;
            self.nextChunk(pbuf);
          }
        }

        self.body.read(0);
      },

      /**
       * @api private
       */
      nextChunk: function nextChunk(chunk) {
        var self = this;
        if (self.failed) return null;
        var partNumber = ++self.totalPartNumbers;

        if (self.isDoneChunking && partNumber === 1) {
          var params = {
            Body: chunk
          };

          if (this.tags) {
            params.Tagging = this.getTaggingHeader();
          }

          var req = self.service.putObject(params);
          req._managedUpload = self;
          req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);
          self.singlePart = req; //save the single part request

          return null;
        } else if (self.service.config.params.ContentMD5) {
          var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {
            code: 'InvalidDigest',
            retryable: false
          });
          self.cleanup(err);
          return null;
        }

        if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {
          return null; // Already uploaded this part.
        }

        self.activeParts++;

        if (!self.service.config.params.UploadId) {
          if (!self.multipartReq) {
            // create multipart
            self.multipartReq = self.service.createMultipartUpload();
            self.multipartReq.on('success', function (resp) {
              self.service.config.params.UploadId = resp.data.UploadId;
              self.multipartReq = null;
            });
            self.queueChunks(chunk, partNumber);
            self.multipartReq.on('error', function (err) {
              self.cleanup(err);
            });
            self.multipartReq.send();
          } else {
            self.queueChunks(chunk, partNumber);
          }
        } else {
          // multipart is created, just send
          self.uploadPart(chunk, partNumber);
        }
      },

      /**
       * @api private
       */
      getTaggingHeader: function getTaggingHeader() {
        var kvPairStrings = [];

        for (var i = 0; i < this.tags.length; i++) {
          kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' + AWS.util.uriEscape(this.tags[i].Value));
        }

        return kvPairStrings.join('&');
      },

      /**
       * @api private
       */
      uploadPart: function uploadPart(chunk, partNumber) {
        var self = this;
        var partParams = {
          Body: chunk,
          ContentLength: AWS.util.string.byteLength(chunk),
          PartNumber: partNumber
        };
        var partInfo = {
          ETag: null,
          PartNumber: partNumber
        };
        self.completeInfo[partNumber] = partInfo;
        var req = self.service.uploadPart(partParams);
        self.parts[partNumber] = req;
        req._lastUploadedBytes = 0;
        req._managedUpload = self;
        req.on('httpUploadProgress', self.progress);
        req.send(function (err, data) {
          delete self.parts[partParams.PartNumber];
          self.activeParts--;

          if (!err && (!data || !data.ETag)) {
            var message = 'No access to ETag property on response.';

            if (AWS.util.isBrowser()) {
              message += ' Check CORS configuration to expose ETag header.';
            }

            err = AWS.util.error(new Error(message), {
              code: 'ETagMissing',
              retryable: false
            });
          }

          if (err) return self.cleanup(err); //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)

          if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;
          partInfo.ETag = data.ETag;
          self.doneParts++;

          if (self.isDoneChunking && self.doneParts === self.numParts) {
            self.finishMultiPart();
          } else {
            self.fillQueue.call(self);
          }
        });
      },

      /**
       * @api private
       */
      queueChunks: function queueChunks(chunk, partNumber) {
        var self = this;
        self.multipartReq.on('success', function () {
          self.uploadPart(chunk, partNumber);
        });
      },

      /**
       * @api private
       */
      cleanup: function cleanup(err) {
        var self = this;
        if (self.failed) return; // clean up stream

        if (typeof self.body.removeAllListeners === 'function' && typeof self.body.resume === 'function') {
          self.body.removeAllListeners('readable');
          self.body.removeAllListeners('end');
          self.body.resume();
        } // cleanup multipartReq listeners


        if (self.multipartReq) {
          self.multipartReq.removeAllListeners('success');
          self.multipartReq.removeAllListeners('error');
          self.multipartReq.removeAllListeners('complete');
          delete self.multipartReq;
        }

        if (self.service.config.params.UploadId && !self.leavePartsOnError) {
          self.service.abortMultipartUpload().send();
        } else if (self.leavePartsOnError) {
          self.isDoneChunking = false;
        }

        AWS.util.each(self.parts, function (partNumber, part) {
          part.removeAllListeners('complete');
          part.abort();
        });
        self.activeParts = 0;
        self.partPos = 0;
        self.numParts = 0;
        self.totalPartNumbers = 0;
        self.parts = {};
        self.failed = true;
        self.callback(err);
      },

      /**
       * @api private
       */
      finishMultiPart: function finishMultiPart() {
        var self = this;
        var completeParams = {
          MultipartUpload: {
            Parts: self.completeInfo.slice(1)
          }
        };
        self.service.completeMultipartUpload(completeParams, function (err, data) {
          if (err) {
            return self.cleanup(err);
          }

          if (data && typeof data.Location === 'string') {
            data.Location = data.Location.replace(/%2F/g, '/');
          }

          if (Array.isArray(self.tags)) {
            for (var i = 0; i < self.tags.length; i++) {
              self.tags[i].Value = String(self.tags[i].Value);
            }

            self.service.putObjectTagging({
              Tagging: {
                TagSet: self.tags
              }
            }, function (e, d) {
              if (e) {
                self.callback(e);
              } else {
                self.callback(e, data);
              }
            });
          } else {
            self.callback(err, data);
          }
        });
      },

      /**
       * @api private
       */
      finishSinglePart: function finishSinglePart(err, data) {
        var upload = this.request._managedUpload;
        var httpReq = this.request.httpRequest;
        var endpoint = httpReq.endpoint;
        if (err) return upload.callback(err);
        data.Location = [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');
        data.key = this.request.params.Key; // will stay undocumented

        data.Key = this.request.params.Key;
        data.Bucket = this.request.params.Bucket;
        upload.callback(err, data);
      },

      /**
       * @api private
       */
      progress: function progress(info) {
        var upload = this._managedUpload;

        if (this.operation === 'putObject') {
          info.part = 1;
          info.key = this.params.Key;
        } else {
          upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
          this._lastUploadedBytes = info.loaded;
          info = {
            loaded: upload.totalUploadedBytes,
            total: upload.totalBytes,
            part: this.params.PartNumber,
            key: this.params.Key
          };
        }

        upload.emit('httpUploadProgress', [info]);
      }
    });
    AWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);
    /**
     * @api private
     */

    AWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);
    };
    /**
     * @api private
     */


    AWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.promise;
    };

    AWS.util.addPromises(AWS.S3.ManagedUpload);
    /**
     * @api private
     */

    module.exports = AWS.S3.ManagedUpload;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/sequential_executor.js":
  /*!*********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/sequential_executor.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSequential_executorJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * @api private
     * @!method on(eventName, callback)
     *   Registers an event listener callback for the event given by `eventName`.
     *   Parameters passed to the callback function depend on the individual event
     *   being triggered. See the event documentation for those parameters.
     *
     *   @param eventName [String] the event name to register the listener for
     *   @param callback [Function] the listener callback function
     *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
     *     Default to be false.
     *   @return [AWS.SequentialExecutor] the same object for chaining
     */


    AWS.SequentialExecutor = AWS.util.inherit({
      constructor: function SequentialExecutor() {
        this._events = {};
      },

      /**
       * @api private
       */
      listeners: function listeners(eventName) {
        return this._events[eventName] ? this._events[eventName].slice(0) : [];
      },
      on: function on(eventName, listener, toHead) {
        if (this._events[eventName]) {
          toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);
        } else {
          this._events[eventName] = [listener];
        }

        return this;
      },
      onAsync: function onAsync(eventName, listener, toHead) {
        listener._isAsync = true;
        return this.on(eventName, listener, toHead);
      },
      removeListener: function removeListener(eventName, listener) {
        var listeners = this._events[eventName];

        if (listeners) {
          var length = listeners.length;
          var position = -1;

          for (var i = 0; i < length; ++i) {
            if (listeners[i] === listener) {
              position = i;
            }
          }

          if (position > -1) {
            listeners.splice(position, 1);
          }
        }

        return this;
      },
      removeAllListeners: function removeAllListeners(eventName) {
        if (eventName) {
          delete this._events[eventName];
        } else {
          this._events = {};
        }

        return this;
      },

      /**
       * @api private
       */
      emit: function emit(eventName, eventArgs, doneCallback) {
        if (!doneCallback) doneCallback = function doneCallback() {};
        var listeners = this.listeners(eventName);
        var count = listeners.length;
        this.callListeners(listeners, eventArgs, doneCallback);
        return count > 0;
      },

      /**
       * @api private
       */
      callListeners: function callListeners(listeners, args, doneCallback, prevError) {
        var self = this;
        var error = prevError || null;

        function callNextListener(err) {
          if (err) {
            error = AWS.util.error(error || new Error(), err);

            if (self._haltHandlersOnError) {
              return doneCallback.call(self, error);
            }
          }

          self.callListeners(listeners, args, doneCallback, error);
        }

        while (listeners.length > 0) {
          var listener = listeners.shift();

          if (listener._isAsync) {
            // asynchronous listener
            listener.apply(self, args.concat([callNextListener]));
            return; // stop here, callNextListener will continue
          } else {
            // synchronous listener
            try {
              listener.apply(self, args);
            } catch (err) {
              error = AWS.util.error(error || new Error(), err);
            }

            if (error && self._haltHandlersOnError) {
              doneCallback.call(self, error);
              return;
            }
          }
        }

        doneCallback.call(self, error);
      },

      /**
       * Adds or copies a set of listeners from another list of
       * listeners or SequentialExecutor object.
       *
       * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
       *   a list of events and callbacks, or an event emitter object
       *   containing listeners to add to this emitter object.
       * @return [AWS.SequentialExecutor] the emitter object, for chaining.
       * @example Adding listeners from a map of listeners
       *   emitter.addListeners({
       *     event1: [function() { ... }, function() { ... }],
       *     event2: [function() { ... }]
       *   });
       *   emitter.emit('event1'); // emitter has event1
       *   emitter.emit('event2'); // emitter has event2
       * @example Adding listeners from another emitter object
       *   var emitter1 = new AWS.SequentialExecutor();
       *   emitter1.on('event1', function() { ... });
       *   emitter1.on('event2', function() { ... });
       *   var emitter2 = new AWS.SequentialExecutor();
       *   emitter2.addListeners(emitter1);
       *   emitter2.emit('event1'); // emitter2 has event1
       *   emitter2.emit('event2'); // emitter2 has event2
       */
      addListeners: function addListeners(listeners) {
        var self = this; // extract listeners if parameter is an SequentialExecutor object

        if (listeners._events) listeners = listeners._events;
        AWS.util.each(listeners, function (event, callbacks) {
          if (typeof callbacks === 'function') callbacks = [callbacks];
          AWS.util.arrayEach(callbacks, function (callback) {
            self.on(event, callback);
          });
        });
        return self;
      },

      /**
       * Registers an event with {on} and saves the callback handle function
       * as a property on the emitter object using a given `name`.
       *
       * @param name [String] the property name to set on this object containing
       *   the callback function handle so that the listener can be removed in
       *   the future.
       * @param (see on)
       * @return (see on)
       * @example Adding a named listener DATA_CALLBACK
       *   var listener = function() { doSomething(); };
       *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
       *
       *   // the following prints: true
       *   console.log(emitter.DATA_CALLBACK == listener);
       */
      addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
        this[name] = callback;
        this.addListener(eventName, callback, toHead);
        return this;
      },

      /**
       * @api private
       */
      addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
        callback._isAsync = true;
        return this.addNamedListener(name, eventName, callback, toHead);
      },

      /**
       * Helper method to add a set of named listeners using
       * {addNamedListener}. The callback contains a parameter
       * with a handle to the `addNamedListener` method.
       *
       * @callback callback function(add)
       *   The callback function is called immediately in order to provide
       *   the `add` function to the block. This simplifies the addition of
       *   a large group of named listeners.
       *   @param add [Function] the {addNamedListener} function to call
       *     when registering listeners.
       * @example Adding a set of named listeners
       *   emitter.addNamedListeners(function(add) {
       *     add('DATA_CALLBACK', 'data', function() { ... });
       *     add('OTHER', 'otherEvent', function() { ... });
       *     add('LAST', 'lastEvent', function() { ... });
       *   });
       *
       *   // these properties are now set:
       *   emitter.DATA_CALLBACK;
       *   emitter.OTHER;
       *   emitter.LAST;
       */
      addNamedListeners: function addNamedListeners(callback) {
        var self = this;
        callback(function () {
          self.addNamedListener.apply(self, arguments);
        }, function () {
          self.addNamedAsyncListener.apply(self, arguments);
        });
        return this;
      }
    });
    /**
     * {on} is the prefered method.
     * @api private
     */

    AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;
    /**
     * @api private
     */

    module.exports = AWS.SequentialExecutor;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/service.js":
  /*!*********************************************!*\
    !*** ./node_modules/aws-sdk/lib/service.js ***!
    \*********************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibServiceJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ./core */
    "./node_modules/aws-sdk/lib/core.js");

    var Api = __webpack_require__(
    /*! ./model/api */
    "./node_modules/aws-sdk/lib/model/api.js");

    var regionConfig = __webpack_require__(
    /*! ./region_config */
    "./node_modules/aws-sdk/lib/region_config.js");

    var inherit = AWS.util.inherit;
    var clientCount = 0;
    /**
     * The service class representing an AWS service.
     *
     * @class_abstract This class is an abstract class.
     *
     * @!attribute apiVersions
     *   @return [Array<String>] the list of API versions supported by this service.
     *   @readonly
     */

    AWS.Service = inherit({
      /**
       * Create a new service object with a configuration object
       *
       * @param config [map] a map of configuration options
       */
      constructor: function Service(config) {
        if (!this.loadServiceClass) {
          throw AWS.util.error(new Error(), 'Service must be constructed with `new\' operator');
        }

        var ServiceClass = this.loadServiceClass(config || {});

        if (ServiceClass) {
          var originalConfig = AWS.util.copy(config);
          var svc = new ServiceClass(config);
          Object.defineProperty(svc, '_originalConfig', {
            get: function get() {
              return originalConfig;
            },
            enumerable: false,
            configurable: true
          });
          svc._clientId = ++clientCount;
          return svc;
        }

        this.initialize(config);
      },

      /**
       * @api private
       */
      initialize: function initialize(config) {
        var svcConfig = AWS.config[this.serviceIdentifier];
        this.config = new AWS.Config(AWS.config);
        if (svcConfig) this.config.update(svcConfig, true);
        if (config) this.config.update(config, true);
        this.validateService();
        if (!this.config.endpoint) regionConfig.configureEndpoint(this);
        this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
        this.setEndpoint(this.config.endpoint); //enable attaching listeners to service client

        AWS.SequentialExecutor.call(this);
        AWS.Service.addDefaultMonitoringListeners(this);

        if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {
          var publisher = this.publisher;
          this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
            process.nextTick(function () {
              publisher.eventHandler(event);
            });
          });
          this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
            process.nextTick(function () {
              publisher.eventHandler(event);
            });
          });
        }
      },

      /**
       * @api private
       */
      validateService: function validateService() {},

      /**
       * @api private
       */
      loadServiceClass: function loadServiceClass(serviceConfig) {
        var config = serviceConfig;

        if (!AWS.util.isEmpty(this.api)) {
          return null;
        } else if (config.apiConfig) {
          return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
        } else if (!this.constructor.services) {
          return null;
        } else {
          config = new AWS.Config(AWS.config);
          config.update(serviceConfig, true);
          var version = config.apiVersions[this.constructor.serviceIdentifier];
          version = version || config.apiVersion;
          return this.getLatestServiceClass(version);
        }
      },

      /**
       * @api private
       */
      getLatestServiceClass: function getLatestServiceClass(version) {
        version = this.getLatestServiceVersion(version);

        if (this.constructor.services[version] === null) {
          AWS.Service.defineServiceApi(this.constructor, version);
        }

        return this.constructor.services[version];
      },

      /**
       * @api private
       */
      getLatestServiceVersion: function getLatestServiceVersion(version) {
        if (!this.constructor.services || this.constructor.services.length === 0) {
          throw new Error('No services defined on ' + this.constructor.serviceIdentifier);
        }

        if (!version) {
          version = 'latest';
        } else if (AWS.util.isType(version, Date)) {
          version = AWS.util.date.iso8601(version).split('T')[0];
        }

        if (Object.hasOwnProperty(this.constructor.services, version)) {
          return version;
        }

        var keys = Object.keys(this.constructor.services).sort();
        var selectedVersion = null;

        for (var i = keys.length - 1; i >= 0; i--) {
          // versions that end in "*" are not available on disk and can be
          // skipped, so do not choose these as selectedVersions
          if (keys[i][keys[i].length - 1] !== '*') {
            selectedVersion = keys[i];
          }

          if (keys[i].substr(0, 10) <= version) {
            return selectedVersion;
          }
        }

        throw new Error('Could not find ' + this.constructor.serviceIdentifier + ' API to satisfy version constraint `' + version + '\'');
      },

      /**
       * @api private
       */
      api: {},

      /**
       * @api private
       */
      defaultRetryCount: 3,

      /**
       * @api private
       */
      customizeRequests: function customizeRequests(callback) {
        if (!callback) {
          this.customRequestHandler = null;
        } else if (typeof callback === 'function') {
          this.customRequestHandler = callback;
        } else {
          throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
        }
      },

      /**
       * Calls an operation on a service with the given input parameters.
       *
       * @param operation [String] the name of the operation to call on the service.
       * @param params [map] a map of input options for the operation
       * @callback callback function(err, data)
       *   If a callback is supplied, it is called when a response is returned
       *   from the service.
       *   @param err [Error] the error object returned from the request.
       *     Set to `null` if the request is successful.
       *   @param data [Object] the de-serialized data returned from
       *     the request. Set to `null` if a request error occurs.
       */
      makeRequest: function makeRequest(operation, params, callback) {
        if (typeof params === 'function') {
          callback = params;
          params = null;
        }

        params = params || {};

        if (this.config.params) {
          // copy only toplevel bound params
          var rules = this.api.operations[operation];

          if (rules) {
            params = AWS.util.copy(params);
            AWS.util.each(this.config.params, function (key, value) {
              if (rules.input.members[key]) {
                if (params[key] === undefined || params[key] === null) {
                  params[key] = value;
                }
              }
            });
          }
        }

        var request = new AWS.Request(this, operation, params);
        this.addAllRequestListeners(request);
        this.attachMonitoringEmitter(request);
        if (callback) request.send(callback);
        return request;
      },

      /**
       * Calls an operation on a service with the given input parameters, without
       * any authentication data. This method is useful for "public" API operations.
       *
       * @param operation [String] the name of the operation to call on the service.
       * @param params [map] a map of input options for the operation
       * @callback callback function(err, data)
       *   If a callback is supplied, it is called when a response is returned
       *   from the service.
       *   @param err [Error] the error object returned from the request.
       *     Set to `null` if the request is successful.
       *   @param data [Object] the de-serialized data returned from
       *     the request. Set to `null` if a request error occurs.
       */
      makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
        if (typeof params === 'function') {
          callback = params;
          params = {};
        }

        var request = this.makeRequest(operation, params).toUnauthenticated();
        return callback ? request.send(callback) : request;
      },

      /**
       * Waits for a given state
       *
       * @param state [String] the state on the service to wait for
       * @param params [map] a map of parameters to pass with each request
       * @option params $waiter [map] a map of configuration options for the waiter
       * @option params $waiter.delay [Number] The number of seconds to wait between
       *                                       requests
       * @option params $waiter.maxAttempts [Number] The maximum number of requests
       *                                             to send while waiting
       * @callback callback function(err, data)
       *   If a callback is supplied, it is called when a response is returned
       *   from the service.
       *   @param err [Error] the error object returned from the request.
       *     Set to `null` if the request is successful.
       *   @param data [Object] the de-serialized data returned from
       *     the request. Set to `null` if a request error occurs.
       */
      waitFor: function waitFor(state, params, callback) {
        var waiter = new AWS.ResourceWaiter(this, state);
        return waiter.wait(params, callback);
      },

      /**
       * @api private
       */
      addAllRequestListeners: function addAllRequestListeners(request) {
        var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(), AWS.EventListeners.CorePost];

        for (var i = 0; i < list.length; i++) {
          if (list[i]) request.addListeners(list[i]);
        } // disable parameter validation


        if (!this.config.paramValidation) {
          request.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
        }

        if (this.config.logger) {
          // add logging events
          request.addListeners(AWS.EventListeners.Logger);
        }

        this.setupRequestListeners(request); // call prototype's customRequestHandler

        if (typeof this.constructor.prototype.customRequestHandler === 'function') {
          this.constructor.prototype.customRequestHandler(request);
        } // call instance's customRequestHandler


        if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
          this.customRequestHandler(request);
        }
      },

      /**
       * Event recording metrics for a whole API call.
       * @returns {object} a subset of api call metrics
       * @api private
       */
      apiCallEvent: function apiCallEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: 'ApiCall',
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Region: request.httpRequest.region,
          MaxRetriesExceeded: 0,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;

        if (response.httpResponse.statusCode) {
          monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
        }

        if (response.error) {
          var error = response.error;
          var statusCode = response.httpResponse.statusCode;

          if (statusCode > 299) {
            if (error.code) monitoringEvent.FinalAwsException = error.code;
            if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
          } else {
            if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
            if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
          }
        }

        return monitoringEvent;
      },

      /**
       * Event recording metrics for an API call attempt.
       * @returns {object} a subset of api call attempt metrics
       * @api private
       */
      apiAttemptEvent: function apiAttemptEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: 'ApiCallAttempt',
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Fqdn: request.httpRequest.endpoint.hostname,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;

        if (response.httpResponse.statusCode) {
          monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
        }

        if (!request._unAuthenticated && request.service.config.credentials && request.service.config.credentials.accessKeyId) {
          monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
        }

        if (!response.httpResponse.headers) return monitoringEvent;

        if (request.httpRequest.headers['x-amz-security-token']) {
          monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
        }

        if (response.httpResponse.headers['x-amzn-requestid']) {
          monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
        }

        if (response.httpResponse.headers['x-amz-request-id']) {
          monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
        }

        if (response.httpResponse.headers['x-amz-id-2']) {
          monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
        }

        return monitoringEvent;
      },

      /**
       * Add metrics of failed request.
       * @api private
       */
      attemptFailEvent: function attemptFailEvent(request) {
        var monitoringEvent = this.apiAttemptEvent(request);
        var response = request.response;
        var error = response.error;

        if (response.httpResponse.statusCode > 299) {
          if (error.code) monitoringEvent.AwsException = error.code;
          if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
        } else {
          if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
          if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
        }

        return monitoringEvent;
      },

      /**
       * Attach listeners to request object to fetch metrics of each request
       * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
       * @api private
       */
      attachMonitoringEmitter: function attachMonitoringEmitter(request) {
        var attemptTimestamp; //timestamp marking the beginning of a request attempt

        var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency

        var attemptLatency; //latency from request sent out to http response reaching SDK

        var callStartRealTime; //Start time of API call. Used to calculating API call latency

        var attemptCount = 0; //request.retryCount is not reliable here

        var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)

        var callTimestamp; //timestamp when the request is created

        var self = this;
        var addToHead = true;
        request.on('validate', function () {
          callStartRealTime = AWS.util.realClock.now();
          callTimestamp = Date.now();
        }, addToHead);
        request.on('sign', function () {
          attemptStartRealTime = AWS.util.realClock.now();
          attemptTimestamp = Date.now();
          region = request.httpRequest.region;
          attemptCount++;
        }, addToHead);
        request.on('validateResponse', function () {
          attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
        });
        request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
          var apiAttemptEvent = self.apiAttemptEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self.emit('apiCallAttempt', [apiAttemptEvent]);
        });
        request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
          var apiAttemptEvent = self.attemptFailEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp; //attemptLatency may not be available if fail before response

          attemptLatency = attemptLatency || Math.round(AWS.util.realClock.now() - attemptStartRealTime);
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self.emit('apiCallAttempt', [apiAttemptEvent]);
        });
        request.addNamedListener('API_CALL', 'complete', function API_CALL() {
          var apiCallEvent = self.apiCallEvent(request);
          apiCallEvent.AttemptCount = attemptCount;
          if (apiCallEvent.AttemptCount <= 0) return;
          apiCallEvent.Timestamp = callTimestamp;
          var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
          apiCallEvent.Latency = latency >= 0 ? latency : 0;
          var response = request.response;

          if (response.error && response.error.retryable && typeof response.retryCount === 'number' && typeof response.maxRetries === 'number' && response.retryCount >= response.maxRetries) {
            apiCallEvent.MaxRetriesExceeded = 1;
          }

          self.emit('apiCall', [apiCallEvent]);
        });
      },

      /**
       * Override this method to setup any custom request listeners for each
       * new request to the service.
       *
       * @method_abstract This is an abstract method.
       */
      setupRequestListeners: function setupRequestListeners(request) {},

      /**
       * Gets the signing name for a given request
       * @api private
       */
      getSigningName: function getSigningName() {
        return this.api.signingName || this.api.endpointPrefix;
      },

      /**
       * Gets the signer class for a given request
       * @api private
       */
      getSignerClass: function getSignerClass(request) {
        var version; // get operation authtype if present

        var operation = null;
        var authtype = '';

        if (request) {
          var operations = request.service.api.operations || {};
          operation = operations[request.operation] || null;
          authtype = operation ? operation.authtype : '';
        }

        if (this.config.signatureVersion) {
          version = this.config.signatureVersion;
        } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
          version = 'v4';
        } else {
          version = this.api.signatureVersion;
        }

        return AWS.Signers.RequestSigner.getVersion(version);
      },

      /**
       * @api private
       */
      serviceInterface: function serviceInterface() {
        switch (this.api.protocol) {
          case 'ec2':
            return AWS.EventListeners.Query;

          case 'query':
            return AWS.EventListeners.Query;

          case 'json':
            return AWS.EventListeners.Json;

          case 'rest-json':
            return AWS.EventListeners.RestJson;

          case 'rest-xml':
            return AWS.EventListeners.RestXml;
        }

        if (this.api.protocol) {
          throw new Error('Invalid service `protocol\' ' + this.api.protocol + ' in API config');
        }
      },

      /**
       * @api private
       */
      successfulResponse: function successfulResponse(resp) {
        return resp.httpResponse.statusCode < 300;
      },

      /**
       * How many times a failed request should be retried before giving up.
       * the defaultRetryCount can be overriden by service classes.
       *
       * @api private
       */
      numRetries: function numRetries() {
        if (this.config.maxRetries !== undefined) {
          return this.config.maxRetries;
        } else {
          return this.defaultRetryCount;
        }
      },

      /**
       * @api private
       */
      retryDelays: function retryDelays(retryCount, err) {
        return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
      },

      /**
       * @api private
       */
      retryableError: function retryableError(error) {
        if (this.timeoutError(error)) return true;
        if (this.networkingError(error)) return true;
        if (this.expiredCredentialsError(error)) return true;
        if (this.throttledError(error)) return true;
        if (error.statusCode >= 500) return true;
        return false;
      },

      /**
       * @api private
       */
      networkingError: function networkingError(error) {
        return error.code === 'NetworkingError';
      },

      /**
       * @api private
       */
      timeoutError: function timeoutError(error) {
        return error.code === 'TimeoutError';
      },

      /**
       * @api private
       */
      expiredCredentialsError: function expiredCredentialsError(error) {
        // TODO : this only handles *one* of the expired credential codes
        return error.code === 'ExpiredTokenException';
      },

      /**
       * @api private
       */
      clockSkewError: function clockSkewError(error) {
        switch (error.code) {
          case 'RequestTimeTooSkewed':
          case 'RequestExpired':
          case 'InvalidSignatureException':
          case 'SignatureDoesNotMatch':
          case 'AuthFailure':
          case 'RequestInTheFuture':
            return true;

          default:
            return false;
        }
      },

      /**
       * @api private
       */
      getSkewCorrectedDate: function getSkewCorrectedDate() {
        return new Date(Date.now() + this.config.systemClockOffset);
      },

      /**
       * @api private
       */
      applyClockOffset: function applyClockOffset(newServerTime) {
        if (newServerTime) {
          this.config.systemClockOffset = newServerTime - Date.now();
        }
      },

      /**
       * @api private
       */
      isClockSkewed: function isClockSkewed(newServerTime) {
        if (newServerTime) {
          return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 300000;
        }
      },

      /**
       * @api private
       */
      throttledError: function throttledError(error) {
        // this logic varies between services
        if (error.statusCode === 429) return true;

        switch (error.code) {
          case 'ProvisionedThroughputExceededException':
          case 'Throttling':
          case 'ThrottlingException':
          case 'RequestLimitExceeded':
          case 'RequestThrottled':
          case 'RequestThrottledException':
          case 'TooManyRequestsException':
          case 'TransactionInProgressException': //dynamodb

          case 'EC2ThrottledException':
            return true;

          default:
            return false;
        }
      },

      /**
       * @api private
       */
      endpointFromTemplate: function endpointFromTemplate(endpoint) {
        if (typeof endpoint !== 'string') return endpoint;
        var e = endpoint;
        e = e.replace(/\{service\}/g, this.api.endpointPrefix);
        e = e.replace(/\{region\}/g, this.config.region);
        e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
        return e;
      },

      /**
       * @api private
       */
      setEndpoint: function setEndpoint(endpoint) {
        this.endpoint = new AWS.Endpoint(endpoint, this.config);
      },

      /**
       * @api private
       */
      paginationConfig: function paginationConfig(operation, throwException) {
        var paginator = this.api.operations[operation].paginator;

        if (!paginator) {
          if (throwException) {
            var e = new Error();
            throw AWS.util.error(e, 'No pagination configuration for ' + operation);
          }

          return null;
        }

        return paginator;
      }
    });
    AWS.util.update(AWS.Service, {
      /**
       * Adds one method for each operation described in the api configuration
       *
       * @api private
       */
      defineMethods: function defineMethods(svc) {
        AWS.util.each(svc.prototype.api.operations, function iterator(method) {
          if (svc.prototype[method]) return;
          var operation = svc.prototype.api.operations[method];

          if (operation.authtype === 'none') {
            svc.prototype[method] = function (params, callback) {
              return this.makeUnauthenticatedRequest(method, params, callback);
            };
          } else {
            svc.prototype[method] = function (params, callback) {
              return this.makeRequest(method, params, callback);
            };
          }
        });
      },

      /**
       * Defines a new Service class using a service identifier and list of versions
       * including an optional set of features (functions) to apply to the class
       * prototype.
       *
       * @param serviceIdentifier [String] the identifier for the service
       * @param versions [Array<String>] a list of versions that work with this
       *   service
       * @param features [Object] an object to attach to the prototype
       * @return [Class<Service>] the service class defined by this function.
       */
      defineService: function defineService(serviceIdentifier, versions, features) {
        AWS.Service._serviceMap[serviceIdentifier] = true;

        if (!Array.isArray(versions)) {
          features = versions;
          versions = [];
        }

        var svc = inherit(AWS.Service, features || {});

        if (typeof serviceIdentifier === 'string') {
          AWS.Service.addVersions(svc, versions);
          var identifier = svc.serviceIdentifier || serviceIdentifier;
          svc.serviceIdentifier = identifier;
        } else {
          // defineService called with an API
          svc.prototype.api = serviceIdentifier;
          AWS.Service.defineMethods(svc);
        }

        AWS.SequentialExecutor.call(this.prototype); //util.clientSideMonitoring is only available in node

        if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
          var Publisher = AWS.util.clientSideMonitoring.Publisher;
          var configProvider = AWS.util.clientSideMonitoring.configProvider;
          var publisherConfig = configProvider();
          this.prototype.publisher = new Publisher(publisherConfig);

          if (publisherConfig.enabled) {
            //if csm is enabled in environment, SDK should send all metrics
            AWS.Service._clientSideMonitoring = true;
          }
        }

        AWS.SequentialExecutor.call(svc.prototype);
        AWS.Service.addDefaultMonitoringListeners(svc.prototype);
        return svc;
      },

      /**
       * @api private
       */
      addVersions: function addVersions(svc, versions) {
        if (!Array.isArray(versions)) versions = [versions];
        svc.services = svc.services || {};

        for (var i = 0; i < versions.length; i++) {
          if (svc.services[versions[i]] === undefined) {
            svc.services[versions[i]] = null;
          }
        }

        svc.apiVersions = Object.keys(svc.services).sort();
      },

      /**
       * @api private
       */
      defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
        var svc = inherit(superclass, {
          serviceIdentifier: superclass.serviceIdentifier
        });

        function setApi(api) {
          if (api.isApi) {
            svc.prototype.api = api;
          } else {
            svc.prototype.api = new Api(api, {
              serviceIdentifier: superclass.serviceIdentifier
            });
          }
        }

        if (typeof version === 'string') {
          if (apiConfig) {
            setApi(apiConfig);
          } else {
            try {
              setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
            } catch (err) {
              throw AWS.util.error(err, {
                message: 'Could not find API configuration ' + superclass.serviceIdentifier + '-' + version
              });
            }
          }

          if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
            superclass.apiVersions = superclass.apiVersions.concat(version).sort();
          }

          superclass.services[version] = svc;
        } else {
          setApi(version);
        }

        AWS.Service.defineMethods(svc);
        return svc;
      },

      /**
       * @api private
       */
      hasService: function hasService(identifier) {
        return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
      },

      /**
       * @param attachOn attach default monitoring listeners to object
       *
       * Each monitoring event should be emitted from service client to service constructor prototype and then
       * to global service prototype like bubbling up. These default monitoring events listener will transfer
       * the monitoring events to the upper layer.
       * @api private
       */
      addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
        attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
        });
        attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events) baseClass.emit('apiCall', [event]);
        });
      },

      /**
       * @api private
       */
      _serviceMap: {}
    });
    AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);
    /**
     * @api private
     */

    module.exports = AWS.Service;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/services/s3.js":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/lib/services/s3.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibServicesS3Js(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var v4Credentials = __webpack_require__(
    /*! ../signers/v4_credentials */
    "./node_modules/aws-sdk/lib/signers/v4_credentials.js");

    var resolveRegionalEndpointsFlag = __webpack_require__(
    /*! ../config_regional_endpoint */
    "./node_modules/aws-sdk/lib/config_regional_endpoint.js");

    var s3util = __webpack_require__(
    /*! ./s3util */
    "./node_modules/aws-sdk/lib/services/s3util.js");

    var regionUtil = __webpack_require__(
    /*! ../region_config */
    "./node_modules/aws-sdk/lib/region_config.js"); // Pull in managed upload extension


    __webpack_require__(
    /*! ../s3/managed_upload */
    "./node_modules/aws-sdk/lib/s3/managed_upload.js");
    /**
     * @api private
     */


    var operationsWith200StatusCodeError = {
      'completeMultipartUpload': true,
      'copyObject': true,
      'uploadPartCopy': true
    };
    /**
     * @api private
     */

    var regionRedirectErrorCodes = ['AuthorizationHeaderMalformed', // non-head operations on virtual-hosted global bucket endpoints
    'BadRequest', // head operations on virtual-hosted global bucket endpoints
    'PermanentRedirect', // non-head operations on path-style or regional endpoints
    301 // head operations on path-style or regional endpoints
    ];
    AWS.util.update(AWS.S3.prototype, {
      /**
       * @api private
       */
      getSignatureVersion: function getSignatureVersion(request) {
        var defaultApiVersion = this.api.signatureVersion;
        var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
        var regionDefinedVersion = this.config.signatureVersion;
        var isPresigned = request ? request.isPresigned() : false;
        /*
          1) User defined version specified:
            a) always return user defined version
          2) No user defined version specified:
            a) If not using presigned urls, default to V4
            b) If using presigned urls, default to lowest version the region supports
        */

        if (userDefinedVersion) {
          userDefinedVersion = userDefinedVersion === 'v2' ? 's3' : userDefinedVersion;
          return userDefinedVersion;
        }

        if (isPresigned !== true) {
          defaultApiVersion = 'v4';
        } else if (regionDefinedVersion) {
          defaultApiVersion = regionDefinedVersion;
        }

        return defaultApiVersion;
      },

      /**
       * @api private
       */
      getSigningName: function getSigningName() {
        var _super = AWS.Service.prototype.getSigningName;
        return this._parsedArn && this._parsedArn.service ? this._parsedArn.service : _super.call(this);
      },

      /**
       * @api private
       */
      getSignerClass: function getSignerClass(request) {
        var signatureVersion = this.getSignatureVersion(request);
        return AWS.Signers.RequestSigner.getVersion(signatureVersion);
      },

      /**
       * @api private
       */
      validateService: function validateService() {
        var msg;
        var messages = []; // default to us-east-1 when no region is provided

        if (!this.config.region) this.config.region = 'us-east-1';

        if (!this.config.endpoint && this.config.s3BucketEndpoint) {
          messages.push('An endpoint must be provided when configuring ' + '`s3BucketEndpoint` to true.');
        }

        if (messages.length === 1) {
          msg = messages[0];
        } else if (messages.length > 1) {
          msg = 'Multiple configuration errors:\n' + messages.join('\n');
        }

        if (msg) {
          throw AWS.util.error(new Error(), {
            name: 'InvalidEndpoint',
            message: msg
          });
        }
      },

      /**
       * @api private
       */
      shouldDisableBodySigning: function shouldDisableBodySigning(request) {
        var signerClass = this.getSignerClass();

        if (this.config.s3DisableBodySigning === true && signerClass === AWS.Signers.V4 && request.httpRequest.endpoint.protocol === 'https:') {
          return true;
        }

        return false;
      },

      /**
       * @api private
       */
      setupRequestListeners: function setupRequestListeners(request) {
        var prependListener = true;
        request.addListener('validate', this.validateScheme);
        request.addListener('validate', this.validateBucketName, prependListener);
        request.addListener('validate', this.optInUsEast1RegionalEndpoint, prependListener);
        request.removeListener('validate', AWS.EventListeners.Core.VALIDATE_REGION);
        request.addListener('build', this.addContentType);
        request.addListener('build', this.computeContentMd5);
        request.addListener('build', this.computeSseCustomerKeyMd5);
        request.addListener('build', this.populateURI);
        request.addListener('afterBuild', this.addExpect100Continue);
        request.addListener('extractError', this.extractError);
        request.addListener('extractData', AWS.util.hoistPayloadMember);
        request.addListener('extractData', this.extractData);
        request.addListener('extractData', this.extractErrorFrom200Response);
        request.addListener('beforePresign', this.prepareSignedUrl);

        if (this.shouldDisableBodySigning(request)) {
          request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
          request.addListener('afterBuild', this.disableBodySigning);
        } //deal with ARNs supplied to Bucket


        if (request.operation !== 'createBucket' && s3util.isArnInParam(request, 'Bucket')) {
          // avoid duplicate parsing in the future
          request.service._parsedArn = AWS.util.ARN.parse(request.params.Bucket);
          request.removeListener('validate', this.validateBucketName);
          request.removeListener('build', this.populateURI);

          if (request.service._parsedArn.service === 's3') {
            request.addListener('validate', s3util.validateS3AccessPointArn);
            request.addListener('validate', this.validateArnResourceType);
          } else if (request.service._parsedArn.service === 's3-outposts') {
            request.addListener('validate', s3util.validateOutpostsAccessPointArn);
            request.addListener('validate', s3util.validateOutpostsArn);
          }

          request.addListener('validate', s3util.validateArnRegion);
          request.addListener('validate', s3util.validateArnAccount);
          request.addListener('validate', s3util.validateArnService);
          request.addListener('build', this.populateUriFromAccessPointArn);
          request.addListener('build', s3util.validatePopulateUriFromArn);
          return;
        } //listeners regarding region inference


        request.addListener('validate', this.validateBucketEndpoint);
        request.addListener('validate', this.correctBucketRegionFromCache);
        request.onAsync('extractError', this.requestBucketRegion);

        if (AWS.util.isBrowser()) {
          request.onAsync('retry', this.reqRegionForNetworkingError);
        }
      },

      /**
       * @api private
       */
      validateScheme: function validateScheme(req) {
        var params = req.params,
            scheme = req.httpRequest.endpoint.protocol,
            sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;

        if (sensitive && scheme !== 'https:') {
          var msg = 'Cannot send SSE keys over HTTP. Set \'sslEnabled\'' + 'to \'true\' in your configuration';
          throw AWS.util.error(new Error(), {
            code: 'ConfigError',
            message: msg
          });
        }
      },

      /**
       * @api private
       */
      validateBucketEndpoint: function validateBucketEndpoint(req) {
        if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
          var msg = 'Cannot send requests to root API with `s3BucketEndpoint` set.';
          throw AWS.util.error(new Error(), {
            code: 'ConfigError',
            message: msg
          });
        }
      },

      /**
       * Validate resource-type supplied in S3 ARN
       */
      validateArnResourceType: function validateArnResourceType(req) {
        var resource = req.service._parsedArn.resource;

        if (resource.indexOf('accesspoint:') !== 0 && resource.indexOf('accesspoint/') !== 0) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'ARN resource should begin with \'accesspoint/\''
          });
        }
      },

      /**
       * @api private
       */
      validateBucketName: function validateBucketName(req) {
        var service = req.service;
        var signatureVersion = service.getSignatureVersion(req);
        var bucket = req.params && req.params.Bucket;
        var key = req.params && req.params.Key;
        var slashIndex = bucket && bucket.indexOf('/');

        if (bucket && slashIndex >= 0) {
          if (typeof key === 'string' && slashIndex > 0) {
            req.params = AWS.util.copy(req.params); // Need to include trailing slash to match sigv2 behavior

            var prefix = bucket.substr(slashIndex + 1) || '';
            req.params.Key = prefix + '/' + key;
            req.params.Bucket = bucket.substr(0, slashIndex);
          } else if (signatureVersion === 'v4') {
            var msg = 'Bucket names cannot contain forward slashes. Bucket: ' + bucket;
            throw AWS.util.error(new Error(), {
              code: 'InvalidBucket',
              message: msg
            });
          }
        }
      },

      /**
       * @api private
       */
      isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
        var invalidOperations = ['createBucket', 'deleteBucket', 'listBuckets'];
        return invalidOperations.indexOf(operation) === -1;
      },

      /**
       * When us-east-1 region endpoint configuration is set, in stead of sending request to
       * global endpoint(e.g. 's3.amazonaws.com'), we will send request to
       * 's3.us-east-1.amazonaws.com'.
       * @api private
       */
      optInUsEast1RegionalEndpoint: function optInUsEast1RegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.s3UsEast1RegionalEndpoint = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: 'AWS_S3_US_EAST_1_REGIONAL_ENDPOINT',
          sharedConfig: 's3_us_east_1_regional_endpoint',
          clientConfig: 's3UsEast1RegionalEndpoint'
        });

        if (!(service._originalConfig || {}).endpoint && req.httpRequest.region === 'us-east-1' && config.s3UsEast1RegionalEndpoint === 'regional' && req.httpRequest.endpoint.hostname.indexOf('s3.amazonaws.com') >= 0) {
          var insertPoint = config.endpoint.indexOf('.amazonaws.com');
          regionalEndpoint = config.endpoint.substring(0, insertPoint) + '.us-east-1' + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint);
        }
      },

      /**
       * S3 prefers dns-compatible bucket names to be moved from the uri path
       * to the hostname as a sub-domain.  This is not possible, even for dns-compat
       * buckets when using SSL and the bucket name contains a dot ('.').  The
       * ssl wildcard certificate is only 1-level deep.
       *
       * @api private
       */
      populateURI: function populateURI(req) {
        var httpRequest = req.httpRequest;
        var b = req.params.Bucket;
        var service = req.service;
        var endpoint = httpRequest.endpoint;

        if (b) {
          if (!service.pathStyleBucketName(b)) {
            if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
              if (service.config.useDualstack) {
                endpoint.hostname = b + '.s3-accelerate.dualstack.amazonaws.com';
              } else {
                endpoint.hostname = b + '.s3-accelerate.amazonaws.com';
              }
            } else if (!service.config.s3BucketEndpoint) {
              endpoint.hostname = b + '.' + endpoint.hostname;
            }

            var port = endpoint.port;

            if (port !== 80 && port !== 443) {
              endpoint.host = endpoint.hostname + ':' + endpoint.port;
            } else {
              endpoint.host = endpoint.hostname;
            }

            httpRequest.virtualHostedBucket = b; // needed for signing the request

            service.removeVirtualHostedBucketFromPath(req);
          }
        }
      },

      /**
       * Takes the bucket name out of the path if bucket is virtual-hosted
       *
       * @api private
       */
      removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
        var httpRequest = req.httpRequest;
        var bucket = httpRequest.virtualHostedBucket;

        if (bucket && httpRequest.path) {
          if (req.params && req.params.Key) {
            var encodedS3Key = '/' + AWS.util.uriEscapePath(req.params.Key);

            if (httpRequest.path.indexOf(encodedS3Key) === 0 && (httpRequest.path.length === encodedS3Key.length || httpRequest.path[encodedS3Key.length] === '?')) {
              //path only contains key or path contains only key and querystring
              return;
            }
          }

          httpRequest.path = httpRequest.path.replace(new RegExp('/' + bucket), '');

          if (httpRequest.path[0] !== '/') {
            httpRequest.path = '/' + httpRequest.path;
          }
        }
      },

      /**
       * When user supply an access point ARN in the Bucket parameter, we need to
       * populate the URI according to the ARN.
       */
      populateUriFromAccessPointArn: function populateUriFromAccessPointArn(req) {
        var accessPointArn = req.service._parsedArn;
        var isOutpostArn = accessPointArn.service === 's3-outposts';
        var outpostsSuffix = isOutpostArn ? '.' + accessPointArn.outpostId : '';
        var serviceName = isOutpostArn ? 's3-outposts' : 's3-accesspoint';
        var dualStackSuffix = !isOutpostArn && req.service.config.useDualstack ? '.dualstack' : '';
        var endpoint = req.httpRequest.endpoint;
        var dnsSuffix = regionUtil.getEndpointSuffix(accessPointArn.region);
        var useArnRegion = req.service.config.s3UseArnRegion;
        endpoint.hostname = [accessPointArn.accessPoint + '-' + accessPointArn.accountId + outpostsSuffix, serviceName + dualStackSuffix, useArnRegion ? accessPointArn.region : req.service.config.region, dnsSuffix].join('.');
        endpoint.host = endpoint.hostname;
        var encodedArn = AWS.util.uriEscape(req.params.Bucket);
        var path = req.httpRequest.path; //remove the Bucket value from path

        req.httpRequest.path = path.replace(new RegExp('/' + encodedArn), '');

        if (req.httpRequest.path[0] !== '/') {
          req.httpRequest.path = '/' + req.httpRequest.path;
        }

        req.httpRequest.region = accessPointArn.region; //region used to sign
      },

      /**
       * Adds Expect: 100-continue header if payload is greater-or-equal 1MB
       * @api private
       */
      addExpect100Continue: function addExpect100Continue(req) {
        var len = req.httpRequest.headers['Content-Length'];

        if (AWS.util.isNode() && (len >= 1024 * 1024 || req.params.Body instanceof AWS.util.stream.Stream)) {
          req.httpRequest.headers['Expect'] = '100-continue';
        }
      },

      /**
       * Adds a default content type if none is supplied.
       *
       * @api private
       */
      addContentType: function addContentType(req) {
        var httpRequest = req.httpRequest;

        if (httpRequest.method === 'GET' || httpRequest.method === 'HEAD') {
          // Content-Type is not set in GET/HEAD requests
          delete httpRequest.headers['Content-Type'];
          return;
        }

        if (!httpRequest.headers['Content-Type']) {
          // always have a Content-Type
          httpRequest.headers['Content-Type'] = 'application/octet-stream';
        }

        var contentType = httpRequest.headers['Content-Type'];

        if (AWS.util.isBrowser()) {
          if (typeof httpRequest.body === 'string' && !contentType.match(/;\s*charset=/)) {
            var charset = '; charset=UTF-8';
            httpRequest.headers['Content-Type'] += charset;
          } else {
            var replaceFn = function replaceFn(_, prefix, charsetName) {
              return prefix + charsetName.toUpperCase();
            };

            httpRequest.headers['Content-Type'] = contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
          }
        }
      },

      /**
       * @api private
       */
      computableChecksumOperations: {
        putBucketCors: true,
        putBucketLifecycle: true,
        putBucketLifecycleConfiguration: true,
        putBucketTagging: true,
        deleteObjects: true,
        putBucketReplication: true,
        putObjectLegalHold: true,
        putObjectRetention: true,
        putObjectLockConfiguration: true
      },

      /**
       * Checks whether checksums should be computed for the request.
       * If the request requires checksums to be computed, this will always
       * return true, otherwise it depends on whether {AWS.Config.computeChecksums}
       * is set.
       *
       * @param req [AWS.Request] the request to check against
       * @return [Boolean] whether to compute checksums for a request.
       * @api private
       */
      willComputeChecksums: function willComputeChecksums(req) {
        if (this.computableChecksumOperations[req.operation]) return true;
        if (!this.config.computeChecksums) return false; // TODO: compute checksums for Stream objects

        if (!AWS.util.Buffer.isBuffer(req.httpRequest.body) && typeof req.httpRequest.body !== 'string') {
          return false;
        }

        var rules = req.service.api.operations[req.operation].input.members; // Sha256 signing disabled, and not a presigned url

        if (req.service.shouldDisableBodySigning(req) && !Object.prototype.hasOwnProperty.call(req.httpRequest.headers, 'presigned-expires')) {
          if (rules.ContentMD5 && !req.params.ContentMD5) {
            return true;
          }
        } // V4 signer uses SHA256 signatures so only compute MD5 if it is required


        if (req.service.getSignerClass(req) === AWS.Signers.V4) {
          if (rules.ContentMD5 && !rules.ContentMD5.required) return false;
        }

        if (rules.ContentMD5 && !req.params.ContentMD5) return true;
      },

      /**
       * A listener that computes the Content-MD5 and sets it in the header.
       * @see AWS.S3.willComputeChecksums
       * @api private
       */
      computeContentMd5: function computeContentMd5(req) {
        if (req.service.willComputeChecksums(req)) {
          var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
          req.httpRequest.headers['Content-MD5'] = md5;
        }
      },

      /**
       * @api private
       */
      computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
        var keys = {
          SSECustomerKey: 'x-amz-server-side-encryption-customer-key-MD5',
          CopySourceSSECustomerKey: 'x-amz-copy-source-server-side-encryption-customer-key-MD5'
        };
        AWS.util.each(keys, function (key, header) {
          if (req.params[key]) {
            var value = AWS.util.crypto.md5(req.params[key], 'base64');
            req.httpRequest.headers[header] = value;
          }
        });
      },

      /**
       * Returns true if the bucket name should be left in the URI path for
       * a request to S3.  This function takes into account the current
       * endpoint protocol (e.g. http or https).
       *
       * @api private
       */
      pathStyleBucketName: function pathStyleBucketName(bucketName) {
        // user can force path style requests via the configuration
        if (this.config.s3ForcePathStyle) return true;
        if (this.config.s3BucketEndpoint) return false;

        if (s3util.dnsCompatibleBucketName(bucketName)) {
          return this.config.sslEnabled && bucketName.match(/\./) ? true : false;
        } else {
          return true; // not dns compatible names must always use path style
        }
      },

      /**
       * For COPY operations, some can be error even with status code 200.
       * SDK treats the response as exception when response body indicates
       * an exception or body is empty.
       *
       * @api private
       */
      extractErrorFrom200Response: function extractErrorFrom200Response(resp) {
        if (!operationsWith200StatusCodeError[resp.request.operation]) return;
        var httpResponse = resp.httpResponse;

        if (httpResponse.body && httpResponse.body.toString().match('<Error>')) {
          // Response body with '<Error>...</Error>' indicates an exception.
          // Get S3 client object. In ManagedUpload, this.service refers to
          // S3 client object.
          resp.data = null;
          var service = this.service ? this.service : this;
          service.extractError(resp);
          throw resp.error;
        } else if (!httpResponse.body || !httpResponse.body.toString().match(/<[\w_]/)) {
          // When body is empty or incomplete, S3 might stop the request on detecting client
          // side aborting the request.
          resp.data = null;
          throw AWS.util.error(new Error(), {
            code: 'InternalError',
            message: 'S3 aborted request'
          });
        }
      },

      /**
       * @return [Boolean] whether the error can be retried
       * @api private
       */
      retryableError: function retryableError(error, request) {
        if (operationsWith200StatusCodeError[request.operation] && error.statusCode === 200) {
          return true;
        } else if (request._requestRegionForBucket && request.service.bucketRegionCache[request._requestRegionForBucket]) {
          return false;
        } else if (error && error.code === 'RequestTimeout') {
          return true;
        } else if (error && regionRedirectErrorCodes.indexOf(error.code) != -1 && error.region && error.region != request.httpRequest.region) {
          request.httpRequest.region = error.region;

          if (error.statusCode === 301) {
            request.service.updateReqBucketRegion(request);
          }

          return true;
        } else {
          var _super = AWS.Service.prototype.retryableError;
          return _super.call(this, error, request);
        }
      },

      /**
       * Updates httpRequest with region. If region is not provided, then
       * the httpRequest will be updated based on httpRequest.region
       *
       * @api private
       */
      updateReqBucketRegion: function updateReqBucketRegion(request, region) {
        var httpRequest = request.httpRequest;

        if (typeof region === 'string' && region.length) {
          httpRequest.region = region;
        }

        if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
          return;
        }

        var service = request.service;
        var s3Config = service.config;
        var s3BucketEndpoint = s3Config.s3BucketEndpoint;

        if (s3BucketEndpoint) {
          delete s3Config.s3BucketEndpoint;
        }

        var newConfig = AWS.util.copy(s3Config);
        delete newConfig.endpoint;
        newConfig.region = httpRequest.region;
        httpRequest.endpoint = new AWS.S3(newConfig).endpoint;
        service.populateURI(request);
        s3Config.s3BucketEndpoint = s3BucketEndpoint;
        httpRequest.headers.Host = httpRequest.endpoint.host;

        if (request._asm.currentState === 'validate') {
          request.removeListener('build', service.populateURI);
          request.addListener('build', service.removeVirtualHostedBucketFromPath);
        }
      },

      /**
       * Provides a specialized parser for getBucketLocation -- all other
       * operations are parsed by the super class.
       *
       * @api private
       */
      extractData: function extractData(resp) {
        var req = resp.request;

        if (req.operation === 'getBucketLocation') {
          var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
          delete resp.data['_'];

          if (match) {
            resp.data.LocationConstraint = match[1];
          } else {
            resp.data.LocationConstraint = '';
          }
        }

        var bucket = req.params.Bucket || null;

        if (req.operation === 'deleteBucket' && typeof bucket === 'string' && !resp.error) {
          req.service.clearBucketRegionCache(bucket);
        } else {
          var headers = resp.httpResponse.headers || {};
          var region = headers['x-amz-bucket-region'] || null;

          if (!region && req.operation === 'createBucket' && !resp.error) {
            var createBucketConfiguration = req.params.CreateBucketConfiguration;

            if (!createBucketConfiguration) {
              region = 'us-east-1';
            } else if (createBucketConfiguration.LocationConstraint === 'EU') {
              region = 'eu-west-1';
            } else {
              region = createBucketConfiguration.LocationConstraint;
            }
          }

          if (region) {
            if (bucket && region !== req.service.bucketRegionCache[bucket]) {
              req.service.bucketRegionCache[bucket] = region;
            }
          }
        }

        req.service.extractRequestIds(resp);
      },

      /**
       * Extracts an error object from the http response.
       *
       * @api private
       */
      extractError: function extractError(resp) {
        var codes = {
          304: 'NotModified',
          403: 'Forbidden',
          400: 'BadRequest',
          404: 'NotFound'
        };
        var req = resp.request;
        var code = resp.httpResponse.statusCode;
        var body = resp.httpResponse.body || '';
        var headers = resp.httpResponse.headers || {};
        var region = headers['x-amz-bucket-region'] || null;
        var bucket = req.params.Bucket || null;
        var bucketRegionCache = req.service.bucketRegionCache;

        if (region && bucket && region !== bucketRegionCache[bucket]) {
          bucketRegionCache[bucket] = region;
        }

        var cachedRegion;

        if (codes[code] && body.length === 0) {
          if (bucket && !region) {
            cachedRegion = bucketRegionCache[bucket] || null;

            if (cachedRegion !== req.httpRequest.region) {
              region = cachedRegion;
            }
          }

          resp.error = AWS.util.error(new Error(), {
            code: codes[code],
            message: null,
            region: region
          });
        } else {
          var data = new AWS.XML.Parser().parse(body.toString());

          if (data.Region && !region) {
            region = data.Region;

            if (bucket && region !== bucketRegionCache[bucket]) {
              bucketRegionCache[bucket] = region;
            }
          } else if (bucket && !region && !data.Region) {
            cachedRegion = bucketRegionCache[bucket] || null;

            if (cachedRegion !== req.httpRequest.region) {
              region = cachedRegion;
            }
          }

          resp.error = AWS.util.error(new Error(), {
            code: data.Code || code,
            message: data.Message || null,
            region: region
          });
        }

        req.service.extractRequestIds(resp);
      },

      /**
       * If region was not obtained synchronously, then send async request
       * to get bucket region for errors resulting from wrong region.
       *
       * @api private
       */
      requestBucketRegion: function requestBucketRegion(resp, done) {
        var error = resp.error;
        var req = resp.request;
        var bucket = req.params.Bucket || null;

        if (!error || !bucket || error.region || req.operation === 'listObjects' || AWS.util.isNode() && req.operation === 'headBucket' || error.statusCode === 400 && req.operation !== 'headObject' || regionRedirectErrorCodes.indexOf(error.code) === -1) {
          return done();
        }

        var reqOperation = AWS.util.isNode() ? 'headBucket' : 'listObjects';
        var reqParams = {
          Bucket: bucket
        };
        if (reqOperation === 'listObjects') reqParams.MaxKeys = 0;
        var regionReq = req.service[reqOperation](reqParams);
        regionReq._requestRegionForBucket = bucket;
        regionReq.send(function () {
          var region = req.service.bucketRegionCache[bucket] || null;
          error.region = region;
          done();
        });
      },

      /**
      * For browser only. If NetworkingError received, will attempt to obtain
      * the bucket region.
      *
      * @api private
      */
      reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
        if (!AWS.util.isBrowser()) {
          return done();
        }

        var error = resp.error;
        var request = resp.request;
        var bucket = request.params.Bucket;

        if (!error || error.code !== 'NetworkingError' || !bucket || request.httpRequest.region === 'us-east-1') {
          return done();
        }

        var service = request.service;
        var bucketRegionCache = service.bucketRegionCache;
        var cachedRegion = bucketRegionCache[bucket] || null;

        if (cachedRegion && cachedRegion !== request.httpRequest.region) {
          service.updateReqBucketRegion(request, cachedRegion);
          done();
        } else if (!s3util.dnsCompatibleBucketName(bucket)) {
          service.updateReqBucketRegion(request, 'us-east-1');

          if (bucketRegionCache[bucket] !== 'us-east-1') {
            bucketRegionCache[bucket] = 'us-east-1';
          }

          done();
        } else if (request.httpRequest.virtualHostedBucket) {
          var getRegionReq = service.listObjects({
            Bucket: bucket,
            MaxKeys: 0
          });
          service.updateReqBucketRegion(getRegionReq, 'us-east-1');
          getRegionReq._requestRegionForBucket = bucket;
          getRegionReq.send(function () {
            var region = service.bucketRegionCache[bucket] || null;

            if (region && region !== request.httpRequest.region) {
              service.updateReqBucketRegion(request, region);
            }

            done();
          });
        } else {
          // DNS-compatible path-style
          // (s3ForcePathStyle or bucket name with dot over https)
          // Cannot obtain region information for this case
          done();
        }
      },

      /**
       * Cache for bucket region.
       *
       * @api private
       */
      bucketRegionCache: {},

      /**
       * Clears bucket region cache.
       *
       * @api private
       */
      clearBucketRegionCache: function clearBucketRegionCache(buckets) {
        var bucketRegionCache = this.bucketRegionCache;

        if (!buckets) {
          buckets = Object.keys(bucketRegionCache);
        } else if (typeof buckets === 'string') {
          buckets = [buckets];
        }

        for (var i = 0; i < buckets.length; i++) {
          delete bucketRegionCache[buckets[i]];
        }

        return bucketRegionCache;
      },

      /**
       * Corrects request region if bucket's cached region is different
       *
       * @api private
       */
      correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
        var bucket = req.params.Bucket || null;

        if (bucket) {
          var service = req.service;
          var requestRegion = req.httpRequest.region;
          var cachedRegion = service.bucketRegionCache[bucket];

          if (cachedRegion && cachedRegion !== requestRegion) {
            service.updateReqBucketRegion(req, cachedRegion);
          }
        }
      },

      /**
       * Extracts S3 specific request ids from the http response.
       *
       * @api private
       */
      extractRequestIds: function extractRequestIds(resp) {
        var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-id-2'] : null;
        var cfId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-cf-id'] : null;
        resp.extendedRequestId = extendedRequestId;
        resp.cfId = cfId;

        if (resp.error) {
          resp.error.requestId = resp.requestId || null;
          resp.error.extendedRequestId = extendedRequestId;
          resp.error.cfId = cfId;
        }
      },

      /**
       * Get a pre-signed URL for a given operation name.
       *
       * @note You must ensure that you have static or previously resolved
       *   credentials if you call this method synchronously (with no callback),
       *   otherwise it may not properly sign the request. If you cannot guarantee
       *   this (you are using an asynchronous credential provider, i.e., EC2
       *   IAM roles), you should always call this method with an asynchronous
       *   callback.
       * @note Not all operation parameters are supported when using pre-signed
       *   URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
       *   `ContentLength`, or `Tagging` must be provided as headers when sending a
       *   request. If you are using pre-signed URLs to upload from a browser and
       *   need to use these fields, see {createPresignedPost}.
       * @note The default signer allows altering the request by adding corresponding
       *   headers to set some parameters (e.g. Range) and these added parameters
       *   won't be signed. You must use signatureVersion v4 to to include these
       *   parameters in the signed portion of the URL and enforce exact matching
       *   between headers and signed params in the URL.
       * @note This operation cannot be used with a promise. See note above regarding
       *   asynchronous credentials and use with a callback.
       * @param operation [String] the name of the operation to call
       * @param params [map] parameters to pass to the operation. See the given
       *   operation for the expected operation parameters. In addition, you can
       *   also pass the "Expires" parameter to inform S3 how long the URL should
       *   work for.
       * @option params Expires [Integer] (900) the number of seconds to expire
       *   the pre-signed URL operation in. Defaults to 15 minutes.
       * @param callback [Function] if a callback is provided, this function will
       *   pass the URL as the second parameter (after the error parameter) to
       *   the callback function.
       * @return [String] if called synchronously (with no callback), returns the
       *   signed URL.
       * @return [null] nothing is returned if a callback is provided.
       * @example Pre-signing a getObject operation (synchronously)
       *   var params = {Bucket: 'bucket', Key: 'key'};
       *   var url = s3.getSignedUrl('getObject', params);
       *   console.log('The URL is', url);
       * @example Pre-signing a putObject (asynchronously)
       *   var params = {Bucket: 'bucket', Key: 'key'};
       *   s3.getSignedUrl('putObject', params, function (err, url) {
       *     console.log('The URL is', url);
       *   });
       * @example Pre-signing a putObject operation with a specific payload
       *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
       *   var url = s3.getSignedUrl('putObject', params);
       *   console.log('The URL is', url);
       * @example Passing in a 1-minute expiry time for a pre-signed URL
       *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
       *   var url = s3.getSignedUrl('getObject', params);
       *   console.log('The URL is', url); // expires in 60 seconds
       */
      getSignedUrl: function getSignedUrl(operation, params, callback) {
        params = AWS.util.copy(params || {});
        var expires = params.Expires || 900;

        if (typeof expires !== 'number') {
          throw AWS.util.error(new Error(), {
            code: 'InvalidParameterException',
            message: 'The expiration must be a number, received ' + typeof expires
          });
        }

        delete params.Expires; // we can't validate this

        var request = this.makeRequest(operation, params);

        if (callback) {
          AWS.util.defer(function () {
            request.presign(expires, callback);
          });
        } else {
          return request.presign(expires, callback);
        }
      },

      /**
       * @!method  getSignedUrlPromise()
       *   Returns a 'thenable' promise that will be resolved with a pre-signed URL
       *   for a given operation name.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @note Not all operation parameters are supported when using pre-signed
       *      URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
       *      `ContentLength`, or `Tagging` must be provided as headers when sending a
       *      request. If you are using pre-signed URLs to upload from a browser and
       *      need to use these fields, see {createPresignedPost}.
       *   @param operation [String] the name of the operation to call
       *   @param params [map] parameters to pass to the operation. See the given
       *      operation for the expected operation parameters. In addition, you can
       *      also pass the "Expires" parameter to inform S3 how long the URL should
       *      work for.
       *   @option params Expires [Integer] (900) the number of seconds to expire
       *      the pre-signed URL operation in. Defaults to 15 minutes.
       *   @callback fulfilledCallback function(url)
       *     Called if the promise is fulfilled.
       *     @param url [String] the signed url
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] if an error occurred, this value will be filled
       *   @return [Promise] A promise that represents the state of the `refresh` call.
       *   @example Pre-signing a getObject operation
       *      var params = {Bucket: 'bucket', Key: 'key'};
       *      var promise = s3.getSignedUrlPromise('getObject', params);
       *      promise.then(function(url) {
       *        console.log('The URL is', url);
       *      }, function(err) { ... });
       *   @example Pre-signing a putObject operation with a specific payload
       *      var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
       *      var promise = s3.getSignedUrlPromise('putObject', params);
       *      promise.then(function(url) {
       *        console.log('The URL is', url);
       *      }, function(err) { ... });
       *   @example Passing in a 1-minute expiry time for a pre-signed URL
       *      var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
       *      var promise = s3.getSignedUrlPromise('getObject', params);
       *      promise.then(function(url) {
       *        console.log('The URL is', url);
       *      }, function(err) { ... });
       */

      /**
       * Get a pre-signed POST policy to support uploading to S3 directly from an
       * HTML form.
       *
       * @param params [map]
       * @option params Bucket [String]     The bucket to which the post should be
       *                                    uploaded
       * @option params Expires [Integer]   (3600) The number of seconds for which
       *                                    the presigned policy should be valid.
       * @option params Conditions [Array]  An array of conditions that must be met
       *                                    for the presigned policy to allow the
       *                                    upload. This can include required tags,
       *                                    the accepted range for content lengths,
       *                                    etc.
       * @see http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html
       * @option params Fields [map]        Fields to include in the form. All
       *                                    values passed in as fields will be
       *                                    signed as exact match conditions.
       * @param callback [Function]
       *
       * @note All fields passed in when creating presigned post data will be signed
       *   as exact match conditions. Any fields that will be interpolated by S3
       *   must be added to the fields hash after signing, and an appropriate
       *   condition for such fields must be explicitly added to the Conditions
       *   array passed to this function before signing.
       *
       * @example Presiging post data with a known key
       *   var params = {
       *     Bucket: 'bucket',
       *     Fields: {
       *       key: 'key'
       *     }
       *   };
       *   s3.createPresignedPost(params, function(err, data) {
       *     if (err) {
       *       console.error('Presigning post data encountered an error', err);
       *     } else {
       *       console.log('The post data is', data);
       *     }
       *   });
       *
       * @example Presigning post data with an interpolated key
       *   var params = {
       *     Bucket: 'bucket',
       *     Conditions: [
       *       ['starts-with', '$key', 'path/to/uploads/']
       *     ]
       *   };
       *   s3.createPresignedPost(params, function(err, data) {
       *     if (err) {
       *       console.error('Presigning post data encountered an error', err);
       *     } else {
       *       data.Fields.key = 'path/to/uploads/${filename}';
       *       console.log('The post data is', data);
       *     }
       *   });
       *
       * @note You must ensure that you have static or previously resolved
       *   credentials if you call this method synchronously (with no callback),
       *   otherwise it may not properly sign the request. If you cannot guarantee
       *   this (you are using an asynchronous credential provider, i.e., EC2
       *   IAM roles), you should always call this method with an asynchronous
       *   callback.
       *
       * @return [map]  If called synchronously (with no callback), returns a hash
       *                with the url to set as the form action and a hash of fields
       *                to include in the form.
       * @return [null] Nothing is returned if a callback is provided.
       *
       * @callback callback function (err, data)
       *  @param err [Error] the error object returned from the policy signer
       *  @param data [map] The data necessary to construct an HTML form
       *  @param data.url [String] The URL to use as the action of the form
       *  @param data.fields [map] A hash of fields that must be included in the
       *                           form for the upload to succeed. This hash will
       *                           include the signed POST policy, your access key
       *                           ID and security token (if present), etc. These
       *                           may be safely included as input elements of type
       *                           'hidden.'
       */
      createPresignedPost: function createPresignedPost(params, callback) {
        if (typeof params === 'function' && callback === undefined) {
          callback = params;
          params = null;
        }

        params = AWS.util.copy(params || {});
        var boundParams = this.config.params || {};
        var bucket = params.Bucket || boundParams.Bucket,
            self = this,
            config = this.config,
            endpoint = AWS.util.copy(this.endpoint);

        if (!config.s3BucketEndpoint) {
          endpoint.pathname = '/' + bucket;
        }

        function finalizePost() {
          return {
            url: AWS.util.urlFormat(endpoint),
            fields: self.preparePostFields(config.credentials, config.region, bucket, params.Fields, params.Conditions, params.Expires)
          };
        }

        if (callback) {
          config.getCredentials(function (err) {
            if (err) {
              callback(err);
            } else {
              try {
                callback(null, finalizePost());
              } catch (err) {
                callback(err);
              }
            }
          });
        } else {
          return finalizePost();
        }
      },

      /**
       * @api private
       */
      preparePostFields: function preparePostFields(credentials, region, bucket, fields, conditions, expiresInSeconds) {
        var now = this.getSkewCorrectedDate();

        if (!credentials || !region || !bucket) {
          throw new Error('Unable to create a POST object policy without a bucket,' + ' region, and credentials');
        }

        fields = AWS.util.copy(fields || {});
        conditions = (conditions || []).slice(0);
        expiresInSeconds = expiresInSeconds || 3600;
        var signingDate = AWS.util.date.iso8601(now).replace(/[:\-]|\.\d{3}/g, '');
        var shortDate = signingDate.substr(0, 8);
        var scope = v4Credentials.createScope(shortDate, region, 's3');
        var credential = credentials.accessKeyId + '/' + scope;
        fields['bucket'] = bucket;
        fields['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
        fields['X-Amz-Credential'] = credential;
        fields['X-Amz-Date'] = signingDate;

        if (credentials.sessionToken) {
          fields['X-Amz-Security-Token'] = credentials.sessionToken;
        }

        for (var field in fields) {
          if (fields.hasOwnProperty(field)) {
            var condition = {};
            condition[field] = fields[field];
            conditions.push(condition);
          }
        }

        fields.Policy = this.preparePostPolicy(new Date(now.valueOf() + expiresInSeconds * 1000), conditions);
        fields['X-Amz-Signature'] = AWS.util.crypto.hmac(v4Credentials.getSigningKey(credentials, shortDate, region, 's3', true), fields.Policy, 'hex');
        return fields;
      },

      /**
       * @api private
       */
      preparePostPolicy: function preparePostPolicy(expiration, conditions) {
        return AWS.util.base64.encode(JSON.stringify({
          expiration: AWS.util.date.iso8601(expiration),
          conditions: conditions
        }));
      },

      /**
       * @api private
       */
      prepareSignedUrl: function prepareSignedUrl(request) {
        request.addListener('validate', request.service.noPresignedContentLength);
        request.removeListener('build', request.service.addContentType);

        if (!request.params.Body) {
          // no Content-MD5/SHA-256 if body is not provided
          request.removeListener('build', request.service.computeContentMd5);
        } else {
          request.addListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
        }
      },

      /**
       * @api private
       * @param request
       */
      disableBodySigning: function disableBodySigning(request) {
        var headers = request.httpRequest.headers; // Add the header to anything that isn't a presigned url, unless that presigned url had a body defined

        if (!Object.prototype.hasOwnProperty.call(headers, 'presigned-expires')) {
          headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
        }
      },

      /**
       * @api private
       */
      noPresignedContentLength: function noPresignedContentLength(request) {
        if (request.params.ContentLength !== undefined) {
          throw AWS.util.error(new Error(), {
            code: 'UnexpectedParameter',
            message: 'ContentLength is not supported in pre-signed URLs.'
          });
        }
      },
      createBucket: function createBucket(params, callback) {
        // When creating a bucket *outside* the classic region, the location
        // constraint must be set for the bucket and it must match the endpoint.
        // This chunk of code will set the location constraint param based
        // on the region (when possible), but it will not override a passed-in
        // location constraint.
        if (typeof params === 'function' || !params) {
          callback = callback || params;
          params = {};
        }

        var hostname = this.endpoint.hostname; // copy params so that appending keys does not unintentioinallly
        // mutate params object argument passed in by user

        var copiedParams = AWS.util.copy(params);

        if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
          copiedParams.CreateBucketConfiguration = {
            LocationConstraint: this.config.region
          };
        }

        return this.makeRequest('createBucket', copiedParams, callback);
      },

      /**
       * @see AWS.S3.ManagedUpload
       * @overload upload(params = {}, [options], [callback])
       *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
       *   concurrent handling of parts if the payload is large enough. You can
       *   configure the concurrent queue size by setting `options`. Note that this
       *   is the only operation for which the SDK can retry requests with stream
       *   bodies.
       *
       *   @param (see AWS.S3.putObject)
       *   @option (see AWS.S3.ManagedUpload.constructor)
       *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
       *     `send()` or track progress.
       *   @example Uploading a stream object
       *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
       *     s3.upload(params, function(err, data) {
       *       console.log(err, data);
       *     });
       *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
       *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
       *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
       *     s3.upload(params, options, function(err, data) {
       *       console.log(err, data);
       *     });
       * @callback callback function(err, data)
       *   @param err [Error] an error or null if no error occurred.
       *   @param data [map] The response data from the successful upload:
       *   @param data.Location [String] the URL of the uploaded object
       *   @param data.ETag [String] the ETag of the uploaded object
       *   @param data.Bucket [String]  the bucket to which the object was uploaded
       *   @param data.Key [String] the key to which the object was uploaded
       */
      upload: function upload(params, options, callback) {
        if (typeof options === 'function' && callback === undefined) {
          callback = options;
          options = null;
        }

        options = options || {};
        options = AWS.util.merge(options || {}, {
          service: this,
          params: params
        });
        var uploader = new AWS.S3.ManagedUpload(options);
        if (typeof callback === 'function') uploader.send(callback);
        return uploader;
      }
    });
    /**
     * @api private
     */

    AWS.S3.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getSignedUrlPromise = AWS.util.promisifyMethod('getSignedUrl', PromiseDependency);
    };
    /**
     * @api private
     */


    AWS.S3.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getSignedUrlPromise;
    };

    AWS.util.addPromises(AWS.S3);
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/services/s3util.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/services/s3util.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibServicesS3utilJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var regionUtil = __webpack_require__(
    /*! ../region_config */
    "./node_modules/aws-sdk/lib/region_config.js");

    var s3util = {
      /**
       * @api private
       */
      isArnInParam: function isArnInParam(req, paramName) {
        var inputShape = (req.service.api.operations[req.operation] || {}).input || {};
        var inputMembers = inputShape.members || {};
        if (!req.params[paramName] || !inputMembers[paramName]) return false;
        return AWS.util.ARN.validate(req.params[paramName]);
      },

      /**
       * Validate service component from ARN supplied in Bucket parameter
       */
      validateArnService: function validateArnService(req) {
        var parsedArn = req.service._parsedArn;

        if (parsedArn.service !== 's3' && parsedArn.service !== 's3-outposts') {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'expect \'s3\' or \'s3-outposts\' in ARN service component'
          });
        }
      },

      /**
       * Validate account ID from ARN supplied in Bucket parameter is a valid account
       */
      validateArnAccount: function validateArnAccount(req) {
        var parsedArn = req.service._parsedArn;

        if (!/[0-9]{12}/.exec(parsedArn.accountId)) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'ARN accountID does not match regex "[0-9]{12}"'
          });
        }
      },

      /**
       * Validate ARN supplied in Bucket parameter is a valid access point ARN
       */
      validateS3AccessPointArn: function validateS3AccessPointArn(req) {
        var parsedArn = req.service._parsedArn; //can be ':' or '/'

        var delimiter = parsedArn.resource['accesspoint'.length];

        if (parsedArn.resource.split(delimiter).length !== 2) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'Access Point ARN should have one resource accesspoint/{accesspointName}'
          });
        }

        var accessPoint = parsedArn.resource.split(delimiter)[1];
        var accessPointPrefix = accessPoint + '-' + parsedArn.accountId;

        if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'Access point resource in ARN is not DNS compatible. Got ' + accessPoint
          });
        } //set parsed valid access point


        req.service._parsedArn.accessPoint = accessPoint;
      },

      /**
       * Validate Outposts ARN supplied in Bucket parameter is a valid outposts ARN
       */
      validateOutpostsArn: function validateOutpostsArn(req) {
        var parsedArn = req.service._parsedArn;

        if (parsedArn.resource.indexOf('outpost:') !== 0 && parsedArn.resource.indexOf('outpost/') !== 0) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'ARN resource should begin with \'outpost/\''
          });
        } //can be ':' or '/'


        var delimiter = parsedArn.resource['outpost'.length];
        var outpostId = parsedArn.resource.split(delimiter)[1];
        var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);

        if (!dnsHostRegex.test(outpostId)) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'Outpost resource in ARN is not DNS compatible. Got ' + outpostId
          });
        }

        req.service._parsedArn.outpostId = outpostId;
      },

      /**
       * Validate Outposts ARN supplied in Bucket parameter is a valid outposts ARN
       */
      validateOutpostsAccessPointArn: function validateOutpostsAccessPointArn(req) {
        var parsedArn = req.service._parsedArn; //can be ':' or '/'

        var delimiter = parsedArn.resource['outpost'.length];

        if (parsedArn.resource.split(delimiter).length !== 4) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'Outposts ARN should have two resources outpost/{outpostId}/accesspoint/{accesspointName}'
          });
        }

        var accessPoint = parsedArn.resource.split(delimiter)[3];
        var accessPointPrefix = accessPoint + '-' + parsedArn.accountId;

        if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'Access point resource in ARN is not DNS compatible. Got ' + accessPoint
          });
        } //set parsed valid access point


        req.service._parsedArn.accessPoint = accessPoint;
      },

      /**
       * Validate region field in ARN supplied in Bucket parameter is a valid region
       */
      validateArnRegion: function validateArnRegion(req) {
        var useArnRegion = s3util.loadUseArnRegionConfig(req);
        var regionFromArn = req.service._parsedArn.region;
        var clientRegion = req.service.config.region;

        if (!regionFromArn) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidARN',
            message: 'ARN region is empty'
          });
        }

        if (clientRegion.indexOf('fips') >= 0 || regionFromArn.indexOf('fips') >= 0) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: 'ARN endpoint is not compatible with FIPS region'
          });
        }

        if (!useArnRegion && regionFromArn !== clientRegion) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: 'Configured region conflicts with access point region'
          });
        } else if (useArnRegion && regionUtil.getEndpointSuffix(regionFromArn) !== regionUtil.getEndpointSuffix(clientRegion)) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: 'Configured region and access point region not in same partition'
          });
        }

        if (req.service.config.useAccelerateEndpoint) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: 'useAccelerateEndpoint config is not supported with access point ARN'
          });
        }

        if (req.service._parsedArn.service === 's3-outposts' && req.service.config.useDualstack) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: 'useDualstack config is not supported with outposts access point ARN'
          });
        }
      },
      loadUseArnRegionConfig: function loadUseArnRegionConfig(req) {
        var envName = 'AWS_S3_USE_ARN_REGION';
        var configName = 's3_use_arn_region';
        var useArnRegion = true;
        var originalConfig = req.service._originalConfig || {};

        if (req.service.config.s3UseArnRegion !== undefined) {
          return req.service.config.s3UseArnRegion;
        } else if (originalConfig.s3UseArnRegion !== undefined) {
          useArnRegion = originalConfig.s3UseArnRegion === true;
        } else if (AWS.util.isNode()) {
          //load from environmental variable AWS_USE_ARN_REGION
          if (process.env[envName]) {
            var value = process.env[envName].trim().toLowerCase();

            if (['false', 'true'].indexOf(value) < 0) {
              throw AWS.util.error(new Error(), {
                code: 'InvalidConfiguration',
                message: envName + ' only accepts true or false. Got ' + process.env[envName],
                retryable: false
              });
            }

            useArnRegion = value === 'true';
          } else {
            //load from shared config property use_arn_region
            var profiles = {};
            var profile = {};

            try {
              profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
              profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
            } catch (e) {}

            if (profile[configName]) {
              if (['false', 'true'].indexOf(profile[configName].trim().toLowerCase()) < 0) {
                throw AWS.util.error(new Error(), {
                  code: 'InvalidConfiguration',
                  message: configName + ' only accepts true or false. Got ' + profile[configName],
                  retryable: false
                });
              }

              useArnRegion = profile[configName].trim().toLowerCase() === 'true';
            }
          }
        }

        req.service.config.s3UseArnRegion = useArnRegion;
        return useArnRegion;
      },

      /**
       * Validations before URI can be populated
       */
      validatePopulateUriFromArn: function validatePopulateUriFromArn(req) {
        if (req.service._originalConfig && req.service._originalConfig.endpoint) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: 'Custom endpoint is not compatible with access point ARN'
          });
        }

        if (req.service.config.s3ForcePathStyle) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: 'Cannot construct path-style endpoint with access point'
          });
        }
      },

      /**
       * Returns true if the bucket name is DNS compatible.  Buckets created
       * outside of the classic region MUST be DNS compatible.
       *
       * @api private
       */
      dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {
        var b = bucketName;
        var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
        var ipAddress = new RegExp(/(\d+\.){3}\d+/);
        var dots = new RegExp(/\.\./);
        return b.match(domain) && !b.match(ipAddress) && !b.match(dots) ? true : false;
      }
    };
    /**
     * @api private
     */

    module.exports = s3util;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/services/sts.js":
  /*!**************************************************!*\
    !*** ./node_modules/aws-sdk/lib/services/sts.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibServicesStsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var resolveRegionalEndpointsFlag = __webpack_require__(
    /*! ../config_regional_endpoint */
    "./node_modules/aws-sdk/lib/config_regional_endpoint.js");

    var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';
    var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';
    AWS.util.update(AWS.STS.prototype, {
      /**
       * @overload credentialsFrom(data, credentials = null)
       *   Creates a credentials object from STS response data containing
       *   credentials information. Useful for quickly setting AWS credentials.
       *
       *   @note This is a low-level utility function. If you want to load temporary
       *     credentials into your process for subsequent requests to AWS resources,
       *     you should use {AWS.TemporaryCredentials} instead.
       *   @param data [map] data retrieved from a call to {getFederatedToken},
       *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
       *   @param credentials [AWS.Credentials] an optional credentials object to
       *     fill instead of creating a new object. Useful when modifying an
       *     existing credentials object from a refresh call.
       *   @return [AWS.TemporaryCredentials] the set of temporary credentials
       *     loaded from a raw STS operation response.
       *   @example Using credentialsFrom to load global AWS credentials
       *     var sts = new AWS.STS();
       *     sts.getSessionToken(function (err, data) {
       *       if (err) console.log("Error getting credentials");
       *       else {
       *         AWS.config.credentials = sts.credentialsFrom(data);
       *       }
       *     });
       *   @see AWS.TemporaryCredentials
       */
      credentialsFrom: function credentialsFrom(data, credentials) {
        if (!data) return null;
        if (!credentials) credentials = new AWS.TemporaryCredentials();
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretAccessKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
        return credentials;
      },
      assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
        return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
      },
      assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
        return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
      },

      /**
       * @api private
       */
      setupRequestListeners: function setupRequestListeners(request) {
        request.addListener('validate', this.optInRegionalEndpoint, true);
      },

      /**
       * @api private
       */
      optInRegionalEndpoint: function optInRegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: ENV_REGIONAL_ENDPOINT_ENABLED,
          sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
          clientConfig: 'stsRegionalEndpoints'
        });

        if (config.stsRegionalEndpoints === 'regional' && service.isGlobalEndpoint) {
          //client will throw if region is not supplied; request will be signed with specified region
          if (!config.region) {
            throw AWS.util.error(new Error(), {
              code: 'ConfigError',
              message: 'Missing region in config'
            });
          }

          var insertPoint = config.endpoint.indexOf('.amazonaws.com');
          var regionalEndpoint = config.endpoint.substring(0, insertPoint) + '.' + config.region + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint);
          req.httpRequest.region = config.region;
        }
      }
    });
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/signers/presign.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/presign.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersPresignJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;
    /**
     * @api private
     */

    var expiresHeader = 'presigned-expires';
    /**
     * @api private
     */

    function signedUrlBuilder(request) {
      var expires = request.httpRequest.headers[expiresHeader];
      var signerClass = request.service.getSignerClass(request);
      delete request.httpRequest.headers['User-Agent'];
      delete request.httpRequest.headers['X-Amz-User-Agent'];

      if (signerClass === AWS.Signers.V4) {
        if (expires > 604800) {
          // one week expiry is invalid
          var message = 'Presigning does not support expiry time greater ' + 'than a week with SigV4 signing.';
          throw AWS.util.error(new Error(), {
            code: 'InvalidExpiryTime',
            message: message,
            retryable: false
          });
        }

        request.httpRequest.headers[expiresHeader] = expires;
      } else if (signerClass === AWS.Signers.S3) {
        var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();
        request.httpRequest.headers[expiresHeader] = parseInt(AWS.util.date.unixTimestamp(now) + expires, 10).toString();
      } else {
        throw AWS.util.error(new Error(), {
          message: 'Presigning only supports S3 or SigV4 signing.',
          code: 'UnsupportedSigner',
          retryable: false
        });
      }
    }
    /**
     * @api private
     */


    function signedUrlSigner(request) {
      var endpoint = request.httpRequest.endpoint;
      var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
      var queryParams = {};

      if (parsedUrl.search) {
        queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
      }

      var auth = request.httpRequest.headers['Authorization'].split(' ');

      if (auth[0] === 'AWS') {
        auth = auth[1].split(':');
        queryParams['Signature'] = auth.pop();
        queryParams['AWSAccessKeyId'] = auth.join(':');
        AWS.util.each(request.httpRequest.headers, function (key, value) {
          if (key === expiresHeader) key = 'Expires';

          if (key.indexOf('x-amz-meta-') === 0) {
            // Delete existing, potentially not normalized key
            delete queryParams[key];
            key = key.toLowerCase();
          }

          queryParams[key] = value;
        });
        delete request.httpRequest.headers[expiresHeader];
        delete queryParams['Authorization'];
        delete queryParams['Host'];
      } else if (auth[0] === 'AWS4-HMAC-SHA256') {
        // SigV4 signing
        auth.shift();
        var rest = auth.join(' ');
        var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
        queryParams['X-Amz-Signature'] = signature;
        delete queryParams['Expires'];
      } // build URL


      endpoint.pathname = parsedUrl.pathname;
      endpoint.search = AWS.util.queryParamsToString(queryParams);
    }
    /**
     * @api private
     */


    AWS.Signers.Presign = inherit({
      /**
       * @api private
       */
      sign: function sign(request, expireTime, callback) {
        request.httpRequest.headers[expiresHeader] = expireTime || 3600;
        request.on('build', signedUrlBuilder);
        request.on('sign', signedUrlSigner);
        request.removeListener('afterBuild', AWS.EventListeners.Core.SET_CONTENT_LENGTH);
        request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
        request.emit('beforePresign', [request]);

        if (callback) {
          request.build(function () {
            if (this.response.error) callback(this.response.error);else {
              callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
            }
          });
        } else {
          request.build();
          if (request.response.error) throw request.response.error;
          return AWS.util.urlFormat(request.httpRequest.endpoint);
        }
      }
    });
    /**
     * @api private
     */

    module.exports = AWS.Signers.Presign;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/signers/request_signer.js":
  /*!************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/request_signer.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersRequest_signerJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;
    /**
     * @api private
     */

    AWS.Signers.RequestSigner = inherit({
      constructor: function RequestSigner(request) {
        this.request = request;
      },
      setServiceClientId: function setServiceClientId(id) {
        this.serviceClientId = id;
      },
      getServiceClientId: function getServiceClientId() {
        return this.serviceClientId;
      }
    });

    AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
      switch (version) {
        case 'v2':
          return AWS.Signers.V2;

        case 'v3':
          return AWS.Signers.V3;

        case 's3v4':
          return AWS.Signers.V4;

        case 'v4':
          return AWS.Signers.V4;

        case 's3':
          return AWS.Signers.S3;

        case 'v3https':
          return AWS.Signers.V3Https;
      }

      throw new Error('Unknown signing version ' + version);
    };

    __webpack_require__(
    /*! ./v2 */
    "./node_modules/aws-sdk/lib/signers/v2.js");

    __webpack_require__(
    /*! ./v3 */
    "./node_modules/aws-sdk/lib/signers/v3.js");

    __webpack_require__(
    /*! ./v3https */
    "./node_modules/aws-sdk/lib/signers/v3https.js");

    __webpack_require__(
    /*! ./v4 */
    "./node_modules/aws-sdk/lib/signers/v4.js");

    __webpack_require__(
    /*! ./s3 */
    "./node_modules/aws-sdk/lib/signers/s3.js");

    __webpack_require__(
    /*! ./presign */
    "./node_modules/aws-sdk/lib/signers/presign.js");
    /***/

  },

  /***/
  "./node_modules/aws-sdk/lib/signers/s3.js":
  /*!************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/s3.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersS3Js(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;
    /**
     * @api private
     */

    AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
      /**
       * When building the stringToSign, these sub resource params should be
       * part of the canonical resource string with their NON-decoded values
       */
      subResources: {
        'acl': 1,
        'accelerate': 1,
        'analytics': 1,
        'cors': 1,
        'lifecycle': 1,
        'delete': 1,
        'inventory': 1,
        'location': 1,
        'logging': 1,
        'metrics': 1,
        'notification': 1,
        'partNumber': 1,
        'policy': 1,
        'requestPayment': 1,
        'replication': 1,
        'restore': 1,
        'tagging': 1,
        'torrent': 1,
        'uploadId': 1,
        'uploads': 1,
        'versionId': 1,
        'versioning': 1,
        'versions': 1,
        'website': 1
      },
      // when building the stringToSign, these querystring params should be
      // part of the canonical resource string with their NON-encoded values
      responseHeaders: {
        'response-content-type': 1,
        'response-content-language': 1,
        'response-expires': 1,
        'response-cache-control': 1,
        'response-content-disposition': 1,
        'response-content-encoding': 1
      },
      addAuthorization: function addAuthorization(credentials, date) {
        if (!this.request.headers['presigned-expires']) {
          this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
        }

        if (credentials.sessionToken) {
          // presigned URLs require this header to be lowercased
          this.request.headers['x-amz-security-token'] = credentials.sessionToken;
        }

        var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
        var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;
        this.request.headers['Authorization'] = auth;
      },
      stringToSign: function stringToSign() {
        var r = this.request;
        var parts = [];
        parts.push(r.method);
        parts.push(r.headers['Content-MD5'] || '');
        parts.push(r.headers['Content-Type'] || ''); // This is the "Date" header, but we use X-Amz-Date.
        // The S3 signing mechanism requires us to pass an empty
        // string for this Date header regardless.

        parts.push(r.headers['presigned-expires'] || '');
        var headers = this.canonicalizedAmzHeaders();
        if (headers) parts.push(headers);
        parts.push(this.canonicalizedResource());
        return parts.join('\n');
      },
      canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {
        var amzHeaders = [];
        AWS.util.each(this.request.headers, function (name) {
          if (name.match(/^x-amz-/i)) amzHeaders.push(name);
        });
        amzHeaders.sort(function (a, b) {
          return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS.util.arrayEach.call(this, amzHeaders, function (name) {
          parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
        });
        return parts.join('\n');
      },
      canonicalizedResource: function canonicalizedResource() {
        var r = this.request;
        var parts = r.path.split('?');
        var path = parts[0];
        var querystring = parts[1];
        var resource = '';
        if (r.virtualHostedBucket) resource += '/' + r.virtualHostedBucket;
        resource += path;

        if (querystring) {
          // collect a list of sub resources and query params that need to be signed
          var resources = [];
          AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
            var name = param.split('=')[0];
            var value = param.split('=')[1];

            if (this.subResources[name] || this.responseHeaders[name]) {
              var subresource = {
                name: name
              };

              if (value !== undefined) {
                if (this.subResources[name]) {
                  subresource.value = value;
                } else {
                  subresource.value = decodeURIComponent(value);
                }
              }

              resources.push(subresource);
            }
          });
          resources.sort(function (a, b) {
            return a.name < b.name ? -1 : 1;
          });

          if (resources.length) {
            querystring = [];
            AWS.util.arrayEach(resources, function (res) {
              if (res.value === undefined) {
                querystring.push(res.name);
              } else {
                querystring.push(res.name + '=' + res.value);
              }
            });
            resource += '?' + querystring.join('&');
          }
        }

        return resource;
      },
      sign: function sign(secret, string) {
        return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
      }
    });
    /**
     * @api private
     */

    module.exports = AWS.Signers.S3;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/signers/v2.js":
  /*!************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/v2.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersV2Js(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;
    /**
     * @api private
     */

    AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        if (!date) date = AWS.util.date.getDate();
        var r = this.request;
        r.params.Timestamp = AWS.util.date.iso8601(date);
        r.params.SignatureVersion = '2';
        r.params.SignatureMethod = 'HmacSHA256';
        r.params.AWSAccessKeyId = credentials.accessKeyId;

        if (credentials.sessionToken) {
          r.params.SecurityToken = credentials.sessionToken;
        }

        delete r.params.Signature; // delete old Signature for re-signing

        r.params.Signature = this.signature(credentials);
        r.body = AWS.util.queryParamsToString(r.params);
        r.headers['Content-Length'] = r.body.length;
      },
      signature: function signature(credentials) {
        return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push(this.request.endpoint.host.toLowerCase());
        parts.push(this.request.pathname());
        parts.push(AWS.util.queryParamsToString(this.request.params));
        return parts.join('\n');
      }
    });
    /**
     * @api private
     */

    module.exports = AWS.Signers.V2;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/signers/v3.js":
  /*!************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/v3.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersV3Js(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;
    /**
     * @api private
     */

    AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS.util.date.rfc822(date);
        this.request.headers['X-Amz-Date'] = datetime;

        if (credentials.sessionToken) {
          this.request.headers['x-amz-security-token'] = credentials.sessionToken;
        }

        this.request.headers['X-Amzn-Authorization'] = this.authorization(credentials, datetime);
      },
      authorization: function authorization(credentials) {
        return 'AWS3 ' + 'AWSAccessKeyId=' + credentials.accessKeyId + ',' + 'Algorithm=HmacSHA256,' + 'SignedHeaders=' + this.signedHeaders() + ',' + 'Signature=' + this.signature(credentials);
      },
      signedHeaders: function signedHeaders() {
        var headers = [];
        AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
          headers.push(h.toLowerCase());
        });
        return headers.sort().join(';');
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = this.request.headers;
        var parts = [];
        AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
          parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
        });
        return parts.sort().join('\n') + '\n';
      },
      headersToSign: function headersToSign() {
        var headers = [];
        AWS.util.each(this.request.headers, function iterator(k) {
          if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
            headers.push(k);
          }
        });
        return headers;
      },
      signature: function signature(credentials) {
        return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push('/');
        parts.push('');
        parts.push(this.canonicalHeaders());
        parts.push(this.request.body);
        return AWS.util.crypto.sha256(parts.join('\n'));
      }
    });
    /**
     * @api private
     */

    module.exports = AWS.Signers.V3;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/signers/v3https.js":
  /*!*****************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/v3https.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersV3httpsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var inherit = AWS.util.inherit;

    __webpack_require__(
    /*! ./v3 */
    "./node_modules/aws-sdk/lib/signers/v3.js");
    /**
     * @api private
     */


    AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
      authorization: function authorization(credentials) {
        return 'AWS3-HTTPS ' + 'AWSAccessKeyId=' + credentials.accessKeyId + ',' + 'Algorithm=HmacSHA256,' + 'Signature=' + this.signature(credentials);
      },
      stringToSign: function stringToSign() {
        return this.request.headers['X-Amz-Date'];
      }
    });
    /**
     * @api private
     */

    module.exports = AWS.Signers.V3Https;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/signers/v4.js":
  /*!************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/v4.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersV4Js(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");

    var v4Credentials = __webpack_require__(
    /*! ./v4_credentials */
    "./node_modules/aws-sdk/lib/signers/v4_credentials.js");

    var inherit = AWS.util.inherit;
    /**
     * @api private
     */

    var expiresHeader = 'presigned-expires';
    /**
     * @api private
     */

    AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
      constructor: function V4(request, serviceName, options) {
        AWS.Signers.RequestSigner.call(this, request);
        this.serviceName = serviceName;
        options = options || {};
        this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
        this.operation = options.operation;
        this.signatureVersion = options.signatureVersion;
      },
      algorithm: 'AWS4-HMAC-SHA256',
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

        if (this.isPresigned()) {
          this.updateForPresigned(credentials, datetime);
        } else {
          this.addHeaders(credentials, datetime);
        }

        this.request.headers['Authorization'] = this.authorization(credentials, datetime);
      },
      addHeaders: function addHeaders(credentials, datetime) {
        this.request.headers['X-Amz-Date'] = datetime;

        if (credentials.sessionToken) {
          this.request.headers['x-amz-security-token'] = credentials.sessionToken;
        }
      },
      updateForPresigned: function updateForPresigned(credentials, datetime) {
        var credString = this.credentialString(datetime);
        var qs = {
          'X-Amz-Date': datetime,
          'X-Amz-Algorithm': this.algorithm,
          'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
          'X-Amz-Expires': this.request.headers[expiresHeader],
          'X-Amz-SignedHeaders': this.signedHeaders()
        };

        if (credentials.sessionToken) {
          qs['X-Amz-Security-Token'] = credentials.sessionToken;
        }

        if (this.request.headers['Content-Type']) {
          qs['Content-Type'] = this.request.headers['Content-Type'];
        }

        if (this.request.headers['Content-MD5']) {
          qs['Content-MD5'] = this.request.headers['Content-MD5'];
        }

        if (this.request.headers['Cache-Control']) {
          qs['Cache-Control'] = this.request.headers['Cache-Control'];
        } // need to pull in any other X-Amz-* headers


        AWS.util.each.call(this, this.request.headers, function (key, value) {
          if (key === expiresHeader) return;

          if (this.isSignableHeader(key)) {
            var lowerKey = key.toLowerCase(); // Metadata should be normalized

            if (lowerKey.indexOf('x-amz-meta-') === 0) {
              qs[lowerKey] = value;
            } else if (lowerKey.indexOf('x-amz-') === 0) {
              qs[key] = value;
            }
          }
        });
        var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
        this.request.path += sep + AWS.util.queryParamsToString(qs);
      },
      authorization: function authorization(credentials, datetime) {
        var parts = [];
        var credString = this.credentialString(datetime);
        parts.push(this.algorithm + ' Credential=' + credentials.accessKeyId + '/' + credString);
        parts.push('SignedHeaders=' + this.signedHeaders());
        parts.push('Signature=' + this.signature(credentials, datetime));
        return parts.join(', ');
      },
      signature: function signature(credentials, datetime) {
        var signingKey = v4Credentials.getSigningKey(credentials, datetime.substr(0, 8), this.request.region, this.serviceName, this.signatureCache);
        return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
      },
      stringToSign: function stringToSign(datetime) {
        var parts = [];
        parts.push('AWS4-HMAC-SHA256');
        parts.push(datetime);
        parts.push(this.credentialString(datetime));
        parts.push(this.hexEncodedHash(this.canonicalString()));
        return parts.join('\n');
      },
      canonicalString: function canonicalString() {
        var parts = [],
            pathname = this.request.pathname();
        if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS.util.uriEscapePath(pathname);
        parts.push(this.request.method);
        parts.push(pathname);
        parts.push(this.request.search());
        parts.push(this.canonicalHeaders() + '\n');
        parts.push(this.signedHeaders());
        parts.push(this.hexEncodedBodyHash());
        return parts.join('\n');
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = [];
        AWS.util.each.call(this, this.request.headers, function (key, item) {
          headers.push([key, item]);
        });
        headers.sort(function (a, b) {
          return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS.util.arrayEach.call(this, headers, function (item) {
          var key = item[0].toLowerCase();

          if (this.isSignableHeader(key)) {
            var value = item[1];

            if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
              throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
                code: 'InvalidHeader'
              });
            }

            parts.push(key + ':' + this.canonicalHeaderValues(value.toString()));
          }
        });
        return parts.join('\n');
      },
      canonicalHeaderValues: function canonicalHeaderValues(values) {
        return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
      },
      signedHeaders: function signedHeaders() {
        var keys = [];
        AWS.util.each.call(this, this.request.headers, function (key) {
          key = key.toLowerCase();
          if (this.isSignableHeader(key)) keys.push(key);
        });
        return keys.sort().join(';');
      },
      credentialString: function credentialString(datetime) {
        return v4Credentials.createScope(datetime.substr(0, 8), this.request.region, this.serviceName);
      },
      hexEncodedHash: function hash(string) {
        return AWS.util.crypto.sha256(string, 'hex');
      },
      hexEncodedBodyHash: function hexEncodedBodyHash() {
        var request = this.request;

        if (this.isPresigned() && this.serviceName === 's3' && !request.body) {
          return 'UNSIGNED-PAYLOAD';
        } else if (request.headers['X-Amz-Content-Sha256']) {
          return request.headers['X-Amz-Content-Sha256'];
        } else {
          return this.hexEncodedHash(this.request.body || '');
        }
      },
      unsignableHeaders: ['authorization', 'content-type', 'content-length', 'user-agent', expiresHeader, 'expect', 'x-amzn-trace-id'],
      isSignableHeader: function isSignableHeader(key) {
        if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
        return this.unsignableHeaders.indexOf(key) < 0;
      },
      isPresigned: function isPresigned() {
        return this.request.headers[expiresHeader] ? true : false;
      }
    });
    /**
     * @api private
     */

    module.exports = AWS.Signers.V4;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/signers/v4_credentials.js":
  /*!************************************************************!*\
    !*** ./node_modules/aws-sdk/lib/signers/v4_credentials.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibSignersV4_credentialsJs(module, exports, __webpack_require__) {
    var AWS = __webpack_require__(
    /*! ../core */
    "./node_modules/aws-sdk/lib/core.js");
    /**
     * @api private
     */


    var cachedSecret = {};
    /**
     * @api private
     */

    var cacheQueue = [];
    /**
     * @api private
     */

    var maxCacheEntries = 50;
    /**
     * @api private
     */

    var v4Identifier = 'aws4_request';
    /**
     * @api private
     */

    module.exports = {
      /**
       * @api private
       *
       * @param date [String]
       * @param region [String]
       * @param serviceName [String]
       * @return [String]
       */
      createScope: function createScope(date, region, serviceName) {
        return [date.substr(0, 8), region, serviceName, v4Identifier].join('/');
      },

      /**
       * @api private
       *
       * @param credentials [Credentials]
       * @param date [String]
       * @param region [String]
       * @param service [String]
       * @param shouldCache [Boolean]
       * @return [String]
       */
      getSigningKey: function getSigningKey(credentials, date, region, service, shouldCache) {
        var credsIdentifier = AWS.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
        var cacheKey = [credsIdentifier, date, region, service].join('_');
        shouldCache = shouldCache !== false;

        if (shouldCache && cacheKey in cachedSecret) {
          return cachedSecret[cacheKey];
        }

        var kDate = AWS.util.crypto.hmac('AWS4' + credentials.secretAccessKey, date, 'buffer');
        var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
        var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');
        var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');

        if (shouldCache) {
          cachedSecret[cacheKey] = signingKey;
          cacheQueue.push(cacheKey);

          if (cacheQueue.length > maxCacheEntries) {
            // remove the oldest entry (not the least recently used)
            delete cachedSecret[cacheQueue.shift()];
          }
        }

        return signingKey;
      },

      /**
       * @api private
       *
       * Empties the derived signing key cache. Made available for testing purposes
       * only.
       */
      emptyCache: function emptyCache() {
        cachedSecret = {};
        cacheQueue = [];
      }
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/state_machine.js":
  /*!***************************************************!*\
    !*** ./node_modules/aws-sdk/lib/state_machine.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibState_machineJs(module, exports) {
    function AcceptorStateMachine(states, state) {
      this.currentState = state || null;
      this.states = states || {};
    }

    AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
      if (typeof finalState === 'function') {
        inputError = bindObject;
        bindObject = done;
        done = finalState;
        finalState = null;
      }

      var self = this;
      var state = self.states[self.currentState];
      state.fn.call(bindObject || self, inputError, function (err) {
        if (err) {
          if (state.fail) self.currentState = state.fail;else return done ? done.call(bindObject, err) : null;
        } else {
          if (state.accept) self.currentState = state.accept;else return done ? done.call(bindObject) : null;
        }

        if (self.currentState === finalState) {
          return done ? done.call(bindObject, err) : null;
        }

        self.runTo(finalState, done, bindObject, err);
      });
    };

    AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
      if (typeof acceptState === 'function') {
        fn = acceptState;
        acceptState = null;
        failState = null;
      } else if (typeof failState === 'function') {
        fn = failState;
        failState = null;
      }

      if (!this.currentState) this.currentState = name;
      this.states[name] = {
        accept: acceptState,
        fail: failState,
        fn: fn
      };
      return this;
    };
    /**
     * @api private
     */


    module.exports = AcceptorStateMachine;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/util.js":
  /*!******************************************!*\
    !*** ./node_modules/aws-sdk/lib/util.js ***!
    \******************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibUtilJs(module, exports, __webpack_require__) {
    /* eslint guard-for-in:0 */
    var AWS;
    /**
     * A set of utility methods for use with the AWS SDK.
     *
     * @!attribute abort
     *   Return this value from an iterator function {each} or {arrayEach}
     *   to break out of the iteration.
     *   @example Breaking out of an iterator function
     *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
     *       if (key == 'b') return AWS.util.abort;
     *     });
     *   @see each
     *   @see arrayEach
     * @api private
     */

    var util = {
      environment: 'nodejs',
      engine: function engine() {
        if (util.isBrowser() && typeof navigator !== 'undefined') {
          return navigator.userAgent;
        } else {
          var engine = process.platform + '/' + process.version;

          if (process.env.AWS_EXECUTION_ENV) {
            engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
          }

          return engine;
        }
      },
      userAgent: function userAgent() {
        var name = util.environment;

        var agent = 'aws-sdk-' + name + '/' + __webpack_require__(
        /*! ./core */
        "./node_modules/aws-sdk/lib/core.js").VERSION;

        if (name === 'nodejs') agent += ' ' + util.engine();
        return agent;
      },
      uriEscape: function uriEscape(string) {
        var output = encodeURIComponent(string);
        output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape); // AWS percent-encodes some extra non-standard characters in a URI

        output = output.replace(/[*]/g, function (ch) {
          return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
        });
        return output;
      },
      uriEscapePath: function uriEscapePath(string) {
        var parts = [];
        util.arrayEach(string.split('/'), function (part) {
          parts.push(util.uriEscape(part));
        });
        return parts.join('/');
      },
      urlParse: function urlParse(url) {
        return util.url.parse(url);
      },
      urlFormat: function urlFormat(url) {
        return util.url.format(url);
      },
      queryStringParse: function queryStringParse(qs) {
        return util.querystring.parse(qs);
      },
      queryParamsToString: function queryParamsToString(params) {
        var items = [];
        var escape = util.uriEscape;
        var sortedKeys = Object.keys(params).sort();
        util.arrayEach(sortedKeys, function (name) {
          var value = params[name];
          var ename = escape(name);
          var result = ename + '=';

          if (Array.isArray(value)) {
            var vals = [];
            util.arrayEach(value, function (item) {
              vals.push(escape(item));
            });
            result = ename + '=' + vals.sort().join('&' + ename + '=');
          } else if (value !== undefined && value !== null) {
            result = ename + '=' + escape(value);
          }

          items.push(result);
        });
        return items.join('&');
      },
      readFileSync: function readFileSync(path) {
        if (util.isBrowser()) return null;
        return __webpack_require__(
        /*! fs */
        4).readFileSync(path, 'utf-8');
      },
      base64: {
        encode: function encode64(string) {
          if (typeof string === 'number') {
            throw util.error(new Error('Cannot base64 encode number ' + string));
          }

          if (string === null || typeof string === 'undefined') {
            return string;
          }

          var buf = util.buffer.toBuffer(string);
          return buf.toString('base64');
        },
        decode: function decode64(string) {
          if (typeof string === 'number') {
            throw util.error(new Error('Cannot base64 decode number ' + string));
          }

          if (string === null || typeof string === 'undefined') {
            return string;
          }

          return util.buffer.toBuffer(string, 'base64');
        }
      },
      buffer: {
        /**
         * Buffer constructor for Node buffer and buffer pollyfill
         */
        toBuffer: function toBuffer(data, encoding) {
          return typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from ? util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
        },
        alloc: function alloc(size, fill, encoding) {
          if (typeof size !== 'number') {
            throw new Error('size passed to alloc must be a number.');
          }

          if (typeof util.Buffer.alloc === 'function') {
            return util.Buffer.alloc(size, fill, encoding);
          } else {
            var buf = new util.Buffer(size);

            if (fill !== undefined && typeof buf.fill === 'function') {
              buf.fill(fill, undefined, undefined, encoding);
            }

            return buf;
          }
        },
        toStream: function toStream(buffer) {
          if (!util.Buffer.isBuffer(buffer)) buffer = util.buffer.toBuffer(buffer);
          var readable = new util.stream.Readable();
          var pos = 0;

          readable._read = function (size) {
            if (pos >= buffer.length) return readable.push(null);
            var end = pos + size;
            if (end > buffer.length) end = buffer.length;
            readable.push(buffer.slice(pos, end));
            pos = end;
          };

          return readable;
        },

        /**
         * Concatenates a list of Buffer objects.
         */
        concat: function concat(buffers) {
          var length = 0,
              offset = 0,
              buffer = null,
              i;

          for (i = 0; i < buffers.length; i++) {
            length += buffers[i].length;
          }

          buffer = util.buffer.alloc(length);

          for (i = 0; i < buffers.length; i++) {
            buffers[i].copy(buffer, offset);
            offset += buffers[i].length;
          }

          return buffer;
        }
      },
      string: {
        byteLength: function byteLength(string) {
          if (string === null || string === undefined) return 0;
          if (typeof string === 'string') string = util.buffer.toBuffer(string);

          if (typeof string.byteLength === 'number') {
            return string.byteLength;
          } else if (typeof string.length === 'number') {
            return string.length;
          } else if (typeof string.size === 'number') {
            return string.size;
          } else if (typeof string.path === 'string') {
            return __webpack_require__(
            /*! fs */
            4).lstatSync(string.path).size;
          } else {
            throw util.error(new Error('Cannot determine length of ' + string), {
              object: string
            });
          }
        },
        upperFirst: function upperFirst(string) {
          return string[0].toUpperCase() + string.substr(1);
        },
        lowerFirst: function lowerFirst(string) {
          return string[0].toLowerCase() + string.substr(1);
        }
      },
      ini: {
        parse: function string(ini) {
          var currentSection,
              map = {};
          util.arrayEach(ini.split(/\r?\n/), function (line) {
            line = line.split(/(^|\s)[;#]/)[0]; // remove comments

            var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);

            if (section) {
              currentSection = section[1];

              if (currentSection === '__proto__' || currentSection.split(/\s/)[1] === '__proto__') {
                throw util.error(new Error('Cannot load profile name \'' + currentSection + '\' from shared ini file.'));
              }
            } else if (currentSection) {
              var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);

              if (item) {
                map[currentSection] = map[currentSection] || {};
                map[currentSection][item[1]] = item[2];
              }
            }
          });
          return map;
        }
      },
      fn: {
        noop: function noop() {},
        callback: function callback(err) {
          if (err) throw err;
        },

        /**
         * Turn a synchronous function into as "async" function by making it call
         * a callback. The underlying function is called with all but the last argument,
         * which is treated as the callback. The callback is passed passed a first argument
         * of null on success to mimick standard node callbacks.
         */
        makeAsync: function makeAsync(fn, expectedArgs) {
          if (expectedArgs && expectedArgs <= fn.length) {
            return fn;
          }

          return function () {
            var args = Array.prototype.slice.call(arguments, 0);
            var callback = args.pop();
            var result = fn.apply(null, args);
            callback(result);
          };
        }
      },

      /**
       * Date and time utility functions.
       */
      date: {
        /**
         * @return [Date] the current JavaScript date object. Since all
         *   AWS services rely on this date object, you can override
         *   this function to provide a special time value to AWS service
         *   requests.
         */
        getDate: function getDate() {
          if (!AWS) AWS = __webpack_require__(
          /*! ./core */
          "./node_modules/aws-sdk/lib/core.js");

          if (AWS.config.systemClockOffset) {
            // use offset when non-zero
            return new Date(new Date().getTime() + AWS.config.systemClockOffset);
          } else {
            return new Date();
          }
        },

        /**
         * @return [String] the date in ISO-8601 format
         */
        iso8601: function iso8601(date) {
          if (date === undefined) {
            date = util.date.getDate();
          }

          return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
        },

        /**
         * @return [String] the date in RFC 822 format
         */
        rfc822: function rfc822(date) {
          if (date === undefined) {
            date = util.date.getDate();
          }

          return date.toUTCString();
        },

        /**
         * @return [Integer] the UNIX timestamp value for the current time
         */
        unixTimestamp: function unixTimestamp(date) {
          if (date === undefined) {
            date = util.date.getDate();
          }

          return date.getTime() / 1000;
        },

        /**
         * @param [String,number,Date] date
         * @return [Date]
         */
        from: function format(date) {
          if (typeof date === 'number') {
            return new Date(date * 1000); // unix timestamp
          } else {
            return new Date(date);
          }
        },

        /**
         * Given a Date or date-like value, this function formats the
         * date into a string of the requested value.
         * @param [String,number,Date] date
         * @param [String] formatter Valid formats are:
         #   * 'iso8601'
         #   * 'rfc822'
         #   * 'unixTimestamp'
         * @return [String]
         */
        format: function format(date, formatter) {
          if (!formatter) formatter = 'iso8601';
          return util.date[formatter](util.date.from(date));
        },
        parseTimestamp: function parseTimestamp(value) {
          if (typeof value === 'number') {
            // unix timestamp (number)
            return new Date(value * 1000);
          } else if (value.match(/^\d+$/)) {
            // unix timestamp
            return new Date(value * 1000);
          } else if (value.match(/^\d{4}/)) {
            // iso8601
            return new Date(value);
          } else if (value.match(/^\w{3},/)) {
            // rfc822
            return new Date(value);
          } else {
            throw util.error(new Error('unhandled timestamp format: ' + value), {
              code: 'TimestampParserError'
            });
          }
        }
      },
      crypto: {
        crc32Table: [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D],
        crc32: function crc32(data) {
          var tbl = util.crypto.crc32Table;
          var crc = 0 ^ -1;

          if (typeof data === 'string') {
            data = util.buffer.toBuffer(data);
          }

          for (var i = 0; i < data.length; i++) {
            var code = data.readUInt8(i);
            crc = crc >>> 8 ^ tbl[(crc ^ code) & 0xFF];
          }

          return (crc ^ -1) >>> 0;
        },
        hmac: function hmac(key, string, digest, fn) {
          if (!digest) digest = 'binary';

          if (digest === 'buffer') {
            digest = undefined;
          }

          if (!fn) fn = 'sha256';
          if (typeof string === 'string') string = util.buffer.toBuffer(string);
          return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
        },
        md5: function md5(data, digest, callback) {
          return util.crypto.hash('md5', data, digest, callback);
        },
        sha256: function sha256(data, digest, callback) {
          return util.crypto.hash('sha256', data, digest, callback);
        },
        hash: function hash(algorithm, data, digest, callback) {
          var hash = util.crypto.createHash(algorithm);

          if (!digest) {
            digest = 'binary';
          }

          if (digest === 'buffer') {
            digest = undefined;
          }

          if (typeof data === 'string') data = util.buffer.toBuffer(data);
          var sliceFn = util.arraySliceFn(data);
          var isBuffer = util.Buffer.isBuffer(data); //Identifying objects with an ArrayBuffer as buffers

          if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

          if (callback && typeof data === 'object' && typeof data.on === 'function' && !isBuffer) {
            data.on('data', function (chunk) {
              hash.update(chunk);
            });
            data.on('error', function (err) {
              callback(err);
            });
            data.on('end', function () {
              callback(null, hash.digest(digest));
            });
          } else if (callback && sliceFn && !isBuffer && typeof FileReader !== 'undefined') {
            // this might be a File/Blob
            var index = 0,
                size = 1024 * 512;
            var reader = new FileReader();

            reader.onerror = function () {
              callback(new Error('Failed to read data.'));
            };

            reader.onload = function () {
              var buf = new util.Buffer(new Uint8Array(reader.result));
              hash.update(buf);
              index += buf.length;

              reader._continueReading();
            };

            reader._continueReading = function () {
              if (index >= data.size) {
                callback(null, hash.digest(digest));
                return;
              }

              var back = index + size;
              if (back > data.size) back = data.size;
              reader.readAsArrayBuffer(sliceFn.call(data, index, back));
            };

            reader._continueReading();
          } else {
            if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
              data = new util.Buffer(new Uint8Array(data));
            }

            var out = hash.update(data).digest(digest);
            if (callback) callback(null, out);
            return out;
          }
        },
        toHex: function toHex(data) {
          var out = [];

          for (var i = 0; i < data.length; i++) {
            out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
          }

          return out.join('');
        },
        createHash: function createHash(algorithm) {
          return util.crypto.lib.createHash(algorithm);
        }
      },

      /** @!ignore */

      /* Abort constant */
      abort: {},
      each: function each(object, iterFunction) {
        for (var key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            var ret = iterFunction.call(this, key, object[key]);
            if (ret === util.abort) break;
          }
        }
      },
      arrayEach: function arrayEach(array, iterFunction) {
        for (var idx in array) {
          if (Object.prototype.hasOwnProperty.call(array, idx)) {
            var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
            if (ret === util.abort) break;
          }
        }
      },
      update: function update(obj1, obj2) {
        util.each(obj2, function iterator(key, item) {
          obj1[key] = item;
        });
        return obj1;
      },
      merge: function merge(obj1, obj2) {
        return util.update(util.copy(obj1), obj2);
      },
      copy: function copy(object) {
        if (object === null || object === undefined) return object;
        var dupe = {}; // jshint forin:false

        for (var key in object) {
          dupe[key] = object[key];
        }

        return dupe;
      },
      isEmpty: function isEmpty(obj) {
        for (var prop in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
          }
        }

        return true;
      },
      arraySliceFn: function arraySliceFn(obj) {
        var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
        return typeof fn === 'function' ? fn : null;
      },
      isType: function isType(obj, type) {
        // handle cross-"frame" objects
        if (typeof type === 'function') type = util.typeName(type);
        return Object.prototype.toString.call(obj) === '[object ' + type + ']';
      },
      typeName: function typeName(type) {
        if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
        var str = type.toString();
        var match = str.match(/^\s*function (.+)\(/);
        return match ? match[1] : str;
      },
      error: function error(err, options) {
        var originalError = null;

        if (typeof err.message === 'string' && err.message !== '') {
          if (typeof options === 'string' || options && options.message) {
            originalError = util.copy(err);
            originalError.message = err.message;
          }
        }

        err.message = err.message || null;

        if (typeof options === 'string') {
          err.message = options;
        } else if (typeof options === 'object' && options !== null) {
          util.update(err, options);
          if (options.message) err.message = options.message;
          if (options.code || options.name) err.code = options.code || options.name;
          if (options.stack) err.stack = options.stack;
        }

        if (typeof Object.defineProperty === 'function') {
          Object.defineProperty(err, 'name', {
            writable: true,
            enumerable: false
          });
          Object.defineProperty(err, 'message', {
            enumerable: true
          });
        }

        err.name = String(options && options.name || err.name || err.code || 'Error');
        err.time = new Date();
        if (originalError) err.originalError = originalError;
        return err;
      },

      /**
       * @api private
       */
      inherit: function inherit(klass, features) {
        var newObject = null;

        if (features === undefined) {
          features = klass;
          klass = Object;
          newObject = {};
        } else {
          var ctor = function ConstructorWrapper() {};

          ctor.prototype = klass.prototype;
          newObject = new ctor();
        } // constructor not supplied, create pass-through ctor


        if (features.constructor === Object) {
          features.constructor = function () {
            if (klass !== Object) {
              return klass.apply(this, arguments);
            }
          };
        }

        features.constructor.prototype = newObject;
        util.update(features.constructor.prototype, features);
        features.constructor.__super__ = klass;
        return features.constructor;
      },

      /**
       * @api private
       */
      mixin: function mixin() {
        var klass = arguments[0];

        for (var i = 1; i < arguments.length; i++) {
          // jshint forin:false
          for (var prop in arguments[i].prototype) {
            var fn = arguments[i].prototype[prop];

            if (prop !== 'constructor') {
              klass.prototype[prop] = fn;
            }
          }
        }

        return klass;
      },

      /**
       * @api private
       */
      hideProperties: function hideProperties(obj, props) {
        if (typeof Object.defineProperty !== 'function') return;
        util.arrayEach(props, function (key) {
          Object.defineProperty(obj, key, {
            enumerable: false,
            writable: true,
            configurable: true
          });
        });
      },

      /**
       * @api private
       */
      property: function property(obj, name, value, enumerable, isValue) {
        var opts = {
          configurable: true,
          enumerable: enumerable !== undefined ? enumerable : true
        };

        if (typeof value === 'function' && !isValue) {
          opts.get = value;
        } else {
          opts.value = value;
          opts.writable = true;
        }

        Object.defineProperty(obj, name, opts);
      },

      /**
       * @api private
       */
      memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
        var cachedValue = null; // build enumerable attribute for each value with lazy accessor.

        util.property(obj, name, function () {
          if (cachedValue === null) {
            cachedValue = get();
          }

          return cachedValue;
        }, enumerable);
      },

      /**
       * TODO Remove in major version revision
       * This backfill populates response data without the
       * top-level payload name.
       *
       * @api private
       */
      hoistPayloadMember: function hoistPayloadMember(resp) {
        var req = resp.request;
        var operationName = req.operation;
        var operation = req.service.api.operations[operationName];
        var output = operation.output;

        if (output.payload && !operation.hasEventOutput) {
          var payloadMember = output.members[output.payload];
          var responsePayload = resp.data[output.payload];

          if (payloadMember.type === 'structure') {
            util.each(responsePayload, function (key, value) {
              util.property(resp.data, key, value, false);
            });
          }
        }
      },

      /**
       * Compute SHA-256 checksums of streams
       *
       * @api private
       */
      computeSha256: function computeSha256(body, done) {
        if (util.isNode()) {
          var Stream = util.stream.Stream;

          var fs = __webpack_require__(
          /*! fs */
          4);

          if (typeof Stream === 'function' && body instanceof Stream) {
            if (typeof body.path === 'string') {
              // assume file object
              var settings = {};

              if (typeof body.start === 'number') {
                settings.start = body.start;
              }

              if (typeof body.end === 'number') {
                settings.end = body.end;
              }

              body = fs.createReadStream(body.path, settings);
            } else {
              // TODO support other stream types
              return done(new Error('Non-file stream objects are ' + 'not supported with SigV4'));
            }
          }
        }

        util.crypto.sha256(body, 'hex', function (err, sha) {
          if (err) done(err);else done(null, sha);
        });
      },

      /**
       * @api private
       */
      isClockSkewed: function isClockSkewed(serverTime) {
        if (serverTime) {
          util.property(AWS.config, 'isClockSkewed', Math.abs(new Date().getTime() - serverTime) >= 300000, false);
          return AWS.config.isClockSkewed;
        }
      },
      applyClockOffset: function applyClockOffset(serverTime) {
        if (serverTime) AWS.config.systemClockOffset = serverTime - new Date().getTime();
      },

      /**
       * @api private
       */
      extractRequestId: function extractRequestId(resp) {
        var requestId = resp.httpResponse.headers['x-amz-request-id'] || resp.httpResponse.headers['x-amzn-requestid'];

        if (!requestId && resp.data && resp.data.ResponseMetadata) {
          requestId = resp.data.ResponseMetadata.RequestId;
        }

        if (requestId) {
          resp.requestId = requestId;
        }

        if (resp.error) {
          resp.error.requestId = requestId;
        }
      },

      /**
       * @api private
       */
      addPromises: function addPromises(constructors, PromiseDependency) {
        var deletePromises = false;

        if (PromiseDependency === undefined && AWS && AWS.config) {
          PromiseDependency = AWS.config.getPromisesDependency();
        }

        if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
          PromiseDependency = Promise;
        }

        if (typeof PromiseDependency !== 'function') deletePromises = true;
        if (!Array.isArray(constructors)) constructors = [constructors];

        for (var ind = 0; ind < constructors.length; ind++) {
          var constructor = constructors[ind];

          if (deletePromises) {
            if (constructor.deletePromisesFromClass) {
              constructor.deletePromisesFromClass();
            }
          } else if (constructor.addPromisesToClass) {
            constructor.addPromisesToClass(PromiseDependency);
          }
        }
      },

      /**
       * @api private
       * Return a function that will return a promise whose fate is decided by the
       * callback behavior of the given method with `methodName`. The method to be
       * promisified should conform to node.js convention of accepting a callback as
       * last argument and calling that callback with error as the first argument
       * and success value on the second argument.
       */
      promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
        return function promise() {
          var self = this;
          var args = Array.prototype.slice.call(arguments);
          return new PromiseDependency(function (resolve, reject) {
            args.push(function (err, data) {
              if (err) {
                reject(err);
              } else {
                resolve(data);
              }
            });
            self[methodName].apply(self, args);
          });
        };
      },

      /**
       * @api private
       */
      isDualstackAvailable: function isDualstackAvailable(service) {
        if (!service) return false;

        var metadata = __webpack_require__(
        /*! ../apis/metadata.json */
        "./node_modules/aws-sdk/apis/metadata.json");

        if (typeof service !== 'string') service = service.serviceIdentifier;
        if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
        return !!metadata[service].dualstackAvailable;
      },

      /**
       * @api private
       */
      calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
        if (!retryDelayOptions) retryDelayOptions = {};
        var customBackoff = retryDelayOptions.customBackoff || null;

        if (typeof customBackoff === 'function') {
          return customBackoff(retryCount, err);
        }

        var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
        var delay = Math.random() * (Math.pow(2, retryCount) * base);
        return delay;
      },

      /**
       * @api private
       */
      handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
        if (!options) options = {};
        var http = AWS.HttpClient.getInstance();
        var httpOptions = options.httpOptions || {};
        var retryCount = 0;

        var errCallback = function errCallback(err) {
          var maxRetries = options.maxRetries || 0;
          if (err && err.code === 'TimeoutError') err.retryable = true; // Call `calculateRetryDelay()` only when relevant, see #3401

          if (err && err.retryable && retryCount < maxRetries) {
            var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);

            if (delay >= 0) {
              retryCount++;
              setTimeout(sendRequest, delay + (err.retryAfter || 0));
              return;
            }
          }

          cb(err);
        };

        var sendRequest = function sendRequest() {
          var data = '';
          http.handleRequest(httpRequest, httpOptions, function (httpResponse) {
            httpResponse.on('data', function (chunk) {
              data += chunk.toString();
            });
            httpResponse.on('end', function () {
              var statusCode = httpResponse.statusCode;

              if (statusCode < 300) {
                cb(null, data);
              } else {
                var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
                var err = util.error(new Error(), {
                  statusCode: statusCode,
                  retryable: statusCode >= 500 || statusCode === 429
                });
                if (retryAfter && err.retryable) err.retryAfter = retryAfter;
                errCallback(err);
              }
            });
          }, errCallback);
        };

        AWS.util.defer(sendRequest);
      },

      /**
       * @api private
       */
      uuid: {
        v4: function uuidV4() {
          return __webpack_require__(
          /*! uuid */
          "./node_modules/aws-sdk/node_modules/uuid/index.js").v4();
        }
      },

      /**
       * @api private
       */
      convertPayloadToString: function convertPayloadToString(resp) {
        var req = resp.request;
        var operation = req.operation;
        var rules = req.service.api.operations[operation].output || {};

        if (rules.payload && resp.data[rules.payload]) {
          resp.data[rules.payload] = resp.data[rules.payload].toString();
        }
      },

      /**
       * @api private
       */
      defer: function defer(callback) {
        if (typeof process === 'object' && typeof process.nextTick === 'function') {
          process.nextTick(callback);
        } else if (typeof setImmediate === 'function') {
          setImmediate(callback);
        } else {
          setTimeout(callback, 0);
        }
      },

      /**
       * @api private
       */
      getRequestPayloadShape: function getRequestPayloadShape(req) {
        var operations = req.service.api.operations;
        if (!operations) return undefined;
        var operation = (operations || {})[req.operation];
        if (!operation || !operation.input || !operation.input.payload) return undefined;
        return operation.input.members[operation.input.payload];
      },
      getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
        var profiles = {};
        var profilesFromConfig = {};

        if (process.env[util.configOptInEnv]) {
          var profilesFromConfig = iniLoader.loadFrom({
            isConfig: true,
            filename: process.env[util.sharedConfigFileEnv]
          });
        }

        var profilesFromCreds = {};

        try {
          var profilesFromCreds = iniLoader.loadFrom({
            filename: filename || process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv]
          });
        } catch (error) {
          // if using config, assume it is fully descriptive without a credentials file:
          if (!process.env[util.configOptInEnv]) throw error;
        }

        for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
        }

        for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
        }

        return profiles;
        /**
         * Roughly the semantics of `Object.assign(target, source)`
         */

        function objectAssign(target, source) {
          for (var i = 0, keys = Object.keys(source); i < keys.length; i++) {
            target[keys[i]] = source[keys[i]];
          }

          return target;
        }
      },

      /**
       * @api private
       */
      ARN: {
        validate: function validateARN(str) {
          return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
        },
        parse: function parseARN(arn) {
          var matched = arn.split(':');
          return {
            partition: matched[1],
            service: matched[2],
            region: matched[3],
            accountId: matched[4],
            resource: matched.slice(5).join(':')
          };
        },
        build: function buildARN(arnObject) {
          if (arnObject.service === undefined || arnObject.region === undefined || arnObject.accountId === undefined || arnObject.resource === undefined) throw util.error(new Error('Input ARN object is invalid'));
          return 'arn:' + (arnObject.partition || 'aws') + ':' + arnObject.service + ':' + arnObject.region + ':' + arnObject.accountId + ':' + arnObject.resource;
        }
      },

      /**
       * @api private
       */
      defaultProfile: 'default',

      /**
       * @api private
       */
      configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

      /**
       * @api private
       */
      sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

      /**
       * @api private
       */
      sharedConfigFileEnv: 'AWS_CONFIG_FILE',

      /**
       * @api private
       */
      imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
    };
    /**
     * @api private
     */

    module.exports = util;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/xml/browser_parser.js":
  /*!********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/xml/browser_parser.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibXmlBrowser_parserJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var Shape = __webpack_require__(
    /*! ../model/shape */
    "./node_modules/aws-sdk/lib/model/shape.js");

    function DomXmlParser() {}

    DomXmlParser.prototype.parse = function (xml, shape) {
      if (xml.replace(/^\s+/, '') === '') return {};
      var result, error;

      try {
        if (window.DOMParser) {
          try {
            var parser = new DOMParser();
            result = parser.parseFromString(xml, 'text/xml');
          } catch (syntaxError) {
            throw util.error(new Error('Parse error in document'), {
              originalError: syntaxError,
              code: 'XMLParserError',
              retryable: true
            });
          }

          if (result.documentElement === null) {
            throw util.error(new Error('Cannot parse empty document.'), {
              code: 'XMLParserError',
              retryable: true
            });
          }

          var isError = result.getElementsByTagName('parsererror')[0];

          if (isError && (isError.parentNode === result || isError.parentNode.nodeName === 'body' || isError.parentNode.parentNode === result || isError.parentNode.parentNode.nodeName === 'body')) {
            var errorElement = isError.getElementsByTagName('div')[0] || isError;
            throw util.error(new Error(errorElement.textContent || 'Parser error in document'), {
              code: 'XMLParserError',
              retryable: true
            });
          }
        } else if (window.ActiveXObject) {
          result = new window.ActiveXObject('Microsoft.XMLDOM');
          result.async = false;

          if (!result.loadXML(xml)) {
            throw util.error(new Error('Parse error in document'), {
              code: 'XMLParserError',
              retryable: true
            });
          }
        } else {
          throw new Error('Cannot load XML parser');
        }
      } catch (e) {
        error = e;
      }

      if (result && result.documentElement && !error) {
        var data = parseXml(result.documentElement, shape);
        var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');

        if (metadata) {
          data.ResponseMetadata = parseXml(metadata, {});
        }

        return data;
      } else if (error) {
        throw util.error(error || new Error(), {
          code: 'XMLParserError',
          retryable: true
        });
      } else {
        // empty xml document
        return {};
      }
    };

    function getElementByTagName(xml, tag) {
      var elements = xml.getElementsByTagName(tag);

      for (var i = 0, iLen = elements.length; i < iLen; i++) {
        if (elements[i].parentNode === xml) {
          return elements[i];
        }
      }
    }

    function parseXml(xml, shape) {
      if (!shape) shape = {};

      switch (shape.type) {
        case 'structure':
          return parseStructure(xml, shape);

        case 'map':
          return parseMap(xml, shape);

        case 'list':
          return parseList(xml, shape);

        case undefined:
        case null:
          return parseUnknown(xml);

        default:
          return parseScalar(xml, shape);
      }
    }

    function parseStructure(xml, shape) {
      var data = {};
      if (xml === null) return data;
      util.each(shape.members, function (memberName, memberShape) {
        if (memberShape.isXmlAttribute) {
          if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
            var value = xml.attributes[memberShape.name].value;
            data[memberName] = parseXml({
              textContent: value
            }, memberShape);
          }
        } else {
          var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);

          if (xmlChild) {
            data[memberName] = parseXml(xmlChild, memberShape);
          } else if (!memberShape.flattened && memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {
            data[memberName] = memberShape.defaultValue;
          }
        }
      });
      return data;
    }

    function parseMap(xml, shape) {
      var data = {};
      var xmlKey = shape.key.name || 'key';
      var xmlValue = shape.value.name || 'value';
      var tagName = shape.flattened ? shape.name : 'entry';
      var child = xml.firstElementChild;

      while (child) {
        if (child.nodeName === tagName) {
          var key = getElementByTagName(child, xmlKey).textContent;
          var value = getElementByTagName(child, xmlValue);
          data[key] = parseXml(value, shape.value);
        }

        child = child.nextElementSibling;
      }

      return data;
    }

    function parseList(xml, shape) {
      var data = [];
      var tagName = shape.flattened ? shape.name : shape.member.name || 'member';
      var child = xml.firstElementChild;

      while (child) {
        if (child.nodeName === tagName) {
          data.push(parseXml(child, shape.member));
        }

        child = child.nextElementSibling;
      }

      return data;
    }

    function parseScalar(xml, shape) {
      if (xml.getAttribute) {
        var encoding = xml.getAttribute('encoding');

        if (encoding === 'base64') {
          shape = new Shape.create({
            type: encoding
          });
        }
      }

      var text = xml.textContent;
      if (text === '') text = null;

      if (typeof shape.toType === 'function') {
        return shape.toType(text);
      } else {
        return text;
      }
    }

    function parseUnknown(xml) {
      if (xml === undefined || xml === null) return ''; // empty object

      if (!xml.firstElementChild) {
        if (xml.parentNode.parentNode === null) return {};
        if (xml.childNodes.length === 0) return '';else return xml.textContent;
      } // object, parse as structure


      var shape = {
        type: 'structure',
        members: {}
      };
      var child = xml.firstElementChild;

      while (child) {
        var tag = child.nodeName;

        if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
          // multiple tags of the same name makes it a list
          shape.members[tag].type = 'list';
        } else {
          shape.members[tag] = {
            name: tag
          };
        }

        child = child.nextElementSibling;
      }

      return parseStructure(xml, shape);
    }
    /**
     * @api private
     */


    module.exports = DomXmlParser;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/xml/builder.js":
  /*!*************************************************!*\
    !*** ./node_modules/aws-sdk/lib/xml/builder.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibXmlBuilderJs(module, exports, __webpack_require__) {
    var util = __webpack_require__(
    /*! ../util */
    "./node_modules/aws-sdk/lib/util.js");

    var XmlNode = __webpack_require__(
    /*! ./xml-node */
    "./node_modules/aws-sdk/lib/xml/xml-node.js").XmlNode;

    var XmlText = __webpack_require__(
    /*! ./xml-text */
    "./node_modules/aws-sdk/lib/xml/xml-text.js").XmlText;

    function XmlBuilder() {}

    XmlBuilder.prototype.toXML = function (params, shape, rootElement, noEmpty) {
      var xml = new XmlNode(rootElement);
      applyNamespaces(xml, shape, true);
      serialize(xml, params, shape);
      return xml.children.length > 0 || noEmpty ? xml.toString() : '';
    };

    function serialize(xml, value, shape) {
      switch (shape.type) {
        case 'structure':
          return serializeStructure(xml, value, shape);

        case 'map':
          return serializeMap(xml, value, shape);

        case 'list':
          return serializeList(xml, value, shape);

        default:
          return serializeScalar(xml, value, shape);
      }
    }

    function serializeStructure(xml, params, shape) {
      util.arrayEach(shape.memberNames, function (memberName) {
        var memberShape = shape.members[memberName];
        if (memberShape.location !== 'body') return;
        var value = params[memberName];
        var name = memberShape.name;

        if (value !== undefined && value !== null) {
          if (memberShape.isXmlAttribute) {
            xml.addAttribute(name, value);
          } else if (memberShape.flattened) {
            serialize(xml, value, memberShape);
          } else {
            var element = new XmlNode(name);
            xml.addChildNode(element);
            applyNamespaces(element, memberShape);
            serialize(element, value, memberShape);
          }
        }
      });
    }

    function serializeMap(xml, map, shape) {
      var xmlKey = shape.key.name || 'key';
      var xmlValue = shape.value.name || 'value';
      util.each(map, function (key, value) {
        var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
        xml.addChildNode(entry);
        var entryKey = new XmlNode(xmlKey);
        var entryValue = new XmlNode(xmlValue);
        entry.addChildNode(entryKey);
        entry.addChildNode(entryValue);
        serialize(entryKey, key, shape.key);
        serialize(entryValue, value, shape.value);
      });
    }

    function serializeList(xml, list, shape) {
      if (shape.flattened) {
        util.arrayEach(list, function (value) {
          var name = shape.member.name || shape.name;
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      } else {
        util.arrayEach(list, function (value) {
          var name = shape.member.name || 'member';
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      }
    }

    function serializeScalar(xml, value, shape) {
      xml.addChildNode(new XmlText(shape.toWireFormat(value)));
    }

    function applyNamespaces(xml, shape, isRoot) {
      var uri,
          prefix = 'xmlns';

      if (shape.xmlNamespaceUri) {
        uri = shape.xmlNamespaceUri;
        if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
      } else if (isRoot && shape.api.xmlNamespaceUri) {
        uri = shape.api.xmlNamespaceUri;
      }

      if (uri) xml.addAttribute(prefix, uri);
    }
    /**
     * @api private
     */


    module.exports = XmlBuilder;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/xml/escape-attribute.js":
  /*!**********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/xml/escape-attribute.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibXmlEscapeAttributeJs(module, exports) {
    /**
     * Escapes characters that can not be in an XML attribute.
     */
    function escapeAttribute(value) {
      return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }
    /**
     * @api private
     */


    module.exports = {
      escapeAttribute: escapeAttribute
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/xml/escape-element.js":
  /*!********************************************************!*\
    !*** ./node_modules/aws-sdk/lib/xml/escape-element.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibXmlEscapeElementJs(module, exports) {
    /**
     * Escapes characters that can not be in an XML element.
     */
    function escapeElement(value) {
      return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    /**
     * @api private
     */


    module.exports = {
      escapeElement: escapeElement
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/xml/xml-node.js":
  /*!**************************************************!*\
    !*** ./node_modules/aws-sdk/lib/xml/xml-node.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibXmlXmlNodeJs(module, exports, __webpack_require__) {
    var escapeAttribute = __webpack_require__(
    /*! ./escape-attribute */
    "./node_modules/aws-sdk/lib/xml/escape-attribute.js").escapeAttribute;
    /**
     * Represents an XML node.
     * @api private
     */


    function XmlNode(name, children) {
      if (children === void 0) {
        children = [];
      }

      this.name = name;
      this.children = children;
      this.attributes = {};
    }

    XmlNode.prototype.addAttribute = function (name, value) {
      this.attributes[name] = value;
      return this;
    };

    XmlNode.prototype.addChildNode = function (child) {
      this.children.push(child);
      return this;
    };

    XmlNode.prototype.removeAttribute = function (name) {
      delete this.attributes[name];
      return this;
    };

    XmlNode.prototype.toString = function () {
      var hasChildren = Boolean(this.children.length);
      var xmlText = '<' + this.name; // add attributes

      var attributes = this.attributes;

      for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];

        if (typeof attribute !== 'undefined' && attribute !== null) {
          xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
        }
      }

      return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) {
        return c.toString();
      }).join('') + '</' + this.name + '>';
    };
    /**
     * @api private
     */


    module.exports = {
      XmlNode: XmlNode
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/lib/xml/xml-text.js":
  /*!**************************************************!*\
    !*** ./node_modules/aws-sdk/lib/xml/xml-text.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkLibXmlXmlTextJs(module, exports, __webpack_require__) {
    var escapeElement = __webpack_require__(
    /*! ./escape-element */
    "./node_modules/aws-sdk/lib/xml/escape-element.js").escapeElement;
    /**
     * Represents an XML text value.
     * @api private
     */


    function XmlText(value) {
      this.value = value;
    }

    XmlText.prototype.toString = function () {
      return escapeElement('' + this.value);
    };
    /**
     * @api private
     */


    module.exports = {
      XmlText: XmlText
    };
    /***/
  },

  /***/
  "./node_modules/aws-sdk/node_modules/uuid/index.js":
  /*!*********************************************************!*\
    !*** ./node_modules/aws-sdk/node_modules/uuid/index.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkNode_modulesUuidIndexJs(module, exports, __webpack_require__) {
    var v1 = __webpack_require__(
    /*! ./v1 */
    "./node_modules/aws-sdk/node_modules/uuid/v1.js");

    var v4 = __webpack_require__(
    /*! ./v4 */
    "./node_modules/aws-sdk/node_modules/uuid/v4.js");

    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module.exports = uuid;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkNode_modulesUuidLibBytesToUuidJs(module, exports) {
    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 0x100).toString(16).substr(1);
    }

    function bytesToUuid(buf, offset) {
      var i = offset || 0;
      var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

      return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
    }

    module.exports = bytesToUuid;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/node_modules/uuid/lib/rng-browser.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/aws-sdk/node_modules/uuid/lib/rng-browser.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkNode_modulesUuidLibRngBrowserJs(module, exports) {
    // Unique ID creation requires a high quality random # generator.  In the
    // browser this is a little complicated due to unknown quality of Math.random()
    // and inconsistent support for the `crypto` API.  We do the best we can via
    // feature-detection
    // getRandomValues needs to be invoked in a context where "this" is a Crypto
    // implementation. Also, find the complete implementation of crypto on IE11.
    var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (getRandomValues) {
      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
      var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var rnds = new Array(16);

      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
          rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return rnds;
      };
    }
    /***/

  },

  /***/
  "./node_modules/aws-sdk/node_modules/uuid/v1.js":
  /*!******************************************************!*\
    !*** ./node_modules/aws-sdk/node_modules/uuid/v1.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkNode_modulesUuidV1Js(module, exports, __webpack_require__) {
    var rng = __webpack_require__(
    /*! ./lib/rng */
    "./node_modules/aws-sdk/node_modules/uuid/lib/rng-browser.js");

    var bytesToUuid = __webpack_require__(
    /*! ./lib/bytesToUuid */
    "./node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js"); // **`v1()` - Generate time-based UUID**
    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html


    var _nodeId;

    var _clockseq; // Previous uuid creation time


    var _lastMSecs = 0;
    var _lastNSecs = 0; // See https://github.com/broofa/node-uuid for API details

    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189

      if (node == null || clockseq == null) {
        var seedBytes = rng();

        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }

        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


      var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock

      var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval


      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      } // Per 4.2.1.2 Throw error if too many uuids are requested


      if (nsecs >= 10000) {
        throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
      }

      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

      msecs += 12219292800000; // `time_low`

      var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff; // `time_mid`

      var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff; // `time_high_and_version`

      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

      b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

      b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

      b[i++] = clockseq & 0xff; // `node`

      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }

      return buf ? buf : bytesToUuid(b);
    }

    module.exports = v1;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/node_modules/uuid/v4.js":
  /*!******************************************************!*\
    !*** ./node_modules/aws-sdk/node_modules/uuid/v4.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkNode_modulesUuidV4Js(module, exports, __webpack_require__) {
    var rng = __webpack_require__(
    /*! ./lib/rng */
    "./node_modules/aws-sdk/node_modules/uuid/lib/rng-browser.js");

    var bytesToUuid = __webpack_require__(
    /*! ./lib/bytesToUuid */
    "./node_modules/aws-sdk/node_modules/uuid/lib/bytesToUuid.js");

    function v4(options, buf, offset) {
      var i = buf && offset || 0;

      if (typeof options == 'string') {
        buf = options === 'binary' ? new Array(16) : null;
        options = null;
      }

      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }

      return buf || bytesToUuid(rnds);
    }

    module.exports = v4;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/vendor/endpoint-cache/index.js":
  /*!*************************************************************!*\
    !*** ./node_modules/aws-sdk/vendor/endpoint-cache/index.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkVendorEndpointCacheIndexJs(module, exports, __webpack_require__) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var LRU_1 = __webpack_require__(
    /*! ./utils/LRU */
    "./node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js");

    var CACHE_SIZE = 1000;
    /**
     * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]
     */

    var EndpointCache =
    /** @class */
    function () {
      function EndpointCache(maxSize) {
        if (maxSize === void 0) {
          maxSize = CACHE_SIZE;
        }

        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
      }

      ;
      Object.defineProperty(EndpointCache.prototype, "size", {
        get: function get() {
          return this.cache.length;
        },
        enumerable: true,
        configurable: true
      });

      EndpointCache.prototype.put = function (key, value) {
        var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
      };

      EndpointCache.prototype.get = function (key) {
        var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);

        if (records) {
          for (var i = 0; i < records.length; i++) {
            var record = records[i];

            if (record.Expire < now) {
              this.cache.remove(keyString);
              return undefined;
            }
          }
        }

        return records;
      };

      EndpointCache.getKeyString = function (key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();

        for (var i = 0; i < identifierNames.length; i++) {
          var identifierName = identifierNames[i];
          if (key[identifierName] === undefined) continue;
          identifiers.push(key[identifierName]);
        }

        return identifiers.join(' ');
      };

      EndpointCache.prototype.populateValue = function (endpoints) {
        var now = Date.now();
        return endpoints.map(function (endpoint) {
          return {
            Address: endpoint.Address || '',
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000
          };
        });
      };

      EndpointCache.prototype.empty = function () {
        this.cache.empty();
      };

      EndpointCache.prototype.remove = function (key) {
        var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        this.cache.remove(keyString);
      };

      return EndpointCache;
    }();

    exports.EndpointCache = EndpointCache;
    /***/
  },

  /***/
  "./node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAwsSdkVendorEndpointCacheUtilsLRUJs(module, exports, __webpack_require__) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var LinkedListNode =
    /** @class */
    function () {
      function LinkedListNode(key, value) {
        this.key = key;
        this.value = value;
      }

      return LinkedListNode;
    }();

    var LRUCache =
    /** @class */
    function () {
      function LRUCache(size) {
        this.nodeMap = {};
        this.size = 0;

        if (typeof size !== 'number' || size < 1) {
          throw new Error('Cache size can only be positive number');
        }

        this.sizeLimit = size;
      }

      Object.defineProperty(LRUCache.prototype, "length", {
        get: function get() {
          return this.size;
        },
        enumerable: true,
        configurable: true
      });

      LRUCache.prototype.prependToList = function (node) {
        if (!this.headerNode) {
          this.tailNode = node;
        } else {
          this.headerNode.prev = node;
          node.next = this.headerNode;
        }

        this.headerNode = node;
        this.size++;
      };

      LRUCache.prototype.removeFromTail = function () {
        if (!this.tailNode) {
          return undefined;
        }

        var node = this.tailNode;
        var prevNode = node.prev;

        if (prevNode) {
          prevNode.next = undefined;
        }

        node.prev = undefined;
        this.tailNode = prevNode;
        this.size--;
        return node;
      };

      LRUCache.prototype.detachFromList = function (node) {
        if (this.headerNode === node) {
          this.headerNode = node.next;
        }

        if (this.tailNode === node) {
          this.tailNode = node.prev;
        }

        if (node.prev) {
          node.prev.next = node.next;
        }

        if (node.next) {
          node.next.prev = node.prev;
        }

        node.next = undefined;
        node.prev = undefined;
        this.size--;
      };

      LRUCache.prototype.get = function (key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          this.prependToList(node);
          return node.value;
        }
      };

      LRUCache.prototype.remove = function (key) {
        if (this.nodeMap[key]) {
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };

      LRUCache.prototype.put = function (key, value) {
        if (this.nodeMap[key]) {
          this.remove(key);
        } else if (this.size === this.sizeLimit) {
          var tailNode = this.removeFromTail();
          var key_1 = tailNode.key;
          delete this.nodeMap[key_1];
        }

        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
      };

      LRUCache.prototype.empty = function () {
        var keys = Object.keys(this.nodeMap);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var node = this.nodeMap[key];
          this.detachFromList(node);
          delete this.nodeMap[key];
        }
      };

      return LRUCache;
    }();

    exports.LRUCache = LRUCache;
    /***/
  },

  /***/
  "./node_modules/base64-js/index.js":
  /*!*****************************************!*\
    !*** ./node_modules/base64-js/index.js ***!
    \*****************************************/

  /*! no static exports found */

  /***/
  function node_modulesBase64JsIndexJs(module, exports, __webpack_require__) {
    "use strict";

    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    } // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications


    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;

    function getLens(b64) {
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      } // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42


      var validLen = b64.indexOf('=');
      if (validLen === -1) validLen = len;
      var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    } // base64 is 4/3 + up to two characters of the original data


    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }

    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }

    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

      var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i;

      for (i = 0; i < len; i += 4) {
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      return arr;
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
    }

    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];

      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
      }

      return output.join('');
    }

    function fromByteArray(uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3
      // go through the array every three bytes, we'll deal with trailing stuff later

      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
      } // pad the end with zeros, but make sure to not forget the extra bytes


      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
      }

      return parts.join('');
    }
    /***/

  },

  /***/
  "./node_modules/buffer/index.js":
  /*!**************************************!*\
    !*** ./node_modules/buffer/index.js ***!
    \**************************************/

  /*! no static exports found */

  /***/
  function node_modulesBufferIndexJs(module, exports, __webpack_require__) {
    "use strict";
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <http://feross.org>
     * @license  MIT
     */

    /* eslint-disable no-proto */

    var base64 = __webpack_require__(
    /*! base64-js */
    "./node_modules/base64-js/index.js");

    var ieee754 = __webpack_require__(
    /*! ieee754 */
    "./node_modules/ieee754/index.js");

    var isArray = __webpack_require__(
    /*! isarray */
    "./node_modules/isarray/index.js");

    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.
    
     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */

    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
    /*
     * Export kMaxLength after typed array support is determined.
     */

    exports.kMaxLength = kMaxLength();

    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = {
          __proto__: Uint8Array.prototype,
          foo: function foo() {
            return 42;
          }
        };
        return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
      } catch (e) {
        return false;
      }
    }

    function kMaxLength() {
      return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
    }

    function createBuffer(that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length');
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }

        that.length = length;
      }

      return that;
    }
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */


    function Buffer(arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length);
      } // Common case.


      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error('If encoding is specified then the first argument must be a string');
        }

        return allocUnsafe(this, arg);
      }

      return from(this, arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation
    // TODO: Legacy, not needed anymore. Remove in next major version.

    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr;
    };

    function from(that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length);
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset);
      }

      return fromObject(that, value);
    }
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/


    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;

      if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        });
      }
    }

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number');
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }

    function alloc(that, size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(that, size);
      }

      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
      }

      return createBuffer(that, size);
    }
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/


    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding);
    };

    function allocUnsafe(that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }

      return that;
    }
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */


    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */


    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size);
    };

    function fromString(that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);
      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that;
    }

    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);

      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }

      return that;
    }

    function fromArrayBuffer(that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds');
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }

      return that;
    }

    function fromObject(that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that;
        }

        obj.copy(that, 0, 0, len);
        return that;
      }

      if (obj) {
        if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0);
          }

          return fromArrayLike(that, obj);
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
    }

    function checked(length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        // eslint-disable-line eqeqeq
        length = 0;
      }

      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return !!(b != null && b._isBuffer);
    };

    Buffer.compare = function compare(a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }

        buf.copy(buffer, pos);
        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }

      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0; // Use a for loop to avoid recursion

      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) return utf8ToBytes(string).length; // assume utf8

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

      if (start === undefined || start < 0) {
        start = 0;
      } // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.


      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.


    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;

      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }

      return '<Buffer ' + str + '>';
    };

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer');
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf


    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1; // Normalize byteOffset

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset; // Coerce to Number.

      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      } // Normalize byteOffset: negative offsets start from the end of the buffer


      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      } // Normalize val


      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      } // Finally, search either indexOf (if dir is true) or lastIndexOf


      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]

        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      } // must be an even number of digits


      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0; // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0; // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;

        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        } // legacy write(string, encoding, offset, length) - remove in v0.13

      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
            return asciiWrite(this, string, offset, length);

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety


    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      } // Decode in chunks to avoid "call stack size exceeded".


      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';

      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf;

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);

        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf;
    };
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */


    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    function objectWriteUInt16(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;

      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }

      return offset + 2;
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }

      return offset + 2;
    };

    function objectWriteUInt32(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;

      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }

      return offset + 4;
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }

      return offset + 4;
    };

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }

      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }

      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }

      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }

      return offset + 4;
    };

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
      }

      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
      }

      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }

      return len;
    }; // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])


    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (code < 256) {
            val = code;
          }
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } // Invalid ranges are not set to a default, so can range check early.


      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    }; // HELPER FUNCTIONS
    // ================


    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function stringtrim(str) {
      if (str.trim) return str.trim();
      return str.replace(/^\s+|\s+$/g, '');
    }

    function toHex(n) {
      if (n < 16) return '0' + n.toString(16);
      return n.toString(16);
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i); // is surrogate component

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } // valid lead


            leadSurrogate = codePoint;
            continue;
          } // 2 leads in a row


          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } // valid surrogate pair


          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null; // encode utf8

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    }

    function isnan(val) {
      return val !== val; // eslint-disable-line no-self-compare
    }
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale sync recursive ^\\.\\/.*$":
  /*!************************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale sync ^\.\/.*$ ***!
    \************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSyncRecursive$(module, exports, __webpack_require__) {
    var map = {
      "./af": "./node_modules/chart.js/node_modules/moment/locale/af.js",
      "./af.js": "./node_modules/chart.js/node_modules/moment/locale/af.js",
      "./ar": "./node_modules/chart.js/node_modules/moment/locale/ar.js",
      "./ar-dz": "./node_modules/chart.js/node_modules/moment/locale/ar-dz.js",
      "./ar-dz.js": "./node_modules/chart.js/node_modules/moment/locale/ar-dz.js",
      "./ar-kw": "./node_modules/chart.js/node_modules/moment/locale/ar-kw.js",
      "./ar-kw.js": "./node_modules/chart.js/node_modules/moment/locale/ar-kw.js",
      "./ar-ly": "./node_modules/chart.js/node_modules/moment/locale/ar-ly.js",
      "./ar-ly.js": "./node_modules/chart.js/node_modules/moment/locale/ar-ly.js",
      "./ar-ma": "./node_modules/chart.js/node_modules/moment/locale/ar-ma.js",
      "./ar-ma.js": "./node_modules/chart.js/node_modules/moment/locale/ar-ma.js",
      "./ar-sa": "./node_modules/chart.js/node_modules/moment/locale/ar-sa.js",
      "./ar-sa.js": "./node_modules/chart.js/node_modules/moment/locale/ar-sa.js",
      "./ar-tn": "./node_modules/chart.js/node_modules/moment/locale/ar-tn.js",
      "./ar-tn.js": "./node_modules/chart.js/node_modules/moment/locale/ar-tn.js",
      "./ar.js": "./node_modules/chart.js/node_modules/moment/locale/ar.js",
      "./az": "./node_modules/chart.js/node_modules/moment/locale/az.js",
      "./az.js": "./node_modules/chart.js/node_modules/moment/locale/az.js",
      "./be": "./node_modules/chart.js/node_modules/moment/locale/be.js",
      "./be.js": "./node_modules/chart.js/node_modules/moment/locale/be.js",
      "./bg": "./node_modules/chart.js/node_modules/moment/locale/bg.js",
      "./bg.js": "./node_modules/chart.js/node_modules/moment/locale/bg.js",
      "./bn": "./node_modules/chart.js/node_modules/moment/locale/bn.js",
      "./bn.js": "./node_modules/chart.js/node_modules/moment/locale/bn.js",
      "./bo": "./node_modules/chart.js/node_modules/moment/locale/bo.js",
      "./bo.js": "./node_modules/chart.js/node_modules/moment/locale/bo.js",
      "./br": "./node_modules/chart.js/node_modules/moment/locale/br.js",
      "./br.js": "./node_modules/chart.js/node_modules/moment/locale/br.js",
      "./bs": "./node_modules/chart.js/node_modules/moment/locale/bs.js",
      "./bs.js": "./node_modules/chart.js/node_modules/moment/locale/bs.js",
      "./ca": "./node_modules/chart.js/node_modules/moment/locale/ca.js",
      "./ca.js": "./node_modules/chart.js/node_modules/moment/locale/ca.js",
      "./cs": "./node_modules/chart.js/node_modules/moment/locale/cs.js",
      "./cs.js": "./node_modules/chart.js/node_modules/moment/locale/cs.js",
      "./cv": "./node_modules/chart.js/node_modules/moment/locale/cv.js",
      "./cv.js": "./node_modules/chart.js/node_modules/moment/locale/cv.js",
      "./cy": "./node_modules/chart.js/node_modules/moment/locale/cy.js",
      "./cy.js": "./node_modules/chart.js/node_modules/moment/locale/cy.js",
      "./da": "./node_modules/chart.js/node_modules/moment/locale/da.js",
      "./da.js": "./node_modules/chart.js/node_modules/moment/locale/da.js",
      "./de": "./node_modules/chart.js/node_modules/moment/locale/de.js",
      "./de-at": "./node_modules/chart.js/node_modules/moment/locale/de-at.js",
      "./de-at.js": "./node_modules/chart.js/node_modules/moment/locale/de-at.js",
      "./de-ch": "./node_modules/chart.js/node_modules/moment/locale/de-ch.js",
      "./de-ch.js": "./node_modules/chart.js/node_modules/moment/locale/de-ch.js",
      "./de.js": "./node_modules/chart.js/node_modules/moment/locale/de.js",
      "./dv": "./node_modules/chart.js/node_modules/moment/locale/dv.js",
      "./dv.js": "./node_modules/chart.js/node_modules/moment/locale/dv.js",
      "./el": "./node_modules/chart.js/node_modules/moment/locale/el.js",
      "./el.js": "./node_modules/chart.js/node_modules/moment/locale/el.js",
      "./en-au": "./node_modules/chart.js/node_modules/moment/locale/en-au.js",
      "./en-au.js": "./node_modules/chart.js/node_modules/moment/locale/en-au.js",
      "./en-ca": "./node_modules/chart.js/node_modules/moment/locale/en-ca.js",
      "./en-ca.js": "./node_modules/chart.js/node_modules/moment/locale/en-ca.js",
      "./en-gb": "./node_modules/chart.js/node_modules/moment/locale/en-gb.js",
      "./en-gb.js": "./node_modules/chart.js/node_modules/moment/locale/en-gb.js",
      "./en-ie": "./node_modules/chart.js/node_modules/moment/locale/en-ie.js",
      "./en-ie.js": "./node_modules/chart.js/node_modules/moment/locale/en-ie.js",
      "./en-nz": "./node_modules/chart.js/node_modules/moment/locale/en-nz.js",
      "./en-nz.js": "./node_modules/chart.js/node_modules/moment/locale/en-nz.js",
      "./eo": "./node_modules/chart.js/node_modules/moment/locale/eo.js",
      "./eo.js": "./node_modules/chart.js/node_modules/moment/locale/eo.js",
      "./es": "./node_modules/chart.js/node_modules/moment/locale/es.js",
      "./es-do": "./node_modules/chart.js/node_modules/moment/locale/es-do.js",
      "./es-do.js": "./node_modules/chart.js/node_modules/moment/locale/es-do.js",
      "./es.js": "./node_modules/chart.js/node_modules/moment/locale/es.js",
      "./et": "./node_modules/chart.js/node_modules/moment/locale/et.js",
      "./et.js": "./node_modules/chart.js/node_modules/moment/locale/et.js",
      "./eu": "./node_modules/chart.js/node_modules/moment/locale/eu.js",
      "./eu.js": "./node_modules/chart.js/node_modules/moment/locale/eu.js",
      "./fa": "./node_modules/chart.js/node_modules/moment/locale/fa.js",
      "./fa.js": "./node_modules/chart.js/node_modules/moment/locale/fa.js",
      "./fi": "./node_modules/chart.js/node_modules/moment/locale/fi.js",
      "./fi.js": "./node_modules/chart.js/node_modules/moment/locale/fi.js",
      "./fo": "./node_modules/chart.js/node_modules/moment/locale/fo.js",
      "./fo.js": "./node_modules/chart.js/node_modules/moment/locale/fo.js",
      "./fr": "./node_modules/chart.js/node_modules/moment/locale/fr.js",
      "./fr-ca": "./node_modules/chart.js/node_modules/moment/locale/fr-ca.js",
      "./fr-ca.js": "./node_modules/chart.js/node_modules/moment/locale/fr-ca.js",
      "./fr-ch": "./node_modules/chart.js/node_modules/moment/locale/fr-ch.js",
      "./fr-ch.js": "./node_modules/chart.js/node_modules/moment/locale/fr-ch.js",
      "./fr.js": "./node_modules/chart.js/node_modules/moment/locale/fr.js",
      "./fy": "./node_modules/chart.js/node_modules/moment/locale/fy.js",
      "./fy.js": "./node_modules/chart.js/node_modules/moment/locale/fy.js",
      "./gd": "./node_modules/chart.js/node_modules/moment/locale/gd.js",
      "./gd.js": "./node_modules/chart.js/node_modules/moment/locale/gd.js",
      "./gl": "./node_modules/chart.js/node_modules/moment/locale/gl.js",
      "./gl.js": "./node_modules/chart.js/node_modules/moment/locale/gl.js",
      "./gom-latn": "./node_modules/chart.js/node_modules/moment/locale/gom-latn.js",
      "./gom-latn.js": "./node_modules/chart.js/node_modules/moment/locale/gom-latn.js",
      "./he": "./node_modules/chart.js/node_modules/moment/locale/he.js",
      "./he.js": "./node_modules/chart.js/node_modules/moment/locale/he.js",
      "./hi": "./node_modules/chart.js/node_modules/moment/locale/hi.js",
      "./hi.js": "./node_modules/chart.js/node_modules/moment/locale/hi.js",
      "./hr": "./node_modules/chart.js/node_modules/moment/locale/hr.js",
      "./hr.js": "./node_modules/chart.js/node_modules/moment/locale/hr.js",
      "./hu": "./node_modules/chart.js/node_modules/moment/locale/hu.js",
      "./hu.js": "./node_modules/chart.js/node_modules/moment/locale/hu.js",
      "./hy-am": "./node_modules/chart.js/node_modules/moment/locale/hy-am.js",
      "./hy-am.js": "./node_modules/chart.js/node_modules/moment/locale/hy-am.js",
      "./id": "./node_modules/chart.js/node_modules/moment/locale/id.js",
      "./id.js": "./node_modules/chart.js/node_modules/moment/locale/id.js",
      "./is": "./node_modules/chart.js/node_modules/moment/locale/is.js",
      "./is.js": "./node_modules/chart.js/node_modules/moment/locale/is.js",
      "./it": "./node_modules/chart.js/node_modules/moment/locale/it.js",
      "./it.js": "./node_modules/chart.js/node_modules/moment/locale/it.js",
      "./ja": "./node_modules/chart.js/node_modules/moment/locale/ja.js",
      "./ja.js": "./node_modules/chart.js/node_modules/moment/locale/ja.js",
      "./jv": "./node_modules/chart.js/node_modules/moment/locale/jv.js",
      "./jv.js": "./node_modules/chart.js/node_modules/moment/locale/jv.js",
      "./ka": "./node_modules/chart.js/node_modules/moment/locale/ka.js",
      "./ka.js": "./node_modules/chart.js/node_modules/moment/locale/ka.js",
      "./kk": "./node_modules/chart.js/node_modules/moment/locale/kk.js",
      "./kk.js": "./node_modules/chart.js/node_modules/moment/locale/kk.js",
      "./km": "./node_modules/chart.js/node_modules/moment/locale/km.js",
      "./km.js": "./node_modules/chart.js/node_modules/moment/locale/km.js",
      "./kn": "./node_modules/chart.js/node_modules/moment/locale/kn.js",
      "./kn.js": "./node_modules/chart.js/node_modules/moment/locale/kn.js",
      "./ko": "./node_modules/chart.js/node_modules/moment/locale/ko.js",
      "./ko.js": "./node_modules/chart.js/node_modules/moment/locale/ko.js",
      "./ky": "./node_modules/chart.js/node_modules/moment/locale/ky.js",
      "./ky.js": "./node_modules/chart.js/node_modules/moment/locale/ky.js",
      "./lb": "./node_modules/chart.js/node_modules/moment/locale/lb.js",
      "./lb.js": "./node_modules/chart.js/node_modules/moment/locale/lb.js",
      "./lo": "./node_modules/chart.js/node_modules/moment/locale/lo.js",
      "./lo.js": "./node_modules/chart.js/node_modules/moment/locale/lo.js",
      "./lt": "./node_modules/chart.js/node_modules/moment/locale/lt.js",
      "./lt.js": "./node_modules/chart.js/node_modules/moment/locale/lt.js",
      "./lv": "./node_modules/chart.js/node_modules/moment/locale/lv.js",
      "./lv.js": "./node_modules/chart.js/node_modules/moment/locale/lv.js",
      "./me": "./node_modules/chart.js/node_modules/moment/locale/me.js",
      "./me.js": "./node_modules/chart.js/node_modules/moment/locale/me.js",
      "./mi": "./node_modules/chart.js/node_modules/moment/locale/mi.js",
      "./mi.js": "./node_modules/chart.js/node_modules/moment/locale/mi.js",
      "./mk": "./node_modules/chart.js/node_modules/moment/locale/mk.js",
      "./mk.js": "./node_modules/chart.js/node_modules/moment/locale/mk.js",
      "./ml": "./node_modules/chart.js/node_modules/moment/locale/ml.js",
      "./ml.js": "./node_modules/chart.js/node_modules/moment/locale/ml.js",
      "./mr": "./node_modules/chart.js/node_modules/moment/locale/mr.js",
      "./mr.js": "./node_modules/chart.js/node_modules/moment/locale/mr.js",
      "./ms": "./node_modules/chart.js/node_modules/moment/locale/ms.js",
      "./ms-my": "./node_modules/chart.js/node_modules/moment/locale/ms-my.js",
      "./ms-my.js": "./node_modules/chart.js/node_modules/moment/locale/ms-my.js",
      "./ms.js": "./node_modules/chart.js/node_modules/moment/locale/ms.js",
      "./my": "./node_modules/chart.js/node_modules/moment/locale/my.js",
      "./my.js": "./node_modules/chart.js/node_modules/moment/locale/my.js",
      "./nb": "./node_modules/chart.js/node_modules/moment/locale/nb.js",
      "./nb.js": "./node_modules/chart.js/node_modules/moment/locale/nb.js",
      "./ne": "./node_modules/chart.js/node_modules/moment/locale/ne.js",
      "./ne.js": "./node_modules/chart.js/node_modules/moment/locale/ne.js",
      "./nl": "./node_modules/chart.js/node_modules/moment/locale/nl.js",
      "./nl-be": "./node_modules/chart.js/node_modules/moment/locale/nl-be.js",
      "./nl-be.js": "./node_modules/chart.js/node_modules/moment/locale/nl-be.js",
      "./nl.js": "./node_modules/chart.js/node_modules/moment/locale/nl.js",
      "./nn": "./node_modules/chart.js/node_modules/moment/locale/nn.js",
      "./nn.js": "./node_modules/chart.js/node_modules/moment/locale/nn.js",
      "./pa-in": "./node_modules/chart.js/node_modules/moment/locale/pa-in.js",
      "./pa-in.js": "./node_modules/chart.js/node_modules/moment/locale/pa-in.js",
      "./pl": "./node_modules/chart.js/node_modules/moment/locale/pl.js",
      "./pl.js": "./node_modules/chart.js/node_modules/moment/locale/pl.js",
      "./pt": "./node_modules/chart.js/node_modules/moment/locale/pt.js",
      "./pt-br": "./node_modules/chart.js/node_modules/moment/locale/pt-br.js",
      "./pt-br.js": "./node_modules/chart.js/node_modules/moment/locale/pt-br.js",
      "./pt.js": "./node_modules/chart.js/node_modules/moment/locale/pt.js",
      "./ro": "./node_modules/chart.js/node_modules/moment/locale/ro.js",
      "./ro.js": "./node_modules/chart.js/node_modules/moment/locale/ro.js",
      "./ru": "./node_modules/chart.js/node_modules/moment/locale/ru.js",
      "./ru.js": "./node_modules/chart.js/node_modules/moment/locale/ru.js",
      "./sd": "./node_modules/chart.js/node_modules/moment/locale/sd.js",
      "./sd.js": "./node_modules/chart.js/node_modules/moment/locale/sd.js",
      "./se": "./node_modules/chart.js/node_modules/moment/locale/se.js",
      "./se.js": "./node_modules/chart.js/node_modules/moment/locale/se.js",
      "./si": "./node_modules/chart.js/node_modules/moment/locale/si.js",
      "./si.js": "./node_modules/chart.js/node_modules/moment/locale/si.js",
      "./sk": "./node_modules/chart.js/node_modules/moment/locale/sk.js",
      "./sk.js": "./node_modules/chart.js/node_modules/moment/locale/sk.js",
      "./sl": "./node_modules/chart.js/node_modules/moment/locale/sl.js",
      "./sl.js": "./node_modules/chart.js/node_modules/moment/locale/sl.js",
      "./sq": "./node_modules/chart.js/node_modules/moment/locale/sq.js",
      "./sq.js": "./node_modules/chart.js/node_modules/moment/locale/sq.js",
      "./sr": "./node_modules/chart.js/node_modules/moment/locale/sr.js",
      "./sr-cyrl": "./node_modules/chart.js/node_modules/moment/locale/sr-cyrl.js",
      "./sr-cyrl.js": "./node_modules/chart.js/node_modules/moment/locale/sr-cyrl.js",
      "./sr.js": "./node_modules/chart.js/node_modules/moment/locale/sr.js",
      "./ss": "./node_modules/chart.js/node_modules/moment/locale/ss.js",
      "./ss.js": "./node_modules/chart.js/node_modules/moment/locale/ss.js",
      "./sv": "./node_modules/chart.js/node_modules/moment/locale/sv.js",
      "./sv.js": "./node_modules/chart.js/node_modules/moment/locale/sv.js",
      "./sw": "./node_modules/chart.js/node_modules/moment/locale/sw.js",
      "./sw.js": "./node_modules/chart.js/node_modules/moment/locale/sw.js",
      "./ta": "./node_modules/chart.js/node_modules/moment/locale/ta.js",
      "./ta.js": "./node_modules/chart.js/node_modules/moment/locale/ta.js",
      "./te": "./node_modules/chart.js/node_modules/moment/locale/te.js",
      "./te.js": "./node_modules/chart.js/node_modules/moment/locale/te.js",
      "./tet": "./node_modules/chart.js/node_modules/moment/locale/tet.js",
      "./tet.js": "./node_modules/chart.js/node_modules/moment/locale/tet.js",
      "./th": "./node_modules/chart.js/node_modules/moment/locale/th.js",
      "./th.js": "./node_modules/chart.js/node_modules/moment/locale/th.js",
      "./tl-ph": "./node_modules/chart.js/node_modules/moment/locale/tl-ph.js",
      "./tl-ph.js": "./node_modules/chart.js/node_modules/moment/locale/tl-ph.js",
      "./tlh": "./node_modules/chart.js/node_modules/moment/locale/tlh.js",
      "./tlh.js": "./node_modules/chart.js/node_modules/moment/locale/tlh.js",
      "./tr": "./node_modules/chart.js/node_modules/moment/locale/tr.js",
      "./tr.js": "./node_modules/chart.js/node_modules/moment/locale/tr.js",
      "./tzl": "./node_modules/chart.js/node_modules/moment/locale/tzl.js",
      "./tzl.js": "./node_modules/chart.js/node_modules/moment/locale/tzl.js",
      "./tzm": "./node_modules/chart.js/node_modules/moment/locale/tzm.js",
      "./tzm-latn": "./node_modules/chart.js/node_modules/moment/locale/tzm-latn.js",
      "./tzm-latn.js": "./node_modules/chart.js/node_modules/moment/locale/tzm-latn.js",
      "./tzm.js": "./node_modules/chart.js/node_modules/moment/locale/tzm.js",
      "./uk": "./node_modules/chart.js/node_modules/moment/locale/uk.js",
      "./uk.js": "./node_modules/chart.js/node_modules/moment/locale/uk.js",
      "./ur": "./node_modules/chart.js/node_modules/moment/locale/ur.js",
      "./ur.js": "./node_modules/chart.js/node_modules/moment/locale/ur.js",
      "./uz": "./node_modules/chart.js/node_modules/moment/locale/uz.js",
      "./uz-latn": "./node_modules/chart.js/node_modules/moment/locale/uz-latn.js",
      "./uz-latn.js": "./node_modules/chart.js/node_modules/moment/locale/uz-latn.js",
      "./uz.js": "./node_modules/chart.js/node_modules/moment/locale/uz.js",
      "./vi": "./node_modules/chart.js/node_modules/moment/locale/vi.js",
      "./vi.js": "./node_modules/chart.js/node_modules/moment/locale/vi.js",
      "./x-pseudo": "./node_modules/chart.js/node_modules/moment/locale/x-pseudo.js",
      "./x-pseudo.js": "./node_modules/chart.js/node_modules/moment/locale/x-pseudo.js",
      "./yo": "./node_modules/chart.js/node_modules/moment/locale/yo.js",
      "./yo.js": "./node_modules/chart.js/node_modules/moment/locale/yo.js",
      "./zh-cn": "./node_modules/chart.js/node_modules/moment/locale/zh-cn.js",
      "./zh-cn.js": "./node_modules/chart.js/node_modules/moment/locale/zh-cn.js",
      "./zh-hk": "./node_modules/chart.js/node_modules/moment/locale/zh-hk.js",
      "./zh-hk.js": "./node_modules/chart.js/node_modules/moment/locale/zh-hk.js",
      "./zh-tw": "./node_modules/chart.js/node_modules/moment/locale/zh-tw.js",
      "./zh-tw.js": "./node_modules/chart.js/node_modules/moment/locale/zh-tw.js"
    };

    function webpackContext(req) {
      var id = webpackContextResolve(req);
      return __webpack_require__(id);
    }

    function webpackContextResolve(req) {
      if (!__webpack_require__.o(map, req)) {
        var e = new Error("Cannot find module '" + req + "'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
      }

      return map[req];
    }

    webpackContext.keys = function webpackContextKeys() {
      return Object.keys(map);
    };

    webpackContext.resolve = webpackContextResolve;
    module.exports = webpackContext;
    webpackContext.id = "./node_modules/chart.js/node_modules/moment/locale sync recursive ^\\.\\/.*$";
    /***/
  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/af.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/af.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleAfJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Afrikaans [af]
    //! author : Werner Mollentze : https://github.com/wernerm
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var af = moment.defineLocale('af', {
        months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM: function isPM(input) {
          return /^nm$/i.test(input);
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 12) {
            return isLower ? 'vm' : 'VM';
          } else {
            return isLower ? 'nm' : 'NM';
          }
        },
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Vandag om] LT',
          nextDay: '[Môre om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[Gister om] LT',
          lastWeek: '[Laas] dddd [om] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'oor %s',
          past: '%s gelede',
          s: '\'n paar sekondes',
          m: '\'n minuut',
          mm: '%d minute',
          h: '\'n uur',
          hh: '%d ure',
          d: '\'n dag',
          dd: '%d dae',
          M: '\'n maand',
          MM: '%d maande',
          y: '\'n jaar',
          yy: '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
          return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
        },
        week: {
          dow: 1,
          // Maandag is die eerste dag van die week.
          doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.

        }
      });
      return af;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ar-dz.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ar-dz.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleArDzJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Arabic (Algeria) [ar-dz]
    //! author : Noureddine LOUAHEDJ : https://github.com/noureddineme
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var arDz = moment.defineLocale('ar-dz', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات'
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 4 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return arDz;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ar-kw.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ar-kw.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleArKwJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Arabic (Kuwait) [ar-kw]
    //! author : Nusret Parlak: https://github.com/nusretparlak
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var arKw = moment.defineLocale('ar-kw', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات'
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return arKw;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ar-ly.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ar-ly.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleArLyJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Arabic (Lybia) [ar-ly]
    //! author : Ali Hmer: https://github.com/kikoanis
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '1',
        '2': '2',
        '3': '3',
        '4': '4',
        '5': '5',
        '6': '6',
        '7': '7',
        '8': '8',
        '9': '9',
        '0': '0'
      };

      var pluralForm = function pluralForm(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
      };

      var plurals = {
        s: ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m: ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h: ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d: ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M: ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y: ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
      };

      var pluralize = function pluralize(u) {
        return function (number, withoutSuffix, string, isFuture) {
          var f = pluralForm(number),
              str = plurals[u][pluralForm(number)];

          if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
          }

          return str.replace(/%d/i, number);
        };
      };

      var months = ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'];
      var arLy = moment.defineLocale('ar-ly', {
        months: months,
        monthsShort: months,
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: "D/\u200FM/\u200FYYYY",
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM: function isPM(input) {
          return 'م' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'ص';
          } else {
            return 'م';
          }
        },
        calendar: {
          sameDay: '[اليوم عند الساعة] LT',
          nextDay: '[غدًا عند الساعة] LT',
          nextWeek: 'dddd [عند الساعة] LT',
          lastDay: '[أمس عند الساعة] LT',
          lastWeek: 'dddd [عند الساعة] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'بعد %s',
          past: 'منذ %s',
          s: pluralize('s'),
          m: pluralize('m'),
          mm: pluralize('m'),
          h: pluralize('h'),
          hh: pluralize('h'),
          d: pluralize('d'),
          dd: pluralize('d'),
          M: pluralize('M'),
          MM: pluralize('M'),
          y: pluralize('y'),
          yy: pluralize('y')
        },
        preparse: function preparse(string) {
          return string.replace(/\u200f/g, '').replace(/،/g, ',');
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          }).replace(/,/g, '،');
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return arLy;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ar-ma.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ar-ma.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleArMaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Arabic (Morocco) [ar-ma]
    //! author : ElFadili Yassine : https://github.com/ElFadiliY
    //! author : Abdel Said : https://github.com/abdelsaid
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var arMa = moment.defineLocale('ar-ma', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات'
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return arMa;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ar-sa.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ar-sa.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleArSaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Arabic (Saudi Arabia) [ar-sa]
    //! author : Suhail Alkowaileet : https://github.com/xsoh
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
      };
      var numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
      };
      var arSa = moment.defineLocale('ar-sa', {
        months: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM: function isPM(input) {
          return 'م' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'ص';
          } else {
            return 'م';
          }
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات'
        },
        preparse: function preparse(string) {
          return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
            return numberMap[match];
          }).replace(/،/g, ',');
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          }).replace(/,/g, '،');
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return arSa;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ar-tn.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ar-tn.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleArTnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale  :  Arabic (Tunisia) [ar-tn]
    //! author : Nader Toukabri : https://github.com/naderio
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var arTn = moment.defineLocale('ar-tn', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[اليوم على الساعة] LT',
          nextDay: '[غدا على الساعة] LT',
          nextWeek: 'dddd [على الساعة] LT',
          lastDay: '[أمس على الساعة] LT',
          lastWeek: 'dddd [على الساعة] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'في %s',
          past: 'منذ %s',
          s: 'ثوان',
          m: 'دقيقة',
          mm: '%d دقائق',
          h: 'ساعة',
          hh: '%d ساعات',
          d: 'يوم',
          dd: '%d أيام',
          M: 'شهر',
          MM: '%d أشهر',
          y: 'سنة',
          yy: '%d سنوات'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return arTn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ar.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ar.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleArJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Arabic [ar]
    //! author : Abdel Said: https://github.com/abdelsaid
    //! author : Ahmed Elkhatib
    //! author : forabi https://github.com/forabi
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
      };
      var numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
      };

      var pluralForm = function pluralForm(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
      };

      var plurals = {
        s: ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m: ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h: ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d: ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M: ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y: ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
      };

      var pluralize = function pluralize(u) {
        return function (number, withoutSuffix, string, isFuture) {
          var f = pluralForm(number),
              str = plurals[u][pluralForm(number)];

          if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
          }

          return str.replace(/%d/i, number);
        };
      };

      var months = ['كانون الثاني يناير', 'شباط فبراير', 'آذار مارس', 'نيسان أبريل', 'أيار مايو', 'حزيران يونيو', 'تموز يوليو', 'آب أغسطس', 'أيلول سبتمبر', 'تشرين الأول أكتوبر', 'تشرين الثاني نوفمبر', 'كانون الأول ديسمبر'];
      var ar = moment.defineLocale('ar', {
        months: months,
        monthsShort: months,
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: "D/\u200FM/\u200FYYYY",
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM: function isPM(input) {
          return 'م' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'ص';
          } else {
            return 'م';
          }
        },
        calendar: {
          sameDay: '[اليوم عند الساعة] LT',
          nextDay: '[غدًا عند الساعة] LT',
          nextWeek: 'dddd [عند الساعة] LT',
          lastDay: '[أمس عند الساعة] LT',
          lastWeek: 'dddd [عند الساعة] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'بعد %s',
          past: 'منذ %s',
          s: pluralize('s'),
          m: pluralize('m'),
          mm: pluralize('m'),
          h: pluralize('h'),
          hh: pluralize('h'),
          d: pluralize('d'),
          dd: pluralize('d'),
          M: pluralize('M'),
          MM: pluralize('M'),
          y: pluralize('y'),
          yy: pluralize('y')
        },
        preparse: function preparse(string) {
          return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
            return numberMap[match];
          }).replace(/،/g, ',');
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          }).replace(/,/g, '،');
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return ar;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/az.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/az.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleAzJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Azerbaijani [az]
    //! author : topchiyev : https://github.com/topchiyev
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-üncü',
        4: '-üncü',
        100: '-üncü',
        6: '-ncı',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-ıncı',
        90: '-ıncı'
      };
      var az = moment.defineLocale('az', {
        months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays: 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
        weekdaysShort: 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
        weekdaysMin: 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[bugün saat] LT',
          nextDay: '[sabah saat] LT',
          nextWeek: '[gələn həftə] dddd [saat] LT',
          lastDay: '[dünən] LT',
          lastWeek: '[keçən həftə] dddd [saat] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s sonra',
          past: '%s əvvəl',
          s: 'birneçə saniyyə',
          m: 'bir dəqiqə',
          mm: '%d dəqiqə',
          h: 'bir saat',
          hh: '%d saat',
          d: 'bir gün',
          dd: '%d gün',
          M: 'bir ay',
          MM: '%d ay',
          y: 'bir il',
          yy: '%d il'
        },
        meridiemParse: /gecə|səhər|gündüz|axşam/,
        isPM: function isPM(input) {
          return /^(gündüz|axşam)$/.test(input);
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'gecə';
          } else if (hour < 12) {
            return 'səhər';
          } else if (hour < 17) {
            return 'gündüz';
          } else {
            return 'axşam';
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
        ordinal: function ordinal(number) {
          if (number === 0) {
            // special case for zero
            return number + '-ıncı';
          }

          var a = number % 10,
              b = number % 100 - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return az;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/be.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/be.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleBeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Belarusian [be]
    //! author : Dmitry Demidov : https://github.com/demidov91
    //! author: Praleska: http://praleska.pro/
    //! Author : Menelion Elensúle : https://github.com/Oire
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
      }

      function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
          'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
          'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
          'dd': 'дзень_дні_дзён',
          'MM': 'месяц_месяцы_месяцаў',
          'yy': 'год_гады_гадоў'
        };

        if (key === 'm') {
          return withoutSuffix ? 'хвіліна' : 'хвіліну';
        } else if (key === 'h') {
          return withoutSuffix ? 'гадзіна' : 'гадзіну';
        } else {
          return number + ' ' + plural(format[key], +number);
        }
      }

      var be = moment.defineLocale('be', {
        months: {
          format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
          standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
        },
        monthsShort: 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
        weekdays: {
          format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
          standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
          isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
        },
        weekdaysShort: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY г.',
          LLL: 'D MMMM YYYY г., HH:mm',
          LLLL: 'dddd, D MMMM YYYY г., HH:mm'
        },
        calendar: {
          sameDay: '[Сёння ў] LT',
          nextDay: '[Заўтра ў] LT',
          lastDay: '[Учора ў] LT',
          nextWeek: function nextWeek() {
            return '[У] dddd [ў] LT';
          },
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return '[У мінулую] dddd [ў] LT';

              case 1:
              case 2:
              case 4:
                return '[У мінулы] dddd [ў] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'праз %s',
          past: '%s таму',
          s: 'некалькі секунд',
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: relativeTimeWithPlural,
          hh: relativeTimeWithPlural,
          d: 'дзень',
          dd: relativeTimeWithPlural,
          M: 'месяц',
          MM: relativeTimeWithPlural,
          y: 'год',
          yy: relativeTimeWithPlural
        },
        meridiemParse: /ночы|раніцы|дня|вечара/,
        isPM: function isPM(input) {
          return /^(дня|вечара)$/.test(input);
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'ночы';
          } else if (hour < 12) {
            return 'раніцы';
          } else if (hour < 17) {
            return 'дня';
          } else {
            return 'вечара';
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
              return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + '-і' : number + '-ы';

            case 'D':
              return number + '-га';

            default:
              return number;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return be;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/bg.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/bg.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleBgJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Bulgarian [bg]
    //! author : Krasen Borisov : https://github.com/kraz
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var bg = moment.defineLocale('bg', {
        months: 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort: 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
        weekdaysShort: 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[Днес в] LT',
          nextDay: '[Утре в] LT',
          nextWeek: 'dddd [в] LT',
          lastDay: '[Вчера в] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return '[В изминалата] dddd [в] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[В изминалия] dddd [в] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'след %s',
          past: 'преди %s',
          s: 'няколко секунди',
          m: 'минута',
          mm: '%d минути',
          h: 'час',
          hh: '%d часа',
          d: 'ден',
          dd: '%d дни',
          M: 'месец',
          MM: '%d месеца',
          y: 'година',
          yy: '%d години'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function ordinal(number) {
          var lastDigit = number % 10,
              last2Digits = number % 100;

          if (number === 0) {
            return number + '-ев';
          } else if (last2Digits === 0) {
            return number + '-ен';
          } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-ти';
          } else if (lastDigit === 1) {
            return number + '-ви';
          } else if (lastDigit === 2) {
            return number + '-ри';
          } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-ми';
          } else {
            return number + '-ти';
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return bg;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/bn.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/bn.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleBnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Bengali [bn]
    //! author : Kaushik Gandhi : https://github.com/kaushikgandhi
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '১',
        '2': '২',
        '3': '৩',
        '4': '৪',
        '5': '৫',
        '6': '৬',
        '7': '৭',
        '8': '৮',
        '9': '৯',
        '0': '০'
      };
      var numberMap = {
        '১': '1',
        '২': '2',
        '৩': '3',
        '৪': '4',
        '৫': '5',
        '৬': '6',
        '৭': '7',
        '৮': '8',
        '৯': '9',
        '০': '0'
      };
      var bn = moment.defineLocale('bn', {
        months: 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
        monthsShort: 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
        weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
        weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
        weekdaysMin: 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
        longDateFormat: {
          LT: 'A h:mm সময়',
          LTS: 'A h:mm:ss সময়',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm সময়',
          LLLL: 'dddd, D MMMM YYYY, A h:mm সময়'
        },
        calendar: {
          sameDay: '[আজ] LT',
          nextDay: '[আগামীকাল] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[গতকাল] LT',
          lastWeek: '[গত] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s পরে',
          past: '%s আগে',
          s: 'কয়েক সেকেন্ড',
          m: 'এক মিনিট',
          mm: '%d মিনিট',
          h: 'এক ঘন্টা',
          hh: '%d ঘন্টা',
          d: 'এক দিন',
          dd: '%d দিন',
          M: 'এক মাস',
          MM: '%d মাস',
          y: 'এক বছর',
          yy: '%d বছর'
        },
        preparse: function preparse(string) {
          return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'রাত' && hour >= 4 || meridiem === 'দুপুর' && hour < 5 || meridiem === 'বিকাল') {
            return hour + 12;
          } else {
            return hour;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'রাত';
          } else if (hour < 10) {
            return 'সকাল';
          } else if (hour < 17) {
            return 'দুপুর';
          } else if (hour < 20) {
            return 'বিকাল';
          } else {
            return 'রাত';
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return bn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/bo.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/bo.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleBoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Tibetan [bo]
    //! author : Thupten N. Chakrishar : https://github.com/vajradog
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '༡',
        '2': '༢',
        '3': '༣',
        '4': '༤',
        '5': '༥',
        '6': '༦',
        '7': '༧',
        '8': '༨',
        '9': '༩',
        '0': '༠'
      };
      var numberMap = {
        '༡': '1',
        '༢': '2',
        '༣': '3',
        '༤': '4',
        '༥': '5',
        '༦': '6',
        '༧': '7',
        '༨': '8',
        '༩': '9',
        '༠': '0'
      };
      var bo = moment.defineLocale('bo', {
        months: 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        monthsShort: 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        weekdays: 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
        weekdaysShort: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        weekdaysMin: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm',
          LLLL: 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar: {
          sameDay: '[དི་རིང] LT',
          nextDay: '[སང་ཉིན] LT',
          nextWeek: '[བདུན་ཕྲག་རྗེས་མ], LT',
          lastDay: '[ཁ་སང] LT',
          lastWeek: '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s ལ་',
          past: '%s སྔན་ལ',
          s: 'ལམ་སང',
          m: 'སྐར་མ་གཅིག',
          mm: '%d སྐར་མ',
          h: 'ཆུ་ཚོད་གཅིག',
          hh: '%d ཆུ་ཚོད',
          d: 'ཉིན་གཅིག',
          dd: '%d ཉིན་',
          M: 'ཟླ་བ་གཅིག',
          MM: '%d ཟླ་བ',
          y: 'ལོ་གཅིག',
          yy: '%d ལོ'
        },
        preparse: function preparse(string) {
          return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'མཚན་མོ' && hour >= 4 || meridiem === 'ཉིན་གུང' && hour < 5 || meridiem === 'དགོང་དག') {
            return hour + 12;
          } else {
            return hour;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'མཚན་མོ';
          } else if (hour < 10) {
            return 'ཞོགས་ཀས';
          } else if (hour < 17) {
            return 'ཉིན་གུང';
          } else if (hour < 20) {
            return 'དགོང་དག';
          } else {
            return 'མཚན་མོ';
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return bo;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/br.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/br.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleBrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Breton [br]
    //! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
          'mm': 'munutenn',
          'MM': 'miz',
          'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
      }

      function specialMutationForYears(number) {
        switch (lastNumber(number)) {
          case 1:
          case 3:
          case 4:
          case 5:
          case 9:
            return number + ' bloaz';

          default:
            return number + ' vloaz';
        }
      }

      function lastNumber(number) {
        if (number > 9) {
          return lastNumber(number % 10);
        }

        return number;
      }

      function mutation(text, number) {
        if (number === 2) {
          return softMutation(text);
        }

        return text;
      }

      function softMutation(text) {
        var mutationTable = {
          'm': 'v',
          'b': 'v',
          'd': 'z'
        };

        if (mutationTable[text.charAt(0)] === undefined) {
          return text;
        }

        return mutationTable[text.charAt(0)] + text.substring(1);
      }

      var br = moment.defineLocale('br', {
        months: 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort: 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays: 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'h[e]mm A',
          LTS: 'h[e]mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D [a viz] MMMM YYYY',
          LLL: 'D [a viz] MMMM YYYY h[e]mm A',
          LLLL: 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar: {
          sameDay: '[Hiziv da] LT',
          nextDay: '[Warc\'hoazh da] LT',
          nextWeek: 'dddd [da] LT',
          lastDay: '[Dec\'h da] LT',
          lastWeek: 'dddd [paset da] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'a-benn %s',
          past: '%s \'zo',
          s: 'un nebeud segondennoù',
          m: 'ur vunutenn',
          mm: relativeTimeWithMutation,
          h: 'un eur',
          hh: '%d eur',
          d: 'un devezh',
          dd: relativeTimeWithMutation,
          M: 'ur miz',
          MM: relativeTimeWithMutation,
          y: 'ur bloaz',
          yy: specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
        ordinal: function ordinal(number) {
          var output = number === 1 ? 'añ' : 'vet';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return br;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/bs.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/bs.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleBsJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Bosnian [bs]
    //! author : Nedim Cholich : https://github.com/frontyard
    //! based on (hr) translation by Bojan Marković
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function translate(number, withoutSuffix, key) {
        var result = number + ' ';

        switch (key) {
          case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';

          case 'mm':
            if (number === 1) {
              result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'minute';
            } else {
              result += 'minuta';
            }

            return result;

          case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';

          case 'hh':
            if (number === 1) {
              result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'sata';
            } else {
              result += 'sati';
            }

            return result;

          case 'dd':
            if (number === 1) {
              result += 'dan';
            } else {
              result += 'dana';
            }

            return result;

          case 'MM':
            if (number === 1) {
              result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'mjeseca';
            } else {
              result += 'mjeseci';
            }

            return result;

          case 'yy':
            if (number === 1) {
              result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'godine';
            } else {
              result += 'godina';
            }

            return result;
        }
      }

      var bs = moment.defineLocale('bs', {
        months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[u] [nedjelju] [u] LT';

              case 3:
                return '[u] [srijedu] [u] LT';

              case 6:
                return '[u] [subotu] [u] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[u] dddd [u] LT';
            }
          },
          lastDay: '[jučer u] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
              case 3:
                return '[prošlu] dddd [u] LT';

              case 6:
                return '[prošle] [subote] [u] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[prošli] dddd [u] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'par sekundi',
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: 'dan',
          dd: translate,
          M: 'mjesec',
          MM: translate,
          y: 'godinu',
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return bs;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ca.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ca.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleCaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Catalan [ca]
    //! author : Juan G. Hurtado : https://github.com/juanghurtado
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ca = moment.defineLocale('ca', {
        months: {
          standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
          format: 'de gener_de febrer_de març_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
          isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort: 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact: true,
        weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin: 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: '[el] D MMMM [de] YYYY',
          ll: 'D MMM YYYY',
          LLL: '[el] D MMMM [de] YYYY [a les] H:mm',
          lll: 'D MMM YYYY, H:mm',
          LLLL: '[el] dddd D MMMM [de] YYYY [a les] H:mm',
          llll: 'ddd D MMM YYYY, H:mm'
        },
        calendar: {
          sameDay: function sameDay() {
            return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          nextDay: function nextDay() {
            return '[demà a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          nextWeek: function nextWeek() {
            return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          lastDay: function lastDay() {
            return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          lastWeek: function lastWeek() {
            return '[el] dddd [passat a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'd\'aquí %s',
          past: 'fa %s',
          s: 'uns segons',
          m: 'un minut',
          mm: '%d minuts',
          h: 'una hora',
          hh: '%d hores',
          d: 'un dia',
          dd: '%d dies',
          M: 'un mes',
          MM: '%d mesos',
          y: 'un any',
          yy: '%d anys'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal: function ordinal(number, period) {
          var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : 'è';

          if (period === 'w' || period === 'W') {
            output = 'a';
          }

          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return ca;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/cs.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/cs.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleCsJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Czech [cs]
    //! author : petrbela : https://github.com/petrbela
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_');
      var monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');

      function plural(n) {
        return n > 1 && n < 5 && ~~(n / 10) !== 1;
      }

      function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';

        switch (key) {
          case 's':
            // a few seconds / in a few seconds / a few seconds ago
            return withoutSuffix || isFuture ? 'pár sekund' : 'pár sekundami';

          case 'm':
            // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';

          case 'mm':
            // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'minuty' : 'minut');
            } else {
              return result + 'minutami';
            }

            break;

          case 'h':
            // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

          case 'hh':
            // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'hodiny' : 'hodin');
            } else {
              return result + 'hodinami';
            }

            break;

          case 'd':
            // a day / in a day / a day ago
            return withoutSuffix || isFuture ? 'den' : 'dnem';

          case 'dd':
            // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'dny' : 'dní');
            } else {
              return result + 'dny';
            }

            break;

          case 'M':
            // a month / in a month / a month ago
            return withoutSuffix || isFuture ? 'měsíc' : 'měsícem';

          case 'MM':
            // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'měsíce' : 'měsíců');
            } else {
              return result + 'měsíci';
            }

            break;

          case 'y':
            // a year / in a year / a year ago
            return withoutSuffix || isFuture ? 'rok' : 'rokem';

          case 'yy':
            // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'roky' : 'let');
            } else {
              return result + 'lety';
            }

            break;
        }
      }

      var cs = moment.defineLocale('cs', {
        months: months,
        monthsShort: monthsShort,
        monthsParse: function (months, monthsShort) {
          var i,
              _monthsParse = [];

          for (i = 0; i < 12; i++) {
            // use custom parser to solve problem with July (červenec)
            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
          }

          return _monthsParse;
        }(months, monthsShort),
        shortMonthsParse: function (monthsShort) {
          var i,
              _shortMonthsParse = [];

          for (i = 0; i < 12; i++) {
            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
          }

          return _shortMonthsParse;
        }(monthsShort),
        longMonthsParse: function (months) {
          var i,
              _longMonthsParse = [];

          for (i = 0; i < 12; i++) {
            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
          }

          return _longMonthsParse;
        }(months),
        weekdays: 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
        weekdaysShort: 'ne_po_út_st_čt_pá_so'.split('_'),
        weekdaysMin: 'ne_po_út_st_čt_pá_so'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd D. MMMM YYYY H:mm',
          l: 'D. M. YYYY'
        },
        calendar: {
          sameDay: '[dnes v] LT',
          nextDay: '[zítra v] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[v neděli v] LT';

              case 1:
              case 2:
                return '[v] dddd [v] LT';

              case 3:
                return '[ve středu v] LT';

              case 4:
                return '[ve čtvrtek v] LT';

              case 5:
                return '[v pátek v] LT';

              case 6:
                return '[v sobotu v] LT';
            }
          },
          lastDay: '[včera v] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
                return '[minulou neděli v] LT';

              case 1:
              case 2:
                return '[minulé] dddd [v] LT';

              case 3:
                return '[minulou středu v] LT';

              case 4:
              case 5:
                return '[minulý] dddd [v] LT';

              case 6:
                return '[minulou sobotu v] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'za %s',
          past: 'před %s',
          s: translate,
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: translate,
          dd: translate,
          M: translate,
          MM: translate,
          y: translate,
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return cs;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/cv.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/cv.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleCvJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Chuvash [cv]
    //! author : Anatoly Mironov : https://github.com/mirontoli
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var cv = moment.defineLocale('cv', {
        months: 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
        monthsShort: 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
        weekdays: 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
        weekdaysShort: 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
        weekdaysMin: 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
          LLL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
          LLLL: 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
        },
        calendar: {
          sameDay: '[Паян] LT [сехетре]',
          nextDay: '[Ыран] LT [сехетре]',
          lastDay: '[Ӗнер] LT [сехетре]',
          nextWeek: '[Ҫитес] dddd LT [сехетре]',
          lastWeek: '[Иртнӗ] dddd LT [сехетре]',
          sameElse: 'L'
        },
        relativeTime: {
          future: function future(output) {
            var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
            return output + affix;
          },
          past: '%s каялла',
          s: 'пӗр-ик ҫеккунт',
          m: 'пӗр минут',
          mm: '%d минут',
          h: 'пӗр сехет',
          hh: '%d сехет',
          d: 'пӗр кун',
          dd: '%d кун',
          M: 'пӗр уйӑх',
          MM: '%d уйӑх',
          y: 'пӗр ҫул',
          yy: '%d ҫул'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
        ordinal: '%d-мӗш',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return cv;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/cy.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/cy.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleCyJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Welsh [cy]
    //! author : Robert Allen : https://github.com/robgallen
    //! author : https://github.com/ryangreaves
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact: true,
        // time formats are the same as en-gb
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Heddiw am] LT',
          nextDay: '[Yfory am] LT',
          nextWeek: 'dddd [am] LT',
          lastDay: '[Ddoe am] LT',
          lastWeek: 'dddd [diwethaf am] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'mewn %s',
          past: '%s yn ôl',
          s: 'ychydig eiliadau',
          m: 'munud',
          mm: '%d munud',
          h: 'awr',
          hh: '%d awr',
          d: 'diwrnod',
          dd: '%d diwrnod',
          M: 'mis',
          MM: '%d mis',
          y: 'blwyddyn',
          yy: '%d flynedd'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function ordinal(number) {
          var b = number,
              output = '',
              lookup = ['', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
          'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
          ];

          if (b > 20) {
            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
              output = 'fed'; // not 30ain, 70ain or 90ain
            } else {
              output = 'ain';
            }
          } else if (b > 0) {
            output = lookup[b];
          }

          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return cy;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/da.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/da.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleDaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Danish [da]
    //! author : Ulrik Nielsen : https://github.com/mrbase
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var da = moment.defineLocale('da', {
        months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'søn_man_tir_ons_tor_fre_lør'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
        },
        calendar: {
          sameDay: '[i dag kl.] LT',
          nextDay: '[i morgen kl.] LT',
          nextWeek: 'på dddd [kl.] LT',
          lastDay: '[i går kl.] LT',
          lastWeek: '[i] dddd[s kl.] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'om %s',
          past: '%s siden',
          s: 'få sekunder',
          m: 'et minut',
          mm: '%d minutter',
          h: 'en time',
          hh: '%d timer',
          d: 'en dag',
          dd: '%d dage',
          M: 'en måned',
          MM: '%d måneder',
          y: 'et år',
          yy: '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return da;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/de-at.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/de-at.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleDeAtJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : German (Austria) [de-at]
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensúle: https://github.com/Oire
    //! author : Martin Groller : https://github.com/MadMG
    //! author : Mikolaj Dadela : https://github.com/mik01aj
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
          'm': ['eine Minute', 'einer Minute'],
          'h': ['eine Stunde', 'einer Stunde'],
          'd': ['ein Tag', 'einem Tag'],
          'dd': [number + ' Tage', number + ' Tagen'],
          'M': ['ein Monat', 'einem Monat'],
          'MM': [number + ' Monate', number + ' Monaten'],
          'y': ['ein Jahr', 'einem Jahr'],
          'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
      }

      var deAt = moment.defineLocale('de-at', {
        months: 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          m: processRelativeTime,
          mm: '%d Minuten',
          h: processRelativeTime,
          hh: '%d Stunden',
          d: processRelativeTime,
          dd: processRelativeTime,
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return deAt;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/de-ch.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/de-ch.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleDeChJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : German (Switzerland) [de-ch]
    //! author : sschueller : https://github.com/sschueller
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict'; // based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
          'm': ['eine Minute', 'einer Minute'],
          'h': ['eine Stunde', 'einer Stunde'],
          'd': ['ein Tag', 'einem Tag'],
          'dd': [number + ' Tage', number + ' Tagen'],
          'M': ['ein Monat', 'einem Monat'],
          'MM': [number + ' Monate', number + ' Monaten'],
          'y': ['ein Jahr', 'einem Jahr'],
          'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
      }

      var deCh = moment.defineLocale('de-ch', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._März_April_Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH.mm',
          LLLL: 'dddd, D. MMMM YYYY HH.mm'
        },
        calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          m: processRelativeTime,
          mm: '%d Minuten',
          h: processRelativeTime,
          hh: '%d Stunden',
          d: processRelativeTime,
          dd: processRelativeTime,
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return deCh;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/de.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/de.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleDeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : German [de]
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensúle: https://github.com/Oire
    //! author : Mikolaj Dadela : https://github.com/mik01aj
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
          'm': ['eine Minute', 'einer Minute'],
          'h': ['eine Stunde', 'einer Stunde'],
          'd': ['ein Tag', 'einem Tag'],
          'dd': [number + ' Tage', number + ' Tagen'],
          'M': ['ein Monat', 'einem Monat'],
          'MM': [number + ' Monate', number + ' Monaten'],
          'y': ['ein Jahr', 'einem Jahr'],
          'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
      }

      var de = moment.defineLocale('de', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          m: processRelativeTime,
          mm: '%d Minuten',
          h: processRelativeTime,
          hh: '%d Stunden',
          d: processRelativeTime,
          dd: processRelativeTime,
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return de;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/dv.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/dv.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleDvJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Maldivian [dv]
    //! author : Jawish Hameed : https://github.com/jawish
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var months = ['ޖެނުއަރީ', 'ފެބްރުއަރީ', 'މާރިޗު', 'އޭޕްރީލު', 'މޭ', 'ޖޫން', 'ޖުލައި', 'އޯގަސްޓު', 'ސެޕްޓެމްބަރު', 'އޮކްޓޯބަރު', 'ނޮވެމްބަރު', 'ޑިސެމްބަރު'];
      var weekdays = ['އާދިއްތަ', 'ހޯމަ', 'އަންގާރަ', 'ބުދަ', 'ބުރާސްފަތި', 'ހުކުރު', 'ހޮނިހިރު'];
      var dv = moment.defineLocale('dv', {
        months: months,
        monthsShort: months,
        weekdays: weekdays,
        weekdaysShort: weekdays,
        weekdaysMin: 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'D/M/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /މކ|މފ/,
        isPM: function isPM(input) {
          return 'މފ' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'މކ';
          } else {
            return 'މފ';
          }
        },
        calendar: {
          sameDay: '[މިއަދު] LT',
          nextDay: '[މާދަމާ] LT',
          nextWeek: 'dddd LT',
          lastDay: '[އިއްޔެ] LT',
          lastWeek: '[ފާއިތުވި] dddd LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'ތެރޭގައި %s',
          past: 'ކުރިން %s',
          s: 'ސިކުންތުކޮޅެއް',
          m: 'މިނިޓެއް',
          mm: 'މިނިޓު %d',
          h: 'ގަޑިއިރެއް',
          hh: 'ގަޑިއިރު %d',
          d: 'ދުވަހެއް',
          dd: 'ދުވަސް %d',
          M: 'މަހެއް',
          MM: 'މަސް %d',
          y: 'އަހަރެއް',
          yy: 'އަހަރު %d'
        },
        preparse: function preparse(string) {
          return string.replace(/،/g, ',');
        },
        postformat: function postformat(string) {
          return string.replace(/,/g, '،');
        },
        week: {
          dow: 7,
          // Sunday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return dv;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/el.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/el.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleElJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Greek [el]
    //! author : Aggelos Karalias : https://github.com/mehiel
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      var el = moment.defineLocale('el', {
        monthsNominativeEl: 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
        monthsGenitiveEl: 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
        months: function months(momentToFormat, format) {
          if (!momentToFormat) {
            return this._monthsNominativeEl;
          } else if (/D/.test(format.substring(0, format.indexOf('MMMM')))) {
            // if there is a day number before 'MMMM'
            return this._monthsGenitiveEl[momentToFormat.month()];
          } else {
            return this._monthsNominativeEl[momentToFormat.month()];
          }
        },
        monthsShort: 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays: 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
        weekdaysShort: 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin: 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'μμ' : 'ΜΜ';
          } else {
            return isLower ? 'πμ' : 'ΠΜ';
          }
        },
        isPM: function isPM(input) {
          return (input + '').toLowerCase()[0] === 'μ';
        },
        meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl: {
          sameDay: '[Σήμερα {}] LT',
          nextDay: '[Αύριο {}] LT',
          nextWeek: 'dddd [{}] LT',
          lastDay: '[Χθες {}] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 6:
                return '[το προηγούμενο] dddd [{}] LT';

              default:
                return '[την προηγούμενη] dddd [{}] LT';
            }
          },
          sameElse: 'L'
        },
        calendar: function calendar(key, mom) {
          var output = this._calendarEl[key],
              hours = mom && mom.hours();

          if (isFunction(output)) {
            output = output.apply(mom);
          }

          return output.replace('{}', hours % 12 === 1 ? 'στη' : 'στις');
        },
        relativeTime: {
          future: 'σε %s',
          past: '%s πριν',
          s: 'λίγα δευτερόλεπτα',
          m: 'ένα λεπτό',
          mm: '%d λεπτά',
          h: 'μία ώρα',
          hh: '%d ώρες',
          d: 'μία μέρα',
          dd: '%d μέρες',
          M: 'ένας μήνας',
          MM: '%d μήνες',
          y: 'ένας χρόνος',
          yy: '%d χρόνια'
        },
        dayOfMonthOrdinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4st is the first week of the year.

        }
      });
      return el;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/en-au.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/en-au.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEnAuJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : English (Australia) [en-au]
    //! author : Jared Morse : https://github.com/jarcoal
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var enAu = moment.defineLocale('en-au', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return enAu;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/en-ca.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/en-ca.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEnCaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : English (Canada) [en-ca]
    //! author : Jonathan Abourbih : https://github.com/jonbca
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var enCa = moment.defineLocale('en-ca', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'YYYY-MM-DD',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        }
      });
      return enCa;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/en-gb.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/en-gb.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEnGbJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : English (United Kingdom) [en-gb]
    //! author : Chris Gedrim : https://github.com/chrisgedrim
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var enGb = moment.defineLocale('en-gb', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return enGb;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/en-ie.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/en-ie.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEnIeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : English (Ireland) [en-ie]
    //! author : Chris Cartlidge : https://github.com/chriscartlidge
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var enIe = moment.defineLocale('en-ie', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return enIe;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/en-nz.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/en-nz.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEnNzJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : English (New Zealand) [en-nz]
    //! author : Luke McGregor : https://github.com/lukemcgregor
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var enNz = moment.defineLocale('en-nz', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return enNz;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/eo.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/eo.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Esperanto [eo]
    //! author : Colin Dean : https://github.com/colindean
    //! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
    //! comment : miestasmia corrected the translation by colindean
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var eo = moment.defineLocale('eo', {
        months: 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
        weekdays: 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
        weekdaysShort: 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
        weekdaysMin: 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D[-a de] MMMM, YYYY',
          LLL: 'D[-a de] MMMM, YYYY HH:mm',
          LLLL: 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function isPM(input) {
          return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'p.t.m.' : 'P.T.M.';
          } else {
            return isLower ? 'a.t.m.' : 'A.T.M.';
          }
        },
        calendar: {
          sameDay: '[Hodiaŭ je] LT',
          nextDay: '[Morgaŭ je] LT',
          nextWeek: 'dddd [je] LT',
          lastDay: '[Hieraŭ je] LT',
          lastWeek: '[pasinta] dddd [je] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'post %s',
          past: 'antaŭ %s',
          s: 'sekundoj',
          m: 'minuto',
          mm: '%d minutoj',
          h: 'horo',
          hh: '%d horoj',
          d: 'tago',
          //ne 'diurno', ĉar estas uzita por proksimumo
          dd: '%d tagoj',
          M: 'monato',
          MM: '%d monatoj',
          y: 'jaro',
          yy: '%d jaroj'
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: '%da',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return eo;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/es-do.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/es-do.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEsDoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Spanish (Dominican Republic) [es-do]
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');

      var _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

      var esDo = moment.defineLocale('es-do', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort: function monthsShort(m, format) {
          if (!m) {
            return monthsShortDot;
          } else if (/-MMM-/.test(format)) {
            return _monthsShort[m.month()];
          } else {
            return monthsShortDot[m.month()];
          }
        },
        monthsParseExact: true,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY h:mm A',
          LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar: {
          sameDay: function sameDay() {
            return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextDay: function nextDay() {
            return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextWeek: function nextWeek() {
            return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastDay: function lastDay() {
            return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastWeek: function lastWeek() {
            return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'en %s',
          past: 'hace %s',
          s: 'unos segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'una hora',
          hh: '%d horas',
          d: 'un día',
          dd: '%d días',
          M: 'un mes',
          MM: '%d meses',
          y: 'un año',
          yy: '%d años'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return esDo;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/es.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/es.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEsJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Spanish [es]
    //! author : Julio Napurí : https://github.com/julionc
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');

      var _monthsShort2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

      var es = moment.defineLocale('es', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort: function monthsShort(m, format) {
          if (!m) {
            return monthsShortDot;
          } else if (/-MMM-/.test(format)) {
            return _monthsShort2[m.month()];
          } else {
            return monthsShortDot[m.month()];
          }
        },
        monthsParseExact: true,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY H:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar: {
          sameDay: function sameDay() {
            return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextDay: function nextDay() {
            return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextWeek: function nextWeek() {
            return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastDay: function lastDay() {
            return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastWeek: function lastWeek() {
            return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'en %s',
          past: 'hace %s',
          s: 'unos segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'una hora',
          hh: '%d horas',
          d: 'un día',
          dd: '%d días',
          M: 'un mes',
          MM: '%d meses',
          y: 'un año',
          yy: '%d años'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return es;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/et.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/et.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEtJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Estonian [et]
    //! author : Henry Kehlmann : https://github.com/madhenry
    //! improvements : Illimar Tambek : https://github.com/ragulka
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
          's': ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
          'm': ['ühe minuti', 'üks minut'],
          'mm': [number + ' minuti', number + ' minutit'],
          'h': ['ühe tunni', 'tund aega', 'üks tund'],
          'hh': [number + ' tunni', number + ' tundi'],
          'd': ['ühe päeva', 'üks päev'],
          'M': ['kuu aja', 'kuu aega', 'üks kuu'],
          'MM': [number + ' kuu', number + ' kuud'],
          'y': ['ühe aasta', 'aasta', 'üks aasta'],
          'yy': [number + ' aasta', number + ' aastat']
        };

        if (withoutSuffix) {
          return format[key][2] ? format[key][2] : format[key][1];
        }

        return isFuture ? format[key][0] : format[key][1];
      }

      var et = moment.defineLocale('et', {
        months: 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort: 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays: 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
        weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[Täna,] LT',
          nextDay: '[Homme,] LT',
          nextWeek: '[Järgmine] dddd LT',
          lastDay: '[Eile,] LT',
          lastWeek: '[Eelmine] dddd LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s pärast',
          past: '%s tagasi',
          s: processRelativeTime,
          m: processRelativeTime,
          mm: processRelativeTime,
          h: processRelativeTime,
          hh: processRelativeTime,
          d: processRelativeTime,
          dd: '%d päeva',
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return et;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/eu.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/eu.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleEuJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Basque [eu]
    //! author : Eneko Illarramendi : https://github.com/eillarra
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var eu = moment.defineLocale('eu', {
        months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact: true,
        weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY[ko] MMMM[ren] D[a]',
          LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
          LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
          l: 'YYYY-M-D',
          ll: 'YYYY[ko] MMM D[a]',
          lll: 'YYYY[ko] MMM D[a] HH:mm',
          llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar: {
          sameDay: '[gaur] LT[etan]',
          nextDay: '[bihar] LT[etan]',
          nextWeek: 'dddd LT[etan]',
          lastDay: '[atzo] LT[etan]',
          lastWeek: '[aurreko] dddd LT[etan]',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s barru',
          past: 'duela %s',
          s: 'segundo batzuk',
          m: 'minutu bat',
          mm: '%d minutu',
          h: 'ordu bat',
          hh: '%d ordu',
          d: 'egun bat',
          dd: '%d egun',
          M: 'hilabete bat',
          MM: '%d hilabete',
          y: 'urte bat',
          yy: '%d urte'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return eu;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/fa.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/fa.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleFaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Persian [fa]
    //! author : Ebrahim Byagowi : https://github.com/ebraminio
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '۱',
        '2': '۲',
        '3': '۳',
        '4': '۴',
        '5': '۵',
        '6': '۶',
        '7': '۷',
        '8': '۸',
        '9': '۹',
        '0': '۰'
      };
      var numberMap = {
        '۱': '1',
        '۲': '2',
        '۳': '3',
        '۴': '4',
        '۵': '5',
        '۶': '6',
        '۷': '7',
        '۸': '8',
        '۹': '9',
        '۰': '0'
      };
      var fa = moment.defineLocale('fa', {
        months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        weekdays: "\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split('_'),
        weekdaysShort: "\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split('_'),
        weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /قبل از ظهر|بعد از ظهر/,
        isPM: function isPM(input) {
          return /بعد از ظهر/.test(input);
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'قبل از ظهر';
          } else {
            return 'بعد از ظهر';
          }
        },
        calendar: {
          sameDay: '[امروز ساعت] LT',
          nextDay: '[فردا ساعت] LT',
          nextWeek: 'dddd [ساعت] LT',
          lastDay: '[دیروز ساعت] LT',
          lastWeek: 'dddd [پیش] [ساعت] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'در %s',
          past: '%s پیش',
          s: 'چند ثانیه',
          m: 'یک دقیقه',
          mm: '%d دقیقه',
          h: 'یک ساعت',
          hh: '%d ساعت',
          d: 'یک روز',
          dd: '%d روز',
          M: 'یک ماه',
          MM: '%d ماه',
          y: 'یک سال',
          yy: '%d سال'
        },
        preparse: function preparse(string) {
          return string.replace(/[۰-۹]/g, function (match) {
            return numberMap[match];
          }).replace(/،/g, ',');
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          }).replace(/,/g, '،');
        },
        dayOfMonthOrdinalParse: /\d{1,2}م/,
        ordinal: '%dم',
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return fa;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/fi.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/fi.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleFiJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Finnish [fi]
    //! author : Tarmo Aidantausta : https://github.com/bleadof
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' ');
      var numbersFuture = ['nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden', numbersPast[7], numbersPast[8], numbersPast[9]];

      function translate(number, withoutSuffix, key, isFuture) {
        var result = '';

        switch (key) {
          case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';

          case 'm':
            return isFuture ? 'minuutin' : 'minuutti';

          case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;

          case 'h':
            return isFuture ? 'tunnin' : 'tunti';

          case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;

          case 'd':
            return isFuture ? 'päivän' : 'päivä';

          case 'dd':
            result = isFuture ? 'päivän' : 'päivää';
            break;

          case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';

          case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;

          case 'y':
            return isFuture ? 'vuoden' : 'vuosi';

          case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
        }

        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
      }

      function verbalNumber(number, isFuture) {
        return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
      }

      var fi = moment.defineLocale('fi', {
        months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort: 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
        weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD.MM.YYYY',
          LL: 'Do MMMM[ta] YYYY',
          LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
          LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
          l: 'D.M.YYYY',
          ll: 'Do MMM YYYY',
          lll: 'Do MMM YYYY, [klo] HH.mm',
          llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar: {
          sameDay: '[tänään] [klo] LT',
          nextDay: '[huomenna] [klo] LT',
          nextWeek: 'dddd [klo] LT',
          lastDay: '[eilen] [klo] LT',
          lastWeek: '[viime] dddd[na] [klo] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s päästä',
          past: '%s sitten',
          s: translate,
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: translate,
          dd: translate,
          M: translate,
          MM: translate,
          y: translate,
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return fi;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/fo.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/fo.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleFoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Faroese [fo]
    //! author : Ragnar Johannesen : https://github.com/ragnar123
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var fo = moment.defineLocale('fo', {
        months: 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
        weekdaysShort: 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
        weekdaysMin: 'su_má_tý_mi_hó_fr_le'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Í dag kl.] LT',
          nextDay: '[Í morgin kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[Í gjár kl.] LT',
          lastWeek: '[síðstu] dddd [kl] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'um %s',
          past: '%s síðani',
          s: 'fá sekund',
          m: 'ein minutt',
          mm: '%d minuttir',
          h: 'ein tími',
          hh: '%d tímar',
          d: 'ein dagur',
          dd: '%d dagar',
          M: 'ein mánaði',
          MM: '%d mánaðir',
          y: 'eitt ár',
          yy: '%d ár'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return fo;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/fr-ca.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/fr-ca.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleFrCaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : French (Canada) [fr-ca]
    //! author : Jonathan Abourbih : https://github.com/jonbca
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var frCa = moment.defineLocale('fr-ca', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Aujourd’hui à] LT',
          nextDay: '[Demain à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[Hier à] LT',
          lastWeek: 'dddd [dernier à] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
              return number + (number === 1 ? 'er' : 'e');
            // Words with feminine grammatical gender: semaine

            case 'w':
            case 'W':
              return number + (number === 1 ? 're' : 'e');
          }
        }
      });
      return frCa;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/fr-ch.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/fr-ch.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleFrChJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : French (Switzerland) [fr-ch]
    //! author : Gaspard Bucher : https://github.com/gaspard
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var frCh = moment.defineLocale('fr-ch', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Aujourd’hui à] LT',
          nextDay: '[Demain à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[Hier à] LT',
          lastWeek: 'dddd [dernier à] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
              return number + (number === 1 ? 'er' : 'e');
            // Words with feminine grammatical gender: semaine

            case 'w':
            case 'W':
              return number + (number === 1 ? 're' : 'e');
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return frCh;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/fr.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/fr.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleFrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : French [fr]
    //! author : John Fischer : https://github.com/jfroffice
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var fr = moment.defineLocale('fr', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Aujourd’hui à] LT',
          nextDay: '[Demain à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[Hier à] LT',
          lastWeek: 'dddd [dernier à] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case 'D':
              return number + (number === 1 ? 'er' : '');
            // Words with masculine grammatical gender: mois, trimestre, jour

            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
              return number + (number === 1 ? 'er' : 'e');
            // Words with feminine grammatical gender: semaine

            case 'w':
            case 'W':
              return number + (number === 1 ? 're' : 'e');
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return fr;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/fy.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/fy.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleFyJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Frisian [fy]
    //! author : Robin van der Vliet : https://github.com/robin0van0der0v
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
      var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
      var fy = moment.defineLocale('fy', {
        months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort: function monthsShort(m, format) {
          if (!m) {
            return monthsShortWithDots;
          } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
          } else {
            return monthsShortWithDots[m.month()];
          }
        },
        monthsParseExact: true,
        weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[hjoed om] LT',
          nextDay: '[moarn om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[juster om] LT',
          lastWeek: '[ôfrûne] dddd [om] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'oer %s',
          past: '%s lyn',
          s: 'in pear sekonden',
          m: 'ien minút',
          mm: '%d minuten',
          h: 'ien oere',
          hh: '%d oeren',
          d: 'ien dei',
          dd: '%d dagen',
          M: 'ien moanne',
          MM: '%d moannen',
          y: 'ien jier',
          yy: '%d jierren'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
          return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return fy;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/gd.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/gd.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleGdJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Scottish Gaelic [gd]
    //! author : Jon Ashdown : https://github.com/jonashdown
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var months = ['Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'];
      var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];
      var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
      var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
      var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];
      var gd = moment.defineLocale('gd', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[An-diugh aig] LT',
          nextDay: '[A-màireach aig] LT',
          nextWeek: 'dddd [aig] LT',
          lastDay: '[An-dè aig] LT',
          lastWeek: 'dddd [seo chaidh] [aig] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'ann an %s',
          past: 'bho chionn %s',
          s: 'beagan diogan',
          m: 'mionaid',
          mm: '%d mionaidean',
          h: 'uair',
          hh: '%d uairean',
          d: 'latha',
          dd: '%d latha',
          M: 'mìos',
          MM: '%d mìosan',
          y: 'bliadhna',
          yy: '%d bliadhna'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function ordinal(number) {
          var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return gd;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/gl.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/gl.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleGlJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Galician [gl]
    //! author : Juan G. Hurtado : https://github.com/juanghurtado
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var gl = moment.defineLocale('gl', {
        months: 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
        monthsShort: 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mé_xo_ve_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY H:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar: {
          sameDay: function sameDay() {
            return '[hoxe ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
          },
          nextDay: function nextDay() {
            return '[mañá ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
          },
          nextWeek: function nextWeek() {
            return 'dddd [' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT';
          },
          lastDay: function lastDay() {
            return '[onte ' + (this.hours() !== 1 ? 'á' : 'a') + '] LT';
          },
          lastWeek: function lastWeek() {
            return '[o] dddd [pasado ' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT';
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: function future(str) {
            if (str.indexOf('un') === 0) {
              return 'n' + str;
            }

            return 'en ' + str;
          },
          past: 'hai %s',
          s: 'uns segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'unha hora',
          hh: '%d horas',
          d: 'un día',
          dd: '%d días',
          M: 'un mes',
          MM: '%d meses',
          y: 'un ano',
          yy: '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return gl;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/gom-latn.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/gom-latn.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleGomLatnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Konkani Latin script [gom-latn]
    //! author : The Discoverer : https://github.com/WikiDiscoverer
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
          's': ['thodde secondanim', 'thodde second'],
          'm': ['eka mintan', 'ek minute'],
          'mm': [number + ' mintanim', number + ' mintam'],
          'h': ['eka horan', 'ek hor'],
          'hh': [number + ' horanim', number + ' hor'],
          'd': ['eka disan', 'ek dis'],
          'dd': [number + ' disanim', number + ' dis'],
          'M': ['eka mhoinean', 'ek mhoino'],
          'MM': [number + ' mhoineanim', number + ' mhoine'],
          'y': ['eka vorsan', 'ek voros'],
          'yy': [number + ' vorsanim', number + ' vorsam']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
      }

      var gomLatn = moment.defineLocale('gom-latn', {
        months: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
        monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
        weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'A h:mm [vazta]',
          LTS: 'A h:mm:ss [vazta]',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY A h:mm [vazta]',
          LLLL: 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
          llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
        },
        calendar: {
          sameDay: '[Aiz] LT',
          nextDay: '[Faleam] LT',
          nextWeek: '[Ieta to] dddd[,] LT',
          lastDay: '[Kal] LT',
          lastWeek: '[Fatlo] dddd[,] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s',
          past: '%s adim',
          s: processRelativeTime,
          m: processRelativeTime,
          mm: processRelativeTime,
          h: processRelativeTime,
          hh: processRelativeTime,
          d: processRelativeTime,
          dd: processRelativeTime,
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            // the ordinal 'er' only applies to day of the month
            case 'D':
              return number + 'er';

            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
            case 'w':
            case 'W':
              return number;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        },
        meridiemParse: /rati|sokalli|donparam|sanje/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'rati') {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'sokalli') {
            return hour;
          } else if (meridiem === 'donparam') {
            return hour > 12 ? hour : hour + 12;
          } else if (meridiem === 'sanje') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'rati';
          } else if (hour < 12) {
            return 'sokalli';
          } else if (hour < 16) {
            return 'donparam';
          } else if (hour < 20) {
            return 'sanje';
          } else {
            return 'rati';
          }
        }
      });
      return gomLatn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/he.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/he.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleHeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Hebrew [he]
    //! author : Tomer Cohen : https://github.com/tomer
    //! author : Moshe Simantov : https://github.com/DevelopmentIL
    //! author : Tal Ater : https://github.com/TalAter
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var he = moment.defineLocale('he', {
        months: 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
        monthsShort: 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
        weekdays: 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
        weekdaysShort: 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
        weekdaysMin: 'א_ב_ג_ד_ה_ו_ש'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [ב]MMMM YYYY',
          LLL: 'D [ב]MMMM YYYY HH:mm',
          LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
          l: 'D/M/YYYY',
          ll: 'D MMM YYYY',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd, D MMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[היום ב־]LT',
          nextDay: '[מחר ב־]LT',
          nextWeek: 'dddd [בשעה] LT',
          lastDay: '[אתמול ב־]LT',
          lastWeek: '[ביום] dddd [האחרון בשעה] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'בעוד %s',
          past: 'לפני %s',
          s: 'מספר שניות',
          m: 'דקה',
          mm: '%d דקות',
          h: 'שעה',
          hh: function hh(number) {
            if (number === 2) {
              return 'שעתיים';
            }

            return number + ' שעות';
          },
          d: 'יום',
          dd: function dd(number) {
            if (number === 2) {
              return 'יומיים';
            }

            return number + ' ימים';
          },
          M: 'חודש',
          MM: function MM(number) {
            if (number === 2) {
              return 'חודשיים';
            }

            return number + ' חודשים';
          },
          y: 'שנה',
          yy: function yy(number) {
            if (number === 2) {
              return 'שנתיים';
            } else if (number % 10 === 0 && number !== 10) {
              return number + ' שנה';
            }

            return number + ' שנים';
          }
        },
        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
        isPM: function isPM(input) {
          return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 5) {
            return 'לפנות בוקר';
          } else if (hour < 10) {
            return 'בבוקר';
          } else if (hour < 12) {
            return isLower ? 'לפנה"צ' : 'לפני הצהריים';
          } else if (hour < 18) {
            return isLower ? 'אחה"צ' : 'אחרי הצהריים';
          } else {
            return 'בערב';
          }
        }
      });
      return he;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/hi.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/hi.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleHiJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Hindi [hi]
    //! author : Mayank Singhal : https://github.com/mayanksinghal
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
      };
      var numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
      };
      var hi = moment.defineLocale('hi', {
        months: 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
        monthsShort: 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
        monthsParseExact: true,
        weekdays: 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort: 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat: {
          LT: 'A h:mm बजे',
          LTS: 'A h:mm:ss बजे',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm बजे',
          LLLL: 'dddd, D MMMM YYYY, A h:mm बजे'
        },
        calendar: {
          sameDay: '[आज] LT',
          nextDay: '[कल] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[कल] LT',
          lastWeek: '[पिछले] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s में',
          past: '%s पहले',
          s: 'कुछ ही क्षण',
          m: 'एक मिनट',
          mm: '%d मिनट',
          h: 'एक घंटा',
          hh: '%d घंटे',
          d: 'एक दिन',
          dd: '%d दिन',
          M: 'एक महीने',
          MM: '%d महीने',
          y: 'एक वर्ष',
          yy: '%d वर्ष'
        },
        preparse: function preparse(string) {
          return string.replace(/[१२३४५६७८९०]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /रात|सुबह|दोपहर|शाम/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'रात') {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'सुबह') {
            return hour;
          } else if (meridiem === 'दोपहर') {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === 'शाम') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'रात';
          } else if (hour < 10) {
            return 'सुबह';
          } else if (hour < 17) {
            return 'दोपहर';
          } else if (hour < 20) {
            return 'शाम';
          } else {
            return 'रात';
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return hi;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/hr.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/hr.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleHrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Croatian [hr]
    //! author : Bojan Marković : https://github.com/bmarkovic
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function translate(number, withoutSuffix, key) {
        var result = number + ' ';

        switch (key) {
          case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';

          case 'mm':
            if (number === 1) {
              result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'minute';
            } else {
              result += 'minuta';
            }

            return result;

          case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';

          case 'hh':
            if (number === 1) {
              result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'sata';
            } else {
              result += 'sati';
            }

            return result;

          case 'dd':
            if (number === 1) {
              result += 'dan';
            } else {
              result += 'dana';
            }

            return result;

          case 'MM':
            if (number === 1) {
              result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'mjeseca';
            } else {
              result += 'mjeseci';
            }

            return result;

          case 'yy':
            if (number === 1) {
              result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
              result += 'godine';
            } else {
              result += 'godina';
            }

            return result;
        }
      }

      var hr = moment.defineLocale('hr', {
        months: {
          format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
          standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort: 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[u] [nedjelju] [u] LT';

              case 3:
                return '[u] [srijedu] [u] LT';

              case 6:
                return '[u] [subotu] [u] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[u] dddd [u] LT';
            }
          },
          lastDay: '[jučer u] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
              case 3:
                return '[prošlu] dddd [u] LT';

              case 6:
                return '[prošle] [subote] [u] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[prošli] dddd [u] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'par sekundi',
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: 'dan',
          dd: translate,
          M: 'mjesec',
          MM: translate,
          y: 'godinu',
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return hr;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/hu.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/hu.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleHuJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Hungarian [hu]
    //! author : Adam Brunner : https://github.com/adambrunner
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');

      function translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;

        switch (key) {
          case 's':
            return isFuture || withoutSuffix ? 'néhány másodperc' : 'néhány másodperce';

          case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');

          case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');

          case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');

          case 'hh':
            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');

          case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');

          case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');

          case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');

          case 'MM':
            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');

          case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');

          case 'yy':
            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
        }

        return '';
      }

      function week(isFuture) {
        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
      }

      var hu = moment.defineLocale('hu', {
        months: 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
        monthsShort: 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
        weekdays: 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
        weekdaysShort: 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
        weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'YYYY.MM.DD.',
          LL: 'YYYY. MMMM D.',
          LLL: 'YYYY. MMMM D. H:mm',
          LLLL: 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function isPM(input) {
          return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 12) {
            return isLower === true ? 'de' : 'DE';
          } else {
            return isLower === true ? 'du' : 'DU';
          }
        },
        calendar: {
          sameDay: '[ma] LT[-kor]',
          nextDay: '[holnap] LT[-kor]',
          nextWeek: function nextWeek() {
            return week.call(this, true);
          },
          lastDay: '[tegnap] LT[-kor]',
          lastWeek: function lastWeek() {
            return week.call(this, false);
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s múlva',
          past: '%s',
          s: translate,
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: translate,
          dd: translate,
          M: translate,
          MM: translate,
          y: translate,
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return hu;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/hy-am.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/hy-am.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleHyAmJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Armenian [hy-am]
    //! author : Armendarabyan : https://github.com/armendarabyan
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var hyAm = moment.defineLocale('hy-am', {
        months: {
          format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
          standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
        },
        monthsShort: 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
        weekdays: 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
        weekdaysShort: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        weekdaysMin: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY թ.',
          LLL: 'D MMMM YYYY թ., HH:mm',
          LLLL: 'dddd, D MMMM YYYY թ., HH:mm'
        },
        calendar: {
          sameDay: '[այսօր] LT',
          nextDay: '[վաղը] LT',
          lastDay: '[երեկ] LT',
          nextWeek: function nextWeek() {
            return 'dddd [օրը ժամը] LT';
          },
          lastWeek: function lastWeek() {
            return '[անցած] dddd [օրը ժամը] LT';
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s հետո',
          past: '%s առաջ',
          s: 'մի քանի վայրկյան',
          m: 'րոպե',
          mm: '%d րոպե',
          h: 'ժամ',
          hh: '%d ժամ',
          d: 'օր',
          dd: '%d օր',
          M: 'ամիս',
          MM: '%d ամիս',
          y: 'տարի',
          yy: '%d տարի'
        },
        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
        isPM: function isPM(input) {
          return /^(ցերեկվա|երեկոյան)$/.test(input);
        },
        meridiem: function meridiem(hour) {
          if (hour < 4) {
            return 'գիշերվա';
          } else if (hour < 12) {
            return 'առավոտվա';
          } else if (hour < 17) {
            return 'ցերեկվա';
          } else {
            return 'երեկոյան';
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
              if (number === 1) {
                return number + '-ին';
              }

              return number + '-րդ';

            default:
              return number;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return hyAm;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/id.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/id.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleIdJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Indonesian [id]
    //! author : Mohammad Satrio Utomo : https://github.com/tyok
    //! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var id = moment.defineLocale('id', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'pagi') {
            return hour;
          } else if (meridiem === 'siang') {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'sore' || meridiem === 'malam') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 11) {
            return 'pagi';
          } else if (hours < 15) {
            return 'siang';
          } else if (hours < 19) {
            return 'sore';
          } else {
            return 'malam';
          }
        },
        calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Besok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kemarin pukul] LT',
          lastWeek: 'dddd [lalu pukul] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'dalam %s',
          past: '%s yang lalu',
          s: 'beberapa detik',
          m: 'semenit',
          mm: '%d menit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return id;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/is.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/is.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleIsJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Icelandic [is]
    //! author : Hinrik Örn Sigurðsson : https://github.com/hinrik
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function plural(n) {
        if (n % 100 === 11) {
          return true;
        } else if (n % 10 === 1) {
          return false;
        }

        return true;
      }

      function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';

        switch (key) {
          case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';

          case 'm':
            return withoutSuffix ? 'mínúta' : 'mínútu';

          case 'mm':
            if (plural(number)) {
              return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
            } else if (withoutSuffix) {
              return result + 'mínúta';
            }

            return result + 'mínútu';

          case 'hh':
            if (plural(number)) {
              return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }

            return result + 'klukkustund';

          case 'd':
            if (withoutSuffix) {
              return 'dagur';
            }

            return isFuture ? 'dag' : 'degi';

          case 'dd':
            if (plural(number)) {
              if (withoutSuffix) {
                return result + 'dagar';
              }

              return result + (isFuture ? 'daga' : 'dögum');
            } else if (withoutSuffix) {
              return result + 'dagur';
            }

            return result + (isFuture ? 'dag' : 'degi');

          case 'M':
            if (withoutSuffix) {
              return 'mánuður';
            }

            return isFuture ? 'mánuð' : 'mánuði';

          case 'MM':
            if (plural(number)) {
              if (withoutSuffix) {
                return result + 'mánuðir';
              }

              return result + (isFuture ? 'mánuði' : 'mánuðum');
            } else if (withoutSuffix) {
              return result + 'mánuður';
            }

            return result + (isFuture ? 'mánuð' : 'mánuði');

          case 'y':
            return withoutSuffix || isFuture ? 'ár' : 'ári';

          case 'yy':
            if (plural(number)) {
              return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
            }

            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
        }
      }

      var is = moment.defineLocale('is', {
        months: 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
        weekdays: 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
        weekdaysShort: 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
        weekdaysMin: 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] H:mm',
          LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar: {
          sameDay: '[í dag kl.] LT',
          nextDay: '[á morgun kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[í gær kl.] LT',
          lastWeek: '[síðasta] dddd [kl.] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'eftir %s',
          past: 'fyrir %s síðan',
          s: translate,
          m: translate,
          mm: translate,
          h: 'klukkustund',
          hh: translate,
          d: translate,
          dd: translate,
          M: translate,
          MM: translate,
          y: translate,
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return is;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/it.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/it.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleItJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Italian [it]
    //! author : Lorenzo : https://github.com/aliem
    //! author: Mattia Larentis: https://github.com/nostalgiaz
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var it = moment.defineLocale('it', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Oggi alle] LT',
          nextDay: '[Domani alle] LT',
          nextWeek: 'dddd [alle] LT',
          lastDay: '[Ieri alle] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
                return '[la scorsa] dddd [alle] LT';

              default:
                return '[lo scorso] dddd [alle] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: function future(s) {
            return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
          },
          past: '%s fa',
          s: 'alcuni secondi',
          m: 'un minuto',
          mm: '%d minuti',
          h: 'un\'ora',
          hh: '%d ore',
          d: 'un giorno',
          dd: '%d giorni',
          M: 'un mese',
          MM: '%d mesi',
          y: 'un anno',
          yy: '%d anni'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return it;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ja.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ja.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleJaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Japanese [ja]
    //! author : LI Long : https://github.com/baryon
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ja = moment.defineLocale('ja', {
        months: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort: '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin: '日_月_火_水_木_金_土'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY年M月D日',
          LLL: 'YYYY年M月D日 HH:mm',
          LLLL: 'YYYY年M月D日 HH:mm dddd',
          l: 'YYYY/MM/DD',
          ll: 'YYYY年M月D日',
          lll: 'YYYY年M月D日 HH:mm',
          llll: 'YYYY年M月D日 HH:mm dddd'
        },
        meridiemParse: /午前|午後/i,
        isPM: function isPM(input) {
          return input === '午後';
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return '午前';
          } else {
            return '午後';
          }
        },
        calendar: {
          sameDay: '[今日] LT',
          nextDay: '[明日] LT',
          nextWeek: '[来週]dddd LT',
          lastDay: '[昨日] LT',
          lastWeek: '[前週]dddd LT',
          sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}日/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日';

            default:
              return number;
          }
        },
        relativeTime: {
          future: '%s後',
          past: '%s前',
          s: '数秒',
          m: '1分',
          mm: '%d分',
          h: '1時間',
          hh: '%d時間',
          d: '1日',
          dd: '%d日',
          M: '1ヶ月',
          MM: '%dヶ月',
          y: '1年',
          yy: '%d年'
        }
      });
      return ja;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/jv.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/jv.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleJvJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Javanese [jv]
    //! author : Rony Lantip : https://github.com/lantip
    //! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var jv = moment.defineLocale('jv', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'enjing') {
            return hour;
          } else if (meridiem === 'siyang') {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 11) {
            return 'enjing';
          } else if (hours < 15) {
            return 'siyang';
          } else if (hours < 19) {
            return 'sonten';
          } else {
            return 'ndalu';
          }
        },
        calendar: {
          sameDay: '[Dinten puniko pukul] LT',
          nextDay: '[Mbenjang pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kala wingi pukul] LT',
          lastWeek: 'dddd [kepengker pukul] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'wonten ing %s',
          past: '%s ingkang kepengker',
          s: 'sawetawis detik',
          m: 'setunggal menit',
          mm: '%d menit',
          h: 'setunggal jam',
          hh: '%d jam',
          d: 'sedinten',
          dd: '%d dinten',
          M: 'sewulan',
          MM: '%d wulan',
          y: 'setaun',
          yy: '%d taun'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return jv;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ka.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ka.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleKaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Georgian [ka]
    //! author : Irakli Janiashvili : https://github.com/irakli-janiashvili
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ka = moment.defineLocale('ka', {
        months: {
          standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
          format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
        },
        monthsShort: 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
        weekdays: {
          standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
          format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
          isFormat: /(წინა|შემდეგ)/
        },
        weekdaysShort: 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
        weekdaysMin: 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
          sameDay: '[დღეს] LT[-ზე]',
          nextDay: '[ხვალ] LT[-ზე]',
          lastDay: '[გუშინ] LT[-ზე]',
          nextWeek: '[შემდეგ] dddd LT[-ზე]',
          lastWeek: '[წინა] dddd LT-ზე',
          sameElse: 'L'
        },
        relativeTime: {
          future: function future(s) {
            return /(წამი|წუთი|საათი|წელი)/.test(s) ? s.replace(/ი$/, 'ში') : s + 'ში';
          },
          past: function past(s) {
            if (/(წამი|წუთი|საათი|დღე|თვე)/.test(s)) {
              return s.replace(/(ი|ე)$/, 'ის უკან');
            }

            if (/წელი/.test(s)) {
              return s.replace(/წელი$/, 'წლის უკან');
            }
          },
          s: 'რამდენიმე წამი',
          m: 'წუთი',
          mm: '%d წუთი',
          h: 'საათი',
          hh: '%d საათი',
          d: 'დღე',
          dd: '%d დღე',
          M: 'თვე',
          MM: '%d თვე',
          y: 'წელი',
          yy: '%d წელი'
        },
        dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
        ordinal: function ordinal(number) {
          if (number === 0) {
            return number;
          }

          if (number === 1) {
            return number + '-ლი';
          }

          if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
            return 'მე-' + number;
          }

          return number + '-ე';
        },
        week: {
          dow: 1,
          doy: 7
        }
      });
      return ka;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/kk.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/kk.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleKkJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Kazakh [kk]
    //! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var suffixes = {
        0: '-ші',
        1: '-ші',
        2: '-ші',
        3: '-ші',
        4: '-ші',
        5: '-ші',
        6: '-шы',
        7: '-ші',
        8: '-ші',
        9: '-шы',
        10: '-шы',
        20: '-шы',
        30: '-шы',
        40: '-шы',
        50: '-ші',
        60: '-шы',
        70: '-ші',
        80: '-ші',
        90: '-шы',
        100: '-ші'
      };
      var kk = moment.defineLocale('kk', {
        months: 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
        monthsShort: 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
        weekdays: 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
        weekdaysShort: 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
        weekdaysMin: 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Бүгін сағат] LT',
          nextDay: '[Ертең сағат] LT',
          nextWeek: 'dddd [сағат] LT',
          lastDay: '[Кеше сағат] LT',
          lastWeek: '[Өткен аптаның] dddd [сағат] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s ішінде',
          past: '%s бұрын',
          s: 'бірнеше секунд',
          m: 'бір минут',
          mm: '%d минут',
          h: 'бір сағат',
          hh: '%d сағат',
          d: 'бір күн',
          dd: '%d күн',
          M: 'бір ай',
          MM: '%d ай',
          y: 'бір жыл',
          yy: '%d жыл'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
        ordinal: function ordinal(number) {
          var a = number % 10,
              b = number >= 100 ? 100 : null;
          return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return kk;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/km.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/km.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleKmJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Cambodian [km]
    //! author : Kruy Vanna : https://github.com/kruyvanna
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var km = moment.defineLocale('km', {
        months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
        monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
          nextDay: '[ស្អែក ម៉ោង] LT',
          nextWeek: 'dddd [ម៉ោង] LT',
          lastDay: '[ម្សិលមិញ ម៉ោង] LT',
          lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%sទៀត',
          past: '%sមុន',
          s: 'ប៉ុន្មានវិនាទី',
          m: 'មួយនាទី',
          mm: '%d នាទី',
          h: 'មួយម៉ោង',
          hh: '%d ម៉ោង',
          d: 'មួយថ្ងៃ',
          dd: '%d ថ្ងៃ',
          M: 'មួយខែ',
          MM: '%d ខែ',
          y: 'មួយឆ្នាំ',
          yy: '%d ឆ្នាំ'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return km;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/kn.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/kn.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleKnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Kannada [kn]
    //! author : Rajeev Naik : https://github.com/rajeevnaikte
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '೧',
        '2': '೨',
        '3': '೩',
        '4': '೪',
        '5': '೫',
        '6': '೬',
        '7': '೭',
        '8': '೮',
        '9': '೯',
        '0': '೦'
      };
      var numberMap = {
        '೧': '1',
        '೨': '2',
        '೩': '3',
        '೪': '4',
        '೫': '5',
        '೬': '6',
        '೭': '7',
        '೮': '8',
        '೯': '9',
        '೦': '0'
      };
      var kn = moment.defineLocale('kn', {
        months: 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split('_'),
        monthsShort: 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬ_ಅಕ್ಟೋಬ_ನವೆಂಬ_ಡಿಸೆಂಬ'.split('_'),
        monthsParseExact: true,
        weekdays: 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split('_'),
        weekdaysShort: 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
        weekdaysMin: 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
        longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm',
          LLLL: 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar: {
          sameDay: '[ಇಂದು] LT',
          nextDay: '[ನಾಳೆ] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[ನಿನ್ನೆ] LT',
          lastWeek: '[ಕೊನೆಯ] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s ನಂತರ',
          past: '%s ಹಿಂದೆ',
          s: 'ಕೆಲವು ಕ್ಷಣಗಳು',
          m: 'ಒಂದು ನಿಮಿಷ',
          mm: '%d ನಿಮಿಷ',
          h: 'ಒಂದು ಗಂಟೆ',
          hh: '%d ಗಂಟೆ',
          d: 'ಒಂದು ದಿನ',
          dd: '%d ದಿನ',
          M: 'ಒಂದು ತಿಂಗಳು',
          MM: '%d ತಿಂಗಳು',
          y: 'ಒಂದು ವರ್ಷ',
          yy: '%d ವರ್ಷ'
        },
        preparse: function preparse(string) {
          return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'ರಾತ್ರಿ') {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
            return hour;
          } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === 'ಸಂಜೆ') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'ರಾತ್ರಿ';
          } else if (hour < 10) {
            return 'ಬೆಳಿಗ್ಗೆ';
          } else if (hour < 17) {
            return 'ಮಧ್ಯಾಹ್ನ';
          } else if (hour < 20) {
            return 'ಸಂಜೆ';
          } else {
            return 'ರಾತ್ರಿ';
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
        ordinal: function ordinal(number) {
          return number + 'ನೇ';
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return kn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ko.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ko.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleKoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Korean [ko]
    //! author : Kyungwook, Park : https://github.com/kyungw00k
    //! author : Jeeeyul Lee <jeeeyul@gmail.com>
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ko = moment.defineLocale('ko', {
        months: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        monthsShort: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        weekdays: '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
        weekdaysShort: '일_월_화_수_목_금_토'.split('_'),
        weekdaysMin: '일_월_화_수_목_금_토'.split('_'),
        longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'YYYY.MM.DD',
          LL: 'YYYY년 MMMM D일',
          LLL: 'YYYY년 MMMM D일 A h:mm',
          LLLL: 'YYYY년 MMMM D일 dddd A h:mm',
          l: 'YYYY.MM.DD',
          ll: 'YYYY년 MMMM D일',
          lll: 'YYYY년 MMMM D일 A h:mm',
          llll: 'YYYY년 MMMM D일 dddd A h:mm'
        },
        calendar: {
          sameDay: '오늘 LT',
          nextDay: '내일 LT',
          nextWeek: 'dddd LT',
          lastDay: '어제 LT',
          lastWeek: '지난주 dddd LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s 후',
          past: '%s 전',
          s: '몇 초',
          ss: '%d초',
          m: '1분',
          mm: '%d분',
          h: '한 시간',
          hh: '%d시간',
          d: '하루',
          dd: '%d일',
          M: '한 달',
          MM: '%d달',
          y: '일 년',
          yy: '%d년'
        },
        dayOfMonthOrdinalParse: /\d{1,2}일/,
        ordinal: '%d일',
        meridiemParse: /오전|오후/,
        isPM: function isPM(token) {
          return token === '오후';
        },
        meridiem: function meridiem(hour, minute, isUpper) {
          return hour < 12 ? '오전' : '오후';
        }
      });
      return ko;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ky.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ky.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleKyJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Kyrgyz [ky]
    //! author : Chyngyz Arystan uulu : https://github.com/chyngyz
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var suffixes = {
        0: '-чү',
        1: '-чи',
        2: '-чи',
        3: '-чү',
        4: '-чү',
        5: '-чи',
        6: '-чы',
        7: '-чи',
        8: '-чи',
        9: '-чу',
        10: '-чу',
        20: '-чы',
        30: '-чу',
        40: '-чы',
        50: '-чү',
        60: '-чы',
        70: '-чи',
        80: '-чи',
        90: '-чу',
        100: '-чү'
      };
      var ky = moment.defineLocale('ky', {
        months: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
        monthsShort: 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
        weekdays: 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
        weekdaysShort: 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
        weekdaysMin: 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Бүгүн саат] LT',
          nextDay: '[Эртең саат] LT',
          nextWeek: 'dddd [саат] LT',
          lastDay: '[Кече саат] LT',
          lastWeek: '[Өткен аптанын] dddd [күнү] [саат] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s ичинде',
          past: '%s мурун',
          s: 'бирнече секунд',
          m: 'бир мүнөт',
          mm: '%d мүнөт',
          h: 'бир саат',
          hh: '%d саат',
          d: 'бир күн',
          dd: '%d күн',
          M: 'бир ай',
          MM: '%d ай',
          y: 'бир жыл',
          yy: '%d жыл'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
        ordinal: function ordinal(number) {
          var a = number % 10,
              b = number >= 100 ? 100 : null;
          return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return ky;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/lb.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/lb.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleLbJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Luxembourgish [lb]
    //! author : mweimerskirch : https://github.com/mweimerskirch
    //! author : David Raison : https://github.com/kwisatz
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
          'm': ['eng Minutt', 'enger Minutt'],
          'h': ['eng Stonn', 'enger Stonn'],
          'd': ['een Dag', 'engem Dag'],
          'M': ['ee Mount', 'engem Mount'],
          'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
      }

      function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));

        if (eifelerRegelAppliesToNumber(number)) {
          return 'a ' + string;
        }

        return 'an ' + string;
      }

      function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));

        if (eifelerRegelAppliesToNumber(number)) {
          return 'viru ' + string;
        }

        return 'virun ' + string;
      }
      /**
       * Returns true if the word before the given number loses the '-n' ending.
       * e.g. 'an 10 Deeg' but 'a 5 Deeg'
       *
       * @param number {integer}
       * @returns {boolean}
       */


      function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);

        if (isNaN(number)) {
          return false;
        }

        if (number < 0) {
          // Negative Number --> always true
          return true;
        } else if (number < 10) {
          // Only 1 digit
          if (4 <= number && number <= 7) {
            return true;
          }

          return false;
        } else if (number < 100) {
          // 2 digits
          var lastDigit = number % 10,
              firstDigit = number / 10;

          if (lastDigit === 0) {
            return eifelerRegelAppliesToNumber(firstDigit);
          }

          return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
          // 3 or 4 digits --> recursively check first digit
          while (number >= 10) {
            number = number / 10;
          }

          return eifelerRegelAppliesToNumber(number);
        } else {
          // Anything larger than 4 digits: recursively check first n-3 digits
          number = number / 1000;
          return eifelerRegelAppliesToNumber(number);
        }
      }

      var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm [Auer]',
          LTS: 'H:mm:ss [Auer]',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm [Auer]',
          LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
          sameDay: '[Haut um] LT',
          sameElse: 'L',
          nextDay: '[Muer um] LT',
          nextWeek: 'dddd [um] LT',
          lastDay: '[Gëschter um] LT',
          lastWeek: function lastWeek() {
            // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
            switch (this.day()) {
              case 2:
              case 4:
                return '[Leschten] dddd [um] LT';

              default:
                return '[Leschte] dddd [um] LT';
            }
          }
        },
        relativeTime: {
          future: processFutureTime,
          past: processPastTime,
          s: 'e puer Sekonnen',
          m: processRelativeTime,
          mm: '%d Minutten',
          h: processRelativeTime,
          hh: '%d Stonnen',
          d: processRelativeTime,
          dd: '%d Deeg',
          M: processRelativeTime,
          MM: '%d Méint',
          y: processRelativeTime,
          yy: '%d Joer'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return lb;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/lo.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/lo.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleLoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Lao [lo]
    //! author : Ryan Hart : https://github.com/ryanhart2
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var lo = moment.defineLocale('lo', {
        months: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        monthsShort: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        weekdays: 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysShort: 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysMin: 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'ວັນdddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
        isPM: function isPM(input) {
          return input === 'ຕອນແລງ';
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'ຕອນເຊົ້າ';
          } else {
            return 'ຕອນແລງ';
          }
        },
        calendar: {
          sameDay: '[ມື້ນີ້ເວລາ] LT',
          nextDay: '[ມື້ອື່ນເວລາ] LT',
          nextWeek: '[ວັນ]dddd[ໜ້າເວລາ] LT',
          lastDay: '[ມື້ວານນີ້ເວລາ] LT',
          lastWeek: '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'ອີກ %s',
          past: '%sຜ່ານມາ',
          s: 'ບໍ່ເທົ່າໃດວິນາທີ',
          m: '1 ນາທີ',
          mm: '%d ນາທີ',
          h: '1 ຊົ່ວໂມງ',
          hh: '%d ຊົ່ວໂມງ',
          d: '1 ມື້',
          dd: '%d ມື້',
          M: '1 ເດືອນ',
          MM: '%d ເດືອນ',
          y: '1 ປີ',
          yy: '%d ປີ'
        },
        dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
        ordinal: function ordinal(number) {
          return 'ທີ່' + number;
        }
      });
      return lo;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/lt.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/lt.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleLtJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Lithuanian [lt]
    //! author : Mindaugas Mozūras : https://github.com/mmozuras
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var units = {
        'm': 'minutė_minutės_minutę',
        'mm': 'minutės_minučių_minutes',
        'h': 'valanda_valandos_valandą',
        'hh': 'valandos_valandų_valandas',
        'd': 'diena_dienos_dieną',
        'dd': 'dienos_dienų_dienas',
        'M': 'mėnuo_mėnesio_mėnesį',
        'MM': 'mėnesiai_mėnesių_mėnesius',
        'y': 'metai_metų_metus',
        'yy': 'metai_metų_metus'
      };

      function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
          return 'kelios sekundės';
        } else {
          return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
        }
      }

      function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
      }

      function special(number) {
        return number % 10 === 0 || number > 10 && number < 20;
      }

      function forms(key) {
        return units[key].split('_');
      }

      function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';

        if (number === 1) {
          return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
          return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
          if (isFuture) {
            return result + forms(key)[1];
          } else {
            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
          }
        }
      }

      var lt = moment.defineLocale('lt', {
        months: {
          format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
          standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
          isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays: {
          format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
          standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
          isFormat: /dddd HH:mm/
        },
        weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
        weekdaysMin: 'S_P_A_T_K_Pn_Š'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY [m.] MMMM D [d.]',
          LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
          LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
          l: 'YYYY-MM-DD',
          ll: 'YYYY [m.] MMMM D [d.]',
          lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
          llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar: {
          sameDay: '[Šiandien] LT',
          nextDay: '[Rytoj] LT',
          nextWeek: 'dddd LT',
          lastDay: '[Vakar] LT',
          lastWeek: '[Praėjusį] dddd LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'po %s',
          past: 'prieš %s',
          s: translateSeconds,
          m: translateSingular,
          mm: translate,
          h: translateSingular,
          hh: translate,
          d: translateSingular,
          dd: translate,
          M: translateSingular,
          MM: translate,
          y: translateSingular,
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal: function ordinal(number) {
          return number + '-oji';
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return lt;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/lv.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/lv.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleLvJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Latvian [lv]
    //! author : Kristaps Karlsons : https://github.com/skakri
    //! author : Jānis Elmeris : https://github.com/JanisE
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var units = {
        'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        'h': 'stundas_stundām_stunda_stundas'.split('_'),
        'hh': 'stundas_stundām_stunda_stundas'.split('_'),
        'd': 'dienas_dienām_diena_dienas'.split('_'),
        'dd': 'dienas_dienām_diena_dienas'.split('_'),
        'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
      };
      /**
       * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
       */

      function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
          // E.g. "21 minūte", "3 minūtes".
          return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
          // E.g. "21 minūtes" as in "pēc 21 minūtes".
          // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
          return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
      }

      function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
      }

      function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
      }

      function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
      }

      var lv = moment.defineLocale('lv', {
        months: 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY.',
          LL: 'YYYY. [gada] D. MMMM',
          LLL: 'YYYY. [gada] D. MMMM, HH:mm',
          LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar: {
          sameDay: '[Šodien pulksten] LT',
          nextDay: '[Rīt pulksten] LT',
          nextWeek: 'dddd [pulksten] LT',
          lastDay: '[Vakar pulksten] LT',
          lastWeek: '[Pagājušā] dddd [pulksten] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'pēc %s',
          past: 'pirms %s',
          s: relativeSeconds,
          m: relativeTimeWithSingular,
          mm: relativeTimeWithPlural,
          h: relativeTimeWithSingular,
          hh: relativeTimeWithPlural,
          d: relativeTimeWithSingular,
          dd: relativeTimeWithPlural,
          M: relativeTimeWithSingular,
          MM: relativeTimeWithPlural,
          y: relativeTimeWithSingular,
          yy: relativeTimeWithPlural
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return lv;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/me.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/me.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Montenegrin [me]
    //! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var translator = {
        words: {
          //Different grammatical cases
          m: ['jedan minut', 'jednog minuta'],
          mm: ['minut', 'minuta', 'minuta'],
          h: ['jedan sat', 'jednog sata'],
          hh: ['sat', 'sata', 'sati'],
          dd: ['dan', 'dana', 'dana'],
          MM: ['mjesec', 'mjeseca', 'mjeseci'],
          yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
          return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function translate(number, withoutSuffix, key) {
          var wordKey = translator.words[key];

          if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
          } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
          }
        }
      };
      var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sjutra u] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[u] [nedjelju] [u] LT';

              case 3:
                return '[u] [srijedu] [u] LT';

              case 6:
                return '[u] [subotu] [u] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[u] dddd [u] LT';
            }
          },
          lastDay: '[juče u] LT',
          lastWeek: function lastWeek() {
            var lastWeekDays = ['[prošle] [nedjelje] [u] LT', '[prošlog] [ponedjeljka] [u] LT', '[prošlog] [utorka] [u] LT', '[prošle] [srijede] [u] LT', '[prošlog] [četvrtka] [u] LT', '[prošlog] [petka] [u] LT', '[prošle] [subote] [u] LT'];
            return lastWeekDays[this.day()];
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'nekoliko sekundi',
          m: translator.translate,
          mm: translator.translate,
          h: translator.translate,
          hh: translator.translate,
          d: 'dan',
          dd: translator.translate,
          M: 'mjesec',
          MM: translator.translate,
          y: 'godinu',
          yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return me;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/mi.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/mi.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMiJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Maori [mi]
    //! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var mi = moment.defineLocale('mi', {
        months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split('_'),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
        weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [i] HH:mm',
          LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
        },
        calendar: {
          sameDay: '[i teie mahana, i] LT',
          nextDay: '[apopo i] LT',
          nextWeek: 'dddd [i] LT',
          lastDay: '[inanahi i] LT',
          lastWeek: 'dddd [whakamutunga i] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'i roto i %s',
          past: '%s i mua',
          s: 'te hēkona ruarua',
          m: 'he meneti',
          mm: '%d meneti',
          h: 'te haora',
          hh: '%d haora',
          d: 'he ra',
          dd: '%d ra',
          M: 'he marama',
          MM: '%d marama',
          y: 'he tau',
          yy: '%d tau'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return mi;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/mk.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/mk.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMkJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Macedonian [mk]
    //! author : Borislav Mickov : https://github.com/B0k0
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var mk = moment.defineLocale('mk', {
        months: 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort: 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
        weekdaysShort: 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
        weekdaysMin: 'нe_пo_вт_ср_че_пе_сa'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[Денес во] LT',
          nextDay: '[Утре во] LT',
          nextWeek: '[Во] dddd [во] LT',
          lastDay: '[Вчера во] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return '[Изминатата] dddd [во] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[Изминатиот] dddd [во] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'после %s',
          past: 'пред %s',
          s: 'неколку секунди',
          m: 'минута',
          mm: '%d минути',
          h: 'час',
          hh: '%d часа',
          d: 'ден',
          dd: '%d дена',
          M: 'месец',
          MM: '%d месеци',
          y: 'година',
          yy: '%d години'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function ordinal(number) {
          var lastDigit = number % 10,
              last2Digits = number % 100;

          if (number === 0) {
            return number + '-ев';
          } else if (last2Digits === 0) {
            return number + '-ен';
          } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-ти';
          } else if (lastDigit === 1) {
            return number + '-ви';
          } else if (lastDigit === 2) {
            return number + '-ри';
          } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-ми';
          } else {
            return number + '-ти';
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return mk;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ml.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ml.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMlJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Malayalam [ml]
    //! author : Floyd Pink : https://github.com/floydpink
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ml = moment.defineLocale('ml', {
        months: 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
        monthsShort: 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
        monthsParseExact: true,
        weekdays: 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
        weekdaysShort: 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
        weekdaysMin: 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
        longDateFormat: {
          LT: 'A h:mm -നു',
          LTS: 'A h:mm:ss -നു',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm -നു',
          LLLL: 'dddd, D MMMM YYYY, A h:mm -നു'
        },
        calendar: {
          sameDay: '[ഇന്ന്] LT',
          nextDay: '[നാളെ] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[ഇന്നലെ] LT',
          lastWeek: '[കഴിഞ്ഞ] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s കഴിഞ്ഞ്',
          past: '%s മുൻപ്',
          s: 'അൽപ നിമിഷങ്ങൾ',
          m: 'ഒരു മിനിറ്റ്',
          mm: '%d മിനിറ്റ്',
          h: 'ഒരു മണിക്കൂർ',
          hh: '%d മണിക്കൂർ',
          d: 'ഒരു ദിവസം',
          dd: '%d ദിവസം',
          M: 'ഒരു മാസം',
          MM: '%d മാസം',
          y: 'ഒരു വർഷം',
          yy: '%d വർഷം'
        },
        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'രാത്രി' && hour >= 4 || meridiem === 'ഉച്ച കഴിഞ്ഞ്' || meridiem === 'വൈകുന്നേരം') {
            return hour + 12;
          } else {
            return hour;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'രാത്രി';
          } else if (hour < 12) {
            return 'രാവിലെ';
          } else if (hour < 17) {
            return 'ഉച്ച കഴിഞ്ഞ്';
          } else if (hour < 20) {
            return 'വൈകുന്നേരം';
          } else {
            return 'രാത്രി';
          }
        }
      });
      return ml;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/mr.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/mr.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Marathi [mr]
    //! author : Harshad Kale : https://github.com/kalehv
    //! author : Vivek Athalye : https://github.com/vnathalye
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
      };
      var numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
      };

      function relativeTimeMr(number, withoutSuffix, string, isFuture) {
        var output = '';

        if (withoutSuffix) {
          switch (string) {
            case 's':
              output = 'काही सेकंद';
              break;

            case 'm':
              output = 'एक मिनिट';
              break;

            case 'mm':
              output = '%d मिनिटे';
              break;

            case 'h':
              output = 'एक तास';
              break;

            case 'hh':
              output = '%d तास';
              break;

            case 'd':
              output = 'एक दिवस';
              break;

            case 'dd':
              output = '%d दिवस';
              break;

            case 'M':
              output = 'एक महिना';
              break;

            case 'MM':
              output = '%d महिने';
              break;

            case 'y':
              output = 'एक वर्ष';
              break;

            case 'yy':
              output = '%d वर्षे';
              break;
          }
        } else {
          switch (string) {
            case 's':
              output = 'काही सेकंदां';
              break;

            case 'm':
              output = 'एका मिनिटा';
              break;

            case 'mm':
              output = '%d मिनिटां';
              break;

            case 'h':
              output = 'एका तासा';
              break;

            case 'hh':
              output = '%d तासां';
              break;

            case 'd':
              output = 'एका दिवसा';
              break;

            case 'dd':
              output = '%d दिवसां';
              break;

            case 'M':
              output = 'एका महिन्या';
              break;

            case 'MM':
              output = '%d महिन्यां';
              break;

            case 'y':
              output = 'एका वर्षा';
              break;

            case 'yy':
              output = '%d वर्षां';
              break;
          }
        }

        return output.replace(/%d/i, number);
      }

      var mr = moment.defineLocale('mr', {
        months: 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
        monthsParseExact: true,
        weekdays: 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort: 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat: {
          LT: 'A h:mm वाजता',
          LTS: 'A h:mm:ss वाजता',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm वाजता',
          LLLL: 'dddd, D MMMM YYYY, A h:mm वाजता'
        },
        calendar: {
          sameDay: '[आज] LT',
          nextDay: '[उद्या] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[काल] LT',
          lastWeek: '[मागील] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%sमध्ये',
          past: '%sपूर्वी',
          s: relativeTimeMr,
          m: relativeTimeMr,
          mm: relativeTimeMr,
          h: relativeTimeMr,
          hh: relativeTimeMr,
          d: relativeTimeMr,
          dd: relativeTimeMr,
          M: relativeTimeMr,
          MM: relativeTimeMr,
          y: relativeTimeMr,
          yy: relativeTimeMr
        },
        preparse: function preparse(string) {
          return string.replace(/[१२३४५६७८९०]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'रात्री') {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'सकाळी') {
            return hour;
          } else if (meridiem === 'दुपारी') {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === 'सायंकाळी') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'रात्री';
          } else if (hour < 10) {
            return 'सकाळी';
          } else if (hour < 17) {
            return 'दुपारी';
          } else if (hour < 20) {
            return 'सायंकाळी';
          } else {
            return 'रात्री';
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return mr;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ms-my.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ms-my.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMsMyJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Malay [ms-my]
    //! note : DEPRECATED, the correct one is [ms]
    //! author : Weldan Jamili : https://github.com/weldan
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var msMy = moment.defineLocale('ms-my', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'pagi') {
            return hour;
          } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 11) {
            return 'pagi';
          } else if (hours < 15) {
            return 'tengahari';
          } else if (hours < 19) {
            return 'petang';
          } else {
            return 'malam';
          }
        },
        calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Esok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kelmarin pukul] LT',
          lastWeek: 'dddd [lepas pukul] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'dalam %s',
          past: '%s yang lepas',
          s: 'beberapa saat',
          m: 'seminit',
          mm: '%d minit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return msMy;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ms.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ms.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMsJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Malay [ms]
    //! author : Weldan Jamili : https://github.com/weldan
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ms = moment.defineLocale('ms', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'pagi') {
            return hour;
          } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 11) {
            return 'pagi';
          } else if (hours < 15) {
            return 'tengahari';
          } else if (hours < 19) {
            return 'petang';
          } else {
            return 'malam';
          }
        },
        calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Esok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kelmarin pukul] LT',
          lastWeek: 'dddd [lepas pukul] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'dalam %s',
          past: '%s yang lepas',
          s: 'beberapa saat',
          m: 'seminit',
          mm: '%d minit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return ms;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/my.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/my.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleMyJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Burmese [my]
    //! author : Squar team, mysquar.com
    //! author : David Rossellat : https://github.com/gholadr
    //! author : Tin Aung Lin : https://github.com/thanyawzinmin
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '၁',
        '2': '၂',
        '3': '၃',
        '4': '၄',
        '5': '၅',
        '6': '၆',
        '7': '၇',
        '8': '၈',
        '9': '၉',
        '0': '၀'
      };
      var numberMap = {
        '၁': '1',
        '၂': '2',
        '၃': '3',
        '၄': '4',
        '၅': '5',
        '၆': '6',
        '၇': '7',
        '၈': '8',
        '၉': '9',
        '၀': '0'
      };
      var my = moment.defineLocale('my', {
        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[ယနေ.] LT [မှာ]',
          nextDay: '[မနက်ဖြန်] LT [မှာ]',
          nextWeek: 'dddd LT [မှာ]',
          lastDay: '[မနေ.က] LT [မှာ]',
          lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'လာမည့် %s မှာ',
          past: 'လွန်ခဲ့သော %s က',
          s: 'စက္ကန်.အနည်းငယ်',
          m: 'တစ်မိနစ်',
          mm: '%d မိနစ်',
          h: 'တစ်နာရီ',
          hh: '%d နာရီ',
          d: 'တစ်ရက်',
          dd: '%d ရက်',
          M: 'တစ်လ',
          MM: '%d လ',
          y: 'တစ်နှစ်',
          yy: '%d နှစ်'
        },
        preparse: function preparse(string) {
          return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return my;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/nb.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/nb.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleNbJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Norwegian Bokmål [nb]
    //! authors : Espen Hovlandsdal : https://github.com/rexxars
    //!           Sigurd Gartmann : https://github.com/sigurdga
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var nb = moment.defineLocale('nb', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact: true,
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] HH:mm',
          LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar: {
          sameDay: '[i dag kl.] LT',
          nextDay: '[i morgen kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[i går kl.] LT',
          lastWeek: '[forrige] dddd [kl.] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'om %s',
          past: '%s siden',
          s: 'noen sekunder',
          m: 'ett minutt',
          mm: '%d minutter',
          h: 'en time',
          hh: '%d timer',
          d: 'en dag',
          dd: '%d dager',
          M: 'en måned',
          MM: '%d måneder',
          y: 'ett år',
          yy: '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return nb;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ne.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ne.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleNeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Nepalese [ne]
    //! author : suvash : https://github.com/suvash
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
      };
      var numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
      };
      var ne = moment.defineLocale('ne', {
        months: 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
        monthsShort: 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
        monthsParseExact: true,
        weekdays: 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
        weekdaysShort: 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
        weekdaysMin: 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'Aको h:mm बजे',
          LTS: 'Aको h:mm:ss बजे',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, Aको h:mm बजे',
          LLLL: 'dddd, D MMMM YYYY, Aको h:mm बजे'
        },
        preparse: function preparse(string) {
          return string.replace(/[१२३४५६७८९०]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'राति') {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'बिहान') {
            return hour;
          } else if (meridiem === 'दिउँसो') {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === 'साँझ') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 3) {
            return 'राति';
          } else if (hour < 12) {
            return 'बिहान';
          } else if (hour < 16) {
            return 'दिउँसो';
          } else if (hour < 20) {
            return 'साँझ';
          } else {
            return 'राति';
          }
        },
        calendar: {
          sameDay: '[आज] LT',
          nextDay: '[भोलि] LT',
          nextWeek: '[आउँदो] dddd[,] LT',
          lastDay: '[हिजो] LT',
          lastWeek: '[गएको] dddd[,] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%sमा',
          past: '%s अगाडि',
          s: 'केही क्षण',
          m: 'एक मिनेट',
          mm: '%d मिनेट',
          h: 'एक घण्टा',
          hh: '%d घण्टा',
          d: 'एक दिन',
          dd: '%d दिन',
          M: 'एक महिना',
          MM: '%d महिना',
          y: 'एक बर्ष',
          yy: '%d बर्ष'
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return ne;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/nl-be.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/nl-be.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleNlBeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Dutch (Belgium) [nl-be]
    //! author : Joris Röling : https://github.com/jorisroling
    //! author : Jacob Middag : https://github.com/middagj
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
      var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
      var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
      var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
      var nlBe = moment.defineLocale('nl-be', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort: function monthsShort(m, format) {
          if (!m) {
            return monthsShortWithDots;
          } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
          } else {
            return monthsShortWithDots[m.month()];
          }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[vandaag om] LT',
          nextDay: '[morgen om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[gisteren om] LT',
          lastWeek: '[afgelopen] dddd [om] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'over %s',
          past: '%s geleden',
          s: 'een paar seconden',
          m: 'één minuut',
          mm: '%d minuten',
          h: 'één uur',
          hh: '%d uur',
          d: 'één dag',
          dd: '%d dagen',
          M: 'één maand',
          MM: '%d maanden',
          y: 'één jaar',
          yy: '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
          return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return nlBe;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/nl.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/nl.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleNlJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Dutch [nl]
    //! author : Joris Röling : https://github.com/jorisroling
    //! author : Jacob Middag : https://github.com/middagj
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
      var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
      var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
      var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
      var nl = moment.defineLocale('nl', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort: function monthsShort(m, format) {
          if (!m) {
            return monthsShortWithDots;
          } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
          } else {
            return monthsShortWithDots[m.month()];
          }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[vandaag om] LT',
          nextDay: '[morgen om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[gisteren om] LT',
          lastWeek: '[afgelopen] dddd [om] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'over %s',
          past: '%s geleden',
          s: 'een paar seconden',
          m: 'één minuut',
          mm: '%d minuten',
          h: 'één uur',
          hh: '%d uur',
          d: 'één dag',
          dd: '%d dagen',
          M: 'één maand',
          MM: '%d maanden',
          y: 'één jaar',
          yy: '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
          return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return nl;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/nn.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/nn.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleNnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Nynorsk [nn]
    //! author : https://github.com/mechuwind
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var nn = moment.defineLocale('nn', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort: 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin: 'su_må_ty_on_to_fr_lø'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] H:mm',
          LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar: {
          sameDay: '[I dag klokka] LT',
          nextDay: '[I morgon klokka] LT',
          nextWeek: 'dddd [klokka] LT',
          lastDay: '[I går klokka] LT',
          lastWeek: '[Føregåande] dddd [klokka] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'om %s',
          past: '%s sidan',
          s: 'nokre sekund',
          m: 'eit minutt',
          mm: '%d minutt',
          h: 'ein time',
          hh: '%d timar',
          d: 'ein dag',
          dd: '%d dagar',
          M: 'ein månad',
          MM: '%d månader',
          y: 'eit år',
          yy: '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return nn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/pa-in.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/pa-in.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocalePaInJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Punjabi (India) [pa-in]
    //! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '੧',
        '2': '੨',
        '3': '੩',
        '4': '੪',
        '5': '੫',
        '6': '੬',
        '7': '੭',
        '8': '੮',
        '9': '੯',
        '0': '੦'
      };
      var numberMap = {
        '੧': '1',
        '੨': '2',
        '੩': '3',
        '੪': '4',
        '੫': '5',
        '੬': '6',
        '੭': '7',
        '੮': '8',
        '੯': '9',
        '੦': '0'
      };
      var paIn = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
        months: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
        monthsShort: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
        weekdays: 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
        weekdaysShort: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        weekdaysMin: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        longDateFormat: {
          LT: 'A h:mm ਵਜੇ',
          LTS: 'A h:mm:ss ਵਜੇ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ਵਜੇ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
        },
        calendar: {
          sameDay: '[ਅਜ] LT',
          nextDay: '[ਕਲ] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[ਕਲ] LT',
          lastWeek: '[ਪਿਛਲੇ] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s ਵਿੱਚ',
          past: '%s ਪਿਛਲੇ',
          s: 'ਕੁਝ ਸਕਿੰਟ',
          m: 'ਇਕ ਮਿੰਟ',
          mm: '%d ਮਿੰਟ',
          h: 'ਇੱਕ ਘੰਟਾ',
          hh: '%d ਘੰਟੇ',
          d: 'ਇੱਕ ਦਿਨ',
          dd: '%d ਦਿਨ',
          M: 'ਇੱਕ ਮਹੀਨਾ',
          MM: '%d ਮਹੀਨੇ',
          y: 'ਇੱਕ ਸਾਲ',
          yy: '%d ਸਾਲ'
        },
        preparse: function preparse(string) {
          return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'ਰਾਤ') {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'ਸਵੇਰ') {
            return hour;
          } else if (meridiem === 'ਦੁਪਹਿਰ') {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === 'ਸ਼ਾਮ') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'ਰਾਤ';
          } else if (hour < 10) {
            return 'ਸਵੇਰ';
          } else if (hour < 17) {
            return 'ਦੁਪਹਿਰ';
          } else if (hour < 20) {
            return 'ਸ਼ਾਮ';
          } else {
            return 'ਰਾਤ';
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return paIn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/pl.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/pl.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocalePlJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Polish [pl]
    //! author : Rafal Hirsz : https://github.com/evoL
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_');
      var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');

      function plural(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
      }

      function translate(number, withoutSuffix, key) {
        var result = number + ' ';

        switch (key) {
          case 'm':
            return withoutSuffix ? 'minuta' : 'minutę';

          case 'mm':
            return result + (plural(number) ? 'minuty' : 'minut');

          case 'h':
            return withoutSuffix ? 'godzina' : 'godzinę';

          case 'hh':
            return result + (plural(number) ? 'godziny' : 'godzin');

          case 'MM':
            return result + (plural(number) ? 'miesiące' : 'miesięcy');

          case 'yy':
            return result + (plural(number) ? 'lata' : 'lat');
        }
      }

      var pl = moment.defineLocale('pl', {
        months: function months(momentToFormat, format) {
          if (!momentToFormat) {
            return monthsNominative;
          } else if (format === '') {
            // Hack: if format empty we know this is used to generate
            // RegExp by moment. Give then back both valid forms of months
            // in RegExp ready format.
            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
          } else if (/D MMMM/.test(format)) {
            return monthsSubjective[momentToFormat.month()];
          } else {
            return monthsNominative[momentToFormat.month()];
          }
        },
        monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
        weekdays: 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
        weekdaysShort: 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
        weekdaysMin: 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Dziś o] LT',
          nextDay: '[Jutro o] LT',
          nextWeek: '[W] dddd [o] LT',
          lastDay: '[Wczoraj o] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
                return '[W zeszłą niedzielę o] LT';

              case 3:
                return '[W zeszłą środę o] LT';

              case 6:
                return '[W zeszłą sobotę o] LT';

              default:
                return '[W zeszły] dddd [o] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'za %s',
          past: '%s temu',
          s: 'kilka sekund',
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: '1 dzień',
          dd: '%d dni',
          M: 'miesiąc',
          MM: translate,
          y: 'rok',
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return pl;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/pt-br.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/pt-br.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocalePtBrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Portuguese (Brazil) [pt-br]
    //! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ptBr = moment.defineLocale('pt-br', {
        months: 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
        },
        calendar: {
          sameDay: '[Hoje às] LT',
          nextDay: '[Amanhã às] LT',
          nextWeek: 'dddd [às] LT',
          lastDay: '[Ontem às] LT',
          lastWeek: function lastWeek() {
            return this.day() === 0 || this.day() === 6 ? '[Último] dddd [às] LT' : // Saturday + Sunday
            '[Última] dddd [às] LT'; // Monday - Friday
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'em %s',
          past: '%s atrás',
          s: 'poucos segundos',
          m: 'um minuto',
          mm: '%d minutos',
          h: 'uma hora',
          hh: '%d horas',
          d: 'um dia',
          dd: '%d dias',
          M: 'um mês',
          MM: '%d meses',
          y: 'um ano',
          yy: '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº'
      });
      return ptBr;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/pt.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/pt.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocalePtJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Portuguese [pt]
    //! author : Jefferson : https://github.com/jalex79
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var pt = moment.defineLocale('pt', {
        months: 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY HH:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Hoje às] LT',
          nextDay: '[Amanhã às] LT',
          nextWeek: 'dddd [às] LT',
          lastDay: '[Ontem às] LT',
          lastWeek: function lastWeek() {
            return this.day() === 0 || this.day() === 6 ? '[Último] dddd [às] LT' : // Saturday + Sunday
            '[Última] dddd [às] LT'; // Monday - Friday
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'em %s',
          past: 'há %s',
          s: 'segundos',
          m: 'um minuto',
          mm: '%d minutos',
          h: 'uma hora',
          hh: '%d horas',
          d: 'um dia',
          dd: '%d dias',
          M: 'um mês',
          MM: '%d meses',
          y: 'um ano',
          yy: '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return pt;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ro.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ro.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleRoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Romanian [ro]
    //! author : Vlad Gurdiga : https://github.com/gurdiga
    //! author : Valentin Agachi : https://github.com/avaly
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
          'mm': 'minute',
          'hh': 'ore',
          'dd': 'zile',
          'MM': 'luni',
          'yy': 'ani'
        },
            separator = ' ';

        if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
          separator = ' de ';
        }

        return number + separator + format[key];
      }

      var ro = moment.defineLocale('ro', {
        months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
        weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
        weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[azi la] LT',
          nextDay: '[mâine la] LT',
          nextWeek: 'dddd [la] LT',
          lastDay: '[ieri la] LT',
          lastWeek: '[fosta] dddd [la] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'peste %s',
          past: '%s în urmă',
          s: 'câteva secunde',
          m: 'un minut',
          mm: relativeTimeWithPlural,
          h: 'o oră',
          hh: relativeTimeWithPlural,
          d: 'o zi',
          dd: relativeTimeWithPlural,
          M: 'o lună',
          MM: relativeTimeWithPlural,
          y: 'un an',
          yy: relativeTimeWithPlural
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return ro;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ru.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ru.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleRuJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Russian [ru]
    //! author : Viktorminator : https://github.com/Viktorminator
    //! Author : Menelion Elensúle : https://github.com/Oire
    //! author : Коренберг Марк : https://github.com/socketpair
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
      }

      function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
          'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
          'hh': 'час_часа_часов',
          'dd': 'день_дня_дней',
          'MM': 'месяц_месяца_месяцев',
          'yy': 'год_года_лет'
        };

        if (key === 'm') {
          return withoutSuffix ? 'минута' : 'минуту';
        } else {
          return number + ' ' + plural(format[key], +number);
        }
      }

      var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i]; // http://new.gramota.ru/spravka/rules/139-prop : § 103
      // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
      // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753

      var ru = moment.defineLocale('ru', {
        months: {
          format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
          standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
        },
        monthsShort: {
          // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
          format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
          standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
        },
        weekdays: {
          standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
          format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
          isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
        },
        weekdaysShort: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
        // копия предыдущего
        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
        // полные названия с падежами
        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,
        // Выражение, которое соотвествует только сокращённым формам
        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY г.',
          LLL: 'D MMMM YYYY г., HH:mm',
          LLLL: 'dddd, D MMMM YYYY г., HH:mm'
        },
        calendar: {
          sameDay: '[Сегодня в] LT',
          nextDay: '[Завтра в] LT',
          lastDay: '[Вчера в] LT',
          nextWeek: function nextWeek(now) {
            if (now.week() !== this.week()) {
              switch (this.day()) {
                case 0:
                  return '[В следующее] dddd [в] LT';

                case 1:
                case 2:
                case 4:
                  return '[В следующий] dddd [в] LT';

                case 3:
                case 5:
                case 6:
                  return '[В следующую] dddd [в] LT';
              }
            } else {
              if (this.day() === 2) {
                return '[Во] dddd [в] LT';
              } else {
                return '[В] dddd [в] LT';
              }
            }
          },
          lastWeek: function lastWeek(now) {
            if (now.week() !== this.week()) {
              switch (this.day()) {
                case 0:
                  return '[В прошлое] dddd [в] LT';

                case 1:
                case 2:
                case 4:
                  return '[В прошлый] dddd [в] LT';

                case 3:
                case 5:
                case 6:
                  return '[В прошлую] dddd [в] LT';
              }
            } else {
              if (this.day() === 2) {
                return '[Во] dddd [в] LT';
              } else {
                return '[В] dddd [в] LT';
              }
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'через %s',
          past: '%s назад',
          s: 'несколько секунд',
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: 'час',
          hh: relativeTimeWithPlural,
          d: 'день',
          dd: relativeTimeWithPlural,
          M: 'месяц',
          MM: relativeTimeWithPlural,
          y: 'год',
          yy: relativeTimeWithPlural
        },
        meridiemParse: /ночи|утра|дня|вечера/i,
        isPM: function isPM(input) {
          return /^(дня|вечера)$/.test(input);
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'ночи';
          } else if (hour < 12) {
            return 'утра';
          } else if (hour < 17) {
            return 'дня';
          } else {
            return 'вечера';
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
              return number + '-й';

            case 'D':
              return number + '-го';

            case 'w':
            case 'W':
              return number + '-я';

            default:
              return number;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return ru;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sd.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sd.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSdJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Sindhi [sd]
    //! author : Narain Sagar : https://github.com/narainsagar
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var months = ['جنوري', 'فيبروري', 'مارچ', 'اپريل', 'مئي', 'جون', 'جولاءِ', 'آگسٽ', 'سيپٽمبر', 'آڪٽوبر', 'نومبر', 'ڊسمبر'];
      var days = ['آچر', 'سومر', 'اڱارو', 'اربع', 'خميس', 'جمع', 'ڇنڇر'];
      var sd = moment.defineLocale('sd', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd، D MMMM YYYY HH:mm'
        },
        meridiemParse: /صبح|شام/,
        isPM: function isPM(input) {
          return 'شام' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'صبح';
          }

          return 'شام';
        },
        calendar: {
          sameDay: '[اڄ] LT',
          nextDay: '[سڀاڻي] LT',
          nextWeek: 'dddd [اڳين هفتي تي] LT',
          lastDay: '[ڪالهه] LT',
          lastWeek: '[گزريل هفتي] dddd [تي] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s پوء',
          past: '%s اڳ',
          s: 'چند سيڪنڊ',
          m: 'هڪ منٽ',
          mm: '%d منٽ',
          h: 'هڪ ڪلاڪ',
          hh: '%d ڪلاڪ',
          d: 'هڪ ڏينهن',
          dd: '%d ڏينهن',
          M: 'هڪ مهينو',
          MM: '%d مهينا',
          y: 'هڪ سال',
          yy: '%d سال'
        },
        preparse: function preparse(string) {
          return string.replace(/،/g, ',');
        },
        postformat: function postformat(string) {
          return string.replace(/,/g, '،');
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return sd;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/se.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/se.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Northern Sami [se]
    //! authors : Bård Rolstad Henriksen : https://github.com/karamell
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var se = moment.defineLocale('se', {
        months: 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
        monthsShort: 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
        weekdays: 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
        weekdaysShort: 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
        weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'MMMM D. [b.] YYYY',
          LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
          LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar: {
          sameDay: '[otne ti] LT',
          nextDay: '[ihttin ti] LT',
          nextWeek: 'dddd [ti] LT',
          lastDay: '[ikte ti] LT',
          lastWeek: '[ovddit] dddd [ti] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s geažes',
          past: 'maŋit %s',
          s: 'moadde sekunddat',
          m: 'okta minuhta',
          mm: '%d minuhtat',
          h: 'okta diimmu',
          hh: '%d diimmut',
          d: 'okta beaivi',
          dd: '%d beaivvit',
          M: 'okta mánnu',
          MM: '%d mánut',
          y: 'okta jahki',
          yy: '%d jagit'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return se;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/si.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/si.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSiJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Sinhalese [si]
    //! author : Sampath Sitinamaluwa : https://github.com/sampathsris
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';
      /*jshint -W100*/

      var si = moment.defineLocale('si', {
        months: 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
        monthsShort: 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
        weekdays: 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
        weekdaysShort: 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
        weekdaysMin: 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'a h:mm',
          LTS: 'a h:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY MMMM D',
          LLL: 'YYYY MMMM D, a h:mm',
          LLLL: 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
        },
        calendar: {
          sameDay: '[අද] LT[ට]',
          nextDay: '[හෙට] LT[ට]',
          nextWeek: 'dddd LT[ට]',
          lastDay: '[ඊයේ] LT[ට]',
          lastWeek: '[පසුගිය] dddd LT[ට]',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%sකින්',
          past: '%sකට පෙර',
          s: 'තත්පර කිහිපය',
          m: 'මිනිත්තුව',
          mm: 'මිනිත්තු %d',
          h: 'පැය',
          hh: 'පැය %d',
          d: 'දිනය',
          dd: 'දින %d',
          M: 'මාසය',
          MM: 'මාස %d',
          y: 'වසර',
          yy: 'වසර %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
        ordinal: function ordinal(number) {
          return number + ' වැනි';
        },
        meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
        isPM: function isPM(input) {
          return input === 'ප.ව.' || input === 'පස් වරු';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'ප.ව.' : 'පස් වරු';
          } else {
            return isLower ? 'පෙ.ව.' : 'පෙර වරු';
          }
        }
      });
      return si;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sk.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sk.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSkJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Slovak [sk]
    //! author : Martin Minka : https://github.com/k2s
    //! based on work of petrbela : https://github.com/petrbela
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_');
      var monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');

      function plural(n) {
        return n > 1 && n < 5;
      }

      function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';

        switch (key) {
          case 's':
            // a few seconds / in a few seconds / a few seconds ago
            return withoutSuffix || isFuture ? 'pár sekúnd' : 'pár sekundami';

          case 'm':
            // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minúta' : isFuture ? 'minútu' : 'minútou';

          case 'mm':
            // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'minúty' : 'minút');
            } else {
              return result + 'minútami';
            }

            break;

          case 'h':
            // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

          case 'hh':
            // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'hodiny' : 'hodín');
            } else {
              return result + 'hodinami';
            }

            break;

          case 'd':
            // a day / in a day / a day ago
            return withoutSuffix || isFuture ? 'deň' : 'dňom';

          case 'dd':
            // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'dni' : 'dní');
            } else {
              return result + 'dňami';
            }

            break;

          case 'M':
            // a month / in a month / a month ago
            return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';

          case 'MM':
            // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'mesiace' : 'mesiacov');
            } else {
              return result + 'mesiacmi';
            }

            break;

          case 'y':
            // a year / in a year / a year ago
            return withoutSuffix || isFuture ? 'rok' : 'rokom';

          case 'yy':
            // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
              return result + (plural(number) ? 'roky' : 'rokov');
            } else {
              return result + 'rokmi';
            }

            break;
        }
      }

      var sk = moment.defineLocale('sk', {
        months: months,
        monthsShort: monthsShort,
        weekdays: 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
        weekdaysShort: 'ne_po_ut_st_št_pi_so'.split('_'),
        weekdaysMin: 'ne_po_ut_st_št_pi_so'.split('_'),
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[dnes o] LT',
          nextDay: '[zajtra o] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[v nedeľu o] LT';

              case 1:
              case 2:
                return '[v] dddd [o] LT';

              case 3:
                return '[v stredu o] LT';

              case 4:
                return '[vo štvrtok o] LT';

              case 5:
                return '[v piatok o] LT';

              case 6:
                return '[v sobotu o] LT';
            }
          },
          lastDay: '[včera o] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
                return '[minulú nedeľu o] LT';

              case 1:
              case 2:
                return '[minulý] dddd [o] LT';

              case 3:
                return '[minulú stredu o] LT';

              case 4:
              case 5:
                return '[minulý] dddd [o] LT';

              case 6:
                return '[minulú sobotu o] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'za %s',
          past: 'pred %s',
          s: translate,
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: translate,
          dd: translate,
          M: translate,
          MM: translate,
          y: translate,
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return sk;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sl.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sl.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSlJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Slovenian [sl]
    //! author : Robert Sedovšek : https://github.com/sedovsek
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';

        switch (key) {
          case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';

          case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';

          case 'mm':
            if (number === 1) {
              result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
              result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
              result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
              result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }

            return result;

          case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';

          case 'hh':
            if (number === 1) {
              result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
              result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
              result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
              result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }

            return result;

          case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';

          case 'dd':
            if (number === 1) {
              result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
              result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
              result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }

            return result;

          case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';

          case 'MM':
            if (number === 1) {
              result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
              result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
              result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
              result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }

            return result;

          case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';

          case 'yy':
            if (number === 1) {
              result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
              result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
              result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
              result += withoutSuffix || isFuture ? 'let' : 'leti';
            }

            return result;
        }
      }

      var sl = moment.defineLocale('sl', {
        months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
        weekdaysShort: 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
        weekdaysMin: 'ne_po_to_sr_če_pe_so'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[danes ob] LT',
          nextDay: '[jutri ob] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[v] [nedeljo] [ob] LT';

              case 3:
                return '[v] [sredo] [ob] LT';

              case 6:
                return '[v] [soboto] [ob] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[v] dddd [ob] LT';
            }
          },
          lastDay: '[včeraj ob] LT',
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
                return '[prejšnjo] [nedeljo] [ob] LT';

              case 3:
                return '[prejšnjo] [sredo] [ob] LT';

              case 6:
                return '[prejšnjo] [soboto] [ob] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[prejšnji] dddd [ob] LT';
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'čez %s',
          past: 'pred %s',
          s: processRelativeTime,
          m: processRelativeTime,
          mm: processRelativeTime,
          h: processRelativeTime,
          hh: processRelativeTime,
          d: processRelativeTime,
          dd: processRelativeTime,
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return sl;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sq.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sq.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSqJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Albanian [sq]
    //! author : Flakërim Ismani : https://github.com/flakerimi
    //! author : Menelion Elensúle : https://github.com/Oire
    //! author : Oerd Cukalla : https://github.com/oerd
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var sq = moment.defineLocale('sq', {
        months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
        monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
        weekdays: 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
        weekdaysShort: 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
        weekdaysMin: 'D_H_Ma_Më_E_P_Sh'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /PD|MD/,
        isPM: function isPM(input) {
          return input.charAt(0) === 'M';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Sot në] LT',
          nextDay: '[Nesër në] LT',
          nextWeek: 'dddd [në] LT',
          lastDay: '[Dje në] LT',
          lastWeek: 'dddd [e kaluar në] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'në %s',
          past: '%s më parë',
          s: 'disa sekonda',
          m: 'një minutë',
          mm: '%d minuta',
          h: 'një orë',
          hh: '%d orë',
          d: 'një ditë',
          dd: '%d ditë',
          M: 'një muaj',
          MM: '%d muaj',
          y: 'një vit',
          yy: '%d vite'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return sq;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sr-cyrl.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sr-cyrl.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSrCyrlJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Serbian Cyrillic [sr-cyrl]
    //! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var translator = {
        words: {
          //Different grammatical cases
          m: ['један минут', 'једне минуте'],
          mm: ['минут', 'минуте', 'минута'],
          h: ['један сат', 'једног сата'],
          hh: ['сат', 'сата', 'сати'],
          dd: ['дан', 'дана', 'дана'],
          MM: ['месец', 'месеца', 'месеци'],
          yy: ['година', 'године', 'година']
        },
        correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
          return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function translate(number, withoutSuffix, key) {
          var wordKey = translator.words[key];

          if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
          } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
          }
        }
      };
      var srCyrl = moment.defineLocale('sr-cyrl', {
        months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
        monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
        monthsParseExact: true,
        weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
        weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
        weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[данас у] LT',
          nextDay: '[сутра у] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[у] [недељу] [у] LT';

              case 3:
                return '[у] [среду] [у] LT';

              case 6:
                return '[у] [суботу] [у] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[у] dddd [у] LT';
            }
          },
          lastDay: '[јуче у] LT',
          lastWeek: function lastWeek() {
            var lastWeekDays = ['[прошле] [недеље] [у] LT', '[прошлог] [понедељка] [у] LT', '[прошлог] [уторка] [у] LT', '[прошле] [среде] [у] LT', '[прошлог] [четвртка] [у] LT', '[прошлог] [петка] [у] LT', '[прошле] [суботе] [у] LT'];
            return lastWeekDays[this.day()];
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'за %s',
          past: 'пре %s',
          s: 'неколико секунди',
          m: translator.translate,
          mm: translator.translate,
          h: translator.translate,
          hh: translator.translate,
          d: 'дан',
          dd: translator.translate,
          M: 'месец',
          MM: translator.translate,
          y: 'годину',
          yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return srCyrl;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sr.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sr.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Serbian [sr]
    //! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var translator = {
        words: {
          //Different grammatical cases
          m: ['jedan minut', 'jedne minute'],
          mm: ['minut', 'minute', 'minuta'],
          h: ['jedan sat', 'jednog sata'],
          hh: ['sat', 'sata', 'sati'],
          dd: ['dan', 'dana', 'dana'],
          MM: ['mesec', 'meseca', 'meseci'],
          yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
          return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function translate(number, withoutSuffix, key) {
          var wordKey = translator.words[key];

          if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
          } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
          }
        }
      };
      var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function nextWeek() {
            switch (this.day()) {
              case 0:
                return '[u] [nedelju] [u] LT';

              case 3:
                return '[u] [sredu] [u] LT';

              case 6:
                return '[u] [subotu] [u] LT';

              case 1:
              case 2:
              case 4:
              case 5:
                return '[u] dddd [u] LT';
            }
          },
          lastDay: '[juče u] LT',
          lastWeek: function lastWeek() {
            var lastWeekDays = ['[prošle] [nedelje] [u] LT', '[prošlog] [ponedeljka] [u] LT', '[prošlog] [utorka] [u] LT', '[prošle] [srede] [u] LT', '[prošlog] [četvrtka] [u] LT', '[prošlog] [petka] [u] LT', '[prošle] [subote] [u] LT'];
            return lastWeekDays[this.day()];
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'za %s',
          past: 'pre %s',
          s: 'nekoliko sekundi',
          m: translator.translate,
          mm: translator.translate,
          h: translator.translate,
          hh: translator.translate,
          d: 'dan',
          dd: translator.translate,
          M: 'mesec',
          MM: translator.translate,
          y: 'godinu',
          yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return sr;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ss.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ss.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSsJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : siSwati [ss]
    //! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var ss = moment.defineLocale('ss', {
        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
          sameDay: '[Namuhla nga] LT',
          nextDay: '[Kusasa nga] LT',
          nextWeek: 'dddd [nga] LT',
          lastDay: '[Itolo nga] LT',
          lastWeek: 'dddd [leliphelile] [nga] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'nga %s',
          past: 'wenteka nga %s',
          s: 'emizuzwana lomcane',
          m: 'umzuzu',
          mm: '%d emizuzu',
          h: 'lihora',
          hh: '%d emahora',
          d: 'lilanga',
          dd: '%d emalanga',
          M: 'inyanga',
          MM: '%d tinyanga',
          y: 'umnyaka',
          yy: '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 11) {
            return 'ekuseni';
          } else if (hours < 15) {
            return 'emini';
          } else if (hours < 19) {
            return 'entsambama';
          } else {
            return 'ebusuku';
          }
        },
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'ekuseni') {
            return hour;
          } else if (meridiem === 'emini') {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
            if (hour === 0) {
              return 0;
            }

            return hour + 12;
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return ss;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sv.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sv.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSvJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Swedish [sv]
    //! author : Jens Alm : https://github.com/ulmus
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var sv = moment.defineLocale('sv', {
        months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort: 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin: 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [kl.] HH:mm',
          LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd D MMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Idag] LT',
          nextDay: '[Imorgon] LT',
          lastDay: '[Igår] LT',
          nextWeek: '[På] dddd LT',
          lastWeek: '[I] dddd[s] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'om %s',
          past: 'för %s sedan',
          s: 'några sekunder',
          m: 'en minut',
          mm: '%d minuter',
          h: 'en timme',
          hh: '%d timmar',
          d: 'en dag',
          dd: '%d dagar',
          M: 'en månad',
          MM: '%d månader',
          y: 'ett år',
          yy: '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'e' : b === 1 ? 'a' : b === 2 ? 'a' : b === 3 ? 'e' : 'e';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return sv;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/sw.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/sw.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleSwJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Swahili [sw]
    //! author : Fahad Kassim : https://github.com/fadsel
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var sw = moment.defineLocale('sw', {
        months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[leo saa] LT',
          nextDay: '[kesho saa] LT',
          nextWeek: '[wiki ijayo] dddd [saat] LT',
          lastDay: '[jana] LT',
          lastWeek: '[wiki iliyopita] dddd [saat] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s baadaye',
          past: 'tokea %s',
          s: 'hivi punde',
          m: 'dakika moja',
          mm: 'dakika %d',
          h: 'saa limoja',
          hh: 'masaa %d',
          d: 'siku moja',
          dd: 'masiku %d',
          M: 'mwezi mmoja',
          MM: 'miezi %d',
          y: 'mwaka mmoja',
          yy: 'miaka %d'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return sw;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ta.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ta.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTaJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Tamil [ta]
    //! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var symbolMap = {
        '1': '௧',
        '2': '௨',
        '3': '௩',
        '4': '௪',
        '5': '௫',
        '6': '௬',
        '7': '௭',
        '8': '௮',
        '9': '௯',
        '0': '௦'
      };
      var numberMap = {
        '௧': '1',
        '௨': '2',
        '௩': '3',
        '௪': '4',
        '௫': '5',
        '௬': '6',
        '௭': '7',
        '௮': '8',
        '௯': '9',
        '௦': '0'
      };
      var ta = moment.defineLocale('ta', {
        months: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        monthsShort: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        weekdays: 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
        weekdaysShort: 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
        weekdaysMin: 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, HH:mm',
          LLLL: 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar: {
          sameDay: '[இன்று] LT',
          nextDay: '[நாளை] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[நேற்று] LT',
          lastWeek: '[கடந்த வாரம்] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s இல்',
          past: '%s முன்',
          s: 'ஒரு சில விநாடிகள்',
          m: 'ஒரு நிமிடம்',
          mm: '%d நிமிடங்கள்',
          h: 'ஒரு மணி நேரம்',
          hh: '%d மணி நேரம்',
          d: 'ஒரு நாள்',
          dd: '%d நாட்கள்',
          M: 'ஒரு மாதம்',
          MM: '%d மாதங்கள்',
          y: 'ஒரு வருடம்',
          yy: '%d ஆண்டுகள்'
        },
        dayOfMonthOrdinalParse: /\d{1,2}வது/,
        ordinal: function ordinal(number) {
          return number + 'வது';
        },
        preparse: function preparse(string) {
          return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
            return numberMap[match];
          });
        },
        postformat: function postformat(string) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match];
          });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 2) {
            return ' யாமம்';
          } else if (hour < 6) {
            return ' வைகறை'; // வைகறை
          } else if (hour < 10) {
            return ' காலை'; // காலை
          } else if (hour < 14) {
            return ' நண்பகல்'; // நண்பகல்
          } else if (hour < 18) {
            return ' எற்பாடு'; // எற்பாடு
          } else if (hour < 22) {
            return ' மாலை'; // மாலை
          } else {
            return ' யாமம்';
          }
        },
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'யாமம்') {
            return hour < 2 ? hour : hour + 12;
          } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
            return hour;
          } else if (meridiem === 'நண்பகல்') {
            return hour >= 10 ? hour : hour + 12;
          } else {
            return hour + 12;
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return ta;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/te.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/te.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTeJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Telugu [te]
    //! author : Krishna Chaitanya Thota : https://github.com/kcthota
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var te = moment.defineLocale('te', {
        months: 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
        monthsShort: 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
        monthsParseExact: true,
        weekdays: 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
        weekdaysShort: 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
        weekdaysMin: 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
        longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm',
          LLLL: 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar: {
          sameDay: '[నేడు] LT',
          nextDay: '[రేపు] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[నిన్న] LT',
          lastWeek: '[గత] dddd, LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s లో',
          past: '%s క్రితం',
          s: 'కొన్ని క్షణాలు',
          m: 'ఒక నిమిషం',
          mm: '%d నిమిషాలు',
          h: 'ఒక గంట',
          hh: '%d గంటలు',
          d: 'ఒక రోజు',
          dd: '%d రోజులు',
          M: 'ఒక నెల',
          MM: '%d నెలలు',
          y: 'ఒక సంవత్సరం',
          yy: '%d సంవత్సరాలు'
        },
        dayOfMonthOrdinalParse: /\d{1,2}వ/,
        ordinal: '%dవ',
        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === 'రాత్రి') {
            return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'ఉదయం') {
            return hour;
          } else if (meridiem === 'మధ్యాహ్నం') {
            return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === 'సాయంత్రం') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'రాత్రి';
          } else if (hour < 10) {
            return 'ఉదయం';
          } else if (hour < 17) {
            return 'మధ్యాహ్నం';
          } else if (hour < 20) {
            return 'సాయంత్రం';
          } else {
            return 'రాత్రి';
          }
        },
        week: {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return te;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/tet.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/tet.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTetJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Tetun Dili (East Timor) [tet]
    //! author : Joshua Brooks : https://github.com/joshbrooks
    //! author : Onorio De J. Afonso : https://github.com/marobo
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var tet = moment.defineLocale('tet', {
        months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
        weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
        weekdaysMin: 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Ohin iha] LT',
          nextDay: '[Aban iha] LT',
          nextWeek: 'dddd [iha] LT',
          lastDay: '[Horiseik iha] LT',
          lastWeek: 'dddd [semana kotuk] [iha] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'iha %s',
          past: '%s liuba',
          s: 'minutu balun',
          m: 'minutu ida',
          mm: 'minutus %d',
          h: 'horas ida',
          hh: 'horas %d',
          d: 'loron ida',
          dd: 'loron %d',
          M: 'fulan ida',
          MM: 'fulan %d',
          y: 'tinan ida',
          yy: 'tinan %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return tet;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/th.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/th.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleThJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Thai [th]
    //! author : Kridsada Thanabulpong : https://github.com/sirn
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var th = moment.defineLocale('th', {
        months: 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
        monthsShort: 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
        monthsParseExact: true,
        weekdays: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'),
        // yes, three characters difference
        weekdaysMin: 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY เวลา H:mm',
          LLLL: 'วันddddที่ D MMMM YYYY เวลา H:mm'
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function isPM(input) {
          return input === 'หลังเที่ยง';
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'ก่อนเที่ยง';
          } else {
            return 'หลังเที่ยง';
          }
        },
        calendar: {
          sameDay: '[วันนี้ เวลา] LT',
          nextDay: '[พรุ่งนี้ เวลา] LT',
          nextWeek: 'dddd[หน้า เวลา] LT',
          lastDay: '[เมื่อวานนี้ เวลา] LT',
          lastWeek: '[วัน]dddd[ที่แล้ว เวลา] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'อีก %s',
          past: '%sที่แล้ว',
          s: 'ไม่กี่วินาที',
          m: '1 นาที',
          mm: '%d นาที',
          h: '1 ชั่วโมง',
          hh: '%d ชั่วโมง',
          d: '1 วัน',
          dd: '%d วัน',
          M: '1 เดือน',
          MM: '%d เดือน',
          y: '1 ปี',
          yy: '%d ปี'
        }
      });
      return th;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/tl-ph.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/tl-ph.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTlPhJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Tagalog (Philippines) [tl-ph]
    //! author : Dan Hagman : https://github.com/hagmandan
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var tlPh = moment.defineLocale('tl-ph', {
        months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'MM/D/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY HH:mm',
          LLLL: 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar: {
          sameDay: 'LT [ngayong araw]',
          nextDay: '[Bukas ng] LT',
          nextWeek: 'LT [sa susunod na] dddd',
          lastDay: 'LT [kahapon]',
          lastWeek: 'LT [noong nakaraang] dddd',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'sa loob ng %s',
          past: '%s ang nakalipas',
          s: 'ilang segundo',
          m: 'isang minuto',
          mm: '%d minuto',
          h: 'isang oras',
          hh: '%d oras',
          d: 'isang araw',
          dd: '%d araw',
          M: 'isang buwan',
          MM: '%d buwan',
          y: 'isang taon',
          yy: '%d taon'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function ordinal(number) {
          return number;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return tlPh;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/tlh.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/tlh.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTlhJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Klingon [tlh]
    //! author : Dominika Kruk : https://github.com/amaranthrose
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

      function translateFuture(output) {
        var time = output;
        time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'leS' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'waQ' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'nem' : time + ' pIq';
        return time;
      }

      function translatePast(output) {
        var time = output;
        time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'Hu’' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'wen' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'ben' : time + ' ret';
        return time;
      }

      function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);

        switch (string) {
          case 'mm':
            return numberNoun + ' tup';

          case 'hh':
            return numberNoun + ' rep';

          case 'dd':
            return numberNoun + ' jaj';

          case 'MM':
            return numberNoun + ' jar';

          case 'yy':
            return numberNoun + ' DIS';
        }
      }

      function numberAsNoun(number) {
        var hundred = Math.floor(number % 1000 / 100),
            ten = Math.floor(number % 100 / 10),
            one = number % 10,
            word = '';

        if (hundred > 0) {
          word += numbersNouns[hundred] + 'vatlh';
        }

        if (ten > 0) {
          word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
        }

        if (one > 0) {
          word += (word !== '' ? ' ' : '') + numbersNouns[one];
        }

        return word === '' ? 'pagh' : word;
      }

      var tlh = moment.defineLocale('tlh', {
        months: 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
        monthsShort: 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
        monthsParseExact: true,
        weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[DaHjaj] LT',
          nextDay: '[wa’leS] LT',
          nextWeek: 'LLL',
          lastDay: '[wa’Hu’] LT',
          lastWeek: 'LLL',
          sameElse: 'L'
        },
        relativeTime: {
          future: translateFuture,
          past: translatePast,
          s: 'puS lup',
          m: 'wa’ tup',
          mm: translate,
          h: 'wa’ rep',
          hh: translate,
          d: 'wa’ jaj',
          dd: translate,
          M: 'wa’ jar',
          MM: translate,
          y: 'wa’ DIS',
          yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return tlh;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/tr.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/tr.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Turkish [tr]
    //! authors : Erhan Gundogan : https://github.com/erhangundogan,
    //!           Burak Yiğit Kaya: https://github.com/BYK
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',
        6: '\'ncı',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'ıncı',
        90: '\'ıncı'
      };
      var tr = moment.defineLocale('tr', {
        months: 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
        monthsShort: 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays: 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort: 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
        weekdaysMin: 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[bugün saat] LT',
          nextDay: '[yarın saat] LT',
          nextWeek: '[haftaya] dddd [saat] LT',
          lastDay: '[dün] LT',
          lastWeek: '[geçen hafta] dddd [saat] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s sonra',
          past: '%s önce',
          s: 'birkaç saniye',
          m: 'bir dakika',
          mm: '%d dakika',
          h: 'bir saat',
          hh: '%d saat',
          d: 'bir gün',
          dd: '%d gün',
          M: 'bir ay',
          MM: '%d ay',
          y: 'bir yıl',
          yy: '%d yıl'
        },
        dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
        ordinal: function ordinal(number) {
          if (number === 0) {
            // special case for zero
            return number + '\'ıncı';
          }

          var a = number % 10,
              b = number % 100 - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return tr;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/tzl.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/tzl.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTzlJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Talossan [tzl]
    //! author : Robin van der Vliet : https://github.com/robin0van0der0v
    //! author : Iustì Canun
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict'; // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
      // This is currently too difficult (maybe even impossible) to add.

      var tzl = moment.defineLocale('tzl', {
        months: 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays: 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
        weekdaysShort: 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
        weekdaysMin: 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
        longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM [dallas] YYYY',
          LLL: 'D. MMMM [dallas] YYYY HH.mm',
          LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function isPM(input) {
          return 'd\'o' === input.toLowerCase();
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'd\'o' : 'D\'O';
          } else {
            return isLower ? 'd\'a' : 'D\'A';
          }
        },
        calendar: {
          sameDay: '[oxhi à] LT',
          nextDay: '[demà à] LT',
          nextWeek: 'dddd [à] LT',
          lastDay: '[ieiri à] LT',
          lastWeek: '[sür el] dddd [lasteu à] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'osprei %s',
          past: 'ja%s',
          s: processRelativeTime,
          m: processRelativeTime,
          mm: processRelativeTime,
          h: processRelativeTime,
          hh: processRelativeTime,
          d: processRelativeTime,
          dd: processRelativeTime,
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });

      function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
          's': ['viensas secunds', '\'iensas secunds'],
          'm': ['\'n míut', '\'iens míut'],
          'mm': [number + ' míuts', '' + number + ' míuts'],
          'h': ['\'n þora', '\'iensa þora'],
          'hh': [number + ' þoras', '' + number + ' þoras'],
          'd': ['\'n ziua', '\'iensa ziua'],
          'dd': [number + ' ziuas', '' + number + ' ziuas'],
          'M': ['\'n mes', '\'iens mes'],
          'MM': [number + ' mesen', '' + number + ' mesen'],
          'y': ['\'n ar', '\'iens ar'],
          'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
      }

      return tzl;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/tzm-latn.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/tzm-latn.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTzmLatnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Central Atlas Tamazight Latin [tzm-latn]
    //! author : Abdel Said : https://github.com/abdelsaid
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var tzmLatn = moment.defineLocale('tzm-latn', {
        months: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        monthsShort: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[asdkh g] LT',
          nextDay: '[aska g] LT',
          nextWeek: 'dddd [g] LT',
          lastDay: '[assant g] LT',
          lastWeek: 'dddd [g] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'dadkh s yan %s',
          past: 'yan %s',
          s: 'imik',
          m: 'minuḍ',
          mm: '%d minuḍ',
          h: 'saɛa',
          hh: '%d tassaɛin',
          d: 'ass',
          dd: '%d ossan',
          M: 'ayowr',
          MM: '%d iyyirn',
          y: 'asgas',
          yy: '%d isgasn'
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return tzmLatn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/tzm.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/tzm.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleTzmJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Central Atlas Tamazight [tzm]
    //! author : Abdel Said : https://github.com/abdelsaid
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var tzm = moment.defineLocale('tzm', {
        months: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        monthsShort: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        weekdays: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysShort: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysMin: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
          nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
          nextWeek: 'dddd [ⴴ] LT',
          lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
          lastWeek: 'dddd [ⴴ] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
          past: 'ⵢⴰⵏ %s',
          s: 'ⵉⵎⵉⴽ',
          m: 'ⵎⵉⵏⵓⴺ',
          mm: '%d ⵎⵉⵏⵓⴺ',
          h: 'ⵙⴰⵄⴰ',
          hh: '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
          d: 'ⴰⵙⵙ',
          dd: '%d oⵙⵙⴰⵏ',
          M: 'ⴰⵢoⵓⵔ',
          MM: '%d ⵉⵢⵢⵉⵔⵏ',
          y: 'ⴰⵙⴳⴰⵙ',
          yy: '%d ⵉⵙⴳⴰⵙⵏ'
        },
        week: {
          dow: 6,
          // Saturday is the first day of the week.
          doy: 12 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return tzm;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/uk.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/uk.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleUkJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Ukrainian [uk]
    //! author : zemlanin : https://github.com/zemlanin
    //! Author : Menelion Elensúle : https://github.com/Oire
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
      }

      function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
          'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
          'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
          'dd': 'день_дні_днів',
          'MM': 'місяць_місяці_місяців',
          'yy': 'рік_роки_років'
        };

        if (key === 'm') {
          return withoutSuffix ? 'хвилина' : 'хвилину';
        } else if (key === 'h') {
          return withoutSuffix ? 'година' : 'годину';
        } else {
          return number + ' ' + plural(format[key], +number);
        }
      }

      function weekdaysCaseReplace(m, format) {
        var weekdays = {
          'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
          'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
          'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
        };

        if (!m) {
          return weekdays['nominative'];
        }

        var nounCase = /(\[[ВвУу]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
        return weekdays[nounCase][m.day()];
      }

      function processHoursFunction(str) {
        return function () {
          return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
        };
      }

      var uk = moment.defineLocale('uk', {
        months: {
          'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
          'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
        },
        monthsShort: 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY р.',
          LLL: 'D MMMM YYYY р., HH:mm',
          LLLL: 'dddd, D MMMM YYYY р., HH:mm'
        },
        calendar: {
          sameDay: processHoursFunction('[Сьогодні '),
          nextDay: processHoursFunction('[Завтра '),
          lastDay: processHoursFunction('[Вчора '),
          nextWeek: processHoursFunction('[У] dddd ['),
          lastWeek: function lastWeek() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return processHoursFunction('[Минулої] dddd [').call(this);

              case 1:
              case 2:
              case 4:
                return processHoursFunction('[Минулого] dddd [').call(this);
            }
          },
          sameElse: 'L'
        },
        relativeTime: {
          future: 'за %s',
          past: '%s тому',
          s: 'декілька секунд',
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: 'годину',
          hh: relativeTimeWithPlural,
          d: 'день',
          dd: relativeTimeWithPlural,
          M: 'місяць',
          MM: relativeTimeWithPlural,
          y: 'рік',
          yy: relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /ночі|ранку|дня|вечора/,
        isPM: function isPM(input) {
          return /^(дня|вечора)$/.test(input);
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 4) {
            return 'ночі';
          } else if (hour < 12) {
            return 'ранку';
          } else if (hour < 17) {
            return 'дня';
          } else {
            return 'вечора';
          }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
              return number + '-й';

            case 'D':
              return number + '-го';

            default:
              return number;
          }
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return uk;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/ur.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/ur.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleUrJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Urdu [ur]
    //! author : Sawood Alam : https://github.com/ibnesayeed
    //! author : Zack : https://github.com/ZackVision
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var months = ['جنوری', 'فروری', 'مارچ', 'اپریل', 'مئی', 'جون', 'جولائی', 'اگست', 'ستمبر', 'اکتوبر', 'نومبر', 'دسمبر'];
      var days = ['اتوار', 'پیر', 'منگل', 'بدھ', 'جمعرات', 'جمعہ', 'ہفتہ'];
      var ur = moment.defineLocale('ur', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd، D MMMM YYYY HH:mm'
        },
        meridiemParse: /صبح|شام/,
        isPM: function isPM(input) {
          return 'شام' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
          if (hour < 12) {
            return 'صبح';
          }

          return 'شام';
        },
        calendar: {
          sameDay: '[آج بوقت] LT',
          nextDay: '[کل بوقت] LT',
          nextWeek: 'dddd [بوقت] LT',
          lastDay: '[گذشتہ روز بوقت] LT',
          lastWeek: '[گذشتہ] dddd [بوقت] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s بعد',
          past: '%s قبل',
          s: 'چند سیکنڈ',
          m: 'ایک منٹ',
          mm: '%d منٹ',
          h: 'ایک گھنٹہ',
          hh: '%d گھنٹے',
          d: 'ایک دن',
          dd: '%d دن',
          M: 'ایک ماہ',
          MM: '%d ماہ',
          y: 'ایک سال',
          yy: '%d سال'
        },
        preparse: function preparse(string) {
          return string.replace(/،/g, ',');
        },
        postformat: function postformat(string) {
          return string.replace(/,/g, '،');
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return ur;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/uz-latn.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/uz-latn.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleUzLatnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Uzbek Latin [uz-latn]
    //! author : Rasulbek Mirzayev : github.com/Rasulbeeek
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var uzLatn = moment.defineLocale('uz-latn', {
        months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
        monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
        weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'D MMMM YYYY, dddd HH:mm'
        },
        calendar: {
          sameDay: '[Bugun soat] LT [da]',
          nextDay: '[Ertaga] LT [da]',
          nextWeek: 'dddd [kuni soat] LT [da]',
          lastDay: '[Kecha soat] LT [da]',
          lastWeek: '[O\'tgan] dddd [kuni soat] LT [da]',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'Yaqin %s ichida',
          past: 'Bir necha %s oldin',
          s: 'soniya',
          m: 'bir daqiqa',
          mm: '%d daqiqa',
          h: 'bir soat',
          hh: '%d soat',
          d: 'bir kun',
          dd: '%d kun',
          M: 'bir oy',
          MM: '%d oy',
          y: 'bir yil',
          yy: '%d yil'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 1st is the first week of the year.

        }
      });
      return uzLatn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/uz.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/uz.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleUzJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Uzbek [uz]
    //! author : Sardor Muminov : https://github.com/muminoff
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var uz = moment.defineLocale('uz', {
        months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
        monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays: 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
        weekdaysShort: 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
        weekdaysMin: 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'D MMMM YYYY, dddd HH:mm'
        },
        calendar: {
          sameDay: '[Бугун соат] LT [да]',
          nextDay: '[Эртага] LT [да]',
          nextWeek: 'dddd [куни соат] LT [да]',
          lastDay: '[Кеча соат] LT [да]',
          lastWeek: '[Утган] dddd [куни соат] LT [да]',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'Якин %s ичида',
          past: 'Бир неча %s олдин',
          s: 'фурсат',
          m: 'бир дакика',
          mm: '%d дакика',
          h: 'бир соат',
          hh: '%d соат',
          d: 'бир кун',
          dd: '%d кун',
          M: 'бир ой',
          MM: '%d ой',
          y: 'бир йил',
          yy: '%d йил'
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 7 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return uz;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/vi.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/vi.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleViJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Vietnamese [vi]
    //! author : Bang Nguyen : https://github.com/bangnk
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var vi = moment.defineLocale('vi', {
        months: 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
        monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact: true,
        weekdays: 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
        weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /sa|ch/i,
        isPM: function isPM(input) {
          return /^ch$/i.test(input);
        },
        meridiem: function meridiem(hours, minutes, isLower) {
          if (hours < 12) {
            return isLower ? 'sa' : 'SA';
          } else {
            return isLower ? 'ch' : 'CH';
          }
        },
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM [năm] YYYY',
          LLL: 'D MMMM [năm] YYYY HH:mm',
          LLLL: 'dddd, D MMMM [năm] YYYY HH:mm',
          l: 'DD/M/YYYY',
          ll: 'D MMM YYYY',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd, D MMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[Hôm nay lúc] LT',
          nextDay: '[Ngày mai lúc] LT',
          nextWeek: 'dddd [tuần tới lúc] LT',
          lastDay: '[Hôm qua lúc] LT',
          lastWeek: 'dddd [tuần rồi lúc] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: '%s tới',
          past: '%s trước',
          s: 'vài giây',
          m: 'một phút',
          mm: '%d phút',
          h: 'một giờ',
          hh: '%d giờ',
          d: 'một ngày',
          dd: '%d ngày',
          M: 'một tháng',
          MM: '%d tháng',
          y: 'một năm',
          yy: '%d năm'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function ordinal(number) {
          return number;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return vi;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/x-pseudo.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/x-pseudo.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleXPseudoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Pseudo [x-pseudo]
    //! author : Andrew Hood : https://github.com/andrewhood125
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var xPseudo = moment.defineLocale('x-pseudo', {
        months: 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
        monthsShort: 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
        monthsParseExact: true,
        weekdays: 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
        weekdaysShort: 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
        weekdaysMin: 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
          LT: 'HH:mm',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
          sameDay: '[T~ódá~ý át] LT',
          nextDay: '[T~ómó~rró~w át] LT',
          nextWeek: 'dddd [át] LT',
          lastDay: '[Ý~ést~érdá~ý át] LT',
          lastWeek: '[L~ást] dddd [át] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'í~ñ %s',
          past: '%s á~gó',
          s: 'á ~féw ~sécó~ñds',
          m: 'á ~míñ~úté',
          mm: '%d m~íñú~tés',
          h: 'á~ñ hó~úr',
          hh: '%d h~óúrs',
          d: 'á ~dáý',
          dd: '%d d~áýs',
          M: 'á ~móñ~th',
          MM: '%d m~óñt~hs',
          y: 'á ~ýéár',
          yy: '%d ý~éárs'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function ordinal(number) {
          var b = number % 10,
              output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        },
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return xPseudo;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/yo.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/yo.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleYoJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Yoruba Nigeria [yo]
    //! author : Atolagbe Abisoye : https://github.com/andela-batolagbe
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var yo = moment.defineLocale('yo', {
        months: 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split('_'),
        monthsShort: 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
        weekdays: 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
        weekdaysShort: 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
        weekdaysMin: 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
        longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
          sameDay: '[Ònì ni] LT',
          nextDay: '[Ọ̀la ni] LT',
          nextWeek: 'dddd [Ọsẹ̀ tón\'bọ] [ni] LT',
          lastDay: '[Àna ni] LT',
          lastWeek: 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
          sameElse: 'L'
        },
        relativeTime: {
          future: 'ní %s',
          past: '%s kọjá',
          s: 'ìsẹjú aayá die',
          m: 'ìsẹjú kan',
          mm: 'ìsẹjú %d',
          h: 'wákati kan',
          hh: 'wákati %d',
          d: 'ọjọ́ kan',
          dd: 'ọjọ́ %d',
          M: 'osù kan',
          MM: 'osù %d',
          y: 'ọdún kan',
          yy: 'ọdún %d'
        },
        dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
        ordinal: 'ọjọ́ %d',
        week: {
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return yo;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/zh-cn.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/zh-cn.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleZhCnJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Chinese (China) [zh-cn]
    //! author : suupic : https://github.com/suupic
    //! author : Zeno Zeng : https://github.com/zenozeng
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var zhCn = moment.defineLocale('zh-cn', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY年MMMD日',
          LL: 'YYYY年MMMD日',
          LLL: 'YYYY年MMMD日Ah点mm分',
          LLLL: 'YYYY年MMMD日ddddAh点mm分',
          l: 'YYYY年MMMD日',
          ll: 'YYYY年MMMD日',
          lll: 'YYYY年MMMD日 HH:mm',
          llll: 'YYYY年MMMD日dddd HH:mm'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
            return hour;
          } else if (meridiem === '下午' || meridiem === '晚上') {
            return hour + 12;
          } else {
            // '中午'
            return hour >= 11 ? hour : hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          var hm = hour * 100 + minute;

          if (hm < 600) {
            return '凌晨';
          } else if (hm < 900) {
            return '早上';
          } else if (hm < 1130) {
            return '上午';
          } else if (hm < 1230) {
            return '中午';
          } else if (hm < 1800) {
            return '下午';
          } else {
            return '晚上';
          }
        },
        calendar: {
          sameDay: '[今天]LT',
          nextDay: '[明天]LT',
          nextWeek: '[下]ddddLT',
          lastDay: '[昨天]LT',
          lastWeek: '[上]ddddLT',
          sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日';

            case 'M':
              return number + '月';

            case 'w':
            case 'W':
              return number + '周';

            default:
              return number;
          }
        },
        relativeTime: {
          future: '%s内',
          past: '%s前',
          s: '几秒',
          m: '1 分钟',
          mm: '%d 分钟',
          h: '1 小时',
          hh: '%d 小时',
          d: '1 天',
          dd: '%d 天',
          M: '1 个月',
          MM: '%d 个月',
          y: '1 年',
          yy: '%d 年'
        },
        week: {
          // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
          dow: 1,
          // Monday is the first day of the week.
          doy: 4 // The week that contains Jan 4th is the first week of the year.

        }
      });
      return zhCn;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/zh-hk.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/zh-hk.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleZhHkJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Chinese (Hong Kong) [zh-hk]
    //! author : Ben : https://github.com/ben-lin
    //! author : Chris Lam : https://github.com/hehachris
    //! author : Konstantin : https://github.com/skfd
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var zhHk = moment.defineLocale('zh-hk', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY年MMMD日',
          LL: 'YYYY年MMMD日',
          LLL: 'YYYY年MMMD日 HH:mm',
          LLLL: 'YYYY年MMMD日dddd HH:mm',
          l: 'YYYY年MMMD日',
          ll: 'YYYY年MMMD日',
          lll: 'YYYY年MMMD日 HH:mm',
          llll: 'YYYY年MMMD日dddd HH:mm'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
            return hour;
          } else if (meridiem === '中午') {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === '下午' || meridiem === '晚上') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          var hm = hour * 100 + minute;

          if (hm < 600) {
            return '凌晨';
          } else if (hm < 900) {
            return '早上';
          } else if (hm < 1130) {
            return '上午';
          } else if (hm < 1230) {
            return '中午';
          } else if (hm < 1800) {
            return '下午';
          } else {
            return '晚上';
          }
        },
        calendar: {
          sameDay: '[今天]LT',
          nextDay: '[明天]LT',
          nextWeek: '[下]ddddLT',
          lastDay: '[昨天]LT',
          lastWeek: '[上]ddddLT',
          sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日';

            case 'M':
              return number + '月';

            case 'w':
            case 'W':
              return number + '週';

            default:
              return number;
          }
        },
        relativeTime: {
          future: '%s內',
          past: '%s前',
          s: '幾秒',
          m: '1 分鐘',
          mm: '%d 分鐘',
          h: '1 小時',
          hh: '%d 小時',
          d: '1 天',
          dd: '%d 天',
          M: '1 個月',
          MM: '%d 個月',
          y: '1 年',
          yy: '%d 年'
        }
      });
      return zhHk;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/locale/zh-tw.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/locale/zh-tw.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentLocaleZhTwJs(module, exports, __webpack_require__) {
    //! moment.js locale configuration
    //! locale : Chinese (Taiwan) [zh-tw]
    //! author : Ben : https://github.com/ben-lin
    //! author : Chris Lam : https://github.com/hehachris
    ;

    (function (global, factory) {
      true ? factory(__webpack_require__(
      /*! ../moment */
      "./node_modules/chart.js/node_modules/moment/moment.js")) : undefined;
    })(this, function (moment) {
      'use strict';

      var zhTw = moment.defineLocale('zh-tw', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY年MMMD日',
          LL: 'YYYY年MMMD日',
          LLL: 'YYYY年MMMD日 HH:mm',
          LLLL: 'YYYY年MMMD日dddd HH:mm',
          l: 'YYYY年MMMD日',
          ll: 'YYYY年MMMD日',
          lll: 'YYYY年MMMD日 HH:mm',
          llll: 'YYYY年MMMD日dddd HH:mm'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function meridiemHour(hour, meridiem) {
          if (hour === 12) {
            hour = 0;
          }

          if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
            return hour;
          } else if (meridiem === '中午') {
            return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === '下午' || meridiem === '晚上') {
            return hour + 12;
          }
        },
        meridiem: function meridiem(hour, minute, isLower) {
          var hm = hour * 100 + minute;

          if (hm < 600) {
            return '凌晨';
          } else if (hm < 900) {
            return '早上';
          } else if (hm < 1130) {
            return '上午';
          } else if (hm < 1230) {
            return '中午';
          } else if (hm < 1800) {
            return '下午';
          } else {
            return '晚上';
          }
        },
        calendar: {
          sameDay: '[今天]LT',
          nextDay: '[明天]LT',
          nextWeek: '[下]ddddLT',
          lastDay: '[昨天]LT',
          lastWeek: '[上]ddddLT',
          sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function ordinal(number, period) {
          switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
              return number + '日';

            case 'M':
              return number + '月';

            case 'w':
            case 'W':
              return number + '週';

            default:
              return number;
          }
        },
        relativeTime: {
          future: '%s內',
          past: '%s前',
          s: '幾秒',
          m: '1 分鐘',
          mm: '%d 分鐘',
          h: '1 小時',
          hh: '%d 小時',
          d: '1 天',
          dd: '%d 天',
          M: '1 個月',
          MM: '%d 個月',
          y: '1 年',
          yy: '%d 年'
        }
      });
      return zhTw;
    });
    /***/

  },

  /***/
  "./node_modules/chart.js/node_modules/moment/moment.js":
  /*!*************************************************************!*\
    !*** ./node_modules/chart.js/node_modules/moment/moment.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsNode_modulesMomentMomentJs(module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */
    (function (module) {
      //! moment.js
      //! version : 2.18.1
      //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
      //! license : MIT
      //! momentjs.com
      ;

      (function (global, factory) {
        true ? module.exports = factory() : undefined;
      })(this, function () {
        'use strict';

        var hookCallback;

        function hooks() {
          return hookCallback.apply(null, arguments);
        } // This is done to register the method called with moment()
        // without creating circular dependencies.


        function setHookCallback(callback) {
          hookCallback = callback;
        }

        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
        }

        function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
        }

        function isObjectEmpty(obj) {
          var k;

          for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
          }

          return true;
        }

        function isUndefined(input) {
          return input === void 0;
        }

        function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
        }

        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
        }

        function map(arr, fn) {
          var res = [],
              i;

          for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
          }

          return res;
        }

        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }

        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }

          if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
          }

          return a;
        }

        function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }

        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }

          return m._pf;
        }

        var some;

        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function some(fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }

            return false;
          };
        }

        var some$1 = some;

        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
              return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }

          return m._isValid;
        }

        function createInvalid(flags) {
          var m = createUTC(NaN);

          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }

          return m;
        } // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.


        var momentProperties = hooks.momentProperties = [];

        function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
          }

          if (!isUndefined(from._i)) {
            to._i = from._i;
          }

          if (!isUndefined(from._f)) {
            to._f = from._f;
          }

          if (!isUndefined(from._l)) {
            to._l = from._l;
          }

          if (!isUndefined(from._strict)) {
            to._strict = from._strict;
          }

          if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
          }

          if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
          }

          if (!isUndefined(from._offset)) {
            to._offset = from._offset;
          }

          if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
          }

          if (!isUndefined(from._locale)) {
            to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
              prop = momentProperties[i];
              val = from[prop];

              if (!isUndefined(val)) {
                to[prop] = val;
              }
            }
          }

          return to;
        }

        var updateInProgress = false; // Moment prototype object

        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);

          if (!this.isValid()) {
            this._d = new Date(NaN);
          } // Prevent infinite loop in case updateOffset creates new moment
          // objects.


          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }

        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }

        function absFloor(number) {
          if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }

        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }

          return value;
        } // compare two arrays, return the number of differences


        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;

          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }

          return diffs + lengthDiff;
        }

        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
          }
        }

        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function () {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }

            if (firstTime) {
              var args = [];
              var arg;

              for (var i = 0; i < arguments.length; i++) {
                arg = '';

                if (typeof arguments[i] === 'object') {
                  arg += '\n[' + i + '] ';

                  for (var key in arguments[0]) {
                    arg += key + ': ' + arguments[0][key] + ', ';
                  }

                  arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                  arg = arguments[i];
                }

                args.push(arg);
              }

              warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
              firstTime = false;
            }

            return fn.apply(this, arguments);
          }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }

          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
          return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
        }

        function set(config) {
          var prop, i;

          for (i in config) {
            prop = config[i];

            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this['_' + i] = prop;
            }
          }

          this._config = config; // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.

          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
        }

        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
              prop;

          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }

          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
            }
          }

          return res;
        }

        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }

        var keys;

        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function keys(obj) {
            var i,
                res = [];

            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }

            return res;
          };
        }

        var keys$1 = keys;
        var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        };

        function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
        }

        var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        };

        function longDateFormat(key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
            return format;
          }

          this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
          });
          return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
          return this._invalidDate;
        }

        var defaultOrdinal = '%d';
        var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
          return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
        }

        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);

              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }

          return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
          var units = [];

          for (var u in unitsObj) {
            units.push({
              unit: u,
              priority: priorities[u]
            });
          }

          units.sort(function (a, b) {
            return a.priority - b.priority;
          });
          return units;
        }

        function makeGetSet(unit, keepTime) {
          return function (value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }

        function get(mom, unit) {
          return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
        }

        function set$1(mom, unit, value) {
          if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
        } // MOMENTS


        function stringGet(units) {
          units = normalizeUnits(units);

          if (isFunction(this[units])) {
            return this[units]();
          }

          return this;
        }

        function stringSet(units, value) {
          if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);

            for (var i = 0; i < prioritized.length; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);

            if (isFunction(this[units])) {
              return this[units](value);
            }
          }

          return this;
        }

        function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }

        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
        var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
        var formatFunctions = {};
        var formatTokenFunctions = {}; // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }

        function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;

          if (typeof callback === 'string') {
            func = function func() {
              return this[callback]();
            };
          }

          if (token) {
            formatTokenFunctions[token] = func;
          }

          if (padded) {
            formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }

          if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(func.apply(this, arguments), token);
            };
          }
        }

        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
          }

          return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
              i,
              length;

          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }

          return function (mom) {
            var output = '',
                i;

            for (i = 0; i < length; i++) {
              output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }

            return output;
          };
        } // format date using native date object


        function formatMoment(m, format) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
          return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;

          while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }

          return format;
        }

        var match1 = /\d/; //       0 - 9

        var match2 = /\d\d/; //      00 - 99

        var match3 = /\d{3}/; //     000 - 999

        var match4 = /\d{4}/; //    0000 - 9999

        var match6 = /[+-]?\d{6}/; // -999999 - 999999

        var match1to2 = /\d\d?/; //       0 - 99

        var match3to4 = /\d\d\d\d?/; //     999 - 9999

        var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

        var match1to3 = /\d{1,3}/; //       0 - 999

        var match1to4 = /\d{1,4}/; //       0 - 9999

        var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

        var matchUnsigned = /\d+/; //       0 - inf

        var matchSigned = /[+-]?\d+/; //    -inf - inf

        var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

        var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

        var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months

        var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
        var regexes = {};

        function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }

        function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
        } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


        function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }

        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
          var i,
              func = callback;

          if (typeof token === 'string') {
            token = [token];
          }

          if (isNumber(callback)) {
            func = function func(input, array) {
              array[callback] = toInt(input);
            };
          }

          for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
          }
        }

        function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
          });
        }

        function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
          }
        }

        var YEAR = 0;
        var MONTH = 1;
        var DATE = 2;
        var HOUR = 3;
        var MINUTE = 4;
        var SECOND = 5;
        var MILLISECOND = 6;
        var WEEK = 7;
        var WEEKDAY = 8;
        var indexOf;

        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function indexOf(o) {
            // I know
            var i;

            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }

            return -1;
          };
        }

        var indexOf$1 = indexOf;

        function daysInMonth(year, month) {
          return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
        } // FORMATTING


        addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
        });
        addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
        });
        addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
        }); // ALIASES

        addUnitAlias('month', 'M'); // PRIORITY

        addUnitPriority('month', 8); // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
        });
        addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        }); // LOCALES

        var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

        function localeMonths(m, format) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months['standalone'];
          }

          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
        }

        var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

        function localeMonthsShort(m, format) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
          }

          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
          var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();

          if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];

            for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
          }

          if (strict) {
            if (format === 'MMM') {
              ii = indexOf$1.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf$1.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'MMM') {
              ii = indexOf$1.call(this._shortMonthsParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf$1.call(this._longMonthsParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }

        function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          } // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse


          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);

            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
              this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }

            if (!strict && !this._monthsParse[i]) {
              regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            } // test the regex


            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        } // MOMENTS


        function setMonth(mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
            // No op
            return mom;
          }

          if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

              if (!isNumber(value)) {
                return mom;
              }
            }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

          return mom;
        }

        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, 'Month');
          }
        }

        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }

        var defaultMonthsShortRegex = matchWord;

        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }

            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }

            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }

        var defaultMonthsRegex = matchWord;

        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }

            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
            }

            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }

        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }

          var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;

          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
          } // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.


          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);

          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }

          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        } // FORMATTING


        addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? '' + y : '+' + y;
        });
        addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
        });
        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

        addUnitAlias('year', 'y'); // PRIORITIES

        addUnitPriority('year', 1); // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);
        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
        }); // HELPERS

        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }

        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        } // HOOKS


        hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        }; // MOMENTS


        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
          return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date = new Date(y, m, d, h, M, s, ms); // the date constructor remaps years 0-99 to 1900-1999

          if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }

          return date;
        }

        function createUTCDate(y) {
          var date = new Date(Date.UTC.apply(null, arguments)); // the Date.UTC function remaps years 0-99 to 1900-1999

          if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }

          return date;
        } // start-of-first-week - start-of-year


        function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
          fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
          fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }

          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }

        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }

          return {
            week: resWeek,
            year: resYear
          };
        }

        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        } // FORMATTING


        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W'); // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5); // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);
        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
        }); // HELPERS
        // LOCALES

        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 1st is the first week of the year.

        };

        function localeFirstDayOfWeek() {
          return this._week.dow;
        }

        function localeFirstDayOfYear() {
          return this._week.doy;
        } // MOMENTS


        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
        } // FORMATTING


        addFormatToken('d', 0, 'do', 'day');
        addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
        });
        addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
        });
        addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
        });
        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E'); // PRIORITY

        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11); // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
        });
        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
        }); // HELPERS

        function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
            return input;
          }

          if (!isNaN(input)) {
            return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);

          if (typeof input === 'number') {
            return input;
          }

          return null;
        }

        function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
          }

          return isNaN(input) ? null : input;
        } // LOCALES


        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

        function localeWeekdays(m, format) {
          if (!m) {
            return isArray(this._weekdays) ? this._weekdays : this._weekdays['standalone'];
          }

          return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
        }

        var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

        function localeWeekdaysShort(m) {
          return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }

        var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

        function localeWeekdaysMin(m) {
          return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
          var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();

          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
          }

          if (strict) {
            if (format === 'dddd') {
              ii = indexOf$1.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf$1.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf$1.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'dddd') {
              ii = indexOf$1.call(this._weekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._shortWeekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf$1.call(this._shortWeekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._weekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf$1.call(this._minWeekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._weekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf$1.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);

            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
              this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
              this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }

            if (!this._weekdaysParse[i]) {
              regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            } // test the regex


            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        } // MOMENTS


        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
          } else {
            return day;
          }
        }

        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          } // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.


          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }

        var defaultWeekdaysRegex = matchWord;

        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }

            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }

            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }

        var defaultWeekdaysShortRegex = matchWord;

        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }

            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }

            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }

        var defaultWeekdaysMinRegex = matchWord;

        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }

            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }

            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }

        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }

          var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;

          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.


          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);

          for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
        } // FORMATTING


        function hFormat() {
          return this.hours() % 12 || 12;
        }

        function kFormat() {
          return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);
        addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });

        function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }

        meridiem('a', true);
        meridiem('A', false); // ALIASES

        addUnitAlias('hour', 'h'); // PRIORITY

        addUnitPriority('hour', 13); // PARSING

        function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);
        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);
        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        }); // LOCALES

        function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

        function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'pm' : 'PM';
          } else {
            return isLower ? 'am' : 'AM';
          }
        } // MOMENTS
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour he wants. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.


        var getSetHour = makeGetSet('Hours', true); // months
        // week
        // weekdays
        // meridiem

        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        }; // internal storage for locale config files

        var locales = {};
        var localeFamilies = {};
        var globalLocale;

        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
        } // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


        function chooseLocale(names) {
          var i = 0,
              j,
              next,
              locale,
              split;

          while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;

            while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));

              if (locale) {
                return locale;
              }

              if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
              }

              j--;
            }

            i++;
          }

          return null;
        }

        function loadLocale(name) {
          var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

          if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
            try {
              oldLocale = globalLocale._abbr;

              __webpack_require__("./node_modules/chart.js/node_modules/moment/locale sync recursive ^\\.\\/.*$")("./" + name); // because defineLocale currently also sets the global locale, we
              // want to undo that for lazy loaded locales


              getSetGlobalLocale(oldLocale);
            } catch (e) {}
          }

          return locales[name];
        } // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.


        function getSetGlobalLocale(key, values) {
          var data;

          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }

            if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
            }
          }

          return globalLocale._abbr;
        }

        function defineLocale(name, config) {
          if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;

            if (locales[name] != null) {
              deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }

                localeFamilies[config.parentLocale].push({
                  name: name,
                  config: config
                });
                return null;
              }
            }

            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
              });
            } // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.


            getSetGlobalLocale(name);
            return locales[name];
          } else {
            // useful for testing
            delete locales[name];
            return null;
          }
        }

        function updateLocale(name, config) {
          if (config != null) {
            var locale,
                parentConfig = baseConfig; // MERGE

            if (locales[name] != null) {
              parentConfig = locales[name]._config;
            }

            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale; // backwards compat for now: also set the locale

            getSetGlobalLocale(name);
          } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }

          return locales[name];
        } // returns locale data


        function getLocale(key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }

          if (!key) {
            return globalLocale;
          }

          if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);

            if (locale) {
              return locale;
            }

            key = [key];
          }

          return chooseLocale(key);
        }

        function listLocales() {
          return keys$1(locales);
        }

        function checkOverflow(m) {
          var overflow;
          var a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }

            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }

            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
          }

          return m;
        } // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
        var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
        var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
        var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

        var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
        var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

        function configFromISO(config) {
          var i,
              l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat;

          if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }

            if (dateFormat == null) {
              config._isValid = false;
              return;
            }

            if (match[3]) {
              for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  // match[2] should be 'T' or space
                  timeFormat = (match[2] || ' ') + isoTimes[i][0];
                  break;
                }
              }

              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }

            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }

            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
              } else {
                config._isValid = false;
                return;
              }
            }

            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


        var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/; // date and time from ref 2822 format

        function configFromRFC2822(config) {
          var string, match, dayFormat, dateFormat, timeFormat, tzFormat;
          var timezones = {
            ' GMT': ' +0000',
            ' EDT': ' -0400',
            ' EST': ' -0500',
            ' CDT': ' -0500',
            ' CST': ' -0600',
            ' MDT': ' -0600',
            ' MST': ' -0700',
            ' PDT': ' -0700',
            ' PST': ' -0800'
          };
          var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
          var timezone, timezoneIndex;
          string = config._i.replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
          .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
          .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces

          match = basicRfcRegex.exec(string);

          if (match) {
            dayFormat = match[1] ? 'ddd' + (match[1].length === 5 ? ', ' : ' ') : '';
            dateFormat = 'D MMM ' + (match[2].length > 10 ? 'YYYY ' : 'YY ');
            timeFormat = 'HH:mm' + (match[4] ? ':ss' : ''); // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.

            if (match[1]) {
              // day of week given
              var momentDate = new Date(match[2]);
              var momentDay = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][momentDate.getDay()];

              if (match[1].substr(0, 3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
              }
            }

            switch (match[5].length) {
              case 2:
                // military
                if (timezoneIndex === 0) {
                  timezone = ' +0000';
                } else {
                  timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                  timezone = (timezoneIndex < 0 ? ' -' : ' +') + ('' + timezoneIndex).replace(/^-?/, '0').match(/..$/)[0] + '00';
                }

                break;

              case 4:
                // Zone
                timezone = timezones[match[5]];
                break;

              default:
                // UT or +/-9999
                timezone = timezones[' GMT'];
            }

            match[5] = timezone;
            config._i = match.splice(1).join('');
            tzFormat = ' ZZ';
            config._f = dayFormat + dateFormat + timeFormat + tzFormat;
            configFromStringAndFormat(config);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        } // date from iso format or fallback


        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);

          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }

          configFromISO(config);

          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }

          configFromRFC2822(config);

          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          } // Final attempt, use Input Fallback


          hooks.createFromInputFallback(config);
        }

        hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }); // Pick the first defined of two or three arguments.

        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }

          if (b != null) {
            return b;
          }

          return c;
        }

        function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());

          if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }

          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        } // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]


        function configFromArray(config) {
          var i,
              date,
              input = [],
              currentDate,
              yearToUse;

          if (config._d) {
            return;
          }

          currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          } //if the day of the year is set, figure out what it is


          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          } // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything


          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          } // Zero out whatever was not defaulted, including time


          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          } // Check for 24:00:00.000


          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input); // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.

          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
        }

        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
          w = config._w;

          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).

            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);

            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            var curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;

              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              // local weekday -- counting starts from begining of week
              weekday = w.e + dow;

              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              // default to begining of week
              weekday = dow;
            }
          }

          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        } // constant that refers to the ISO standard


        hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


        hooks.RFC_2822 = function () {}; // date from string and format string


        function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }

          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }

          config._a = [];
          getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

          var string = '' + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0;
          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));

            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));

              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }

              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            } // don't parse if it's not a known token


            if (formatTokenFunctions[token]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token);
              }

              addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
            }
          } // add remaining unparsed input length to the string


          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          } // clear _12h flag if hour is <= 12


          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
          configFromArray(config);
          checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
            // nothing to do
            return hour;
          }

          if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);

            if (isPm && hour < 12) {
              hour += 12;
            }

            if (!isPm && hour === 12) {
              hour = 0;
            }

            return hour;
          } else {
            // this is not supposed to happen
            return hour;
          }
        } // date from string and array of format strings


        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore;

          if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }

          for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);

            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }

            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
              continue;
            } // if there is any input that was not parsed add a penalty for that format


            currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }

          extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
          if (config._d) {
            return;
          }

          var i = normalizeObjectUnits(config._i);
          config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }

        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));

          if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
          }

          return res;
        }

        function prepareConfig(config) {
          var input = config._i,
              format = config._f;
          config._locale = config._locale || getLocale(config._l);

          if (input === null || format === undefined && input === '') {
            return createInvalid({
              nullInput: true
            });
          }

          if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format)) {
            configFromStringAndArray(config);
          } else if (format) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }

          if (!isValid(config)) {
            config._d = null;
          }

          return config;
        }

        function configFromInput(config) {
          var input = config._i;

          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};

          if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
          }

          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
          } // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423


          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;
          return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
          var other = createLocal.apply(null, arguments);

          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        });
        var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
          var other = createLocal.apply(null, arguments);

          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }); // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.

        function pickBy(fn, moments) {
          var res, i;

          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }

          if (!moments.length) {
            return createLocal();
          }

          res = moments[0];

          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }

          return res;
        } // TODO: Use [].sort instead?


        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isBefore', args);
        }

        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isAfter', args);
        }

        var now = function now() {
          return Date.now ? Date.now() : +new Date();
        };

        var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

        function isDurationValid(m) {
          for (var key in m) {
            if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }

          var unitHasDecimal = false;

          for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
              }

              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }

          return true;
        }

        function isValid$1() {
          return this._isValid;
        }

        function createInvalid$1() {
          return createDuration(NaN);
        }

        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

          this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
          minutes * 6e4 + // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately

          this._days = +days + weeks * 7; // It is impossible translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.

          this._months = +months + quarters * 3 + years * 12;
          this._data = {};
          this._locale = getLocale();

          this._bubble();
        }

        function isDuration(obj) {
          return obj instanceof Duration;
        }

        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        } // FORMATTING


        function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';

            if (offset < 0) {
              offset = -offset;
              sign = '-';
            }

            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
          });
        }

        offset('Z', ':');
        offset('ZZ', ''); // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        }); // HELPERS
        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']

        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher);

          if (matches === null) {
            return null;
          }

          var chunk = matches[matches.length - 1] || [];
          var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          var minutes = +(parts[1] * 60) + toInt(parts[2]);
          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        } // Return a moment from input, that is local/utc/zone equivalent to model.


        function cloneWithOffset(input, model) {
          var res, diff;

          if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

            res._d.setTime(res._d.valueOf() + diff);

            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }

        function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
        } // HOOKS
        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.


        hooks.updateOffset = function () {}; // MOMENTS
        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.


        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;

          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          if (input != null) {
            if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);

              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }

            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }

            this._offset = input;
            this._isUTC = true;

            if (localAdjust != null) {
              this.add(localAdjust, 'm');
            }

            if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }

            return this;
          } else {
            return this._isUTC ? offset : getDateOffset(this);
          }
        }

        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== 'string') {
              input = -input;
            }

            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }

        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
            }
          }

          return this;
        }

        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);

            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }

          return this;
        }

        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }

          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }

        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }

          var c = {};
          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }

          return this._isDSTShifted;
        }

        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        } // ASP.NET json date format regex


        var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day

        var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
          match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input)) {
            duration = {};

            if (key) {
              duration[key] = input;
            } else {
              duration.milliseconds = input;
            }
          } else if (!!(match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign,
              h: toInt(match[HOUR]) * sign,
              m: toInt(match[MINUTE]) * sign,
              s: toInt(match[SECOND]) * sign,
              ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

            };
          } else if (!!(match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign)
            };
          } else if (duration == null) {
            // checks for null or undefined
            duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
          }

          return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

          return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
          var res = {
            milliseconds: 0,
            months: 0
          };
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

          if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
          }

          res.milliseconds = +other - +base.clone().add(res.months, 'M');
          return res;
        }

        function momentsDifference(base, other) {
          var res;

          if (!(base.isValid() && other.isValid())) {
            return {
              milliseconds: 0,
              months: 0
            };
          }

          other = cloneWithOffset(other, base);

          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }

          return res;
        } // TODO: remove 'name' arg after deprecation is removed


        function createAdder(direction, name) {
          return function (val, period) {
            var dur, tmp; //invert the arguments, but complain about it

            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
              tmp = val;
              val = period;
              period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
            // No op
            return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }

          if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }

          if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
          }

          if (updateOffset) {
            hooks.updateOffset(mom, days || months);
          }
        }

        var add = createAdder(1, 'add');
        var subtract = createAdder(-1, 'subtract');

        function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        }

        function calendar$1(time, formats) {
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse';
          var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
        }

        function clone() {
          return new Moment(this);
        }

        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);

          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }

          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');

          if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }

        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);

          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }

          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');

          if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }

        function isBetween(from, to, units, inclusivity) {
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
        }

        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;

          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }

          units = normalizeUnits(units || 'millisecond');

          if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }

        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
          var that, zoneDelta, delta, output;

          if (!this.isValid()) {
            return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
            return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);

          if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);

            if (units === 'quarter') {
              output = output / 3;
            } else if (units === 'year') {
              output = output / 12;
            }
          } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
          }

          return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
          anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2,
              adjust;

          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

            adjust = (b - anchor) / (anchor2 - anchor);
          } //check for negative zero, return zero if negative zero


          return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString() {
          if (!this.isValid()) {
            return null;
          }

          var m = this.clone().utc();

          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
          }

          if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString();
          }

          return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */


        function inspect() {
          if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
          }

          var func = 'moment';
          var zone = '';

          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
          }

          var prefix = '[' + func + '("]';
          var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          var datetime = '-MM-DD[T]HH:mm:ss.SSS';
          var suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }

          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              to: this,
              from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }

        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              from: this,
              to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }

        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        } // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.


        function locale(key) {
          var newLocaleData;

          if (key === undefined) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);

            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }

            return this;
          }
        }

        var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
          if (key === undefined) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });

        function localeData() {
          return this._locale;
        }

        function startOf(units) {
          units = normalizeUnits(units); // the following switch intentionally omits break keywords
          // to utilize falling through the cases.

          switch (units) {
            case 'year':
              this.month(0);

            /* falls through */

            case 'quarter':
            case 'month':
              this.date(1);

            /* falls through */

            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
              this.hours(0);

            /* falls through */

            case 'hour':
              this.minutes(0);

            /* falls through */

            case 'minute':
              this.seconds(0);

            /* falls through */

            case 'second':
              this.milliseconds(0);
          } // weeks are a special case


          if (units === 'week') {
            this.weekday(0);
          }

          if (units === 'isoWeek') {
            this.isoWeekday(1);
          } // quarters are also special


          if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
          }

          return this;
        }

        function endOf(units) {
          units = normalizeUnits(units);

          if (units === undefined || units === 'millisecond') {
            return this;
          } // 'date' is an alias for 'day', so it should be considered as such.


          if (units === 'date') {
            units = 'day';
          }

          return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');
        }

        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
          return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
          return new Date(this.valueOf());
        }

        function toArray() {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }

        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }

        function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
          return isValid(this);
        }

        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
          return getParsingFlags(this).overflow;
        }

        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        } // FORMATTING


        addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1); // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);
        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
        }); // MOMENTS

        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }

        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }

        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }

        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;

          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;

          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);

            if (week > weeksTarget) {
              week = weeksTarget;
            }

            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        } // FORMATTING


        addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

        addUnitAlias('quarter', 'Q'); // PRIORITY

        addUnitPriority('quarter', 7); // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        }); // MOMENTS

        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        } // FORMATTING


        addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

        addUnitAlias('date', 'D'); // PRIOROITY

        addUnitPriority('date', 9); // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0], 10);
        }); // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

        addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

        addUnitPriority('dayOfYear', 4); // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
        }); // HELPERS
        // MOMENTS

        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        } // FORMATTING


        addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

        addUnitAlias('minute', 'm'); // PRIORITY

        addUnitPriority('minute', 14); // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE); // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

        addUnitAlias('second', 's'); // PRIORITY

        addUnitPriority('second', 15); // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND); // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

        addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
        }); // ALIASES

        addUnitAlias('millisecond', 'ms'); // PRIORITY

        addUnitPriority('millisecond', 16); // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);
        var token;

        for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
        } // MOMENTS


        var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

        function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData; // Year

        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear; // Week Year

        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear; // Quarter

        proto.quarter = proto.quarters = getSetQuarter; // Month

        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth; // Week

        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.isoWeeksInYear = getISOWeeksInYear; // Day

        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear; // Hour

        proto.hour = proto.hours = getSetHour; // Minute

        proto.minute = proto.minutes = getSetMinute; // Second

        proto.second = proto.seconds = getSetSecond; // Millisecond

        proto.millisecond = proto.milliseconds = getSetMillisecond; // Offset

        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc; // Timezone

        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName; // Deprecations

        proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
        proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
        proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
        proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
        proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

        function createUnix(input) {
          return createLocal(input * 1000);
        }

        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
          return string;
        }

        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set; // Month

        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex; // Week

        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek; // Day of Week

        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex; // Hours

        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
          var locale = getLocale();
          var utc = createUTC().set(setter, index);
          return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }

          format = format || '';

          if (index != null) {
            return get$1(format, index, field, 'month');
          }

          var i;
          var out = [];

          for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
          }

          return out;
        } // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)


        function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }

            format = format || '';
          } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
              index = format;
              format = undefined;
            }

            format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0;

          if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
          }

          var i;
          var out = [];

          for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }

          return out;
        }

        function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function ordinal(number) {
            var b = number % 10,
                output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
          }
        }); // Side effect imports

        hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
        hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
        var mathAbs = Math.abs;

        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }

        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        } // supports only 2.0-style add(1, 's') or add(duration)


        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        } // supports only 2.0-style subtract(1, 's') or subtract(duration)


        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }

        function bubble() {
          var milliseconds = this._milliseconds;
          var days = this._days;
          var months = this._months;
          var data = this._data;
          var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166

          if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
          } // The following code bubbles up values, see the tests for
          // examples of what that means.


          data.milliseconds = milliseconds % 1000;
          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;
          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;
          hours = absFloor(minutes / 60);
          data.hours = hours % 24;
          days += absFloor(hours / 24); // convert days to months

          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

          years = absFloor(months / 12);
          months %= 12;
          data.days = days;
          data.months = months;
          data.years = years;
          return this;
        }

        function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
        }

        function monthsToDays(months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
        }

        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }

          var days;
          var months;
          var milliseconds = this._milliseconds;
          units = normalizeUnits(units);

          if (units === 'month' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
          } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));

            switch (units) {
              case 'week':
                return days / 7 + milliseconds / 6048e5;

              case 'day':
                return days + milliseconds / 864e5;

              case 'hour':
                return days * 24 + milliseconds / 36e5;

              case 'minute':
                return days * 1440 + milliseconds / 6e4;

              case 'second':
                return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here

              case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;

              default:
                throw new Error('Unknown unit ' + units);
            }
          }
        } // TODO: Use this.as('ms')?


        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }

          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }

        function makeAs(alias) {
          return function () {
            return this.as(alias);
          };
        }

        var asMilliseconds = makeAs('ms');
        var asSeconds = makeAs('s');
        var asMinutes = makeAs('m');
        var asHours = makeAs('h');
        var asDays = makeAs('d');
        var asWeeks = makeAs('w');
        var asMonths = makeAs('M');
        var asYears = makeAs('y');

        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
          return function () {
            return this.isValid() ? this._data[name] : NaN;
          };
        }

        var milliseconds = makeGetter('milliseconds');
        var seconds = makeGetter('seconds');
        var minutes = makeGetter('minutes');
        var hours = makeGetter('hours');
        var days = makeGetter('days');
        var months = makeGetter('months');
        var years = makeGetter('years');

        function weeks() {
          return absFloor(this.days() / 7);
        }

        var round = Math.round;
        var thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month
          M: 11 // months to year

        }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, locale) {
          var duration = createDuration(posNegDuration).abs();
          var seconds = round(duration.as('s'));
          var minutes = round(duration.as('m'));
          var hours = round(duration.as('h'));
          var days = round(duration.as('d'));
          var months = round(duration.as('M'));
          var years = round(duration.as('y'));
          var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
        } // This function allows you to set the rounding function for relative time strings


        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
            return round;
          }

          if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
          }

          return false;
        } // This function allows you to set a threshold for relative time strings


        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
            return false;
          }

          if (limit === undefined) {
            return thresholds[threshold];
          }

          thresholds[threshold] = limit;

          if (threshold === 's') {
            thresholds.ss = limit - 1;
          }

          return true;
        }

        function humanize(withSuffix) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }

          var locale = this.localeData();
          var output = relativeTime$1(this, !withSuffix, locale);

          if (withSuffix) {
            output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000;
          var days = abs$1(this._days);
          var months = abs$1(this._months);
          var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60; // 12 months -> 1 year

          years = absFloor(months / 12);
          months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

          var Y = years;
          var M = months;
          var D = days;
          var h = hours;
          var m = minutes;
          var s = seconds;
          var total = this.asSeconds();

          if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
          }

          return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
        }

        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData; // Deprecations

        proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
        proto$2.lang = lang; // Side effect imports
        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf'); // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input, 10) * 1000);
        });
        addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
        }); // Side effect imports

        hooks.version = '2.18.1';
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        return hooks;
      });
      /* WEBPACK VAR INJECTION */

    }).call(this, __webpack_require__(
    /*! ./../../../webpack/buildin/module.js */
    "./node_modules/webpack/buildin/module.js")(module));
    /***/
  },

  /***/
  "./node_modules/chart.js/src/chart.js":
  /*!********************************************!*\
    !*** ./node_modules/chart.js/src/chart.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartJs(module, exports, __webpack_require__) {
    /**
     * @namespace Chart
     */
    var Chart = __webpack_require__(
    /*! ./core/core */
    "./node_modules/chart.js/src/core/core.js")();

    Chart.helpers = __webpack_require__(
    /*! ./helpers/index */
    "./node_modules/chart.js/src/helpers/index.js"); // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

    __webpack_require__(
    /*! ./core/core.helpers */
    "./node_modules/chart.js/src/core/core.helpers.js")(Chart);

    Chart.defaults = __webpack_require__(
    /*! ./core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");
    Chart.Element = __webpack_require__(
    /*! ./core/core.element */
    "./node_modules/chart.js/src/core/core.element.js");
    Chart.elements = __webpack_require__(
    /*! ./elements/index */
    "./node_modules/chart.js/src/elements/index.js");
    Chart.Interaction = __webpack_require__(
    /*! ./core/core.interaction */
    "./node_modules/chart.js/src/core/core.interaction.js");
    Chart.platform = __webpack_require__(
    /*! ./platforms/platform */
    "./node_modules/chart.js/src/platforms/platform.js");

    __webpack_require__(
    /*! ./core/core.plugin */
    "./node_modules/chart.js/src/core/core.plugin.js")(Chart);

    __webpack_require__(
    /*! ./core/core.animation */
    "./node_modules/chart.js/src/core/core.animation.js")(Chart);

    __webpack_require__(
    /*! ./core/core.controller */
    "./node_modules/chart.js/src/core/core.controller.js")(Chart);

    __webpack_require__(
    /*! ./core/core.datasetController */
    "./node_modules/chart.js/src/core/core.datasetController.js")(Chart);

    __webpack_require__(
    /*! ./core/core.layoutService */
    "./node_modules/chart.js/src/core/core.layoutService.js")(Chart);

    __webpack_require__(
    /*! ./core/core.scaleService */
    "./node_modules/chart.js/src/core/core.scaleService.js")(Chart);

    __webpack_require__(
    /*! ./core/core.scale */
    "./node_modules/chart.js/src/core/core.scale.js")(Chart);

    __webpack_require__(
    /*! ./core/core.tooltip */
    "./node_modules/chart.js/src/core/core.tooltip.js")(Chart);

    __webpack_require__(
    /*! ./scales/scale.linearbase */
    "./node_modules/chart.js/src/scales/scale.linearbase.js")(Chart);

    __webpack_require__(
    /*! ./scales/scale.category */
    "./node_modules/chart.js/src/scales/scale.category.js")(Chart);

    __webpack_require__(
    /*! ./scales/scale.linear */
    "./node_modules/chart.js/src/scales/scale.linear.js")(Chart);

    __webpack_require__(
    /*! ./scales/scale.logarithmic */
    "./node_modules/chart.js/src/scales/scale.logarithmic.js")(Chart);

    __webpack_require__(
    /*! ./scales/scale.radialLinear */
    "./node_modules/chart.js/src/scales/scale.radialLinear.js")(Chart);

    __webpack_require__(
    /*! ./scales/scale.time */
    "./node_modules/chart.js/src/scales/scale.time.js")(Chart); // Controllers must be loaded after elements
    // See Chart.core.datasetController.dataElementType


    __webpack_require__(
    /*! ./controllers/controller.bar */
    "./node_modules/chart.js/src/controllers/controller.bar.js")(Chart);

    __webpack_require__(
    /*! ./controllers/controller.bubble */
    "./node_modules/chart.js/src/controllers/controller.bubble.js")(Chart);

    __webpack_require__(
    /*! ./controllers/controller.doughnut */
    "./node_modules/chart.js/src/controllers/controller.doughnut.js")(Chart);

    __webpack_require__(
    /*! ./controllers/controller.line */
    "./node_modules/chart.js/src/controllers/controller.line.js")(Chart);

    __webpack_require__(
    /*! ./controllers/controller.polarArea */
    "./node_modules/chart.js/src/controllers/controller.polarArea.js")(Chart);

    __webpack_require__(
    /*! ./controllers/controller.radar */
    "./node_modules/chart.js/src/controllers/controller.radar.js")(Chart);

    __webpack_require__(
    /*! ./controllers/controller.scatter */
    "./node_modules/chart.js/src/controllers/controller.scatter.js")(Chart);

    __webpack_require__(
    /*! ./charts/Chart.Bar */
    "./node_modules/chart.js/src/charts/Chart.Bar.js")(Chart);

    __webpack_require__(
    /*! ./charts/Chart.Bubble */
    "./node_modules/chart.js/src/charts/Chart.Bubble.js")(Chart);

    __webpack_require__(
    /*! ./charts/Chart.Doughnut */
    "./node_modules/chart.js/src/charts/Chart.Doughnut.js")(Chart);

    __webpack_require__(
    /*! ./charts/Chart.Line */
    "./node_modules/chart.js/src/charts/Chart.Line.js")(Chart);

    __webpack_require__(
    /*! ./charts/Chart.PolarArea */
    "./node_modules/chart.js/src/charts/Chart.PolarArea.js")(Chart);

    __webpack_require__(
    /*! ./charts/Chart.Radar */
    "./node_modules/chart.js/src/charts/Chart.Radar.js")(Chart);

    __webpack_require__(
    /*! ./charts/Chart.Scatter */
    "./node_modules/chart.js/src/charts/Chart.Scatter.js")(Chart); // Loading built-it plugins


    var plugins = [];
    plugins.push(__webpack_require__(
    /*! ./plugins/plugin.filler */
    "./node_modules/chart.js/src/plugins/plugin.filler.js")(Chart), __webpack_require__(
    /*! ./plugins/plugin.legend */
    "./node_modules/chart.js/src/plugins/plugin.legend.js")(Chart), __webpack_require__(
    /*! ./plugins/plugin.title */
    "./node_modules/chart.js/src/plugins/plugin.title.js")(Chart));
    Chart.plugins.register(plugins);
    Chart.platform.initialize();
    module.exports = Chart;

    if (typeof window !== 'undefined') {
      window.Chart = Chart;
    } // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas instead.
     * @namespace Chart.canvasHelpers
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */


    Chart.canvasHelpers = Chart.helpers.canvas;
    /***/
  },

  /***/
  "./node_modules/chart.js/src/charts/Chart.Bar.js":
  /*!*******************************************************!*\
    !*** ./node_modules/chart.js/src/charts/Chart.Bar.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartsChartBarJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      Chart.Bar = function (context, config) {
        config.type = 'bar';
        return new Chart(context, config);
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/charts/Chart.Bubble.js":
  /*!**********************************************************!*\
    !*** ./node_modules/chart.js/src/charts/Chart.Bubble.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartsChartBubbleJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      Chart.Bubble = function (context, config) {
        config.type = 'bubble';
        return new Chart(context, config);
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/charts/Chart.Doughnut.js":
  /*!************************************************************!*\
    !*** ./node_modules/chart.js/src/charts/Chart.Doughnut.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartsChartDoughnutJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      Chart.Doughnut = function (context, config) {
        config.type = 'doughnut';
        return new Chart(context, config);
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/charts/Chart.Line.js":
  /*!********************************************************!*\
    !*** ./node_modules/chart.js/src/charts/Chart.Line.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartsChartLineJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      Chart.Line = function (context, config) {
        config.type = 'line';
        return new Chart(context, config);
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/charts/Chart.PolarArea.js":
  /*!*************************************************************!*\
    !*** ./node_modules/chart.js/src/charts/Chart.PolarArea.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartsChartPolarAreaJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      Chart.PolarArea = function (context, config) {
        config.type = 'polarArea';
        return new Chart(context, config);
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/charts/Chart.Radar.js":
  /*!*********************************************************!*\
    !*** ./node_modules/chart.js/src/charts/Chart.Radar.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartsChartRadarJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      Chart.Radar = function (context, config) {
        config.type = 'radar';
        return new Chart(context, config);
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/charts/Chart.Scatter.js":
  /*!***********************************************************!*\
    !*** ./node_modules/chart.js/src/charts/Chart.Scatter.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcChartsChartScatterJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      Chart.Scatter = function (context, config) {
        config.type = 'scatter';
        return new Chart(context, config);
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/controllers/controller.bar.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/chart.js/src/controllers/controller.bar.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcControllersControllerBarJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var elements = __webpack_require__(
    /*! ../elements/index */
    "./node_modules/chart.js/src/elements/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('bar', {
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          // Specific to Bar Controller
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          // offset settings
          offset: true,
          // grid line settings
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: 'linear'
        }]
      }
    });

    defaults._set('horizontalBar', {
      hover: {
        mode: 'index',
        axis: 'y'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          position: 'bottom'
        }],
        yAxes: [{
          position: 'left',
          type: 'category',
          // Specific to Horizontal Bar Controller
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          // offset settings
          offset: true,
          // grid line settings
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: 'left'
        }
      },
      tooltips: {
        callbacks: {
          title: function title(item, data) {
            // Pick first xLabel for now
            var title = '';

            if (item.length > 0) {
              if (item[0].yLabel) {
                title = item[0].yLabel;
              } else if (data.labels.length > 0 && item[0].index < data.labels.length) {
                title = data.labels[item[0].index];
              }
            }

            return title;
          },
          label: function label(item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            return datasetLabel + ': ' + item.xLabel;
          }
        },
        mode: 'index',
        axis: 'y'
      }
    });

    module.exports = function (Chart) {
      Chart.controllers.bar = Chart.DatasetController.extend({
        dataElementType: elements.Rectangle,
        initialize: function initialize() {
          var me = this;
          var meta;
          Chart.DatasetController.prototype.initialize.apply(me, arguments);
          meta = me.getMeta();
          meta.stack = me.getDataset().stack;
          meta.bar = true;
        },
        update: function update(reset) {
          var me = this;
          var rects = me.getMeta().data;
          var i, ilen;
          me._ruler = me.getRuler();

          for (i = 0, ilen = rects.length; i < ilen; ++i) {
            me.updateElement(rects[i], i, reset);
          }
        },
        updateElement: function updateElement(rectangle, index, reset) {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var dataset = me.getDataset();
          var custom = rectangle.custom || {};
          var rectangleOptions = chart.options.elements.rectangle;
          rectangle._xScale = me.getScaleForId(meta.xAxisID);
          rectangle._yScale = me.getScaleForId(meta.yAxisID);
          rectangle._datasetIndex = me.index;
          rectangle._index = index;
          rectangle._model = {
            datasetLabel: dataset.label,
            label: chart.data.labels[index],
            borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
            backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
            borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
            borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
          };
          me.updateElementGeometry(rectangle, index, reset);
          rectangle.pivot();
        },

        /**
         * @private
         */
        updateElementGeometry: function updateElementGeometry(rectangle, index, reset) {
          var me = this;
          var model = rectangle._model;
          var vscale = me.getValueScale();
          var base = vscale.getBasePixel();
          var horizontal = vscale.isHorizontal();
          var ruler = me._ruler || me.getRuler();
          var vpixels = me.calculateBarValuePixels(me.index, index);
          var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
          model.horizontal = horizontal;
          model.base = reset ? base : vpixels.base;
          model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
          model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
          model.height = horizontal ? ipixels.size : undefined;
          model.width = horizontal ? undefined : ipixels.size;
        },

        /**
         * @private
         */
        getValueScaleId: function getValueScaleId() {
          return this.getMeta().yAxisID;
        },

        /**
         * @private
         */
        getIndexScaleId: function getIndexScaleId() {
          return this.getMeta().xAxisID;
        },

        /**
         * @private
         */
        getValueScale: function getValueScale() {
          return this.getScaleForId(this.getValueScaleId());
        },

        /**
         * @private
         */
        getIndexScale: function getIndexScale() {
          return this.getScaleForId(this.getIndexScaleId());
        },

        /**
         * Returns the effective number of stacks based on groups and bar visibility.
         * @private
         */
        getStackCount: function getStackCount(last) {
          var me = this;
          var chart = me.chart;
          var scale = me.getIndexScale();
          var stacked = scale.options.stacked;
          var ilen = last === undefined ? chart.data.datasets.length : last + 1;
          var stacks = [];
          var i, meta;

          for (i = 0; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);

            if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
              stacks.push(meta.stack);
            }
          }

          return stacks.length;
        },

        /**
         * Returns the stack index for the given dataset based on groups and bar visibility.
         * @private
         */
        getStackIndex: function getStackIndex(datasetIndex) {
          return this.getStackCount(datasetIndex) - 1;
        },

        /**
         * @private
         */
        getRuler: function getRuler() {
          var me = this;
          var scale = me.getIndexScale();
          var stackCount = me.getStackCount();
          var datasetIndex = me.index;
          var pixels = [];
          var isHorizontal = scale.isHorizontal();
          var start = isHorizontal ? scale.left : scale.top;
          var end = start + (isHorizontal ? scale.width : scale.height);
          var i, ilen;

          for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
            pixels.push(scale.getPixelForValue(null, i, datasetIndex));
          }

          return {
            pixels: pixels,
            start: start,
            end: end,
            stackCount: stackCount,
            scale: scale
          };
        },

        /**
         * Note: pixel values are not clamped to the scale area.
         * @private
         */
        calculateBarValuePixels: function calculateBarValuePixels(datasetIndex, index) {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var scale = me.getValueScale();
          var datasets = chart.data.datasets;
          var value = scale.getRightValue(datasets[datasetIndex].data[index]);
          var stacked = scale.options.stacked;
          var stack = meta.stack;
          var start = 0;
          var i, imeta, ivalue, base, head, size;

          if (stacked || stacked === undefined && stack !== undefined) {
            for (i = 0; i < datasetIndex; ++i) {
              imeta = chart.getDatasetMeta(i);

              if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
                ivalue = scale.getRightValue(datasets[i].data[index]);

                if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                  start += ivalue;
                }
              }
            }
          }

          base = scale.getPixelForValue(start);
          head = scale.getPixelForValue(start + value);
          size = (head - base) / 2;
          return {
            size: size,
            base: base,
            head: head,
            center: head + size / 2
          };
        },

        /**
         * @private
         */
        calculateBarIndexPixels: function calculateBarIndexPixels(datasetIndex, index, ruler) {
          var me = this;
          var options = ruler.scale.options;
          var stackIndex = me.getStackIndex(datasetIndex);
          var pixels = ruler.pixels;
          var base = pixels[index];
          var length = pixels.length;
          var start = ruler.start;
          var end = ruler.end;
          var leftSampleSize, rightSampleSize, leftCategorySize, rightCategorySize, fullBarSize, size;

          if (length === 1) {
            leftSampleSize = base > start ? base - start : end - base;
            rightSampleSize = base < end ? end - base : base - start;
          } else {
            if (index > 0) {
              leftSampleSize = (base - pixels[index - 1]) / 2;

              if (index === length - 1) {
                rightSampleSize = leftSampleSize;
              }
            }

            if (index < length - 1) {
              rightSampleSize = (pixels[index + 1] - base) / 2;

              if (index === 0) {
                leftSampleSize = rightSampleSize;
              }
            }
          }

          leftCategorySize = leftSampleSize * options.categoryPercentage;
          rightCategorySize = rightSampleSize * options.categoryPercentage;
          fullBarSize = (leftCategorySize + rightCategorySize) / ruler.stackCount;
          size = fullBarSize * options.barPercentage;
          size = Math.min(helpers.valueOrDefault(options.barThickness, size), helpers.valueOrDefault(options.maxBarThickness, Infinity));
          base -= leftCategorySize;
          base += fullBarSize * stackIndex;
          base += (fullBarSize - size) / 2;
          return {
            size: size,
            base: base,
            head: base + size,
            center: base + size / 2
          };
        },
        draw: function draw() {
          var me = this;
          var chart = me.chart;
          var scale = me.getValueScale();
          var rects = me.getMeta().data;
          var dataset = me.getDataset();
          var ilen = rects.length;
          var i = 0;
          helpers.canvas.clipArea(chart.ctx, chart.chartArea);

          for (; i < ilen; ++i) {
            if (!isNaN(scale.getRightValue(dataset.data[i]))) {
              rects[i].draw();
            }
          }

          helpers.canvas.unclipArea(chart.ctx);
        },
        setHoverStyle: function setHoverStyle(rectangle) {
          var dataset = this.chart.data.datasets[rectangle._datasetIndex];
          var index = rectangle._index;
          var custom = rectangle.custom || {};
          var model = rectangle._model;
          model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
        },
        removeHoverStyle: function removeHoverStyle(rectangle) {
          var dataset = this.chart.data.datasets[rectangle._datasetIndex];
          var index = rectangle._index;
          var custom = rectangle.custom || {};
          var model = rectangle._model;
          var rectangleElementOptions = this.chart.options.elements.rectangle;
          model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
          model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
          model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
        }
      });
      Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
        /**
         * @private
         */
        getValueScaleId: function getValueScaleId() {
          return this.getMeta().xAxisID;
        },

        /**
         * @private
         */
        getIndexScaleId: function getIndexScaleId() {
          return this.getMeta().yAxisID;
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/controllers/controller.bubble.js":
  /*!********************************************************************!*\
    !*** ./node_modules/chart.js/src/controllers/controller.bubble.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcControllersControllerBubbleJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var elements = __webpack_require__(
    /*! ../elements/index */
    "./node_modules/chart.js/src/elements/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('bubble', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          // bubble should probably use a linear scale by default
          position: 'bottom',
          id: 'x-axis-0' // need an ID so datasets can reference the scale

        }],
        yAxes: [{
          type: 'linear',
          position: 'left',
          id: 'y-axis-0'
        }]
      },
      tooltips: {
        callbacks: {
          title: function title() {
            // Title doesn't make sense for scatter since we format the data as a point
            return '';
          },
          label: function label(item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
          }
        }
      }
    });

    module.exports = function (Chart) {
      Chart.controllers.bubble = Chart.DatasetController.extend({
        /**
         * @protected
         */
        dataElementType: elements.Point,

        /**
         * @protected
         */
        update: function update(reset) {
          var me = this;
          var meta = me.getMeta();
          var points = meta.data; // Update Points

          helpers.each(points, function (point, index) {
            me.updateElement(point, index, reset);
          });
        },

        /**
         * @protected
         */
        updateElement: function updateElement(point, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var custom = point.custom || {};
          var xScale = me.getScaleForId(meta.xAxisID);
          var yScale = me.getScaleForId(meta.yAxisID);

          var options = me._resolveElementOptions(point, index);

          var data = me.getDataset().data[index];
          var dsIndex = me.index;
          var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
          var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
          point._xScale = xScale;
          point._yScale = yScale;
          point._options = options;
          point._datasetIndex = dsIndex;
          point._index = index;
          point._model = {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            hitRadius: options.hitRadius,
            pointStyle: options.pointStyle,
            radius: reset ? 0 : options.radius,
            skip: custom.skip || isNaN(x) || isNaN(y),
            x: x,
            y: y
          };
          point.pivot();
        },

        /**
         * @protected
         */
        setHoverStyle: function setHoverStyle(point) {
          var model = point._model;
          var options = point._options;
          model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
          model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
          model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
          model.radius = options.radius + options.hoverRadius;
        },

        /**
         * @protected
         */
        removeHoverStyle: function removeHoverStyle(point) {
          var model = point._model;
          var options = point._options;
          model.backgroundColor = options.backgroundColor;
          model.borderColor = options.borderColor;
          model.borderWidth = options.borderWidth;
          model.radius = options.radius;
        },

        /**
         * @private
         */
        _resolveElementOptions: function _resolveElementOptions(point, index) {
          var me = this;
          var chart = me.chart;
          var datasets = chart.data.datasets;
          var dataset = datasets[me.index];
          var custom = point.custom || {};
          var options = chart.options.elements.point;
          var resolve = helpers.options.resolve;
          var data = dataset.data[index];
          var values = {};
          var i, ilen, key; // Scriptable options

          var context = {
            chart: chart,
            dataIndex: index,
            dataset: dataset,
            datasetIndex: me.index
          };
          var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle'];

          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve([custom[key], dataset[key], options[key]], context, index);
          } // Custom radius resolution


          values.radius = resolve([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
          return values;
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/controllers/controller.doughnut.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/chart.js/src/controllers/controller.doughnut.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcControllersControllerDoughnutJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var elements = __webpack_require__(
    /*! ../elements/index */
    "./node_modules/chart.js/src/elements/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('doughnut', {
      animation: {
        // Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,
        // Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false
      },
      hover: {
        mode: 'single'
      },
      legendCallback: function legendCallback(chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function generateLabels(chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc && arc.custom || {};
                var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
                var arcOpts = chart.options.elements.arc;
                var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
                var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
                var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function onClick(e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }

          chart.update();
        }
      },
      // The percentage of the chart that we cut out of the middle.
      cutoutPercentage: 50,
      // The rotation of the chart, where the first data arc begins.
      rotation: Math.PI * -0.5,
      // The total circumference of the chart.
      circumference: Math.PI * 2.0,
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function title() {
            return '';
          },
          label: function label(tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

            if (helpers.isArray(dataLabel)) {
              // show value on first line of multiline label
              // need to clone because we are changing the value
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }

            return dataLabel;
          }
        }
      }
    });

    defaults._set('pie', helpers.clone(defaults.doughnut));

    defaults._set('pie', {
      cutoutPercentage: 0
    });

    module.exports = function (Chart) {
      Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
        dataElementType: elements.Arc,
        linkScales: helpers.noop,
        // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
        getRingIndex: function getRingIndex(datasetIndex) {
          var ringIndex = 0;

          for (var j = 0; j < datasetIndex; ++j) {
            if (this.chart.isDatasetVisible(j)) {
              ++ringIndex;
            }
          }

          return ringIndex;
        },
        update: function update(reset) {
          var me = this;
          var chart = me.chart;
          var chartArea = chart.chartArea;
          var opts = chart.options;
          var arcOpts = opts.elements.arc;
          var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
          var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
          var minSize = Math.min(availableWidth, availableHeight);
          var offset = {
            x: 0,
            y: 0
          };
          var meta = me.getMeta();
          var cutoutPercentage = opts.cutoutPercentage;
          var circumference = opts.circumference; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

          if (circumference < Math.PI * 2.0) {
            var startAngle = opts.rotation % (Math.PI * 2.0);
            startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
            var endAngle = startAngle + circumference;
            var start = {
              x: Math.cos(startAngle),
              y: Math.sin(startAngle)
            };
            var end = {
              x: Math.cos(endAngle),
              y: Math.sin(endAngle)
            };
            var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
            var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
            var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
            var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
            var cutout = cutoutPercentage / 100.0;
            var min = {
              x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
              y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
            };
            var max = {
              x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
              y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
            };
            var size = {
              width: (max.x - min.x) * 0.5,
              height: (max.y - min.y) * 0.5
            };
            minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
            offset = {
              x: (max.x + min.x) * -0.5,
              y: (max.y + min.y) * -0.5
            };
          }

          chart.borderWidth = me.getMaxBorderWidth(meta.data);
          chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
          chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
          chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
          chart.offsetX = offset.x * chart.outerRadius;
          chart.offsetY = offset.y * chart.outerRadius;
          meta.total = me.calculateTotal();
          me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
          me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
          helpers.each(meta.data, function (arc, index) {
            me.updateElement(arc, index, reset);
          });
        },
        updateElement: function updateElement(arc, index, reset) {
          var me = this;
          var chart = me.chart;
          var chartArea = chart.chartArea;
          var opts = chart.options;
          var animationOpts = opts.animation;
          var centerX = (chartArea.left + chartArea.right) / 2;
          var centerY = (chartArea.top + chartArea.bottom) / 2;
          var startAngle = opts.rotation; // non reset case handled later

          var endAngle = opts.rotation; // non reset case handled later

          var dataset = me.getDataset();
          var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
          var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
          var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
          var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
          helpers.extend(arc, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            // Desired view properties
            _model: {
              x: centerX + chart.offsetX,
              y: centerY + chart.offsetY,
              startAngle: startAngle,
              endAngle: endAngle,
              circumference: circumference,
              outerRadius: outerRadius,
              innerRadius: innerRadius,
              label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
            }
          });
          var model = arc._model; // Resets the visual styles

          this.removeHoverStyle(arc); // Set correct angles if not resetting

          if (!reset || !animationOpts.animateRotate) {
            if (index === 0) {
              model.startAngle = opts.rotation;
            } else {
              model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
            }

            model.endAngle = model.startAngle + model.circumference;
          }

          arc.pivot();
        },
        removeHoverStyle: function removeHoverStyle(arc) {
          Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
        },
        calculateTotal: function calculateTotal() {
          var dataset = this.getDataset();
          var meta = this.getMeta();
          var total = 0;
          var value;
          helpers.each(meta.data, function (element, index) {
            value = dataset.data[index];

            if (!isNaN(value) && !element.hidden) {
              total += Math.abs(value);
            }
          });
          /* if (total === 0) {
          	total = NaN;
          }*/

          return total;
        },
        calculateCircumference: function calculateCircumference(value) {
          var total = this.getMeta().total;

          if (total > 0 && !isNaN(value)) {
            return Math.PI * 2.0 * (value / total);
          }

          return 0;
        },
        // gets the max border or hover width to properly scale pie charts
        getMaxBorderWidth: function getMaxBorderWidth(arcs) {
          var max = 0;
          var index = this.index;
          var length = arcs.length;
          var borderWidth;
          var hoverWidth;

          for (var i = 0; i < length; i++) {
            borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
            hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }

          return max;
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/controllers/controller.line.js":
  /*!******************************************************************!*\
    !*** ./node_modules/chart.js/src/controllers/controller.line.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcControllersControllerLineJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var elements = __webpack_require__(
    /*! ../elements/index */
    "./node_modules/chart.js/src/elements/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('line', {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          id: 'x-axis-0'
        }],
        yAxes: [{
          type: 'linear',
          id: 'y-axis-0'
        }]
      }
    });

    module.exports = function (Chart) {
      function lineEnabled(dataset, options) {
        return helpers.valueOrDefault(dataset.showLine, options.showLines);
      }

      Chart.controllers.line = Chart.DatasetController.extend({
        datasetElementType: elements.Line,
        dataElementType: elements.Point,
        update: function update(reset) {
          var me = this;
          var meta = me.getMeta();
          var line = meta.dataset;
          var points = meta.data || [];
          var options = me.chart.options;
          var lineElementOptions = options.elements.line;
          var scale = me.getScaleForId(meta.yAxisID);
          var i, ilen, custom;
          var dataset = me.getDataset();
          var showLine = lineEnabled(dataset, options); // Update Line

          if (showLine) {
            custom = line.custom || {}; // Compatibility: If the properties are defined with only the old name, use those values

            if (dataset.tension !== undefined && dataset.lineTension === undefined) {
              dataset.lineTension = dataset.tension;
            } // Utility


            line._scale = scale;
            line._datasetIndex = me.index; // Data

            line._children = points; // Model

            line._model = {
              // Appearance
              // The default behavior of lines is to break at null values, according
              // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
              // This option gives lines the ability to span gaps
              spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
              tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
              backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
              borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
              borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
              borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
              borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
              borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
              borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
              fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
              steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
              cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)
            };
            line.pivot();
          } // Update Points


          for (i = 0, ilen = points.length; i < ilen; ++i) {
            me.updateElement(points[i], i, reset);
          }

          if (showLine && line._model.tension !== 0) {
            me.updateBezierControlPoints();
          } // Now pivot the point for animation


          for (i = 0, ilen = points.length; i < ilen; ++i) {
            points[i].pivot();
          }
        },
        getPointBackgroundColor: function getPointBackgroundColor(point, index) {
          var backgroundColor = this.chart.options.elements.point.backgroundColor;
          var dataset = this.getDataset();
          var custom = point.custom || {};

          if (custom.backgroundColor) {
            backgroundColor = custom.backgroundColor;
          } else if (dataset.pointBackgroundColor) {
            backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
          } else if (dataset.backgroundColor) {
            backgroundColor = dataset.backgroundColor;
          }

          return backgroundColor;
        },
        getPointBorderColor: function getPointBorderColor(point, index) {
          var borderColor = this.chart.options.elements.point.borderColor;
          var dataset = this.getDataset();
          var custom = point.custom || {};

          if (custom.borderColor) {
            borderColor = custom.borderColor;
          } else if (dataset.pointBorderColor) {
            borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
          } else if (dataset.borderColor) {
            borderColor = dataset.borderColor;
          }

          return borderColor;
        },
        getPointBorderWidth: function getPointBorderWidth(point, index) {
          var borderWidth = this.chart.options.elements.point.borderWidth;
          var dataset = this.getDataset();
          var custom = point.custom || {};

          if (!isNaN(custom.borderWidth)) {
            borderWidth = custom.borderWidth;
          } else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
            borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
          } else if (!isNaN(dataset.borderWidth)) {
            borderWidth = dataset.borderWidth;
          }

          return borderWidth;
        },
        updateElement: function updateElement(point, index, reset) {
          var me = this;
          var meta = me.getMeta();
          var custom = point.custom || {};
          var dataset = me.getDataset();
          var datasetIndex = me.index;
          var value = dataset.data[index];
          var yScale = me.getScaleForId(meta.yAxisID);
          var xScale = me.getScaleForId(meta.xAxisID);
          var pointOptions = me.chart.options.elements.point;
          var x, y; // Compatibility: If the properties are defined with only the old name, use those values

          if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
            dataset.pointRadius = dataset.radius;
          }

          if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
            dataset.pointHitRadius = dataset.hitRadius;
          }

          x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
          y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

          point._xScale = xScale;
          point._yScale = yScale;
          point._datasetIndex = datasetIndex;
          point._index = index; // Desired view properties

          point._model = {
            x: x,
            y: y,
            skip: custom.skip || isNaN(x) || isNaN(y),
            // Appearance
            radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
            pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
            backgroundColor: me.getPointBackgroundColor(point, index),
            borderColor: me.getPointBorderColor(point, index),
            borderWidth: me.getPointBorderWidth(point, index),
            tension: meta.dataset._model ? meta.dataset._model.tension : 0,
            steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
            // Tooltip
            hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
          };
        },
        calculatePointY: function calculatePointY(value, index, datasetIndex) {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var yScale = me.getScaleForId(meta.yAxisID);
          var sumPos = 0;
          var sumNeg = 0;
          var i, ds, dsMeta;

          if (yScale.options.stacked) {
            for (i = 0; i < datasetIndex; i++) {
              ds = chart.data.datasets[i];
              dsMeta = chart.getDatasetMeta(i);

              if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
                var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

                if (stackedRightValue < 0) {
                  sumNeg += stackedRightValue || 0;
                } else {
                  sumPos += stackedRightValue || 0;
                }
              }
            }

            var rightValue = Number(yScale.getRightValue(value));

            if (rightValue < 0) {
              return yScale.getPixelForValue(sumNeg + rightValue);
            }

            return yScale.getPixelForValue(sumPos + rightValue);
          }

          return yScale.getPixelForValue(value);
        },
        updateBezierControlPoints: function updateBezierControlPoints() {
          var me = this;
          var meta = me.getMeta();
          var area = me.chart.chartArea;
          var points = meta.data || [];
          var i, ilen, point, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

          if (meta.dataset._model.spanGaps) {
            points = points.filter(function (pt) {
              return !pt._model.skip;
            });
          }

          function capControlPoint(pt, min, max) {
            return Math.max(Math.min(pt, max), min);
          }

          if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
            helpers.splineCurveMonotone(points);
          } else {
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              model = point._model;
              controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);
              model.controlPointPreviousX = controlPoints.previous.x;
              model.controlPointPreviousY = controlPoints.previous.y;
              model.controlPointNextX = controlPoints.next.x;
              model.controlPointNextY = controlPoints.next.y;
            }
          }

          if (me.chart.options.elements.line.capBezierPoints) {
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;
              model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
              model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
              model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
            }
          }
        },
        draw: function draw() {
          var me = this;
          var chart = me.chart;
          var meta = me.getMeta();
          var points = meta.data || [];
          var area = chart.chartArea;
          var ilen = points.length;
          var i = 0;
          helpers.canvas.clipArea(chart.ctx, area);

          if (lineEnabled(me.getDataset(), chart.options)) {
            meta.dataset.draw();
          }

          helpers.canvas.unclipArea(chart.ctx); // Draw the points

          for (; i < ilen; ++i) {
            points[i].draw(area);
          }
        },
        setHoverStyle: function setHoverStyle(point) {
          // Point
          var dataset = this.chart.data.datasets[point._datasetIndex];
          var index = point._index;
          var custom = point.custom || {};
          var model = point._model;
          model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
          model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
        },
        removeHoverStyle: function removeHoverStyle(point) {
          var me = this;
          var dataset = me.chart.data.datasets[point._datasetIndex];
          var index = point._index;
          var custom = point.custom || {};
          var model = point._model; // Compatibility: If the properties are defined with only the old name, use those values

          if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
            dataset.pointRadius = dataset.radius;
          }

          model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
          model.backgroundColor = me.getPointBackgroundColor(point, index);
          model.borderColor = me.getPointBorderColor(point, index);
          model.borderWidth = me.getPointBorderWidth(point, index);
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/controllers/controller.polarArea.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/chart.js/src/controllers/controller.polarArea.js ***!
    \***********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcControllersControllerPolarAreaJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var elements = __webpack_require__(
    /*! ../elements/index */
    "./node_modules/chart.js/src/elements/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('polarArea', {
      scale: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      // Boolean - Whether to animate the rotation of the chart
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function legendCallback(chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function generateLabels(chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc.custom || {};
                var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
                var arcOpts = chart.options.elements.arc;
                var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
                var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
                var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function onClick(e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }

          chart.update();
        }
      },
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function title() {
            return '';
          },
          label: function label(item, data) {
            return data.labels[item.index] + ': ' + item.yLabel;
          }
        }
      }
    });

    module.exports = function (Chart) {
      Chart.controllers.polarArea = Chart.DatasetController.extend({
        dataElementType: elements.Arc,
        linkScales: helpers.noop,
        update: function update(reset) {
          var me = this;
          var chart = me.chart;
          var chartArea = chart.chartArea;
          var meta = me.getMeta();
          var opts = chart.options;
          var arcOpts = opts.elements.arc;
          var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
          chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
          me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
          me.innerRadius = me.outerRadius - chart.radiusLength;
          meta.count = me.countVisibleElements();
          helpers.each(meta.data, function (arc, index) {
            me.updateElement(arc, index, reset);
          });
        },
        updateElement: function updateElement(arc, index, reset) {
          var me = this;
          var chart = me.chart;
          var dataset = me.getDataset();
          var opts = chart.options;
          var animationOpts = opts.animation;
          var scale = chart.scale;
          var labels = chart.data.labels;
          var circumference = me.calculateCircumference(dataset.data[index]);
          var centerX = scale.xCenter;
          var centerY = scale.yCenter; // If there is NaN data before us, we need to calculate the starting angle correctly.
          // We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data

          var visibleCount = 0;
          var meta = me.getMeta();

          for (var i = 0; i < index; ++i) {
            if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
              ++visibleCount;
            }
          } // var negHalfPI = -0.5 * Math.PI;


          var datasetStartAngle = opts.startAngle;
          var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
          var startAngle = datasetStartAngle + circumference * visibleCount;
          var endAngle = startAngle + (arc.hidden ? 0 : circumference);
          var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
          helpers.extend(arc, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            _scale: scale,
            // Desired view properties
            _model: {
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius: reset ? resetRadius : distance,
              startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
              endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
              label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
            }
          }); // Apply border and fill style

          me.removeHoverStyle(arc);
          arc.pivot();
        },
        removeHoverStyle: function removeHoverStyle(arc) {
          Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
        },
        countVisibleElements: function countVisibleElements() {
          var dataset = this.getDataset();
          var meta = this.getMeta();
          var count = 0;
          helpers.each(meta.data, function (element, index) {
            if (!isNaN(dataset.data[index]) && !element.hidden) {
              count++;
            }
          });
          return count;
        },
        calculateCircumference: function calculateCircumference(value) {
          var count = this.getMeta().count;

          if (count > 0 && !isNaN(value)) {
            return 2 * Math.PI / count;
          }

          return 0;
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/controllers/controller.radar.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/chart.js/src/controllers/controller.radar.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcControllersControllerRadarJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var elements = __webpack_require__(
    /*! ../elements/index */
    "./node_modules/chart.js/src/elements/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('radar', {
      scale: {
        type: 'radialLinear'
      },
      elements: {
        line: {
          tension: 0 // no bezier in radar

        }
      }
    });

    module.exports = function (Chart) {
      Chart.controllers.radar = Chart.DatasetController.extend({
        datasetElementType: elements.Line,
        dataElementType: elements.Point,
        linkScales: helpers.noop,
        update: function update(reset) {
          var me = this;
          var meta = me.getMeta();
          var line = meta.dataset;
          var points = meta.data;
          var custom = line.custom || {};
          var dataset = me.getDataset();
          var lineElementOptions = me.chart.options.elements.line;
          var scale = me.chart.scale; // Compatibility: If the properties are defined with only the old name, use those values

          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          }

          helpers.extend(meta.dataset, {
            // Utility
            _datasetIndex: me.index,
            _scale: scale,
            // Data
            _children: points,
            _loop: true,
            // Model
            _model: {
              // Appearance
              tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
              backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
              borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
              borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
              fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
              borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
              borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
              borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
              borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle
            }
          });
          meta.dataset.pivot(); // Update Points

          helpers.each(points, function (point, index) {
            me.updateElement(point, index, reset);
          }, me); // Update bezier control points

          me.updateBezierControlPoints();
        },
        updateElement: function updateElement(point, index, reset) {
          var me = this;
          var custom = point.custom || {};
          var dataset = me.getDataset();
          var scale = me.chart.scale;
          var pointElementOptions = me.chart.options.elements.point;
          var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]); // Compatibility: If the properties are defined with only the old name, use those values

          if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
            dataset.pointRadius = dataset.radius;
          }

          if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
            dataset.pointHitRadius = dataset.hitRadius;
          }

          helpers.extend(point, {
            // Utility
            _datasetIndex: me.index,
            _index: index,
            _scale: scale,
            // Desired view properties
            _model: {
              x: reset ? scale.xCenter : pointPosition.x,
              // value not used in dataset scale, but we want a consistent API between scales
              y: reset ? scale.yCenter : pointPosition.y,
              // Appearance
              tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
              radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
              backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
              borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
              borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
              pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
              // Tooltip
              hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
            }
          });
          point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);
        },
        updateBezierControlPoints: function updateBezierControlPoints() {
          var chartArea = this.chart.chartArea;
          var meta = this.getMeta();
          helpers.each(meta.data, function (point, index) {
            var model = point._model;
            var controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

            model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
            model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
            model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
            model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top); // Now pivot the point for animation

            point.pivot();
          });
        },
        setHoverStyle: function setHoverStyle(point) {
          // Point
          var dataset = this.chart.data.datasets[point._datasetIndex];
          var custom = point.custom || {};
          var index = point._index;
          var model = point._model;
          model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
          model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
        },
        removeHoverStyle: function removeHoverStyle(point) {
          var dataset = this.chart.data.datasets[point._datasetIndex];
          var custom = point.custom || {};
          var index = point._index;
          var model = point._model;
          var pointElementOptions = this.chart.options.elements.point;
          model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
          model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
          model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
          model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/controllers/controller.scatter.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/chart.js/src/controllers/controller.scatter.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcControllersControllerScatterJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    defaults._set('scatter', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          id: 'x-axis-1',
          // need an ID so datasets can reference the scale
          type: 'linear',
          // scatter should not use a category axis
          position: 'bottom'
        }],
        yAxes: [{
          id: 'y-axis-1',
          type: 'linear',
          position: 'left'
        }]
      },
      showLines: false,
      tooltips: {
        callbacks: {
          title: function title() {
            return ''; // doesn't make sense for scatter since data are formatted as a point
          },
          label: function label(item) {
            return '(' + item.xLabel + ', ' + item.yLabel + ')';
          }
        }
      }
    });

    module.exports = function (Chart) {
      // Scatter charts use line controllers
      Chart.controllers.scatter = Chart.controllers.line;
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.animation.js":
  /*!**********************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.animation.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreAnimationJs(module, exports, __webpack_require__) {
    "use strict";
    /* global window: false */

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ./core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('global', {
      animation: {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers.noop,
        onComplete: helpers.noop
      }
    });

    module.exports = function (Chart) {
      Chart.Animation = Element.extend({
        chart: null,
        // the animation associated chart instance
        currentStep: 0,
        // the current animation step
        numSteps: 60,
        // default number of steps
        easing: '',
        // the easing to use for this animation
        render: null,
        // render function used by the animation service
        onAnimationProgress: null,
        // user specified callback to fire on each step of the animation
        onAnimationComplete: null // user specified callback to fire when the animation finishes

      });
      Chart.animationService = {
        frameDuration: 17,
        animations: [],
        dropFrames: 0,
        request: null,

        /**
         * @param {Chart} chart - The chart to animate.
         * @param {Chart.Animation} animation - The animation that we will animate.
         * @param {Number} duration - The animation duration in ms.
         * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
         */
        addAnimation: function addAnimation(chart, animation, duration, lazy) {
          var animations = this.animations;
          var i, ilen;
          animation.chart = chart;

          if (!lazy) {
            chart.animating = true;
          }

          for (i = 0, ilen = animations.length; i < ilen; ++i) {
            if (animations[i].chart === chart) {
              animations[i] = animation;
              return;
            }
          }

          animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

          if (animations.length === 1) {
            this.requestAnimationFrame();
          }
        },
        cancelAnimation: function cancelAnimation(chart) {
          var index = helpers.findIndex(this.animations, function (animation) {
            return animation.chart === chart;
          });

          if (index !== -1) {
            this.animations.splice(index, 1);
            chart.animating = false;
          }
        },
        requestAnimationFrame: function requestAnimationFrame() {
          var me = this;

          if (me.request === null) {
            // Skip animation frame requests until the active one is executed.
            // This can happen when processing mouse events, e.g. 'mousemove'
            // and 'mouseout' events will trigger multiple renders.
            me.request = helpers.requestAnimFrame.call(window, function () {
              me.request = null;
              me.startDigest();
            });
          }
        },

        /**
         * @private
         */
        startDigest: function startDigest() {
          var me = this;
          var startTime = Date.now();
          var framesToDrop = 0;

          if (me.dropFrames > 1) {
            framesToDrop = Math.floor(me.dropFrames);
            me.dropFrames = me.dropFrames % 1;
          }

          me.advance(1 + framesToDrop);
          var endTime = Date.now();
          me.dropFrames += (endTime - startTime) / me.frameDuration; // Do we have more stuff to animate?

          if (me.animations.length > 0) {
            me.requestAnimationFrame();
          }
        },

        /**
         * @private
         */
        advance: function advance(count) {
          var animations = this.animations;
          var animation, chart;
          var i = 0;

          while (i < animations.length) {
            animation = animations[i];
            chart = animation.chart;
            animation.currentStep = (animation.currentStep || 0) + count;
            animation.currentStep = Math.min(animation.currentStep, animation.numSteps);
            helpers.callback(animation.render, [chart, animation], chart);
            helpers.callback(animation.onAnimationProgress, [animation], chart);

            if (animation.currentStep >= animation.numSteps) {
              helpers.callback(animation.onAnimationComplete, [animation], chart);
              chart.animating = false;
              animations.splice(i, 1);
            } else {
              ++i;
            }
          }
        }
      };
      /**
       * Provided for backward compatibility, use Chart.Animation instead
       * @prop Chart.Animation#animationObject
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       */

      Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
        get: function get() {
          return this;
        }
      });
      /**
       * Provided for backward compatibility, use Chart.Animation#chart instead
       * @prop Chart.Animation#chartInstance
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       */

      Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
        get: function get() {
          return this.chart;
        },
        set: function set(value) {
          this.chart = value;
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.controller.js":
  /*!***********************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.controller.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreControllerJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var Interaction = __webpack_require__(
    /*! ./core.interaction */
    "./node_modules/chart.js/src/core/core.interaction.js");

    var platform = __webpack_require__(
    /*! ../platforms/platform */
    "./node_modules/chart.js/src/platforms/platform.js");

    module.exports = function (Chart) {
      var plugins = Chart.plugins; // Create a dictionary of chart types, to allow for extension of existing types

      Chart.types = {}; // Store a reference to each instance - allowing us to globally resize chart instances on window resize.
      // Destroy method on the chart will remove the instance of the chart from this reference.

      Chart.instances = {}; // Controllers available for dataset visualization eg. bar, line, slice, etc.

      Chart.controllers = {};
      /**
       * Initializes the given config with global and chart default values.
       */

      function initConfig(config) {
        config = config || {}; // Do NOT use configMerge() for the data object because this method merges arrays
        // and so would change references to labels and datasets, preventing data updates.

        var data = config.data = config.data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        config.options = helpers.configMerge(defaults.global, defaults[config.type], config.options || {});
        return config;
      }
      /**
       * Updates the config of the chart
       * @param chart {Chart} chart to update the options for
       */


      function updateConfig(chart) {
        var newOptions = chart.options; // Update Scale(s) with options

        if (newOptions.scale) {
          chart.scale.options = newOptions.scale;
        } else if (newOptions.scales) {
          newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {
            chart.scales[scaleOptions.id].options = scaleOptions;
          });
        } // Tooltip


        chart.tooltip._options = newOptions.tooltips;
      }

      function positionIsHorizontal(position) {
        return position === 'top' || position === 'bottom';
      }

      helpers.extend(Chart.prototype,
      /** @lends Chart */
      {
        /**
         * @private
         */
        construct: function construct(item, config) {
          var me = this;
          config = initConfig(config);
          var context = platform.acquireContext(item, config);
          var canvas = context && context.canvas;
          var height = canvas && canvas.height;
          var width = canvas && canvas.width;
          me.id = helpers.uid();
          me.ctx = context;
          me.canvas = canvas;
          me.config = config;
          me.width = width;
          me.height = height;
          me.aspectRatio = height ? width / height : null;
          me.options = config.options;
          me._bufferedRender = false;
          /**
           * Provided for backward compatibility, Chart and Chart.Controller have been merged,
           * the "instance" still need to be defined since it might be called from plugins.
           * @prop Chart#chart
           * @deprecated since version 2.6.0
           * @todo remove at version 3
           * @private
           */

          me.chart = me;
          me.controller = me; // chart.chart.controller #inception
          // Add the chart instance to the global namespace

          Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

          Object.defineProperty(me, 'data', {
            get: function get() {
              return me.config.data;
            },
            set: function set(value) {
              me.config.data = value;
            }
          });

          if (!context || !canvas) {
            // The given item is not a compatible context2d element, let's return before finalizing
            // the chart initialization but after setting basic chart / controller properties that
            // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
            // https://github.com/chartjs/Chart.js/issues/2807
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }

          me.initialize();
          me.update();
        },

        /**
         * @private
         */
        initialize: function initialize() {
          var me = this; // Before init plugin notification

          plugins.notify(me, 'beforeInit');
          helpers.retinaScale(me, me.options.devicePixelRatio);
          me.bindEvents();

          if (me.options.responsive) {
            // Initial resize before chart draws (must be silent to preserve initial animations).
            me.resize(true);
          } // Make sure scales have IDs and are built before we build any controllers.


          me.ensureScalesHaveIDs();
          me.buildScales();
          me.initToolTip(); // After init plugin notification

          plugins.notify(me, 'afterInit');
          return me;
        },
        clear: function clear() {
          helpers.canvas.clear(this);
          return this;
        },
        stop: function stop() {
          // Stops any current animation loop occurring
          Chart.animationService.cancelAnimation(this);
          return this;
        },
        resize: function resize(silent) {
          var me = this;
          var options = me.options;
          var canvas = me.canvas;
          var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
          // the canvas display style uses the same integer values to avoid blurring effect.
          // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased

          var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
          var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

          if (me.width === newWidth && me.height === newHeight) {
            return;
          }

          canvas.width = me.width = newWidth;
          canvas.height = me.height = newHeight;
          canvas.style.width = newWidth + 'px';
          canvas.style.height = newHeight + 'px';
          helpers.retinaScale(me, options.devicePixelRatio);

          if (!silent) {
            // Notify any plugins about the resize
            var newSize = {
              width: newWidth,
              height: newHeight
            };
            plugins.notify(me, 'resize', [newSize]); // Notify of resize

            if (me.options.onResize) {
              me.options.onResize(me, newSize);
            }

            me.stop();
            me.update(me.options.responsiveAnimationDuration);
          }
        },
        ensureScalesHaveIDs: function ensureScalesHaveIDs() {
          var options = this.options;
          var scalesOptions = options.scales || {};
          var scaleOptions = options.scale;
          helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
            xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
          });
          helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
            yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
          });

          if (scaleOptions) {
            scaleOptions.id = scaleOptions.id || 'scale';
          }
        },

        /**
         * Builds a map of scale ID to scale object for future lookup.
         */
        buildScales: function buildScales() {
          var me = this;
          var options = me.options;
          var scales = me.scales = {};
          var items = [];

          if (options.scales) {
            items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
              return {
                options: xAxisOptions,
                dtype: 'category',
                dposition: 'bottom'
              };
            }), (options.scales.yAxes || []).map(function (yAxisOptions) {
              return {
                options: yAxisOptions,
                dtype: 'linear',
                dposition: 'left'
              };
            }));
          }

          if (options.scale) {
            items.push({
              options: options.scale,
              dtype: 'radialLinear',
              isDefault: true,
              dposition: 'chartArea'
            });
          }

          helpers.each(items, function (item) {
            var scaleOptions = item.options;
            var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
            var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);

            if (!scaleClass) {
              return;
            }

            if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
              scaleOptions.position = item.dposition;
            }

            var scale = new scaleClass({
              id: scaleOptions.id,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales[scale.id] = scale;
            scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
            // and consider it as a regular scale part of the "scales"" map only! This would
            // make the logic easier and remove some useless? custom code.

            if (item.isDefault) {
              me.scale = scale;
            }
          });
          Chart.scaleService.addScalesToLayout(this);
        },
        buildOrUpdateControllers: function buildOrUpdateControllers() {
          var me = this;
          var types = [];
          var newControllers = [];
          helpers.each(me.data.datasets, function (dataset, datasetIndex) {
            var meta = me.getDatasetMeta(datasetIndex);
            var type = dataset.type || me.config.type;

            if (meta.type && meta.type !== type) {
              me.destroyDatasetMeta(datasetIndex);
              meta = me.getDatasetMeta(datasetIndex);
            }

            meta.type = type;
            types.push(meta.type);

            if (meta.controller) {
              meta.controller.updateIndex(datasetIndex);
            } else {
              var ControllerClass = Chart.controllers[meta.type];

              if (ControllerClass === undefined) {
                throw new Error('"' + meta.type + '" is not a chart type.');
              }

              meta.controller = new ControllerClass(me, datasetIndex);
              newControllers.push(meta.controller);
            }
          }, me);
          return newControllers;
        },

        /**
         * Reset the elements of all datasets
         * @private
         */
        resetElements: function resetElements() {
          var me = this;
          helpers.each(me.data.datasets, function (dataset, datasetIndex) {
            me.getDatasetMeta(datasetIndex).controller.reset();
          }, me);
        },

        /**
        * Resets the chart back to it's state before the initial animation
        */
        reset: function reset() {
          this.resetElements();
          this.tooltip.initialize();
        },
        update: function update(config) {
          var me = this;

          if (!config || typeof config !== 'object') {
            // backwards compatibility
            config = {
              duration: config,
              lazy: arguments[1]
            };
          }

          updateConfig(me);

          if (plugins.notify(me, 'beforeUpdate') === false) {
            return;
          } // In case the entire data object changed


          me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

          var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

          helpers.each(me.data.datasets, function (dataset, datasetIndex) {
            me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
          }, me);
          me.updateLayout(); // Can only reset the new controllers after the scales have been updated

          helpers.each(newControllers, function (controller) {
            controller.reset();
          });
          me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
          // after update.

          me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
          // When we reset the tooltip, we need to clear it

          me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

          plugins.notify(me, 'afterUpdate');

          if (me._bufferedRender) {
            me._bufferedRequest = {
              duration: config.duration,
              easing: config.easing,
              lazy: config.lazy
            };
          } else {
            me.render(config);
          }
        },

        /**
         * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
         * hook, in which case, plugins will not be called on `afterLayout`.
         * @private
         */
        updateLayout: function updateLayout() {
          var me = this;

          if (plugins.notify(me, 'beforeLayout') === false) {
            return;
          }

          Chart.layoutService.update(this, this.width, this.height);
          /**
           * Provided for backward compatibility, use `afterLayout` instead.
           * @method IPlugin#afterScaleUpdate
           * @deprecated since version 2.5.0
           * @todo remove at version 3
           * @private
           */

          plugins.notify(me, 'afterScaleUpdate');
          plugins.notify(me, 'afterLayout');
        },

        /**
         * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
         * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
         * @private
         */
        updateDatasets: function updateDatasets() {
          var me = this;

          if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
            return;
          }

          for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me.updateDataset(i);
          }

          plugins.notify(me, 'afterDatasetsUpdate');
        },

        /**
         * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
         * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
         * @private
         */
        updateDataset: function updateDataset(index) {
          var me = this;
          var meta = me.getDatasetMeta(index);
          var args = {
            meta: meta,
            index: index
          };

          if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
            return;
          }

          meta.controller.update();
          plugins.notify(me, 'afterDatasetUpdate', [args]);
        },
        render: function render(config) {
          var me = this;

          if (!config || typeof config !== 'object') {
            // backwards compatibility
            config = {
              duration: config,
              lazy: arguments[1]
            };
          }

          var duration = config.duration;
          var lazy = config.lazy;

          if (plugins.notify(me, 'beforeRender') === false) {
            return;
          }

          var animationOptions = me.options.animation;

          var onComplete = function onComplete(animation) {
            plugins.notify(me, 'afterRender');
            helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
          };

          if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {
            var animation = new Chart.Animation({
              numSteps: (duration || animationOptions.duration) / 16.66,
              // 60 fps
              easing: config.easing || animationOptions.easing,
              render: function render(chart, animationObject) {
                var easingFunction = helpers.easing.effects[animationObject.easing];
                var currentStep = animationObject.currentStep;
                var stepDecimal = currentStep / animationObject.numSteps;
                chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
              },
              onAnimationProgress: animationOptions.onProgress,
              onAnimationComplete: onComplete
            });
            Chart.animationService.addAnimation(me, animation, duration, lazy);
          } else {
            me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

            onComplete(new Chart.Animation({
              numSteps: 0,
              chart: me
            }));
          }

          return me;
        },
        draw: function draw(easingValue) {
          var me = this;
          me.clear();

          if (helpers.isNullOrUndef(easingValue)) {
            easingValue = 1;
          }

          me.transition(easingValue);

          if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
            return;
          } // Draw all the scales


          helpers.each(me.boxes, function (box) {
            box.draw(me.chartArea);
          }, me);

          if (me.scale) {
            me.scale.draw();
          }

          me.drawDatasets(easingValue);

          me._drawTooltip(easingValue);

          plugins.notify(me, 'afterDraw', [easingValue]);
        },

        /**
         * @private
         */
        transition: function transition(easingValue) {
          var me = this;

          for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
            if (me.isDatasetVisible(i)) {
              me.getDatasetMeta(i).controller.transition(easingValue);
            }
          }

          me.tooltip.transition(easingValue);
        },

        /**
         * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
         * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
         * @private
         */
        drawDatasets: function drawDatasets(easingValue) {
          var me = this;

          if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
            return;
          } // Draw datasets reversed to support proper line stacking


          for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
            if (me.isDatasetVisible(i)) {
              me.drawDataset(i, easingValue);
            }
          }

          plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
        },

        /**
         * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
         * hook, in which case, plugins will not be called on `afterDatasetDraw`.
         * @private
         */
        drawDataset: function drawDataset(index, easingValue) {
          var me = this;
          var meta = me.getDatasetMeta(index);
          var args = {
            meta: meta,
            index: index,
            easingValue: easingValue
          };

          if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
            return;
          }

          meta.controller.draw(easingValue);
          plugins.notify(me, 'afterDatasetDraw', [args]);
        },

        /**
         * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
         * hook, in which case, plugins will not be called on `afterTooltipDraw`.
         * @private
         */
        _drawTooltip: function _drawTooltip(easingValue) {
          var me = this;
          var tooltip = me.tooltip;
          var args = {
            tooltip: tooltip,
            easingValue: easingValue
          };

          if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
            return;
          }

          tooltip.draw();
          plugins.notify(me, 'afterTooltipDraw', [args]);
        },
        // Get the single element that was clicked on
        // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
        getElementAtEvent: function getElementAtEvent(e) {
          return Interaction.modes.single(this, e);
        },
        getElementsAtEvent: function getElementsAtEvent(e) {
          return Interaction.modes.label(this, e, {
            intersect: true
          });
        },
        getElementsAtXAxis: function getElementsAtXAxis(e) {
          return Interaction.modes['x-axis'](this, e, {
            intersect: true
          });
        },
        getElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {
          var method = Interaction.modes[mode];

          if (typeof method === 'function') {
            return method(this, e, options);
          }

          return [];
        },
        getDatasetAtEvent: function getDatasetAtEvent(e) {
          return Interaction.modes.dataset(this, e, {
            intersect: true
          });
        },
        getDatasetMeta: function getDatasetMeta(datasetIndex) {
          var me = this;
          var dataset = me.data.datasets[datasetIndex];

          if (!dataset._meta) {
            dataset._meta = {};
          }

          var meta = dataset._meta[me.id];

          if (!meta) {
            meta = dataset._meta[me.id] = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              // See isDatasetVisible() comment
              xAxisID: null,
              yAxisID: null
            };
          }

          return meta;
        },
        getVisibleDatasetCount: function getVisibleDatasetCount() {
          var count = 0;

          for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            if (this.isDatasetVisible(i)) {
              count++;
            }
          }

          return count;
        },
        isDatasetVisible: function isDatasetVisible(datasetIndex) {
          var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
          // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

          return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
        },
        generateLegend: function generateLegend() {
          return this.options.legendCallback(this);
        },

        /**
         * @private
         */
        destroyDatasetMeta: function destroyDatasetMeta(datasetIndex) {
          var id = this.id;
          var dataset = this.data.datasets[datasetIndex];
          var meta = dataset._meta && dataset._meta[id];

          if (meta) {
            meta.controller.destroy();
            delete dataset._meta[id];
          }
        },
        destroy: function destroy() {
          var me = this;
          var canvas = me.canvas;
          var i, ilen;
          me.stop(); // dataset controllers need to cleanup associated data

          for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me.destroyDatasetMeta(i);
          }

          if (canvas) {
            me.unbindEvents();
            helpers.canvas.clear(me);
            platform.releaseContext(me.ctx);
            me.canvas = null;
            me.ctx = null;
          }

          plugins.notify(me, 'destroy');
          delete Chart.instances[me.id];
        },
        toBase64Image: function toBase64Image() {
          return this.canvas.toDataURL.apply(this.canvas, arguments);
        },
        initToolTip: function initToolTip() {
          var me = this;
          me.tooltip = new Chart.Tooltip({
            _chart: me,
            _chartInstance: me,
            // deprecated, backward compatibility
            _data: me.data,
            _options: me.options.tooltips
          }, me);
        },

        /**
         * @private
         */
        bindEvents: function bindEvents() {
          var me = this;
          var listeners = me._listeners = {};

          var listener = function listener() {
            me.eventHandler.apply(me, arguments);
          };

          helpers.each(me.options.events, function (type) {
            platform.addEventListener(me, type, listener);
            listeners[type] = listener;
          }); // Elements used to detect size change should not be injected for non responsive charts.
          // See https://github.com/chartjs/Chart.js/issues/2210

          if (me.options.responsive) {
            listener = function listener() {
              me.resize();
            };

            platform.addEventListener(me, 'resize', listener);
            listeners.resize = listener;
          }
        },

        /**
         * @private
         */
        unbindEvents: function unbindEvents() {
          var me = this;
          var listeners = me._listeners;

          if (!listeners) {
            return;
          }

          delete me._listeners;
          helpers.each(listeners, function (listener, type) {
            platform.removeEventListener(me, type, listener);
          });
        },
        updateHoverStyle: function updateHoverStyle(elements, mode, enabled) {
          var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
          var element, i, ilen;

          for (i = 0, ilen = elements.length; i < ilen; ++i) {
            element = elements[i];

            if (element) {
              this.getDatasetMeta(element._datasetIndex).controller[method](element);
            }
          }
        },

        /**
         * @private
         */
        eventHandler: function eventHandler(e) {
          var me = this;
          var tooltip = me.tooltip;

          if (plugins.notify(me, 'beforeEvent', [e]) === false) {
            return;
          } // Buffer any update calls so that renders do not occur


          me._bufferedRender = true;
          me._bufferedRequest = null;
          var changed = me.handleEvent(e);
          changed |= tooltip && tooltip.handleEvent(e);
          plugins.notify(me, 'afterEvent', [e]);
          var bufferedRequest = me._bufferedRequest;

          if (bufferedRequest) {
            // If we have an update that was triggered, we need to do a normal render
            me.render(bufferedRequest);
          } else if (changed && !me.animating) {
            // If entering, leaving, or changing elements, animate the change via pivot
            me.stop(); // We only need to render at this point. Updating will cause scales to be
            // recomputed generating flicker & using more memory than necessary.

            me.render(me.options.hover.animationDuration, true);
          }

          me._bufferedRender = false;
          me._bufferedRequest = null;
          return me;
        },

        /**
         * Handle an event
         * @private
         * @param {IEvent} event the event to handle
         * @return {Boolean} true if the chart needs to re-render
         */
        handleEvent: function handleEvent(e) {
          var me = this;
          var options = me.options || {};
          var hoverOptions = options.hover;
          var changed = false;
          me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

          if (e.type === 'mouseout') {
            me.active = [];
          } else {
            me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
          } // Invoke onHover hook
          // Need to call with native event here to not break backwards compatibility


          helpers.callback(options.onHover || options.hover.onHover, [e["native"], me.active], me);

          if (e.type === 'mouseup' || e.type === 'click') {
            if (options.onClick) {
              // Use e.native here for backwards compatibility
              options.onClick.call(me, e["native"], me.active);
            }
          } // Remove styling for last active (even if it may still be active)


          if (me.lastActive.length) {
            me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
          } // Built in hover styling


          if (me.active.length && hoverOptions.mode) {
            me.updateHoverStyle(me.active, hoverOptions.mode, true);
          }

          changed = !helpers.arrayEquals(me.active, me.lastActive); // Remember Last Actives

          me.lastActive = me.active;
          return changed;
        }
      });
      /**
       * Provided for backward compatibility, use Chart instead.
       * @class Chart.Controller
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */

      Chart.Controller = Chart;
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.datasetController.js":
  /*!******************************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.datasetController.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreDatasetControllerJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    module.exports = function (Chart) {
      var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
      /**
       * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
       * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
       * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
       */

      function listenArrayEvents(array, listener) {
        if (array._chartjs) {
          array._chartjs.listeners.push(listener);

          return;
        }

        Object.defineProperty(array, '_chartjs', {
          configurable: true,
          enumerable: false,
          value: {
            listeners: [listener]
          }
        });
        arrayEvents.forEach(function (key) {
          var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
          var base = array[key];
          Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value: function value() {
              var args = Array.prototype.slice.call(arguments);
              var res = base.apply(this, args);
              helpers.each(array._chartjs.listeners, function (object) {
                if (typeof object[method] === 'function') {
                  object[method].apply(object, args);
                }
              });
              return res;
            }
          });
        });
      }
      /**
       * Removes the given array event listener and cleanup extra attached properties (such as
       * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
       */


      function unlistenArrayEvents(array, listener) {
        var stub = array._chartjs;

        if (!stub) {
          return;
        }

        var listeners = stub.listeners;
        var index = listeners.indexOf(listener);

        if (index !== -1) {
          listeners.splice(index, 1);
        }

        if (listeners.length > 0) {
          return;
        }

        arrayEvents.forEach(function (key) {
          delete array[key];
        });
        delete array._chartjs;
      } // Base class for all dataset controllers (line, bar, etc)


      Chart.DatasetController = function (chart, datasetIndex) {
        this.initialize(chart, datasetIndex);
      };

      helpers.extend(Chart.DatasetController.prototype, {
        /**
         * Element type used to generate a meta dataset (e.g. Chart.element.Line).
         * @type {Chart.core.element}
         */
        datasetElementType: null,

        /**
         * Element type used to generate a meta data (e.g. Chart.element.Point).
         * @type {Chart.core.element}
         */
        dataElementType: null,
        initialize: function initialize(chart, datasetIndex) {
          var me = this;
          me.chart = chart;
          me.index = datasetIndex;
          me.linkScales();
          me.addElements();
        },
        updateIndex: function updateIndex(datasetIndex) {
          this.index = datasetIndex;
        },
        linkScales: function linkScales() {
          var me = this;
          var meta = me.getMeta();
          var dataset = me.getDataset();

          if (meta.xAxisID === null) {
            meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
          }

          if (meta.yAxisID === null) {
            meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
          }
        },
        getDataset: function getDataset() {
          return this.chart.data.datasets[this.index];
        },
        getMeta: function getMeta() {
          return this.chart.getDatasetMeta(this.index);
        },
        getScaleForId: function getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
        },
        reset: function reset() {
          this.update(true);
        },

        /**
         * @private
         */
        destroy: function destroy() {
          if (this._data) {
            unlistenArrayEvents(this._data, this);
          }
        },
        createMetaDataset: function createMetaDataset() {
          var me = this;
          var type = me.datasetElementType;
          return type && new type({
            _chart: me.chart,
            _datasetIndex: me.index
          });
        },
        createMetaData: function createMetaData(index) {
          var me = this;
          var type = me.dataElementType;
          return type && new type({
            _chart: me.chart,
            _datasetIndex: me.index,
            _index: index
          });
        },
        addElements: function addElements() {
          var me = this;
          var meta = me.getMeta();
          var data = me.getDataset().data || [];
          var metaData = meta.data;
          var i, ilen;

          for (i = 0, ilen = data.length; i < ilen; ++i) {
            metaData[i] = metaData[i] || me.createMetaData(i);
          }

          meta.dataset = meta.dataset || me.createMetaDataset();
        },
        addElementAndReset: function addElementAndReset(index) {
          var element = this.createMetaData(index);
          this.getMeta().data.splice(index, 0, element);
          this.updateElement(element, index, true);
        },
        buildOrUpdateElements: function buildOrUpdateElements() {
          var me = this;
          var dataset = me.getDataset();
          var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
          // real-time charts), we need to monitor these data modifications and synchronize
          // the internal meta data accordingly.

          if (me._data !== data) {
            if (me._data) {
              // This case happens when the user replaced the data array instance.
              unlistenArrayEvents(me._data, me);
            }

            listenArrayEvents(data, me);
            me._data = data;
          } // Re-sync meta data in case the user replaced the data array or if we missed
          // any updates and so make sure that we handle number of datapoints changing.


          me.resyncElements();
        },
        update: helpers.noop,
        transition: function transition(easingValue) {
          var meta = this.getMeta();
          var elements = meta.data || [];
          var ilen = elements.length;
          var i = 0;

          for (; i < ilen; ++i) {
            elements[i].transition(easingValue);
          }

          if (meta.dataset) {
            meta.dataset.transition(easingValue);
          }
        },
        draw: function draw() {
          var meta = this.getMeta();
          var elements = meta.data || [];
          var ilen = elements.length;
          var i = 0;

          if (meta.dataset) {
            meta.dataset.draw();
          }

          for (; i < ilen; ++i) {
            elements[i].draw();
          }
        },
        removeHoverStyle: function removeHoverStyle(element, elementOpts) {
          var dataset = this.chart.data.datasets[element._datasetIndex];
          var index = element._index;
          var custom = element.custom || {};
          var valueOrDefault = helpers.valueAtIndexOrDefault;
          var model = element._model;
          model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
          model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
          model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
        },
        setHoverStyle: function setHoverStyle(element) {
          var dataset = this.chart.data.datasets[element._datasetIndex];
          var index = element._index;
          var custom = element.custom || {};
          var valueOrDefault = helpers.valueAtIndexOrDefault;
          var getHoverColor = helpers.getHoverColor;
          var model = element._model;
          model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
          model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
          model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
        },

        /**
         * @private
         */
        resyncElements: function resyncElements() {
          var me = this;
          var meta = me.getMeta();
          var data = me.getDataset().data;
          var numMeta = meta.data.length;
          var numData = data.length;

          if (numData < numMeta) {
            meta.data.splice(numData, numMeta - numData);
          } else if (numData > numMeta) {
            me.insertElements(numMeta, numData - numMeta);
          }
        },

        /**
         * @private
         */
        insertElements: function insertElements(start, count) {
          for (var i = 0; i < count; ++i) {
            this.addElementAndReset(start + i);
          }
        },

        /**
         * @private
         */
        onDataPush: function onDataPush() {
          this.insertElements(this.getDataset().data.length - 1, arguments.length);
        },

        /**
         * @private
         */
        onDataPop: function onDataPop() {
          this.getMeta().data.pop();
        },

        /**
         * @private
         */
        onDataShift: function onDataShift() {
          this.getMeta().data.shift();
        },

        /**
         * @private
         */
        onDataSplice: function onDataSplice(start, count) {
          this.getMeta().data.splice(start, count);
          this.insertElements(start, arguments.length - 2);
        },

        /**
         * @private
         */
        onDataUnshift: function onDataUnshift() {
          this.insertElements(0, arguments.length);
        }
      });
      Chart.DatasetController.extend = helpers.inherits;
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.defaults.js":
  /*!*********************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.defaults.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreDefaultsJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    module.exports = {
      /**
       * @private
       */
      _set: function _set(scope, values) {
        return helpers.merge(this[scope] || (this[scope] = {}), values);
      }
    };
    /***/
  },

  /***/
  "./node_modules/chart.js/src/core/core.element.js":
  /*!********************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.element.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreElementJs(module, exports, __webpack_require__) {
    "use strict";

    var color = __webpack_require__(
    /*! chartjs-color */
    "./node_modules/chartjs-color/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key]; // if a value is added to the model after pivot() has been called, the view
        // doesn't contain it, so let's initialize the view to the target value.

        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }

        actual = view[key];

        if (actual === target || key[0] === '_') {
          continue;
        }

        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }

        origin = start[key];
        type = typeof target;

        if (type === typeof origin) {
          if (type === 'string') {
            c0 = color(origin);

            if (c0.valid) {
              c1 = color(target);

              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (type === 'number' && isFinite(origin) && isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }

        view[key] = target;
      }
    }

    var Element = function Element(configuration) {
      helpers.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };

    helpers.extend(Element.prototype, {
      initialize: function initialize() {
        this.hidden = false;
      },
      pivot: function pivot() {
        var me = this;

        if (!me._view) {
          me._view = helpers.clone(me._model);
        }

        me._start = {};
        return me;
      },
      transition: function transition(ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view; // No animation -> No Transition

        if (!model || ease === 1) {
          me._view = model;
          me._start = null;
          return me;
        }

        if (!view) {
          view = me._view = {};
        }

        if (!start) {
          start = me._start = {};
        }

        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function tooltipPosition() {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function hasValue() {
        return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
      }
    });
    Element.extend = helpers.inherits;
    module.exports = Element;
    /***/
  },

  /***/
  "./node_modules/chart.js/src/core/core.helpers.js":
  /*!********************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.helpers.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreHelpersJs(module, exports, __webpack_require__) {
    "use strict";
    /* global window: false */

    /* global document: false */

    var color = __webpack_require__(
    /*! chartjs-color */
    "./node_modules/chartjs-color/index.js");

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    module.exports = function (Chart) {
      // -- Basic js utility methods
      helpers.configMerge = function ()
      /* objects ... */
      {
        return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
          merger: function merger(key, target, source, options) {
            var tval = target[key] || {};
            var sval = source[key];

            if (key === 'scales') {
              // scale config merging is complex. Add our own function here for that
              target[key] = helpers.scaleMerge(tval, sval);
            } else if (key === 'scale') {
              // used in polar area & radar charts since there is only one scale
              target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
            } else {
              helpers._merger(key, target, source, options);
            }
          }
        });
      };

      helpers.scaleMerge = function ()
      /* objects ... */
      {
        return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
          merger: function merger(key, target, source, options) {
            if (key === 'xAxes' || key === 'yAxes') {
              var slen = source[key].length;
              var i, type, scale;

              if (!target[key]) {
                target[key] = [];
              }

              for (i = 0; i < slen; ++i) {
                scale = source[key][i];
                type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

                if (i >= target[key].length) {
                  target[key].push({});
                }

                if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                  // new/untyped scale or type changed: let's apply the new defaults
                  // then merge source scale to correctly overwrite the defaults.
                  helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
                } else {
                  // scales type are the same
                  helpers.merge(target[key][i], scale);
                }
              }
            } else {
              helpers._merger(key, target, source, options);
            }
          }
        });
      };

      helpers.where = function (collection, filterCallback) {
        if (helpers.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }

        var filtered = [];
        helpers.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };

      helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;

        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }

        return -1;
      };

      helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (helpers.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }

        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };

      helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (helpers.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }

        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      }; // -- Math methods


      helpers.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };

      helpers.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };

      helpers.almostWhole = function (x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon < x && rounded + epsilon > x;
      };

      helpers.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }

          return max;
        }, Number.NEGATIVE_INFINITY);
      };

      helpers.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }

          return min;
        }, Number.POSITIVE_INFINITY);
      };

      helpers.sign = Math.sign ? function (x) {
        return Math.sign(x);
      } : function (x) {
        x = +x; // convert to a number

        if (x === 0 || isNaN(x)) {
          return x;
        }

        return x > 0 ? 1 : -1;
      };
      helpers.log10 = Math.log10 ? function (x) {
        return Math.log10(x);
      } : function (x) {
        return Math.log(x) / Math.LN10;
      };

      helpers.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
      };

      helpers.toDegrees = function (radians) {
        return radians * (180 / Math.PI);
      }; // Gets the angle from vertical upright to the point about a centre.


      helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * Math.PI) {
          angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      };

      helpers.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };

      helpers.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };

      helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01; // scaling factor for triangle Ta

        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };

      helpers.EPSILON = Number.EPSILON || 1e-14;

      helpers.splineCurveMonotone = function (points) {
        // This function calculates Bézier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        }); // Calculate slopes (deltaK) and initialize tangents (mK)

        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }

          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        } // Adjust tangents to ensure monotonic properties


        var alphaK, betaK, tauK, squaredMagnitude;

        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];

          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }

          if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }

          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        } // Compute control points


        var deltaX;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }

          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };

      helpers.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }

        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };

      helpers.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }

        return index <= 0 ? collection[0] : collection[index - 1];
      }; // Implementation of the nice number algorithm used in determining where axis labels will go


      helpers.niceNum = function (range, round) {
        var exponent = Math.floor(helpers.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;

        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1.0) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }

        return niceFraction * Math.pow(10, exponent);
      }; // Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


      helpers.requestAnimFrame = function () {
        if (typeof window === 'undefined') {
          return function (callback) {
            callback();
          };
        }

        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
      }(); // -- DOM methods


      helpers.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas = evt.currentTarget || evt.srcElement;
        var boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;

        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        } // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


        var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      }; // Private helper function to convert max-width/max-height values that may be percentages into a number


      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }
      /**
       * Returns if the given value contains an effective constraint.
       * @private
       */


      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none';
      } // Private helper to get a constraint dimension
      // @param domNode : the node to check the constraint on
      // @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
      // @param percentageProperty : property of parent to use when calculating width as a percentage
      // @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser


      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;
        var parentNode = domNode.parentNode;
        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;

        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }

        return 'none';
      } // returns Number or undefined if no constraint


      helpers.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth');
      }; // returns Number or undefined if no constraint


      helpers.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight');
      };

      helpers.getMaximumWidth = function (domNode) {
        var container = domNode.parentNode;

        if (!container) {
          return domNode.clientWidth;
        }

        var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
        var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
        var w = container.clientWidth - paddingLeft - paddingRight;
        var cw = helpers.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };

      helpers.getMaximumHeight = function (domNode) {
        var container = domNode.parentNode;

        if (!container) {
          return domNode.clientHeight;
        }

        var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
        var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
        var h = container.clientHeight - paddingTop - paddingBottom;
        var ch = helpers.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };

      helpers.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };

      helpers.retinaScale = function (chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;

        if (pixelRatio === 1) {
          return;
        }

        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575

        canvas.style.height = height + 'px';
        canvas.style.width = width + 'px';
      }; // -- Canvas methods


      helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
      };

      helpers.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.font = font;
        var longest = 0;
        helpers.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
            longest = helpers.measureText(ctx, data, gc, longest, thing);
          } else if (helpers.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
                longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
              }
            });
          }
        });
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      };

      helpers.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      };

      helpers.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers.each(arrayOfThings, function (thing) {
          if (helpers.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };

      helpers.color = !color ? function (value) {
        console.error('Color.js not found!');
        return value;
      } : function (value) {
        /* global CanvasGradient */
        if (value instanceof CanvasGradient) {
          value = defaults.global.defaultColor;
        }

        return color(value);
      };

      helpers.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.interaction.js":
  /*!************************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.interaction.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreInteractionJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");
    /**
     * Helper function to get relative position for an event
     * @param {Event|IEvent} event - The event to get the position for
     * @param {Chart} chart - The chart
     * @returns {Point} the event position
     */


    function getRelativePosition(e, chart) {
      if (e["native"]) {
        return {
          x: e.x,
          y: e.y
        };
      }

      return helpers.getRelativePosition(e, chart);
    }
    /**
     * Helper function to traverse all of the visible elements in the chart
     * @param chart {chart} the chart
     * @param handler {Function} the callback to execute for each visible item
     */


    function parseVisibleItems(chart, handler) {
      var datasets = chart.data.datasets;
      var meta, i, j, ilen, jlen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!chart.isDatasetVisible(i)) {
          continue;
        }

        meta = chart.getDatasetMeta(i);

        for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
          var element = meta.data[j];

          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    /**
     * Helper function to get the items that intersect the event position
     * @param items {ChartElement[]} elements to filter
     * @param position {Point} the point to be nearest to
     * @return {ChartElement[]} the nearest items
     */


    function getIntersectItems(chart, position) {
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Helper function to get the items nearest to the event position considering all visible items in teh chart
     * @param chart {Chart} the chart to look at elements from
     * @param position {Point} the point to be nearest to
     * @param intersect {Boolean} if true, only consider items that intersect the position
     * @param distanceMetric {Function} function to provide the distance between points
     * @return {ChartElement[]} the nearest items
     */


    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function (element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }

        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);

        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          // Can have multiple items at the same distance in which case we sort by size
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    /**
     * Get a distance metric function for two points based on the
     * axis mode setting
     * @param {String} axis the axis mode. x|y|xy
     */


    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf('x') !== -1;
      var useY = axis.indexOf('y') !== -1;
      return function (pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }

    function indexMode(chart, e, options) {
      var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

      options.axis = options.axis || 'x';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements = [];

      if (!items.length) {
        return [];
      }

      chart.data.datasets.forEach(function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

          if (element && !element._view.skip) {
            elements.push(element);
          }
        }
      });
      return elements;
    }
    /**
     * @interface IInteractionOptions
     */

    /**
     * If true, only consider items that intersect the point
     * @name IInterfaceOptions#boolean
     * @type Boolean
     */

    /**
     * Contains interaction related functions
     * @namespace Chart.Interaction
     */


    module.exports = {
      // Helper function for different modes
      modes: {
        single: function single(chart, e) {
          var position = getRelativePosition(e, chart);
          var elements = [];
          parseVisibleItems(chart, function (element) {
            if (element.inRange(position.x, position.y)) {
              elements.push(element);
              return elements;
            }
          });
          return elements.slice(0, 1);
        },

        /**
         * @function Chart.Interaction.modes.label
         * @deprecated since version 2.4.0
         * @todo remove at version 3
         * @private
         */
        label: indexMode,

        /**
         * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
         * @function Chart.Interaction.modes.index
         * @since v2.4.0
         * @param chart {chart} the chart we are returning items from
         * @param e {Event} the event we are find things at
         * @param options {IInteractionOptions} options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        index: indexMode,

        /**
         * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect is false, we find the nearest item and return the items in that dataset
         * @function Chart.Interaction.modes.dataset
         * @param chart {chart} the chart we are returning items from
         * @param e {Event} the event we are find things at
         * @param options {IInteractionOptions} options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        dataset: function dataset(chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }

          return items;
        },

        /**
         * @function Chart.Interaction.modes.x-axis
         * @deprecated since version 2.4.0. Use index mode and intersect == true
         * @todo remove at version 3
         * @private
         */
        'x-axis': function xAxis(chart, e) {
          return indexMode(chart, e, {
            intersect: false
          });
        },

        /**
         * Point mode returns all elements that hit test based on the event position
         * of the event
         * @function Chart.Interaction.modes.intersect
         * @param chart {chart} the chart we are returning items from
         * @param e {Event} the event we are find things at
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        point: function point(chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },

        /**
         * nearest mode returns the element closest to the point
         * @function Chart.Interaction.modes.intersect
         * @param chart {chart} the chart we are returning items from
         * @param e {Event} the event we are find things at
         * @param options {IInteractionOptions} options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        nearest: function nearest(chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric); // We have multiple items at the same distance from the event. Now sort by smallest

          if (nearestItems.length > 1) {
            nearestItems.sort(function (a, b) {
              var sizeA = a.getArea();
              var sizeB = b.getArea();
              var ret = sizeA - sizeB;

              if (ret === 0) {
                // if equal sort by dataset index
                ret = a._datasetIndex - b._datasetIndex;
              }

              return ret;
            });
          } // Return only 1 item


          return nearestItems.slice(0, 1);
        },

        /**
         * x mode returns the elements that hit-test at the current x coordinate
         * @function Chart.Interaction.modes.x
         * @param chart {chart} the chart we are returning items from
         * @param e {Event} the event we are find things at
         * @param options {IInteractionOptions} options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        x: function x(chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        },

        /**
         * y mode returns the elements that hit-test at the current y coordinate
         * @function Chart.Interaction.modes.y
         * @param chart {chart} the chart we are returning items from
         * @param e {Event} the event we are find things at
         * @param options {IInteractionOptions} options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        y: function y(chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        }
      }
    };
    /***/
  },

  /***/
  "./node_modules/chart.js/src/core/core.js":
  /*!************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    defaults._set('global', {
      responsive: true,
      responsiveAnimationDuration: 0,
      maintainAspectRatio: true,
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null,
        mode: 'nearest',
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      showLines: true,
      // Element defaults defined in element extensions
      elements: {},
      // Layout options such as padding
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });

    module.exports = function () {
      // Occupy the global variable of Chart, and create a simple base class
      var Chart = function Chart(item, config) {
        this.construct(item, config);
        return this;
      };

      Chart.Chart = Chart;
      return Chart;
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.layoutService.js":
  /*!**************************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.layoutService.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreLayoutServiceJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    module.exports = function (Chart) {
      function filterByPosition(array, position) {
        return helpers.where(array, function (v) {
          return v.position === position;
        });
      }

      function sortByWeight(array, reverse) {
        array.forEach(function (v, i) {
          v._tmpIndex_ = i;
          return v;
        });
        array.sort(function (a, b) {
          var v0 = reverse ? b : a;
          var v1 = reverse ? a : b;
          return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
        });
        array.forEach(function (v) {
          delete v._tmpIndex_;
        });
      }
      /**
       * @interface ILayoutItem
       * @prop {String} position - The position of the item in the chart layout. Possible values are
       * 'left', 'top', 'right', 'bottom', and 'chartArea'
       * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
       * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
       * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
       * @prop {Function} update - Takes two parameters: width and height. Returns size of item
       * @prop {Function} getPadding -  Returns an object with padding on the edges
       * @prop {Number} width - Width of item. Must be valid after update()
       * @prop {Number} height - Height of item. Must be valid after update()
       * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
       * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
       * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
       * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
       */
      // The layout service is very self explanatory.  It's responsible for the layout within a chart.
      // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
      // It is this service's responsibility of carrying out that layout.


      Chart.layoutService = {
        defaults: {},

        /**
         * Register a box to a chart.
         * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
         * @param {Chart} chart - the chart to use
         * @param {ILayoutItem} item - the item to add to be layed out
         */
        addBox: function addBox(chart, item) {
          if (!chart.boxes) {
            chart.boxes = [];
          } // initialize item with default values


          item.fullWidth = item.fullWidth || false;
          item.position = item.position || 'top';
          item.weight = item.weight || 0;
          chart.boxes.push(item);
        },

        /**
         * Remove a layoutItem from a chart
         * @param {Chart} chart - the chart to remove the box from
         * @param {Object} layoutItem - the item to remove from the layout
         */
        removeBox: function removeBox(chart, layoutItem) {
          var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

          if (index !== -1) {
            chart.boxes.splice(index, 1);
          }
        },

        /**
         * Sets (or updates) options on the given `item`.
         * @param {Chart} chart - the chart in which the item lives (or will be added to)
         * @param {Object} item - the item to configure with the given options
         * @param {Object} options - the new item options.
         */
        configure: function configure(chart, item, options) {
          var props = ['fullWidth', 'position', 'weight'];
          var ilen = props.length;
          var i = 0;
          var prop;

          for (; i < ilen; ++i) {
            prop = props[i];

            if (options.hasOwnProperty(prop)) {
              item[prop] = options[prop];
            }
          }
        },

        /**
         * Fits boxes of the given chart into the given size by having each box measure itself
         * then running a fitting algorithm
         * @param {Chart} chart - the chart
         * @param {Number} width - the width to fit into
         * @param {Number} height - the height to fit into
         */
        update: function update(chart, width, height) {
          if (!chart) {
            return;
          }

          var layoutOptions = chart.options.layout || {};
          var padding = helpers.options.toPadding(layoutOptions.padding);
          var leftPadding = padding.left;
          var rightPadding = padding.right;
          var topPadding = padding.top;
          var bottomPadding = padding.bottom;
          var leftBoxes = filterByPosition(chart.boxes, 'left');
          var rightBoxes = filterByPosition(chart.boxes, 'right');
          var topBoxes = filterByPosition(chart.boxes, 'top');
          var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
          var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

          sortByWeight(leftBoxes, true);
          sortByWeight(rightBoxes, false);
          sortByWeight(topBoxes, true);
          sortByWeight(bottomBoxes, false); // Essentially we now have any number of boxes on each of the 4 sides.
          // Our canvas looks like the following.
          // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
          // B1 is the bottom axis
          // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
          // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
          // an error will be thrown.
          //
          // |----------------------------------------------------|
          // |                  T1 (Full Width)                   |
          // |----------------------------------------------------|
          // |    |    |                 T2                  |    |
          // |    |----|-------------------------------------|----|
          // |    |    | C1 |                           | C2 |    |
          // |    |    |----|                           |----|    |
          // |    |    |                                     |    |
          // | L1 | L2 |           ChartArea (C0)            | R1 |
          // |    |    |                                     |    |
          // |    |    |----|                           |----|    |
          // |    |    | C3 |                           | C4 |    |
          // |    |----|-------------------------------------|----|
          // |    |    |                 B1                  |    |
          // |----------------------------------------------------|
          // |                  B2 (Full Width)                   |
          // |----------------------------------------------------|
          //
          // What we do to find the best sizing, we do the following
          // 1. Determine the minimum size of the chart area.
          // 2. Split the remaining width equally between each vertical axis
          // 3. Split the remaining height equally between each horizontal axis
          // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
          // 5. Adjust the sizes of each axis based on it's minimum reported size.
          // 6. Refit each axis
          // 7. Position each axis in the final location
          // 8. Tell the chart the final location of the chart area
          // 9. Tell any axes that overlay the chart area the positions of the chart area
          // Step 1

          var chartWidth = width - leftPadding - rightPadding;
          var chartHeight = height - topPadding - bottomPadding;
          var chartAreaWidth = chartWidth / 2; // min 50%

          var chartAreaHeight = chartHeight / 2; // min 50%
          // Step 2

          var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length); // Step 3

          var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length); // Step 4

          var maxChartAreaWidth = chartWidth;
          var maxChartAreaHeight = chartHeight;
          var minBoxSizes = [];

          function getMinimumBoxSize(box) {
            var minSize;
            var isHorizontal = box.isHorizontal();

            if (isHorizontal) {
              minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
              maxChartAreaHeight -= minSize.height;
            } else {
              minSize = box.update(verticalBoxWidth, chartAreaHeight);
              maxChartAreaWidth -= minSize.width;
            }

            minBoxSizes.push({
              horizontal: isHorizontal,
              minSize: minSize,
              box: box
            });
          }

          helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

          var maxHorizontalLeftPadding = 0;
          var maxHorizontalRightPadding = 0;
          var maxVerticalTopPadding = 0;
          var maxVerticalBottomPadding = 0;
          helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {
            if (horizontalBox.getPadding) {
              var boxPadding = horizontalBox.getPadding();
              maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
              maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
            }
          });
          helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {
            if (verticalBox.getPadding) {
              var boxPadding = verticalBox.getPadding();
              maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
              maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
            }
          }); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
          // be if the axes are drawn at their minimum sizes.
          // Steps 5 & 6

          var totalLeftBoxesWidth = leftPadding;
          var totalRightBoxesWidth = rightPadding;
          var totalTopBoxesHeight = topPadding;
          var totalBottomBoxesHeight = bottomPadding; // Function to fit a box

          function fitBox(box) {
            var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
              return minBox.box === box;
            });

            if (minBoxSize) {
              if (box.isHorizontal()) {
                var scaleMargin = {
                  left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
                  right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
                  top: 0,
                  bottom: 0
                }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
                // on the margin. Sometimes they need to increase in size slightly

                box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
              } else {
                box.update(minBoxSize.minSize.width, maxChartAreaHeight);
              }
            }
          } // Update, and calculate the left and right margins for the horizontal boxes


          helpers.each(leftBoxes.concat(rightBoxes), fitBox);
          helpers.each(leftBoxes, function (box) {
            totalLeftBoxesWidth += box.width;
          });
          helpers.each(rightBoxes, function (box) {
            totalRightBoxesWidth += box.width;
          }); // Set the Left and Right margins for the horizontal boxes

          helpers.each(topBoxes.concat(bottomBoxes), fitBox); // Figure out how much margin is on the top and bottom of the vertical boxes

          helpers.each(topBoxes, function (box) {
            totalTopBoxesHeight += box.height;
          });
          helpers.each(bottomBoxes, function (box) {
            totalBottomBoxesHeight += box.height;
          });

          function finalFitVerticalBox(box) {
            var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
              return minSize.box === box;
            });
            var scaleMargin = {
              left: 0,
              right: 0,
              top: totalTopBoxesHeight,
              bottom: totalBottomBoxesHeight
            };

            if (minBoxSize) {
              box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
            }
          } // Let the left layout know the final margin


          helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

          totalLeftBoxesWidth = leftPadding;
          totalRightBoxesWidth = rightPadding;
          totalTopBoxesHeight = topPadding;
          totalBottomBoxesHeight = bottomPadding;
          helpers.each(leftBoxes, function (box) {
            totalLeftBoxesWidth += box.width;
          });
          helpers.each(rightBoxes, function (box) {
            totalRightBoxesWidth += box.width;
          });
          helpers.each(topBoxes, function (box) {
            totalTopBoxesHeight += box.height;
          });
          helpers.each(bottomBoxes, function (box) {
            totalBottomBoxesHeight += box.height;
          }); // We may be adding some padding to account for rotated x axis labels

          var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
          totalLeftBoxesWidth += leftPaddingAddition;
          totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
          var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
          totalTopBoxesHeight += topPaddingAddition;
          totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
          // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
          // without calling `fit` again

          var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
          var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

          if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
            helpers.each(leftBoxes, function (box) {
              box.height = newMaxChartAreaHeight;
            });
            helpers.each(rightBoxes, function (box) {
              box.height = newMaxChartAreaHeight;
            });
            helpers.each(topBoxes, function (box) {
              if (!box.fullWidth) {
                box.width = newMaxChartAreaWidth;
              }
            });
            helpers.each(bottomBoxes, function (box) {
              if (!box.fullWidth) {
                box.width = newMaxChartAreaWidth;
              }
            });
            maxChartAreaHeight = newMaxChartAreaHeight;
            maxChartAreaWidth = newMaxChartAreaWidth;
          } // Step 7 - Position the boxes


          var left = leftPadding + leftPaddingAddition;
          var top = topPadding + topPaddingAddition;

          function placeBox(box) {
            if (box.isHorizontal()) {
              box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
              box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
              box.top = top;
              box.bottom = top + box.height; // Move to next point

              top = box.bottom;
            } else {
              box.left = left;
              box.right = left + box.width;
              box.top = totalTopBoxesHeight;
              box.bottom = totalTopBoxesHeight + maxChartAreaHeight; // Move to next point

              left = box.right;
            }
          }

          helpers.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

          left += maxChartAreaWidth;
          top += maxChartAreaHeight;
          helpers.each(rightBoxes, placeBox);
          helpers.each(bottomBoxes, placeBox); // Step 8

          chart.chartArea = {
            left: totalLeftBoxesWidth,
            top: totalTopBoxesHeight,
            right: totalLeftBoxesWidth + maxChartAreaWidth,
            bottom: totalTopBoxesHeight + maxChartAreaHeight
          }; // Step 9

          helpers.each(chartAreaBoxes, function (box) {
            box.left = chart.chartArea.left;
            box.top = chart.chartArea.top;
            box.right = chart.chartArea.right;
            box.bottom = chart.chartArea.bottom;
            box.update(maxChartAreaWidth, maxChartAreaHeight);
          });
        }
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.plugin.js":
  /*!*******************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.plugin.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCorePluginJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ./core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('global', {
      plugins: {}
    });

    module.exports = function (Chart) {
      /**
       * The plugin service singleton
       * @namespace Chart.plugins
       * @since 2.1.0
       */
      Chart.plugins = {
        /**
         * Globally registered plugins.
         * @private
         */
        _plugins: [],

        /**
         * This identifier is used to invalidate the descriptors cache attached to each chart
         * when a global plugin is registered or unregistered. In this case, the cache ID is
         * incremented and descriptors are regenerated during following API calls.
         * @private
         */
        _cacheId: 0,

        /**
         * Registers the given plugin(s) if not already registered.
         * @param {Array|Object} plugins plugin instance(s).
         */
        register: function register(plugins) {
          var p = this._plugins;
          [].concat(plugins).forEach(function (plugin) {
            if (p.indexOf(plugin) === -1) {
              p.push(plugin);
            }
          });
          this._cacheId++;
        },

        /**
         * Unregisters the given plugin(s) only if registered.
         * @param {Array|Object} plugins plugin instance(s).
         */
        unregister: function unregister(plugins) {
          var p = this._plugins;
          [].concat(plugins).forEach(function (plugin) {
            var idx = p.indexOf(plugin);

            if (idx !== -1) {
              p.splice(idx, 1);
            }
          });
          this._cacheId++;
        },

        /**
         * Remove all registered plugins.
         * @since 2.1.5
         */
        clear: function clear() {
          this._plugins = [];
          this._cacheId++;
        },

        /**
         * Returns the number of registered plugins?
         * @returns {Number}
         * @since 2.1.5
         */
        count: function count() {
          return this._plugins.length;
        },

        /**
         * Returns all registered plugin instances.
         * @returns {Array} array of plugin objects.
         * @since 2.1.5
         */
        getAll: function getAll() {
          return this._plugins;
        },

        /**
         * Calls enabled plugins for `chart` on the specified hook and with the given args.
         * This method immediately returns as soon as a plugin explicitly returns false. The
         * returned value can be used, for instance, to interrupt the current action.
         * @param {Object} chart - The chart instance for which plugins should be called.
         * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
         * @param {Array} [args] - Extra arguments to apply to the hook call.
         * @returns {Boolean} false if any of the plugins return false, else returns true.
         */
        notify: function notify(chart, hook, args) {
          var descriptors = this.descriptors(chart);
          var ilen = descriptors.length;
          var i, descriptor, plugin, params, method;

          for (i = 0; i < ilen; ++i) {
            descriptor = descriptors[i];
            plugin = descriptor.plugin;
            method = plugin[hook];

            if (typeof method === 'function') {
              params = [chart].concat(args || []);
              params.push(descriptor.options);

              if (method.apply(plugin, params) === false) {
                return false;
              }
            }
          }

          return true;
        },

        /**
         * Returns descriptors of enabled plugins for the given chart.
         * @returns {Array} [{ plugin, options }]
         * @private
         */
        descriptors: function descriptors(chart) {
          var cache = chart._plugins || (chart._plugins = {});

          if (cache.id === this._cacheId) {
            return cache.descriptors;
          }

          var plugins = [];
          var descriptors = [];
          var config = chart && chart.config || {};
          var options = config.options && config.options.plugins || {};

          this._plugins.concat(config.plugins || []).forEach(function (plugin) {
            var idx = plugins.indexOf(plugin);

            if (idx !== -1) {
              return;
            }

            var id = plugin.id;
            var opts = options[id];

            if (opts === false) {
              return;
            }

            if (opts === true) {
              opts = helpers.clone(defaults.global.plugins[id]);
            }

            plugins.push(plugin);
            descriptors.push({
              plugin: plugin,
              options: opts || {}
            });
          });

          cache.descriptors = descriptors;
          cache.id = this._cacheId;
          return descriptors;
        }
      };
      /**
       * Plugin extension hooks.
       * @interface IPlugin
       * @since 2.1.0
       */

      /**
       * @method IPlugin#beforeInit
       * @desc Called before initializing `chart`.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#afterInit
       * @desc Called after `chart` has been initialized and before the first update.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#beforeUpdate
       * @desc Called before updating `chart`. If any plugin returns `false`, the update
       * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart update.
       */

      /**
       * @method IPlugin#afterUpdate
       * @desc Called after `chart` has been updated and before rendering. Note that this
       * hook will not be called if the chart update has been previously cancelled.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#beforeDatasetsUpdate
      	 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
       * the datasets update is cancelled until another `update` is triggered.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} false to cancel the datasets update.
       * @since version 2.1.5
       */

      /**
       * @method IPlugin#afterDatasetsUpdate
       * @desc Called after the `chart` datasets have been updated. Note that this hook
       * will not be called if the datasets update has been previously cancelled.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       * @since version 2.1.5
       */

      /**
       * @method IPlugin#beforeDatasetUpdate
      	 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
       * returns `false`, the datasets update is cancelled until another `update` is triggered.
       * @param {Chart} chart - The chart instance.
       * @param {Object} args - The call arguments.
       * @param {Number} args.index - The dataset index.
       * @param {Object} args.meta - The dataset metadata.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart datasets drawing.
       */

      /**
       * @method IPlugin#afterDatasetUpdate
      	 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
       * that this hook will not be called if the datasets update has been previously cancelled.
       * @param {Chart} chart - The chart instance.
       * @param {Object} args - The call arguments.
       * @param {Number} args.index - The dataset index.
       * @param {Object} args.meta - The dataset metadata.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#beforeLayout
       * @desc Called before laying out `chart`. If any plugin returns `false`,
       * the layout update is cancelled until another `update` is triggered.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart layout.
       */

      /**
       * @method IPlugin#afterLayout
       * @desc Called after the `chart` has been layed out. Note that this hook will not
       * be called if the layout update has been previously cancelled.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#beforeRender
       * @desc Called before rendering `chart`. If any plugin returns `false`,
       * the rendering is cancelled until another `render` is triggered.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart rendering.
       */

      /**
       * @method IPlugin#afterRender
       * @desc Called after the `chart` has been fully rendered (and animation completed). Note
       * that this hook will not be called if the rendering has been previously cancelled.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#beforeDraw
       * @desc Called before drawing `chart` at every animation frame specified by the given
       * easing value. If any plugin returns `false`, the frame drawing is cancelled until
       * another `render` is triggered.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart drawing.
       */

      /**
       * @method IPlugin#afterDraw
       * @desc Called after the `chart` has been drawn for the specific easing value. Note
       * that this hook will not be called if the drawing has been previously cancelled.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#beforeDatasetsDraw
      	 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
       * the datasets drawing is cancelled until another `render` is triggered.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart datasets drawing.
       */

      /**
       * @method IPlugin#afterDatasetsDraw
       * @desc Called after the `chart` datasets have been drawn. Note that this hook
       * will not be called if the datasets drawing has been previously cancelled.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#beforeDatasetDraw
      	 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
       * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
       * is cancelled until another `render` is triggered.
       * @param {Chart} chart - The chart instance.
       * @param {Object} args - The call arguments.
       * @param {Number} args.index - The dataset index.
       * @param {Object} args.meta - The dataset metadata.
       * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart datasets drawing.
       */

      /**
       * @method IPlugin#afterDatasetDraw
      	 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
       * (datasets are drawn in the reverse order). Note that this hook will not be called
       * if the datasets drawing has been previously cancelled.
       * @param {Chart} chart - The chart instance.
       * @param {Object} args - The call arguments.
       * @param {Number} args.index - The dataset index.
       * @param {Object} args.meta - The dataset metadata.
       * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
       * @param {Object} options - The plugin options.
       */

      /**
       	 * @method IPlugin#beforeTooltipDraw
       * @desc Called before drawing the `tooltip`. If any plugin returns `false`,
       * the tooltip drawing is cancelled until another `render` is triggered.
       * @param {Chart} chart - The chart instance.
       * @param {Object} args - The call arguments.
       * @param {Object} args.tooltip - The tooltip.
       * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
       * @param {Object} options - The plugin options.
       * @returns {Boolean} `false` to cancel the chart tooltip drawing.
       	 */

      /**
      	 * @method IPlugin#afterTooltipDraw
       	 * @desc Called after drawing the `tooltip`. Note that this hook will not
      	 * be called if the tooltip drawing has been previously cancelled.
      	 * @param {Chart} chart - The chart instance.
      	 * @param {Object} args - The call arguments.
      	 * @param {Object} args.tooltip - The tooltip.
       * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
      	 * @param {Object} options - The plugin options.
      	 */

      /**
       * @method IPlugin#beforeEvent
      	 * @desc Called before processing the specified `event`. If any plugin returns `false`,
       * the event will be discarded.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {IEvent} event - The event object.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#afterEvent
       * @desc Called after the `event` has been consumed. Note that this hook
       * will not be called if the `event` has been previously discarded.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {IEvent} event - The event object.
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#resize
       * @desc Called after the chart as been resized.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
       * @param {Object} options - The plugin options.
       */

      /**
       * @method IPlugin#destroy
       * @desc Called after the chart as been destroyed.
       * @param {Chart.Controller} chart - The chart instance.
       * @param {Object} options - The plugin options.
       */

      /**
       * Provided for backward compatibility, use Chart.plugins instead
       * @namespace Chart.pluginService
       * @deprecated since version 2.1.5
       * @todo remove at version 3
       * @private
       */

      Chart.pluginService = Chart.plugins;
      /**
       * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
       * effect, instead simply create/register plugins via plain JavaScript objects.
       * @interface Chart.PluginBase
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */

      Chart.PluginBase = Element.extend({});
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.scale.js":
  /*!******************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.scale.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreScaleJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ./core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var Ticks = __webpack_require__(
    /*! ./core.ticks */
    "./node_modules/chart.js/src/core/core.ticks.js");

    defaults._set('scale', {
      display: true,
      position: 'left',
      offset: false,
      // grid line settings
      gridLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: 'rgba(0,0,0,0.25)',
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0.0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0.0
      },
      // scale label
      scaleLabel: {
        // display property
        display: false,
        // actual label
        labelString: '',
        // line height
        lineHeight: 1.2,
        // top/bottom padding
        padding: {
          top: 4,
          bottom: 4
        }
      },
      // label settings
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
        callback: Ticks.formatters.values,
        minor: {},
        major: {}
      }
    });

    function labelsFromTicks(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(ticks[i].label);
      }

      return labels;
    }

    function getLineValue(scale, index, offsetGridLines) {
      var lineValue = scale.getPixelForTick(index);

      if (offsetGridLines) {
        if (index === 0) {
          lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
        }
      }

      return lineValue;
    }

    module.exports = function (Chart) {
      function computeTextSize(context, tick, font) {
        return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;
      }

      function parseFontOptions(options) {
        var valueOrDefault = helpers.valueOrDefault;
        var globalDefaults = defaults.global;
        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
        var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
        var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
        return {
          size: size,
          style: style,
          family: family,
          font: helpers.fontString(size, style, family)
        };
      }

      function parseLineHeight(options) {
        return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
      }

      Chart.Scale = Element.extend({
        /**
         * Get the padding needed for the scale
         * @method getPadding
         * @private
         * @returns {Padding} the necessary padding
         */
        getPadding: function getPadding() {
          var me = this;
          return {
            left: me.paddingLeft || 0,
            top: me.paddingTop || 0,
            right: me.paddingRight || 0,
            bottom: me.paddingBottom || 0
          };
        },

        /**
         * Returns the scale tick objects ({label, major})
         * @since 2.7
         */
        getTicks: function getTicks() {
          return this._ticks;
        },
        // These methods are ordered by lifecyle. Utilities then follow.
        // Any function defined here is inherited by all scale types.
        // Any function can be extended by the scale type
        mergeTicksOptions: function mergeTicksOptions() {
          var ticks = this.options.ticks;

          if (ticks.minor === false) {
            ticks.minor = {
              display: false
            };
          }

          if (ticks.major === false) {
            ticks.major = {
              display: false
            };
          }

          for (var key in ticks) {
            if (key !== 'major' && key !== 'minor') {
              if (typeof ticks.minor[key] === 'undefined') {
                ticks.minor[key] = ticks[key];
              }

              if (typeof ticks.major[key] === 'undefined') {
                ticks.major[key] = ticks[key];
              }
            }
          }
        },
        beforeUpdate: function beforeUpdate() {
          helpers.callback(this.options.beforeUpdate, [this]);
        },
        update: function update(maxWidth, maxHeight, margins) {
          var me = this;
          var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

          me.beforeUpdate(); // Absorb the master measurements

          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = helpers.extend({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          me.longestTextCache = me.longestTextCache || {}; // Dimensions

          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions(); // Data min/max

          me.beforeDataLimits();
          me.determineDataLimits();
          me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
          // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
          // and must not be accessed directly from outside this class. `this.ticks` being
          // around for long time and not marked as private, we can't change its structure
          // without unexpected breaking changes. If you need to access the scale ticks,
          // use scale.getTicks() instead.

          me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
          // we still support no return (`this.ticks` internally set by calling this method).

          ticks = me.buildTicks() || [];
          me.afterBuildTicks();
          me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
          // COMPAT, we still support no return (`this.ticks` internally changed by calling
          // this method and supposed to contain only string values).

          labels = me.convertTicksToLabels(ticks) || me.ticks;
          me.afterTickToLabelConversion();
          me.ticks = labels; // BACKWARD COMPATIBILITY
          // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
          // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            tick = ticks[i];

            if (!tick) {
              ticks.push(tick = {
                label: label,
                major: false
              });
            } else {
              tick.label = label;
            }
          }

          me._ticks = ticks; // Tick Rotation

          me.beforeCalculateTickRotation();
          me.calculateTickRotation();
          me.afterCalculateTickRotation(); // Fit

          me.beforeFit();
          me.fit();
          me.afterFit(); //

          me.afterUpdate();
          return me.minSize;
        },
        afterUpdate: function afterUpdate() {
          helpers.callback(this.options.afterUpdate, [this]);
        },
        //
        beforeSetDimensions: function beforeSetDimensions() {
          helpers.callback(this.options.beforeSetDimensions, [this]);
        },
        setDimensions: function setDimensions() {
          var me = this; // Set the unconstrained dimension before label rotation

          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight; // Reset position before calculating rotation

            me.top = 0;
            me.bottom = me.height;
          } // Reset padding


          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0;
        },
        afterSetDimensions: function afterSetDimensions() {
          helpers.callback(this.options.afterSetDimensions, [this]);
        },
        // Data limits
        beforeDataLimits: function beforeDataLimits() {
          helpers.callback(this.options.beforeDataLimits, [this]);
        },
        determineDataLimits: helpers.noop,
        afterDataLimits: function afterDataLimits() {
          helpers.callback(this.options.afterDataLimits, [this]);
        },
        //
        beforeBuildTicks: function beforeBuildTicks() {
          helpers.callback(this.options.beforeBuildTicks, [this]);
        },
        buildTicks: helpers.noop,
        afterBuildTicks: function afterBuildTicks() {
          helpers.callback(this.options.afterBuildTicks, [this]);
        },
        beforeTickToLabelConversion: function beforeTickToLabelConversion() {
          helpers.callback(this.options.beforeTickToLabelConversion, [this]);
        },
        convertTicksToLabels: function convertTicksToLabels() {
          var me = this; // Convert ticks to strings

          var tickOpts = me.options.ticks;
          me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
        },
        afterTickToLabelConversion: function afterTickToLabelConversion() {
          helpers.callback(this.options.afterTickToLabelConversion, [this]);
        },
        //
        beforeCalculateTickRotation: function beforeCalculateTickRotation() {
          helpers.callback(this.options.beforeCalculateTickRotation, [this]);
        },
        calculateTickRotation: function calculateTickRotation() {
          var me = this;
          var context = me.ctx;
          var tickOpts = me.options.ticks;
          var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
          // between x offsets between 0 and 1.

          var tickFont = parseFontOptions(tickOpts);
          context.font = tickFont.font;
          var labelRotation = tickOpts.minRotation || 0;

          if (labels.length && me.options.display && me.isHorizontal()) {
            var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
            var labelWidth = originalLabelWidth;
            var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

            var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

            while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
              var angleRadians = helpers.toRadians(labelRotation);
              cosRotation = Math.cos(angleRadians);
              sinRotation = Math.sin(angleRadians);

              if (sinRotation * originalLabelWidth > me.maxHeight) {
                // go back one step
                labelRotation--;
                break;
              }

              labelRotation++;
              labelWidth = cosRotation * originalLabelWidth;
            }
          }

          me.labelRotation = labelRotation;
        },
        afterCalculateTickRotation: function afterCalculateTickRotation() {
          helpers.callback(this.options.afterCalculateTickRotation, [this]);
        },
        //
        beforeFit: function beforeFit() {
          helpers.callback(this.options.beforeFit, [this]);
        },
        fit: function fit() {
          var me = this; // Reset

          var minSize = me.minSize = {
            width: 0,
            height: 0
          };
          var labels = labelsFromTicks(me._ticks);
          var opts = me.options;
          var tickOpts = opts.ticks;
          var scaleLabelOpts = opts.scaleLabel;
          var gridLineOpts = opts.gridLines;
          var display = opts.display;
          var isHorizontal = me.isHorizontal();
          var tickFont = parseFontOptions(tickOpts);
          var tickMarkLength = opts.gridLines.tickMarkLength; // Width

          if (isHorizontal) {
            // subtract the margins to line up with the chartArea if we are a full width scale
            minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
          } else {
            minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
          } // height


          if (isHorizontal) {
            minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
          } else {
            minSize.height = me.maxHeight; // fill all the height
          } // Are we showing a title for the scale?


          if (scaleLabelOpts.display && display) {
            var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
            var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
            var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

            if (isHorizontal) {
              minSize.height += deltaHeight;
            } else {
              minSize.width += deltaHeight;
            }
          } // Don't bother fitting the ticks if we are not showing them


          if (tickOpts.display && display) {
            var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
            var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
            var lineSpace = tickFont.size * 0.5;
            var tickPadding = me.options.ticks.padding;

            if (isHorizontal) {
              // A horizontal axis is more constrained by the height.
              me.longestLabelWidth = largestTextWidth;
              var angleRadians = helpers.toRadians(me.labelRotation);
              var cosRotation = Math.cos(angleRadians);
              var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

              var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace; // padding

              minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
              me.ctx.font = tickFont.font;
              var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
              var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font); // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
              // which means that the right padding is dominated by the font height

              if (me.labelRotation !== 0) {
                me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges

                me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;
              } else {
                me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges

                me.paddingRight = lastLabelWidth / 2 + 3;
              }
            } else {
              // A vertical axis is more constrained by the width. Labels are the
              // dominant factor here, so get that length first and account for padding
              if (tickOpts.mirror) {
                largestTextWidth = 0;
              } else {
                // use lineSpace for consistency with horizontal axis
                // tickPadding is not implemented for horizontal
                largestTextWidth += tickPadding + lineSpace;
              }

              minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
              me.paddingTop = tickFont.size / 2;
              me.paddingBottom = tickFont.size / 2;
            }
          }

          me.handleMargins();
          me.width = minSize.width;
          me.height = minSize.height;
        },

        /**
         * Handle margins and padding interactions
         * @private
         */
        handleMargins: function handleMargins() {
          var me = this;

          if (me.margins) {
            me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
            me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
            me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
            me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
          }
        },
        afterFit: function afterFit() {
          helpers.callback(this.options.afterFit, [this]);
        },
        // Shared Methods
        isHorizontal: function isHorizontal() {
          return this.options.position === 'top' || this.options.position === 'bottom';
        },
        isFullWidth: function isFullWidth() {
          return this.options.fullWidth;
        },
        // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
        getRightValue: function getRightValue(rawValue) {
          // Null and undefined values first
          if (helpers.isNullOrUndef(rawValue)) {
            return NaN;
          } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


          if (typeof rawValue === 'number' && !isFinite(rawValue)) {
            return NaN;
          } // If it is in fact an object, dive in one more level


          if (rawValue) {
            if (this.isHorizontal()) {
              if (rawValue.x !== undefined) {
                return this.getRightValue(rawValue.x);
              }
            } else if (rawValue.y !== undefined) {
              return this.getRightValue(rawValue.y);
            }
          } // Value is good, return it


          return rawValue;
        },

        /**
         * Used to get the value to display in the tooltip for the data at the given index
         * @param index
         * @param datasetIndex
         */
        getLabelForIndex: helpers.noop,

        /**
         * Returns the location of the given data point. Value can either be an index or a numerical value
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         * @param value
         * @param index
         * @param datasetIndex
         */
        getPixelForValue: helpers.noop,

        /**
         * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         * @param pixel
         */
        getValueForPixel: helpers.noop,

        /**
         * Returns the location of the tick at the given index
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
        getPixelForTick: function getPixelForTick(index) {
          var me = this;
          var offset = me.options.offset;

          if (me.isHorizontal()) {
            var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
            var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
            var pixel = tickWidth * index + me.paddingLeft;

            if (offset) {
              pixel += tickWidth / 2;
            }

            var finalVal = me.left + Math.round(pixel);
            finalVal += me.isFullWidth() ? me.margins.left : 0;
            return finalVal;
          }

          var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
          return me.top + index * (innerHeight / (me._ticks.length - 1));
        },

        /**
         * Utility for getting the pixel location of a percentage of scale
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
        getPixelForDecimal: function getPixelForDecimal(decimal) {
          var me = this;

          if (me.isHorizontal()) {
            var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
            var valueOffset = innerWidth * decimal + me.paddingLeft;
            var finalVal = me.left + Math.round(valueOffset);
            finalVal += me.isFullWidth() ? me.margins.left : 0;
            return finalVal;
          }

          return me.top + decimal * me.height;
        },

        /**
         * Returns the pixel for the minimum chart value
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
        getBasePixel: function getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        },
        getBaseValue: function getBaseValue() {
          var me = this;
          var min = me.min;
          var max = me.max;
          return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        },

        /**
         * Returns a subset of ticks to be plotted to avoid overlapping labels.
         * @private
         */
        _autoSkip: function _autoSkip(ticks) {
          var skipRatio;
          var me = this;
          var isHorizontal = me.isHorizontal();
          var optionTicks = me.options.ticks.minor;
          var tickCount = ticks.length;
          var labelRotationRadians = helpers.toRadians(me.labelRotation);
          var cosRotation = Math.cos(labelRotationRadians);
          var longestRotatedLabel = me.longestLabelWidth * cosRotation;
          var result = [];
          var i, tick, shouldSkip; // figure out the maximum number of gridlines to show

          var maxTicks;

          if (optionTicks.maxTicksLimit) {
            maxTicks = optionTicks.maxTicksLimit;
          }

          if (isHorizontal) {
            skipRatio = false;

            if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {
              skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));
            } // if they defined a max number of optionTicks,
            // increase skipRatio until that number is met


            if (maxTicks && tickCount > maxTicks) {
              skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
            }
          }

          for (i = 0; i < tickCount; i++) {
            tick = ticks[i]; // Since we always show the last tick,we need may need to hide the last shown one before

            shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;

            if (shouldSkip && i !== tickCount - 1) {
              // leave tick in place but make sure it's not displayed (#4635)
              delete tick.label;
            }

            result.push(tick);
          }

          return result;
        },
        // Actually draw the scale on the canvas
        // @param {rectangle} chartArea : the area of the chart to draw full grid lines on
        draw: function draw(chartArea) {
          var me = this;
          var options = me.options;

          if (!options.display) {
            return;
          }

          var context = me.ctx;
          var globalDefaults = defaults.global;
          var optionTicks = options.ticks.minor;
          var optionMajorTicks = options.ticks.major || optionTicks;
          var gridLines = options.gridLines;
          var scaleLabel = options.scaleLabel;
          var isRotated = me.labelRotation !== 0;
          var isHorizontal = me.isHorizontal();
          var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
          var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
          var tickFont = parseFontOptions(optionTicks);
          var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
          var majorTickFont = parseFontOptions(optionMajorTicks);
          var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
          var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
          var scaleLabelFont = parseFontOptions(scaleLabel);
          var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
          var labelRotationRadians = helpers.toRadians(me.labelRotation);
          var itemsToDraw = [];
          var xTickStart = options.position === 'right' ? me.left : me.right - tl;
          var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
          var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
          var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;
          helpers.each(ticks, function (tick, index) {
            // autoskipper skipped this tick (#4635)
            if (helpers.isNullOrUndef(tick.label)) {
              return;
            }

            var label = tick.label;
            var lineWidth, lineColor, borderDash, borderDashOffset;

            if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
              // Draw the first index specially
              lineWidth = gridLines.zeroLineWidth;
              lineColor = gridLines.zeroLineColor;
              borderDash = gridLines.zeroLineBorderDash;
              borderDashOffset = gridLines.zeroLineBorderDashOffset;
            } else {
              lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
              lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
              borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
              borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
            } // Common properties


            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
            var textAlign = 'middle';
            var textBaseline = 'middle';
            var tickPadding = optionTicks.padding;

            if (isHorizontal) {
              var labelYOffset = tl + tickPadding;

              if (options.position === 'bottom') {
                // bottom
                textBaseline = !isRotated ? 'top' : 'middle';
                textAlign = !isRotated ? 'center' : 'right';
                labelY = me.top + labelYOffset;
              } else {
                // top
                textBaseline = !isRotated ? 'bottom' : 'middle';
                textAlign = !isRotated ? 'center' : 'left';
                labelY = me.bottom - labelYOffset;
              }

              var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);

              if (xLineValue < me.left) {
                lineColor = 'rgba(0,0,0,0)';
              }

              xLineValue += helpers.aliasPixel(lineWidth);
              labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

              tx1 = tx2 = x1 = x2 = xLineValue;
              ty1 = yTickStart;
              ty2 = yTickEnd;
              y1 = chartArea.top;
              y2 = chartArea.bottom;
            } else {
              var isLeft = options.position === 'left';
              var labelXOffset;

              if (optionTicks.mirror) {
                textAlign = isLeft ? 'left' : 'right';
                labelXOffset = tickPadding;
              } else {
                textAlign = isLeft ? 'right' : 'left';
                labelXOffset = tl + tickPadding;
              }

              labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;
              var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);

              if (yLineValue < me.top) {
                lineColor = 'rgba(0,0,0,0)';
              }

              yLineValue += helpers.aliasPixel(lineWidth);
              labelY = me.getPixelForTick(index) + optionTicks.labelOffset;
              tx1 = xTickStart;
              tx2 = xTickEnd;
              x1 = chartArea.left;
              x2 = chartArea.right;
              ty1 = ty2 = y1 = y2 = yLineValue;
            }

            itemsToDraw.push({
              tx1: tx1,
              ty1: ty1,
              tx2: tx2,
              ty2: ty2,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              labelX: labelX,
              labelY: labelY,
              glWidth: lineWidth,
              glColor: lineColor,
              glBorderDash: borderDash,
              glBorderDashOffset: borderDashOffset,
              rotation: -1 * labelRotationRadians,
              label: label,
              major: tick.major,
              textBaseline: textBaseline,
              textAlign: textAlign
            });
          }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

          helpers.each(itemsToDraw, function (itemToDraw) {
            if (gridLines.display) {
              context.save();
              context.lineWidth = itemToDraw.glWidth;
              context.strokeStyle = itemToDraw.glColor;

              if (context.setLineDash) {
                context.setLineDash(itemToDraw.glBorderDash);
                context.lineDashOffset = itemToDraw.glBorderDashOffset;
              }

              context.beginPath();

              if (gridLines.drawTicks) {
                context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
                context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
              }

              if (gridLines.drawOnChartArea) {
                context.moveTo(itemToDraw.x1, itemToDraw.y1);
                context.lineTo(itemToDraw.x2, itemToDraw.y2);
              }

              context.stroke();
              context.restore();
            }

            if (optionTicks.display) {
              // Make sure we draw text in the correct color and font
              context.save();
              context.translate(itemToDraw.labelX, itemToDraw.labelY);
              context.rotate(itemToDraw.rotation);
              context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
              context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
              context.textBaseline = itemToDraw.textBaseline;
              context.textAlign = itemToDraw.textAlign;
              var label = itemToDraw.label;

              if (helpers.isArray(label)) {
                for (var i = 0, y = 0; i < label.length; ++i) {
                  // We just make sure the multiline element is a string here..
                  context.fillText('' + label[i], 0, y); // apply same lineSpacing as calculated @ L#320

                  y += tickFont.size * 1.5;
                }
              } else {
                context.fillText(label, 0, 0);
              }

              context.restore();
            }
          });

          if (scaleLabel.display) {
            // Draw the scale label
            var scaleLabelX;
            var scaleLabelY;
            var rotation = 0;
            var halfLineHeight = parseLineHeight(scaleLabel) / 2;

            if (isHorizontal) {
              scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

              scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
            } else {
              var isLeft = options.position === 'left';
              scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
              scaleLabelY = me.top + (me.bottom - me.top) / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
            }

            context.save();
            context.translate(scaleLabelX, scaleLabelY);
            context.rotate(rotation);
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = scaleLabelFontColor; // render in correct colour

            context.font = scaleLabelFont.font;
            context.fillText(scaleLabel.labelString, 0, 0);
            context.restore();
          }

          if (gridLines.drawBorder) {
            // Draw the line at the edge of the axis
            context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
            context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
            var x1 = me.left;
            var x2 = me.right;
            var y1 = me.top;
            var y2 = me.bottom;
            var aliasPixel = helpers.aliasPixel(context.lineWidth);

            if (isHorizontal) {
              y1 = y2 = options.position === 'top' ? me.bottom : me.top;
              y1 += aliasPixel;
              y2 += aliasPixel;
            } else {
              x1 = x2 = options.position === 'left' ? me.right : me.left;
              x1 += aliasPixel;
              x2 += aliasPixel;
            }

            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.stroke();
          }
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.scaleService.js":
  /*!*************************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.scaleService.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreScaleServiceJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    module.exports = function (Chart) {
      Chart.scaleService = {
        // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
        // use the new chart options to grab the correct scale
        constructors: {},
        // Use a registration function so that we can move to an ES6 map when we no longer need to support
        // old browsers
        // Scale config defaults
        defaults: {},
        registerScaleType: function registerScaleType(type, scaleConstructor, scaleDefaults) {
          this.constructors[type] = scaleConstructor;
          this.defaults[type] = helpers.clone(scaleDefaults);
        },
        getScaleConstructor: function getScaleConstructor(type) {
          return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
        },
        getScaleDefaults: function getScaleDefaults(type) {
          // Return the scale defaults merged with the global settings so that we always use the latest ones
          return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
        },
        updateScaleDefaults: function updateScaleDefaults(type, additions) {
          var me = this;

          if (me.defaults.hasOwnProperty(type)) {
            me.defaults[type] = helpers.extend(me.defaults[type], additions);
          }
        },
        addScalesToLayout: function addScalesToLayout(chart) {
          // Adds each scale to the chart.boxes array to be sized accordingly
          helpers.each(chart.scales, function (scale) {
            // Set ILayoutItem parameters for backwards compatibility
            scale.fullWidth = scale.options.fullWidth;
            scale.position = scale.options.position;
            scale.weight = scale.options.weight;
            Chart.layoutService.addBox(chart, scale);
          });
        }
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/core/core.ticks.js":
  /*!******************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.ticks.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreTicksJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");
    /**
     * Namespace to hold static tick generation functions
     * @namespace Chart.Ticks
     */


    module.exports = {
      /**
       * Namespace to hold generators for different types of ticks
       * @namespace Chart.Ticks.generators
       */
      generators: {
        /**
         * Interface for the options provided to the numeric tick generator
         * @interface INumericTickGenerationOptions
         */

        /**
         * The maximum number of ticks to display
         * @name INumericTickGenerationOptions#maxTicks
         * @type Number
         */

        /**
         * The distance between each tick.
         * @name INumericTickGenerationOptions#stepSize
         * @type Number
         * @optional
         */

        /**
         * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
         * @name INumericTickGenerationOptions#min
         * @type Number
         * @optional
         */

        /**
         * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
         * @name INumericTickGenerationOptions#max
         * @type Number
         * @optional
         */

        /**
         * Generate a set of linear ticks
         * @method Chart.Ticks.generators.linear
         * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
         * @param dataRange {IRange} the range of the data
         * @returns {Array<Number>} array of tick values
         */
        linear: function linear(generationOptions, dataRange) {
          var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
          // "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
          // for details.

          var spacing;

          if (generationOptions.stepSize && generationOptions.stepSize > 0) {
            spacing = generationOptions.stepSize;
          } else {
            var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
            spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
          }

          var niceMin = Math.floor(dataRange.min / spacing) * spacing;
          var niceMax = Math.ceil(dataRange.max / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

          if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
            // If very close to our whole number, use it.
            if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
              niceMin = generationOptions.min;
              niceMax = generationOptions.max;
            }
          }

          var numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

          if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          } // Put the values into the ticks array


          ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);

          for (var j = 1; j < numSpaces; ++j) {
            ticks.push(niceMin + j * spacing);
          }

          ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
          return ticks;
        },

        /**
         * Generate a set of logarithmic ticks
         * @method Chart.Ticks.generators.logarithmic
         * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
         * @param dataRange {IRange} the range of the data
         * @returns {Array<Number>} array of tick values
         */
        logarithmic: function logarithmic(generationOptions, dataRange) {
          var ticks = [];
          var valueOrDefault = helpers.valueOrDefault; // Figure out what the max number of ticks we can support it is based on the size of
          // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
          // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
          // the graph

          var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
          var endExp = Math.floor(helpers.log10(dataRange.max));
          var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          var exp, significand;

          if (tickVal === 0) {
            exp = Math.floor(helpers.log10(dataRange.minNotZero));
            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
            ticks.push(tickVal);
            tickVal = significand * Math.pow(10, exp);
          } else {
            exp = Math.floor(helpers.log10(tickVal));
            significand = Math.floor(tickVal / Math.pow(10, exp));
          }

          do {
            ticks.push(tickVal);
            ++significand;

            if (significand === 10) {
              significand = 1;
              ++exp;
            }

            tickVal = significand * Math.pow(10, exp);
          } while (exp < endExp || exp === endExp && significand < endSignificand);

          var lastTick = valueOrDefault(generationOptions.max, tickVal);
          ticks.push(lastTick);
          return ticks;
        }
      },

      /**
       * Namespace to hold formatters for different types of ticks
       * @namespace Chart.Ticks.formatters
       */
      formatters: {
        /**
         * Formatter for value labels
         * @method Chart.Ticks.formatters.values
         * @param value the value to display
         * @return {String|Array} the label to display
         */
        values: function values(value) {
          return helpers.isArray(value) ? value : '' + value;
        },

        /**
         * Formatter for linear numeric ticks
         * @method Chart.Ticks.formatters.linear
         * @param tickValue {Number} the value to be formatted
         * @param index {Number} the position of the tickValue parameter in the ticks array
         * @param ticks {Array<Number>} the list of ticks being converted
         * @return {String} string representation of the tickValue parameter
         */
        linear: function linear(tickValue, index, ticks) {
          // If we have lots of ticks, don't use the ones
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              // not an integer
              delta = tickValue - Math.floor(tickValue);
            }
          }

          var logDelta = helpers.log10(Math.abs(delta));
          var tickString = '';

          if (tickValue !== 0) {
            var numDecimal = -1 * Math.floor(logDelta);
            numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

            tickString = tickValue.toFixed(numDecimal);
          } else {
            tickString = '0'; // never show decimal places for 0
          }

          return tickString;
        },
        logarithmic: function logarithmic(tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));

          if (tickValue === 0) {
            return '0';
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }

          return '';
        }
      }
    };
    /***/
  },

  /***/
  "./node_modules/chart.js/src/core/core.tooltip.js":
  /*!********************************************************!*\
    !*** ./node_modules/chart.js/src/core/core.tooltip.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcCoreCoreTooltipJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ./core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ./core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('global', {
      tooltips: {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers.noop,
          title: function title(tooltipItems, data) {
            // Pick first xLabel for now
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;

            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];

              if (item.xLabel) {
                title = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index];
              }
            }

            return title;
          },
          afterTitle: helpers.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers.noop,
          label: function label(tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || '';

            if (label) {
              label += ': ';
            }

            label += tooltipItem.yLabel;
            return label;
          },
          labelColor: function labelColor(tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function labelTextColor() {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers.noop,
          footer: helpers.noop,
          afterFooter: helpers.noop
        }
      }
    });

    module.exports = function (Chart) {
      /**
      	 * Helper method to merge the opacity into a color
      	 */
      function mergeOpacity(colorString, opacity) {
        var color = helpers.color(colorString);
        return color.alpha(opacity * color.alpha()).rgbaString();
      } // Helper to push or concat based on if the 2nd parameter is an array or not


      function pushOrConcat(base, toPush) {
        if (toPush) {
          if (helpers.isArray(toPush)) {
            // base = base.concat(toPush);
            Array.prototype.push.apply(base, toPush);
          } else {
            base.push(toPush);
          }
        }

        return base;
      } // Private helper to create a tooltip item model
      // @param element : the chart element (point, arc, bar) to create the tooltip item for
      // @return : new tooltip item


      function createTooltipItem(element) {
        var xScale = element._xScale;
        var yScale = element._yScale || element._scale; // handle radar || polarArea charts

        var index = element._index;
        var datasetIndex = element._datasetIndex;
        return {
          xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
          yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
          index: index,
          datasetIndex: datasetIndex,
          x: element._model.x,
          y: element._model.y
        };
      }
      /**
       * Helper to get the reset model for the tooltip
       * @param tooltipOpts {Object} the tooltip options
       */


      function getBaseModel(tooltipOpts) {
        var globalDefaults = defaults.global;
        var valueOrDefault = helpers.valueOrDefault;
        return {
          // Positioning
          xPadding: tooltipOpts.xPadding,
          yPadding: tooltipOpts.yPadding,
          xAlign: tooltipOpts.xAlign,
          yAlign: tooltipOpts.yAlign,
          // Body
          bodyFontColor: tooltipOpts.bodyFontColor,
          _bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
          _bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
          _bodyAlign: tooltipOpts.bodyAlign,
          bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
          bodySpacing: tooltipOpts.bodySpacing,
          // Title
          titleFontColor: tooltipOpts.titleFontColor,
          _titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
          _titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
          titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
          _titleAlign: tooltipOpts.titleAlign,
          titleSpacing: tooltipOpts.titleSpacing,
          titleMarginBottom: tooltipOpts.titleMarginBottom,
          // Footer
          footerFontColor: tooltipOpts.footerFontColor,
          _footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
          _footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
          footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
          _footerAlign: tooltipOpts.footerAlign,
          footerSpacing: tooltipOpts.footerSpacing,
          footerMarginTop: tooltipOpts.footerMarginTop,
          // Appearance
          caretSize: tooltipOpts.caretSize,
          cornerRadius: tooltipOpts.cornerRadius,
          backgroundColor: tooltipOpts.backgroundColor,
          opacity: 0,
          legendColorBackground: tooltipOpts.multiKeyBackground,
          displayColors: tooltipOpts.displayColors,
          borderColor: tooltipOpts.borderColor,
          borderWidth: tooltipOpts.borderWidth
        };
      }
      /**
       * Get the size of the tooltip
       */


      function getTooltipSize(tooltip, model) {
        var ctx = tooltip._chart.ctx;
        var height = model.yPadding * 2; // Tooltip Padding

        var width = 0; // Count of all lines in the body

        var body = model.body;
        var combinedBodyLength = body.reduce(function (count, bodyItem) {
          return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
        }, 0);
        combinedBodyLength += model.beforeBody.length + model.afterBody.length;
        var titleLineCount = model.title.length;
        var footerLineCount = model.footer.length;
        var titleFontSize = model.titleFontSize;
        var bodyFontSize = model.bodyFontSize;
        var footerFontSize = model.footerFontSize;
        height += titleLineCount * titleFontSize; // Title Lines

        height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

        height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

        height += combinedBodyLength * bodyFontSize; // Body Lines

        height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

        height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

        height += footerLineCount * footerFontSize; // Footer Lines

        height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
        // Title width

        var widthPadding = 0;

        var maxLineWidth = function maxLineWidth(line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };

        ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
        helpers.each(model.title, maxLineWidth); // Body width

        ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
        helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

        widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
        helpers.each(body, function (bodyItem) {
          helpers.each(bodyItem.before, maxLineWidth);
          helpers.each(bodyItem.lines, maxLineWidth);
          helpers.each(bodyItem.after, maxLineWidth);
        }); // Reset back to 0

        widthPadding = 0; // Footer width

        ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
        helpers.each(model.footer, maxLineWidth); // Add padding

        width += 2 * model.xPadding;
        return {
          width: width,
          height: height
        };
      }
      /**
       * Helper to get the alignment of a tooltip given the size
       */


      function determineAlignment(tooltip, size) {
        var model = tooltip._model;
        var chart = tooltip._chart;
        var chartArea = tooltip._chart.chartArea;
        var xAlign = 'center';
        var yAlign = 'center';

        if (model.y < size.height) {
          yAlign = 'top';
        } else if (model.y > chart.height - size.height) {
          yAlign = 'bottom';
        }

        var lf, rf; // functions to determine left, right alignment

        var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

        var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

        var midX = (chartArea.left + chartArea.right) / 2;
        var midY = (chartArea.top + chartArea.bottom) / 2;

        if (yAlign === 'center') {
          lf = function lf(x) {
            return x <= midX;
          };

          rf = function rf(x) {
            return x > midX;
          };
        } else {
          lf = function lf(x) {
            return x <= size.width / 2;
          };

          rf = function rf(x) {
            return x >= chart.width - size.width / 2;
          };
        }

        olf = function olf(x) {
          return x + size.width > chart.width;
        };

        orf = function orf(x) {
          return x - size.width < 0;
        };

        yf = function yf(y) {
          return y <= midY ? 'top' : 'bottom';
        };

        if (lf(model.x)) {
          xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

          if (olf(model.x)) {
            xAlign = 'center';
            yAlign = yf(model.y);
          }
        } else if (rf(model.x)) {
          xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

          if (orf(model.x)) {
            xAlign = 'center';
            yAlign = yf(model.y);
          }
        }

        var opts = tooltip._options;
        return {
          xAlign: opts.xAlign ? opts.xAlign : xAlign,
          yAlign: opts.yAlign ? opts.yAlign : yAlign
        };
      }
      /**
       * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
       */


      function getBackgroundPoint(vm, size, alignment) {
        // Background Position
        var x = vm.x;
        var y = vm.y;
        var caretSize = vm.caretSize;
        var caretPadding = vm.caretPadding;
        var cornerRadius = vm.cornerRadius;
        var xAlign = alignment.xAlign;
        var yAlign = alignment.yAlign;
        var paddingAndSize = caretSize + caretPadding;
        var radiusAndPadding = cornerRadius + caretPadding;

        if (xAlign === 'right') {
          x -= size.width;
        } else if (xAlign === 'center') {
          x -= size.width / 2;
        }

        if (yAlign === 'top') {
          y += paddingAndSize;
        } else if (yAlign === 'bottom') {
          y -= size.height + paddingAndSize;
        } else {
          y -= size.height / 2;
        }

        if (yAlign === 'center') {
          if (xAlign === 'left') {
            x += paddingAndSize;
          } else if (xAlign === 'right') {
            x -= paddingAndSize;
          }
        } else if (xAlign === 'left') {
          x -= radiusAndPadding;
        } else if (xAlign === 'right') {
          x += radiusAndPadding;
        }

        return {
          x: x,
          y: y
        };
      }

      Chart.Tooltip = Element.extend({
        initialize: function initialize() {
          this._model = getBaseModel(this._options);
          this._lastActive = [];
        },
        // Get the title
        // Args are: (tooltipItem, data)
        getTitle: function getTitle() {
          var me = this;
          var opts = me._options;
          var callbacks = opts.callbacks;
          var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
          var title = callbacks.title.apply(me, arguments);
          var afterTitle = callbacks.afterTitle.apply(me, arguments);
          var lines = [];
          lines = pushOrConcat(lines, beforeTitle);
          lines = pushOrConcat(lines, title);
          lines = pushOrConcat(lines, afterTitle);
          return lines;
        },
        // Args are: (tooltipItem, data)
        getBeforeBody: function getBeforeBody() {
          var lines = this._options.callbacks.beforeBody.apply(this, arguments);

          return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
        },
        // Args are: (tooltipItem, data)
        getBody: function getBody(tooltipItems, data) {
          var me = this;
          var callbacks = me._options.callbacks;
          var bodyItems = [];
          helpers.each(tooltipItems, function (tooltipItem) {
            var bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
            pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
            pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
            bodyItems.push(bodyItem);
          });
          return bodyItems;
        },
        // Args are: (tooltipItem, data)
        getAfterBody: function getAfterBody() {
          var lines = this._options.callbacks.afterBody.apply(this, arguments);

          return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
        },
        // Get the footer and beforeFooter and afterFooter lines
        // Args are: (tooltipItem, data)
        getFooter: function getFooter() {
          var me = this;
          var callbacks = me._options.callbacks;
          var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
          var footer = callbacks.footer.apply(me, arguments);
          var afterFooter = callbacks.afterFooter.apply(me, arguments);
          var lines = [];
          lines = pushOrConcat(lines, beforeFooter);
          lines = pushOrConcat(lines, footer);
          lines = pushOrConcat(lines, afterFooter);
          return lines;
        },
        update: function update(changed) {
          var me = this;
          var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
          // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
          // which breaks any animations.

          var existingModel = me._model;
          var model = me._model = getBaseModel(opts);
          var active = me._active;
          var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

          var alignment = {
            xAlign: existingModel.xAlign,
            yAlign: existingModel.yAlign
          };
          var backgroundPoint = {
            x: existingModel.x,
            y: existingModel.y
          };
          var tooltipSize = {
            width: existingModel.width,
            height: existingModel.height
          };
          var tooltipPosition = {
            x: existingModel.caretX,
            y: existingModel.caretY
          };
          var i, len;

          if (active.length) {
            model.opacity = 1;
            var labelColors = [];
            var labelTextColors = [];
            tooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);
            var tooltipItems = [];

            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(active[i]));
            } // If the user provided a filter function, use it to modify the tooltip items


            if (opts.filter) {
              tooltipItems = tooltipItems.filter(function (a) {
                return opts.filter(a, data);
              });
            } // If the user provided a sorting function, use it to modify the tooltip items


            if (opts.itemSort) {
              tooltipItems = tooltipItems.sort(function (a, b) {
                return opts.itemSort(a, b, data);
              });
            } // Determine colors for boxes


            helpers.each(tooltipItems, function (tooltipItem) {
              labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
              labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
            }); // Build the Text Lines

            model.title = me.getTitle(tooltipItems, data);
            model.beforeBody = me.getBeforeBody(tooltipItems, data);
            model.body = me.getBody(tooltipItems, data);
            model.afterBody = me.getAfterBody(tooltipItems, data);
            model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

            model.x = Math.round(tooltipPosition.x);
            model.y = Math.round(tooltipPosition.y);
            model.caretPadding = opts.caretPadding;
            model.labelColors = labelColors;
            model.labelTextColors = labelTextColors; // data points

            model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

            tooltipSize = getTooltipSize(this, model);
            alignment = determineAlignment(this, tooltipSize); // Final Size and Position

            backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
          } else {
            model.opacity = 0;
          }

          model.xAlign = alignment.xAlign;
          model.yAlign = alignment.yAlign;
          model.x = backgroundPoint.x;
          model.y = backgroundPoint.y;
          model.width = tooltipSize.width;
          model.height = tooltipSize.height; // Point where the caret on the tooltip points to

          model.caretX = tooltipPosition.x;
          model.caretY = tooltipPosition.y;
          me._model = model;

          if (changed && opts.custom) {
            opts.custom.call(me, model);
          }

          return me;
        },
        drawCaret: function drawCaret(tooltipPoint, size) {
          var ctx = this._chart.ctx;
          var vm = this._view;
          var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
        },
        getCaretPosition: function getCaretPosition(tooltipPoint, size, vm) {
          var x1, x2, x3, y1, y2, y3;
          var caretSize = vm.caretSize;
          var cornerRadius = vm.cornerRadius;
          var xAlign = vm.xAlign;
          var yAlign = vm.yAlign;
          var ptX = tooltipPoint.x;
          var ptY = tooltipPoint.y;
          var width = size.width;
          var height = size.height;

          if (yAlign === 'center') {
            y2 = ptY + height / 2;

            if (xAlign === 'left') {
              x1 = ptX;
              x2 = x1 - caretSize;
              x3 = x1;
              y1 = y2 + caretSize;
              y3 = y2 - caretSize;
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              x3 = x1;
              y1 = y2 - caretSize;
              y3 = y2 + caretSize;
            }
          } else {
            if (xAlign === 'left') {
              x2 = ptX + cornerRadius + caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else if (xAlign === 'right') {
              x2 = ptX + width - cornerRadius - caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else {
              x2 = ptX + width / 2;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            }

            if (yAlign === 'top') {
              y1 = ptY;
              y2 = y1 - caretSize;
              y3 = y1;
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              y3 = y1; // invert drawing order

              var tmp = x3;
              x3 = x1;
              x1 = tmp;
            }
          }

          return {
            x1: x1,
            x2: x2,
            x3: x3,
            y1: y1,
            y2: y2,
            y3: y3
          };
        },
        drawTitle: function drawTitle(pt, vm, ctx, opacity) {
          var title = vm.title;

          if (title.length) {
            ctx.textAlign = vm._titleAlign;
            ctx.textBaseline = 'top';
            var titleFontSize = vm.titleFontSize;
            var titleSpacing = vm.titleSpacing;
            ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
            ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
            var i, len;

            for (i = 0, len = title.length; i < len; ++i) {
              ctx.fillText(title[i], pt.x, pt.y);
              pt.y += titleFontSize + titleSpacing; // Line Height and spacing

              if (i + 1 === title.length) {
                pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
              }
            }
          }
        },
        drawBody: function drawBody(pt, vm, ctx, opacity) {
          var bodyFontSize = vm.bodyFontSize;
          var bodySpacing = vm.bodySpacing;
          var body = vm.body;
          ctx.textAlign = vm._bodyAlign;
          ctx.textBaseline = 'top';
          ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily); // Before Body

          var xLinePadding = 0;

          var fillLineOfText = function fillLineOfText(line) {
            ctx.fillText(line, pt.x + xLinePadding, pt.y);
            pt.y += bodyFontSize + bodySpacing;
          }; // Before body lines


          ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
          helpers.each(vm.beforeBody, fillLineOfText);
          var drawColorBoxes = vm.displayColors;
          xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0; // Draw body lines now

          helpers.each(body, function (bodyItem, i) {
            var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
            ctx.fillStyle = textColor;
            helpers.each(bodyItem.before, fillLineOfText);
            helpers.each(bodyItem.lines, function (line) {
              // Draw Legend-like boxes if needed
              if (drawColorBoxes) {
                // Fill a white rect so that colours merge nicely if the opacity is < 1
                ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
                ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize); // Border

                ctx.lineWidth = 1;
                ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
                ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize); // Inner square

                ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
                ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                ctx.fillStyle = textColor;
              }

              fillLineOfText(line);
            });
            helpers.each(bodyItem.after, fillLineOfText);
          }); // Reset back to 0 for after body

          xLinePadding = 0; // After body lines

          helpers.each(vm.afterBody, fillLineOfText);
          pt.y -= bodySpacing; // Remove last body spacing
        },
        drawFooter: function drawFooter(pt, vm, ctx, opacity) {
          var footer = vm.footer;

          if (footer.length) {
            pt.y += vm.footerMarginTop;
            ctx.textAlign = vm._footerAlign;
            ctx.textBaseline = 'top';
            ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
            ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
            helpers.each(footer, function (line) {
              ctx.fillText(line, pt.x, pt.y);
              pt.y += vm.footerFontSize + vm.footerSpacing;
            });
          }
        },
        drawBackground: function drawBackground(pt, vm, ctx, tooltipSize, opacity) {
          ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
          ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
          ctx.lineWidth = vm.borderWidth;
          var xAlign = vm.xAlign;
          var yAlign = vm.yAlign;
          var x = pt.x;
          var y = pt.y;
          var width = tooltipSize.width;
          var height = tooltipSize.height;
          var radius = vm.cornerRadius;
          ctx.beginPath();
          ctx.moveTo(x + radius, y);

          if (yAlign === 'top') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

          if (yAlign === 'center' && xAlign === 'right') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

          if (yAlign === 'bottom') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

          if (yAlign === 'center' && xAlign === 'left') {
            this.drawCaret(pt, tooltipSize);
          }

          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();

          if (vm.borderWidth > 0) {
            ctx.stroke();
          }
        },
        draw: function draw() {
          var ctx = this._chart.ctx;
          var vm = this._view;

          if (vm.opacity === 0) {
            return;
          }

          var tooltipSize = {
            width: vm.width,
            height: vm.height
          };
          var pt = {
            x: vm.x,
            y: vm.y
          }; // IE11/Edge does not like very small opacities, so snap to 0

          var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

          var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

          if (this._options.enabled && hasTooltipContent) {
            // Draw Background
            this.drawBackground(pt, vm, ctx, tooltipSize, opacity); // Draw Title, Body, and Footer

            pt.x += vm.xPadding;
            pt.y += vm.yPadding; // Titles

            this.drawTitle(pt, vm, ctx, opacity); // Body

            this.drawBody(pt, vm, ctx, opacity); // Footer

            this.drawFooter(pt, vm, ctx, opacity);
          }
        },

        /**
         * Handle an event
         * @private
         * @param {IEvent} event - The event to handle
         * @returns {Boolean} true if the tooltip changed
         */
        handleEvent: function handleEvent(e) {
          var me = this;
          var options = me._options;
          var changed = false;
          me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

          if (e.type === 'mouseout') {
            me._active = [];
          } else {
            me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
          } // Remember Last Actives


          changed = !helpers.arrayEquals(me._active, me._lastActive); // If tooltip didn't change, do not handle the target event

          if (!changed) {
            return false;
          }

          me._lastActive = me._active;

          if (options.enabled || options.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            var model = me._model;
            me.update(true);
            me.pivot(); // See if our tooltip position changed

            changed |= model.x !== me._model.x || model.y !== me._model.y;
          }

          return changed;
        }
      });
      /**
       * @namespace Chart.Tooltip.positioners
       */

      Chart.Tooltip.positioners = {
        /**
         * Average mode places the tooltip at the average position of the elements shown
         * @function Chart.Tooltip.positioners.average
         * @param elements {ChartElement[]} the elements being displayed in the tooltip
         * @returns {Point} tooltip position
         */
        average: function average(elements) {
          if (!elements.length) {
            return false;
          }

          var i, len;
          var x = 0;
          var y = 0;
          var count = 0;

          for (i = 0, len = elements.length; i < len; ++i) {
            var el = elements[i];

            if (el && el.hasValue()) {
              var pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count;
            }
          }

          return {
            x: Math.round(x / count),
            y: Math.round(y / count)
          };
        },

        /**
         * Gets the tooltip position nearest of the item nearest to the event position
         * @function Chart.Tooltip.positioners.nearest
         * @param elements {Chart.Element[]} the tooltip elements
         * @param eventPosition {Point} the position of the event in canvas coordinates
         * @returns {Point} the tooltip position
         */
        nearest: function nearest(elements, eventPosition) {
          var x = eventPosition.x;
          var y = eventPosition.y;
          var minDistance = Number.POSITIVE_INFINITY;
          var i, len, nearestElement;

          for (i = 0, len = elements.length; i < len; ++i) {
            var el = elements[i];

            if (el && el.hasValue()) {
              var center = el.getCenterPoint();
              var d = helpers.distanceBetweenPoints(eventPosition, center);

              if (d < minDistance) {
                minDistance = d;
                nearestElement = el;
              }
            }
          }

          if (nearestElement) {
            var tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
          }

          return {
            x: x,
            y: y
          };
        }
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/elements/element.arc.js":
  /*!***********************************************************!*\
    !*** ./node_modules/chart.js/src/elements/element.arc.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcElementsElementArcJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ../core/core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('global', {
      elements: {
        arc: {
          backgroundColor: defaults.global.defaultColor,
          borderColor: '#fff',
          borderWidth: 2
        }
      }
    });

    module.exports = Element.extend({
      inLabelRange: function inLabelRange(mouseX) {
        var vm = this._view;

        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }

        return false;
      },
      inRange: function inRange(chartX, chartY) {
        var vm = this._view;

        if (vm) {
          var pointRelativePosition = helpers.getAngleFromPoint(vm, {
            x: chartX,
            y: chartY
          });
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance; // Sanitise angle range

          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;

          while (endAngle < startAngle) {
            endAngle += 2.0 * Math.PI;
          }

          while (angle > endAngle) {
            angle -= 2.0 * Math.PI;
          }

          while (angle < startAngle) {
            angle += 2.0 * Math.PI;
          } // Check if within the range of the open/close angle


          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }

        return false;
      },
      getCenterPoint: function getCenterPoint() {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function getArea() {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function tooltipPosition() {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function draw() {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var sA = vm.startAngle;
        var eA = vm.endAngle;
        ctx.beginPath();
        ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
        ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
        ctx.closePath();
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fill();
        ctx.lineJoin = 'bevel';

        if (vm.borderWidth) {
          ctx.stroke();
        }
      }
    });
    /***/
  },

  /***/
  "./node_modules/chart.js/src/elements/element.line.js":
  /*!************************************************************!*\
    !*** ./node_modules/chart.js/src/elements/element.line.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcElementsElementLineJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ../core/core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var globalDefaults = defaults.global;

    defaults._set('global', {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: globalDefaults.defaultColor,
          borderWidth: 3,
          borderColor: globalDefaults.defaultColor,
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0.0,
          borderJoinStyle: 'miter',
          capBezierPoints: true,
          fill: true // do we fill in the area between the line and its base axis

        }
      }
    });

    module.exports = Element.extend({
      draw: function draw() {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;

        var points = me._children.slice(); // clone array


        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var index, current, previous, currentVM; // If we are looping, adding the first point again

        if (me._loop && points.length) {
          points.push(points[0]);
        }

        ctx.save(); // Stroke Line Options

        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }

        ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

        ctx.beginPath();
        lastDrawnIndex = -1;

        for (index = 0; index < points.length; ++index) {
          current = points[index];
          previous = helpers.previousItem(points, index);
          currentVM = current._view; // First point moves to it's starting position no matter what

          if (index === 0) {
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = index;
            }
          } else {
            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

            if (!currentVM.skip) {
              if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                // There was a gap and this is the first point after the gap
                ctx.moveTo(currentVM.x, currentVM.y);
              } else {
                // Line to next point
                helpers.canvas.lineTo(ctx, previous._view, current._view);
              }

              lastDrawnIndex = index;
            }
          }
        }

        ctx.stroke();
        ctx.restore();
      }
    });
    /***/
  },

  /***/
  "./node_modules/chart.js/src/elements/element.point.js":
  /*!*************************************************************!*\
    !*** ./node_modules/chart.js/src/elements/element.point.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcElementsElementPointJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ../core/core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var defaultColor = defaults.global.defaultColor;

    defaults._set('global', {
      elements: {
        point: {
          radius: 3,
          pointStyle: 'circle',
          backgroundColor: defaultColor,
          borderColor: defaultColor,
          borderWidth: 1,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });

    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
    }

    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
    }

    module.exports = Element.extend({
      inRange: function inRange(mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function getCenterPoint() {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function getArea() {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function tooltipPosition() {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function draw(chartArea) {
        var vm = this._view;
        var model = this._model;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var color = helpers.color;
        var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)

        var ratio = 0;

        if (vm.skip) {
          return;
        }

        ctx.strokeStyle = vm.borderColor || defaultColor;
        ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
        ctx.fillStyle = vm.backgroundColor || defaultColor; // Cliping for Points.
        // going out from inner charArea?

        if (chartArea !== undefined && (model.x < chartArea.left || chartArea.right * errMargin < model.x || model.y < chartArea.top || chartArea.bottom * errMargin < model.y)) {
          // Point fade out
          if (model.x < chartArea.left) {
            ratio = (x - model.x) / (chartArea.left - model.x);
          } else if (chartArea.right * errMargin < model.x) {
            ratio = (model.x - x) / (model.x - chartArea.right);
          } else if (model.y < chartArea.top) {
            ratio = (y - model.y) / (chartArea.top - model.y);
          } else if (chartArea.bottom * errMargin < model.y) {
            ratio = (model.y - y) / (model.y - chartArea.bottom);
          }

          ratio = Math.round(ratio * 100) / 100;
          ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
          ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
        }

        helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
      }
    });
    /***/
  },

  /***/
  "./node_modules/chart.js/src/elements/element.rectangle.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/chart.js/src/elements/element.rectangle.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcElementsElementRectangleJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ../core/core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    defaults._set('global', {
      elements: {
        rectangle: {
          backgroundColor: defaults.global.defaultColor,
          borderColor: defaults.global.defaultColor,
          borderSkipped: 'bottom',
          borderWidth: 0
        }
      }
    });

    function isVertical(bar) {
      return bar._view.width !== undefined;
    }
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param bar {Chart.Element.Rectangle} the bar
     * @return {Bounds} bounds of the bar
     * @private
     */


    function getBarBounds(bar) {
      var vm = bar._view;
      var x1, x2, y1, y2;

      if (isVertical(bar)) {
        // vertical
        var halfWidth = vm.width / 2;
        x1 = vm.x - halfWidth;
        x2 = vm.x + halfWidth;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        // horizontal bar
        var halfHeight = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - halfHeight;
        y2 = vm.y + halfHeight;
      }

      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    module.exports = Element.extend({
      draw: function draw() {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var left, right, top, bottom, signX, signY, borderSkipped;
        var borderWidth = vm.borderWidth;

        if (!vm.horizontal) {
          // bar
          left = vm.x - vm.width / 2;
          right = vm.x + vm.width / 2;
          top = vm.y;
          bottom = vm.base;
          signX = 1;
          signY = bottom > top ? 1 : -1;
          borderSkipped = vm.borderSkipped || 'bottom';
        } else {
          // horizontal bar
          left = vm.base;
          right = vm.x;
          top = vm.y - vm.height / 2;
          bottom = vm.y + vm.height / 2;
          signX = right > left ? 1 : -1;
          signY = 1;
          borderSkipped = vm.borderSkipped || 'left';
        } // Canvas doesn't allow us to stroke inside the width so we can
        // adjust the sizes to fit if we're setting a stroke on the line


        if (borderWidth) {
          // borderWidth shold be less than bar width and bar height.
          var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
          borderWidth = borderWidth > barSize ? barSize : borderWidth;
          var halfStroke = borderWidth / 2; // Adjust borderWidth when bar top position is near vm.base(zero).

          var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
          var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
          var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
          var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0); // not become a vertical line?

          if (borderLeft !== borderRight) {
            top = borderTop;
            bottom = borderBottom;
          } // not become a horizontal line?


          if (borderTop !== borderBottom) {
            left = borderLeft;
            right = borderRight;
          }
        }

        ctx.beginPath();
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = borderWidth; // Corner points, from bottom-left to bottom-right clockwise
        // | 1 2 |
        // | 0 3 |

        var corners = [[left, bottom], [left, top], [right, top], [right, bottom]]; // Find first (starting) corner with fallback to 'bottom'

        var borders = ['bottom', 'left', 'top', 'right'];
        var startCorner = borders.indexOf(borderSkipped, 0);

        if (startCorner === -1) {
          startCorner = 0;
        }

        function cornerAt(index) {
          return corners[(startCorner + index) % 4];
        } // Draw rectangle from 'startCorner'


        var corner = cornerAt(0);
        ctx.moveTo(corner[0], corner[1]);

        for (var i = 1; i < 4; i++) {
          corner = cornerAt(i);
          ctx.lineTo(corner[0], corner[1]);
        }

        ctx.fill();

        if (borderWidth) {
          ctx.stroke();
        }
      },
      height: function height() {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function inRange(mouseX, mouseY) {
        var inRange = false;

        if (this._view) {
          var bounds = getBarBounds(this);
          inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
        }

        return inRange;
      },
      inLabelRange: function inLabelRange(mouseX, mouseY) {
        var me = this;

        if (!me._view) {
          return false;
        }

        var inRange = false;
        var bounds = getBarBounds(me);

        if (isVertical(me)) {
          inRange = mouseX >= bounds.left && mouseX <= bounds.right;
        } else {
          inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
        }

        return inRange;
      },
      inXRange: function inXRange(mouseX) {
        var bounds = getBarBounds(this);
        return mouseX >= bounds.left && mouseX <= bounds.right;
      },
      inYRange: function inYRange(mouseY) {
        var bounds = getBarBounds(this);
        return mouseY >= bounds.top && mouseY <= bounds.bottom;
      },
      getCenterPoint: function getCenterPoint() {
        var vm = this._view;
        var x, y;

        if (isVertical(this)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }

        return {
          x: x,
          y: y
        };
      },
      getArea: function getArea() {
        var vm = this._view;
        return vm.width * Math.abs(vm.y - vm.base);
      },
      tooltipPosition: function tooltipPosition() {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    /***/
  },

  /***/
  "./node_modules/chart.js/src/elements/index.js":
  /*!*****************************************************!*\
    !*** ./node_modules/chart.js/src/elements/index.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcElementsIndexJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = {};
    module.exports.Arc = __webpack_require__(
    /*! ./element.arc */
    "./node_modules/chart.js/src/elements/element.arc.js");
    module.exports.Line = __webpack_require__(
    /*! ./element.line */
    "./node_modules/chart.js/src/elements/element.line.js");
    module.exports.Point = __webpack_require__(
    /*! ./element.point */
    "./node_modules/chart.js/src/elements/element.point.js");
    module.exports.Rectangle = __webpack_require__(
    /*! ./element.rectangle */
    "./node_modules/chart.js/src/elements/element.rectangle.js");
    /***/
  },

  /***/
  "./node_modules/chart.js/src/helpers/helpers.canvas.js":
  /*!*************************************************************!*\
    !*** ./node_modules/chart.js/src/helpers/helpers.canvas.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcHelpersHelpersCanvasJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ./helpers.core */
    "./node_modules/chart.js/src/helpers/helpers.core.js");
    /**
     * @namespace Chart.helpers.canvas
     */


    var exports = module.exports = {
      /**
       * Clears the entire canvas associated to the given `chart`.
       * @param {Chart} chart - The chart for which to clear the canvas.
       */
      clear: function clear(chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },

      /**
       * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
       * given size (width, height) and the same `radius` for all corners.
       * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
       * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
       * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
       * @param {Number} width - The rectangle's width.
       * @param {Number} height - The rectangle's height.
       * @param {Number} radius - The rounded amount (in pixels) for the four corners.
       * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
       */
      roundedRect: function roundedRect(ctx, x, y, width, height, radius) {
        if (radius) {
          var rx = Math.min(radius, width / 2);
          var ry = Math.min(radius, height / 2);
          ctx.moveTo(x + rx, y);
          ctx.lineTo(x + width - rx, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
          ctx.lineTo(x + width, y + height - ry);
          ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
          ctx.lineTo(x + rx, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
          ctx.lineTo(x, y + ry);
          ctx.quadraticCurveTo(x, y, x + rx, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function drawPoint(ctx, style, radius, x, y) {
        var type, edgeLength, xOffset, yOffset, height, size;

        if (style && typeof style === 'object') {
          type = style.toString();

          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        switch (style) {
          // Default includes circle
          default:
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            break;

          case 'triangle':
            ctx.beginPath();
            edgeLength = 3 * radius / Math.sqrt(3);
            height = edgeLength * Math.sqrt(3) / 2;
            ctx.moveTo(x - edgeLength / 2, y + height / 3);
            ctx.lineTo(x + edgeLength / 2, y + height / 3);
            ctx.lineTo(x, y - 2 * height / 3);
            ctx.closePath();
            ctx.fill();
            break;

          case 'rect':
            size = 1 / Math.SQRT2 * radius;
            ctx.beginPath();
            ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
            ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
            break;

          case 'rectRounded':
            var offset = radius / Math.SQRT2;
            var leftX = x - offset;
            var topY = y - offset;
            var sideSize = Math.SQRT2 * radius;
            ctx.beginPath();
            this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
            ctx.closePath();
            ctx.fill();
            break;

          case 'rectRot':
            size = 1 / Math.SQRT2 * radius;
            ctx.beginPath();
            ctx.moveTo(x - size, y);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x + size, y);
            ctx.lineTo(x, y - size);
            ctx.closePath();
            ctx.fill();
            break;

          case 'cross':
            ctx.beginPath();
            ctx.moveTo(x, y + radius);
            ctx.lineTo(x, y - radius);
            ctx.moveTo(x - radius, y);
            ctx.lineTo(x + radius, y);
            ctx.closePath();
            break;

          case 'crossRot':
            ctx.beginPath();
            xOffset = Math.cos(Math.PI / 4) * radius;
            yOffset = Math.sin(Math.PI / 4) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x - xOffset, y + yOffset);
            ctx.lineTo(x + xOffset, y - yOffset);
            ctx.closePath();
            break;

          case 'star':
            ctx.beginPath();
            ctx.moveTo(x, y + radius);
            ctx.lineTo(x, y - radius);
            ctx.moveTo(x - radius, y);
            ctx.lineTo(x + radius, y);
            xOffset = Math.cos(Math.PI / 4) * radius;
            yOffset = Math.sin(Math.PI / 4) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x - xOffset, y + yOffset);
            ctx.lineTo(x + xOffset, y - yOffset);
            ctx.closePath();
            break;

          case 'line':
            ctx.beginPath();
            ctx.moveTo(x - radius, y);
            ctx.lineTo(x + radius, y);
            ctx.closePath();
            break;

          case 'dash':
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + radius, y);
            ctx.closePath();
            break;
        }

        ctx.stroke();
      },
      clipArea: function clipArea(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function unclipArea(ctx) {
        ctx.restore();
      },
      lineTo: function lineTo(ctx, previous, target, flip) {
        if (target.steppedLine) {
          if (target.steppedLine === 'after' && !flip || target.steppedLine !== 'after' && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }

          ctx.lineTo(target.x, target.y);
          return;
        }

        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }

        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
     * @namespace Chart.helpers.clear
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.clear = exports.clear;
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
     * @namespace Chart.helpers.drawRoundedRectangle
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.drawRoundedRectangle = function (ctx) {
      ctx.beginPath();
      exports.roundedRect.apply(exports, arguments);
      ctx.closePath();
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/helpers/helpers.core.js":
  /*!***********************************************************!*\
    !*** ./node_modules/chart.js/src/helpers/helpers.core.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcHelpersHelpersCoreJs(module, exports, __webpack_require__) {
    "use strict";
    /**
     * @namespace Chart.helpers
     */

    var helpers = {
      /**
       * An empty function that can be used, for example, for optional callback.
       */
      noop: function noop() {},

      /**
       * Returns a unique id, sequentially generated from a global variable.
       * @returns {Number}
       * @function
       */
      uid: function () {
        var id = 0;
        return function () {
          return id++;
        };
      }(),

      /**
       * Returns true if `value` is neither null nor undefined, else returns false.
       * @param {*} value - The value to test.
       * @returns {Boolean}
       * @since 2.7.0
       */
      isNullOrUndef: function isNullOrUndef(value) {
        return value === null || typeof value === 'undefined';
      },

      /**
       * Returns true if `value` is an array, else returns false.
       * @param {*} value - The value to test.
       * @returns {Boolean}
       * @function
       */
      isArray: Array.isArray ? Array.isArray : function (value) {
        return Object.prototype.toString.call(value) === '[object Array]';
      },

      /**
       * Returns true if `value` is an object (excluding null), else returns false.
       * @param {*} value - The value to test.
       * @returns {Boolean}
       * @since 2.7.0
       */
      isObject: function isObject(value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
      },

      /**
       * Returns `value` if defined, else returns `defaultValue`.
       * @param {*} value - The value to return if defined.
       * @param {*} defaultValue - The value to return if `value` is undefined.
       * @returns {*}
       */
      valueOrDefault: function valueOrDefault(value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
      },

      /**
       * Returns value at the given `index` in array if defined, else returns `defaultValue`.
       * @param {Array} value - The array to lookup for value at `index`.
       * @param {Number} index - The index in `value` to lookup for value.
       * @param {*} defaultValue - The value to return if `value[index]` is undefined.
       * @returns {*}
       */
      valueAtIndexOrDefault: function valueAtIndexOrDefault(value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },

      /**
       * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
       * value returned by `fn`. If `fn` is not a function, this method returns undefined.
       * @param {Function} fn - The function to call.
       * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
       * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @returns {*}
       */
      callback: function callback(fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
        }
      },

      /**
       * Note(SB) for performance sake, this method should only be used when loopable type
       * is unknown or in none intensive code (not called often and small loopable). Else
       * it's preferable to use a regular for() loop and save extra function calls.
       * @param {Object|Array} loopable - The object or array to be iterated.
       * @param {Function} fn - The function to call for each item.
       * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
       */
      each: function each(loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (helpers.isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },

      /**
       * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
       * @see http://stackoverflow.com/a/14853974
       * @param {Array} a0 - The array to compare
       * @param {Array} a1 - The array to compare
       * @returns {Boolean}
       */
      arrayEquals: function arrayEquals(a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false;
          }
        }

        return true;
      },

      /**
       * Returns a deep copy of `source` without keeping references on objects and arrays.
       * @param {*} source - The value to clone.
       * @returns {*}
       */
      clone: function clone(source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }

        if (helpers.isObject(source)) {
          var target = {};
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = helpers.clone(source[keys[k]]);
          }

          return target;
        }

        return source;
      },

      /**
       * The default merger when Chart.helpers.merge is called without merger option.
       * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
       * @private
       */
      _merger: function _merger(key, target, source, options) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options);
        } else {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Merges source[key] in target[key] only if target[key] is undefined.
       * @private
       */
      _mergerIf: function _mergerIf(key, target, source) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Recursively deep copies `source` properties into `target` with the given `options`.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {Object} target - The target object in which all sources are merged into.
       * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
       * @param {Object} [options] - Merging options:
       * @param {Function} [options.merger] - The merge method (key, target, source, options)
       * @returns {Object} The `target` object.
       */
      merge: function merge(target, source, options) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k;

        if (!helpers.isObject(target)) {
          return target;
        }

        options = options || {};
        merge = options.merger || helpers._merger;

        for (i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!helpers.isObject(source)) {
            continue;
          }

          keys = Object.keys(source);

          for (k = 0, klen = keys.length; k < klen; ++k) {
            merge(keys[k], target, source, options);
          }
        }

        return target;
      },

      /**
       * Recursively deep copies `source` properties into `target` *only* if not defined in target.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {Object} target - The target object in which all sources are merged into.
       * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
       * @returns {Object} The `target` object.
       */
      mergeIf: function mergeIf(target, source) {
        return helpers.merge(target, source, {
          merger: helpers._mergerIf
        });
      },

      /**
       * Applies the contents of two or more objects together into the first object.
       * @param {Object} target - The target object in which all objects are merged into.
       * @param {Object} arg1 - Object containing additional properties to merge in target.
       * @param {Object} argN - Additional objects containing properties to merge in target.
       * @returns {Object} The `target` object.
       */
      extend: function extend(target) {
        var setFn = function setFn(value, key) {
          target[key] = value;
        };

        for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
          helpers.each(arguments[i], setFn);
        }

        return target;
      },

      /**
       * Basic javascript inheritance based on the model created in Backbone.js
       */
      inherits: function inherits(extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments);
        };

        var Surrogate = function Surrogate() {
          this.constructor = ChartElement;
        };

        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;

        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }

        ChartElement.__super__ = me.prototype;
        return ChartElement;
      }
    };
    module.exports = helpers; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.callback instead.
     * @function Chart.helpers.callCallback
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    helpers.callCallback = helpers.callback;
    /**
     * Provided for backward compatibility, use Array.prototype.indexOf instead.
     * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
     * @function Chart.helpers.indexOf
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.indexOf = function (array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    /**
     * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
     * @function Chart.helpers.getValueOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */


    helpers.getValueOrDefault = helpers.valueOrDefault;
    /**
     * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
     * @function Chart.helpers.getValueAtIndexOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    /***/
  },

  /***/
  "./node_modules/chart.js/src/helpers/helpers.easing.js":
  /*!*************************************************************!*\
    !*** ./node_modules/chart.js/src/helpers/helpers.easing.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcHelpersHelpersEasingJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ./helpers.core */
    "./node_modules/chart.js/src/helpers/helpers.core.js");
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easingEffects
     * @see http://www.robertpenner.com/easing/
     */


    var effects = {
      linear: function linear(t) {
        return t;
      },
      easeInQuad: function easeInQuad(t) {
        return t * t;
      },
      easeOutQuad: function easeOutQuad(t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function easeInOutQuad(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }

        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function easeInCubic(t) {
        return t * t * t;
      },
      easeOutCubic: function easeOutCubic(t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function easeInOutCubic(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function easeInQuart(t) {
        return t * t * t * t;
      },
      easeOutQuart: function easeOutQuart(t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function easeInOutQuart(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }

        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function easeInQuint(t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function easeOutQuint(t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function easeInOutQuint(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function easeInSine(t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function easeOutSine(t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function easeInOutSine(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function easeInExpo(t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function easeOutExpo(t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function easeInOutExpo(t) {
        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }

        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function easeInCirc(t) {
        if (t >= 1) {
          return t;
        }

        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function easeOutCirc(t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function easeInOutCirc(t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function easeInElastic(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function easeOutElastic(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function easeInOutElastic(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if ((t /= 0.5) === 2) {
          return 1;
        }

        if (!p) {
          p = 0.45;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function easeInBack(t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function easeOutBack(t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function easeInOutBack(t) {
        var s = 1.70158;

        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }

        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function easeInBounce(t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function easeOutBounce(t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }

        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function easeInOutBounce(t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }

        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    module.exports = {
      effects: effects
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
     * @function Chart.helpers.easingEffects
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.easingEffects = effects;
    /***/
  },

  /***/
  "./node_modules/chart.js/src/helpers/helpers.options.js":
  /*!**************************************************************!*\
    !*** ./node_modules/chart.js/src/helpers/helpers.options.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcHelpersHelpersOptionsJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ./helpers.core */
    "./node_modules/chart.js/src/helpers/helpers.core.js");
    /**
     * @alias Chart.helpers.options
     * @namespace
     */


    module.exports = {
      /**
       * Converts the given line height `value` in pixels for a specific font `size`.
       * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
       * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
       * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
       * @since 2.7.0
       */
      toLineHeight: function toLineHeight(value, size) {
        var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

        if (!matches || matches[1] === 'normal') {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case 'px':
            return value;

          case '%':
            value /= 100;
            break;

          default:
            break;
        }

        return size * value;
      },

      /**
       * Converts the given value into a padding object with pre-computed width/height.
       * @param {Number|Object} value - If a number, set the value to all TRBL component,
       *  else, if and object, use defined properties and sets undefined ones to 0.
       * @returns {Object} The padding values (top, right, bottom, left, width, height)
       * @since 2.7.0
       */
      toPadding: function toPadding(value) {
        var t, r, b, l;

        if (helpers.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },

      /**
       * Evaluates the given `inputs` sequentially and returns the first defined value.
       * @param {Array[]} inputs - An array of values, falling back to the last value.
       * @param {Object} [context] - If defined and the current value is a function, the value
       * is called with `context` as first argument and the result becomes the new input.
       * @param {Number} [index] - If defined and the current value is an array, the value
       * at `index` become the new input.
       * @since 2.7.0
       */
      resolve: function resolve(inputs, context, index) {
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === 'function') {
            value = value(context);
          }

          if (index !== undefined && helpers.isArray(value)) {
            value = value[index];
          }

          if (value !== undefined) {
            return value;
          }
        }
      }
    };
    /***/
  },

  /***/
  "./node_modules/chart.js/src/helpers/index.js":
  /*!****************************************************!*\
    !*** ./node_modules/chart.js/src/helpers/index.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcHelpersIndexJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = __webpack_require__(
    /*! ./helpers.core */
    "./node_modules/chart.js/src/helpers/helpers.core.js");
    module.exports.easing = __webpack_require__(
    /*! ./helpers.easing */
    "./node_modules/chart.js/src/helpers/helpers.easing.js");
    module.exports.canvas = __webpack_require__(
    /*! ./helpers.canvas */
    "./node_modules/chart.js/src/helpers/helpers.canvas.js");
    module.exports.options = __webpack_require__(
    /*! ./helpers.options */
    "./node_modules/chart.js/src/helpers/helpers.options.js");
    /***/
  },

  /***/
  "./node_modules/chart.js/src/platforms/platform.basic.js":
  /*!***************************************************************!*\
    !*** ./node_modules/chart.js/src/platforms/platform.basic.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcPlatformsPlatformBasicJs(module, exports) {
    /**
     * Platform fallback implementation (minimal).
     * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
     */
    module.exports = {
      acquireContext: function acquireContext(item) {
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        }

        return item && item.getContext('2d') || null;
      }
    };
    /***/
  },

  /***/
  "./node_modules/chart.js/src/platforms/platform.dom.js":
  /*!*************************************************************!*\
    !*** ./node_modules/chart.js/src/platforms/platform.dom.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcPlatformsPlatformDomJs(module, exports, __webpack_require__) {
    "use strict";
    /**
     * Chart.Platform implementation for targeting a web browser
     */

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var EXPANDO_KEY = '$chartjs';
    var CSS_PREFIX = 'chartjs-';
    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
    var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
    /**
     * DOM event types -> Chart.js event types.
     * Note: only events with different types are mapped.
     * @see https://developer.mozilla.org/en-US/docs/Web/Events
     */

    var EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns {Number} Size in pixels or undefined if unknown.
     */

    function readUsedSize(element, property) {
      var value = helpers.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : undefined;
    }
    /**
     * Initializes the canvas style and render size without modifying the canvas display size,
     * since responsiveness is handled by the controller.resize() method. The config is used
     * to determine the aspect ratio to apply in case no explicit height has been specified.
     */


    function initCanvas(canvas, config) {
      var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
      // returns null or '' if no explicit value has been set to the canvas attribute.

      var renderHeight = canvas.getAttribute('height');
      var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      }; // Force canvas to display as block to avoid extra space caused by inline
      // elements, which would interfere with the responsive resize process.
      // https://github.com/chartjs/Chart.js/issues/2538

      style.display = style.display || 'block';

      if (renderWidth === null || renderWidth === '') {
        var displayWidth = readUsedSize(canvas, 'width');

        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }

      if (renderHeight === null || renderHeight === '') {
        if (canvas.style.height === '') {
          // If no explicit render height and style height, let's apply the aspect ratio,
          // which one can be specified by the user but also by charts as default option
          // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
          canvas.height = canvas.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas, 'height');

          if (displayWidth !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }

      return canvas;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */


    var supportsEventListenerOptions = function () {
      var supports = false;

      try {
        var options = Object.defineProperty({}, 'passive', {
          get: function get() {
            supports = true;
          }
        });
        window.addEventListener('e', null, options);
      } catch (e) {// continue regardless of error
      }

      return supports;
    }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
    // https://github.com/chartjs/Chart.js/issues/4287


    var eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;

    function _addEventListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }

    function _removeEventListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }

    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type: type,
        chart: chart,
        "native": nativeEvent || null,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
      };
    }

    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }

    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function () {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;

        if (!ticking) {
          ticking = true;
          helpers.requestAnimFrame.call(window, function () {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    } // Implementation based on https://github.com/marcj/css-element-queries


    function createResizer(handler) {
      var resizer = document.createElement('div');
      var cls = CSS_PREFIX + 'size-monitor';
      var maxSize = 1000000;
      var style = 'position:absolute;' + 'left:0;' + 'top:0;' + 'right:0;' + 'bottom:0;' + 'overflow:hidden;' + 'pointer-events:none;' + 'visibility:hidden;' + 'z-index:-1;';
      resizer.style.cssText = style;
      resizer.className = cls;
      resizer.innerHTML = '<div class="' + cls + '-expand" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:' + maxSize + 'px;' + 'height:' + maxSize + 'px;' + 'left:0;' + 'top:0">' + '</div>' + '</div>' + '<div class="' + cls + '-shrink" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:200%;' + 'height:200%;' + 'left:0; ' + 'top:0">' + '</div>' + '</div>';
      var expand = resizer.childNodes[0];
      var shrink = resizer.childNodes[1];

      resizer._reset = function () {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };

      var onScroll = function onScroll() {
        resizer._reset();

        handler();
      };

      _addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));

      _addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

      return resizer;
    } // https://davidwalsh.name/detect-node-insertion


    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

      var proxy = expando.renderProxy = function (e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };

      helpers.each(ANIMATION_START_EVENTS, function (type) {
        _addEventListener(node, type, proxy);
      }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
      // is removed then added back immediately (same animation frame?). Accessing the
      // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
      // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
      // https://github.com/chartjs/Chart.js/issues/4737

      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }

    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;

      if (proxy) {
        helpers.each(ANIMATION_START_EVENTS, function (type) {
          _removeEventListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }

      node.classList.remove(CSS_RENDER_MONITOR);
    }

    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

      var resizer = expando.resizer = createResizer(throttled(function () {
        if (expando.resizer) {
          return listener(createEvent('resize', chart));
        }
      })); // The resizer needs to be attached to the node parent, so we first need to be
      // sure that `node` is attached to the DOM before injecting the resizer element.

      watchForRender(node, function () {
        if (expando.resizer) {
          var container = node.parentNode;

          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          } // The container size might have changed, let's reset the resizer state.


          resizer._reset();
        }
      });
    }

    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);

      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }

    function injectCSS(platform, css) {
      // http://stackoverflow.com/q/3922139
      var style = platform._style || document.createElement('style');

      if (!platform._style) {
        platform._style = style;
        css = '/* Chart.js */\n' + css;
        style.setAttribute('type', 'text/css');
        document.getElementsByTagName('head')[0].appendChild(style);
      }

      style.appendChild(document.createTextNode(css));
    }

    module.exports = {
      /**
       * This property holds whether this platform is enabled for the current environment.
       * Currently used by platform.js to select the proper implementation.
       * @private
       */
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
      initialize: function initialize() {
        var keyframes = 'from{opacity:0.99}to{opacity:1}';
        injectCSS(this, // DOM rendering detection
        // https://davidwalsh.name/detect-node-insertion
        '@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '.' + CSS_RENDER_MONITOR + '{' + '-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + 'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + '}');
      },
      acquireContext: function acquireContext(item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item);
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0];
        }

        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        } // To prevent canvas fingerprinting, some add-ons undefine the getContext
        // method, for example: https://github.com/kkapsner/CanvasBlocker
        // https://github.com/chartjs/Chart.js/issues/2807


        var context = item && item.getContext && item.getContext('2d'); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
        // inside an iframe or when running in a protected environment. We could guess the
        // types from their toString() value but let's keep things flexible and assume it's
        // a sufficient condition if the item has a context2D which has item as `canvas`.
        // https://github.com/chartjs/Chart.js/issues/3887
        // https://github.com/chartjs/Chart.js/issues/4102
        // https://github.com/chartjs/Chart.js/issues/4152

        if (context && context.canvas === item) {
          initCanvas(item, config);
          return context;
        }

        return null;
      },
      releaseContext: function releaseContext(context) {
        var canvas = context.canvas;

        if (!canvas[EXPANDO_KEY]) {
          return;
        }

        var initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach(function (prop) {
          var value = initial[prop];

          if (helpers.isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        helpers.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value;
        }); // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html

        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
      },
      addEventListener: function addEventListener(chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          addResizeListener(canvas, listener, chart);
          return;
        }

        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});

        var proxy = proxies[chart.id + '_' + type] = function (event) {
          listener(fromNativeEvent(event, chart));
        };

        _addEventListener(canvas, type, proxy);
      },
      removeEventListener: function removeEventListener(chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          removeResizeListener(canvas, listener);
          return;
        }

        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + '_' + type];

        if (!proxy) {
          return;
        }

        _removeEventListener(canvas, type, proxy);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use EventTarget.addEventListener instead.
     * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * @function Chart.helpers.addEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.addEvent = _addEventListener;
    /**
     * Provided for backward compatibility, use EventTarget.removeEventListener instead.
     * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     * @function Chart.helpers.removeEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.removeEvent = _removeEventListener;
    /***/
  },

  /***/
  "./node_modules/chart.js/src/platforms/platform.js":
  /*!*********************************************************!*\
    !*** ./node_modules/chart.js/src/platforms/platform.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcPlatformsPlatformJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var basic = __webpack_require__(
    /*! ./platform.basic */
    "./node_modules/chart.js/src/platforms/platform.basic.js");

    var dom = __webpack_require__(
    /*! ./platform.dom */
    "./node_modules/chart.js/src/platforms/platform.dom.js"); // @TODO Make possible to select another platform at build time.


    var implementation = dom._enabled ? dom : basic;
    /**
     * @namespace Chart.platform
     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
     * @since 2.4.0
     */

    module.exports = helpers.extend({
      /**
       * @since 2.7.0
       */
      initialize: function initialize() {},

      /**
       * Called at chart construction time, returns a context2d instance implementing
       * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
       * @param {*} item - The native item from which to acquire context (platform specific)
       * @param {Object} options - The chart options
       * @returns {CanvasRenderingContext2D} context2d instance
       */
      acquireContext: function acquireContext() {},

      /**
       * Called at chart destruction time, releases any resources associated to the context
       * previously returned by the acquireContext() method.
       * @param {CanvasRenderingContext2D} context - The context2d instance
       * @returns {Boolean} true if the method succeeded, else false
       */
      releaseContext: function releaseContext() {},

      /**
       * Registers the specified listener on the given chart.
       * @param {Chart} chart - Chart from which to listen for event
       * @param {String} type - The ({@link IEvent}) type to listen for
       * @param {Function} listener - Receives a notification (an object that implements
       * the {@link IEvent} interface) when an event of the specified type occurs.
       */
      addEventListener: function addEventListener() {},

      /**
       * Removes the specified listener previously registered with addEventListener.
       * @param {Chart} chart -Chart from which to remove the listener
       * @param {String} type - The ({@link IEvent}) type to remove
       * @param {Function} listener - The listener function to remove from the event target.
       */
      removeEventListener: function removeEventListener() {}
    }, implementation);
    /**
     * @interface IPlatform
     * Allows abstracting platform dependencies away from the chart
     * @borrows Chart.platform.acquireContext as acquireContext
     * @borrows Chart.platform.releaseContext as releaseContext
     * @borrows Chart.platform.addEventListener as addEventListener
     * @borrows Chart.platform.removeEventListener as removeEventListener
     */

    /**
     * @interface IEvent
     * @prop {String} type - The event type name, possible values are:
     * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
     * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
     * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
     * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
     * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
     */

    /***/
  },

  /***/
  "./node_modules/chart.js/src/plugins/plugin.filler.js":
  /*!************************************************************!*\
    !*** ./node_modules/chart.js/src/plugins/plugin.filler.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcPluginsPluginFillerJs(module, exports, __webpack_require__) {
    "use strict";
    /**
     * Plugin based on discussion from the following Chart.js issues:
     * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
     * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
     */

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var elements = __webpack_require__(
    /*! ../elements/index */
    "./node_modules/chart.js/src/elements/index.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('global', {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });

    module.exports = function () {
      var mappers = {
        dataset: function dataset(source) {
          var index = source.fill;
          var chart = source.chart;
          var meta = chart.getDatasetMeta(index);
          var visible = meta && chart.isDatasetVisible(index);
          var points = visible && meta.dataset._children || [];
          var length = points.length || 0;
          return !length ? null : function (point, i) {
            return i < length && points[i]._view || null;
          };
        },
        boundary: function boundary(source) {
          var boundary = source.boundary;
          var x = boundary ? boundary.x : null;
          var y = boundary ? boundary.y : null;
          return function (point) {
            return {
              x: x === null ? point.x : x,
              y: y === null ? point.y : y
            };
          };
        }
      }; // @todo if (fill[0] === '#')

      function decodeFill(el, index, count) {
        var model = el._model || {};
        var fill = model.fill;
        var target;

        if (fill === undefined) {
          fill = !!model.backgroundColor;
        }

        if (fill === false || fill === null) {
          return false;
        }

        if (fill === true) {
          return 'origin';
        }

        target = parseFloat(fill, 10);

        if (isFinite(target) && Math.floor(target) === target) {
          if (fill[0] === '-' || fill[0] === '+') {
            target = index + target;
          }

          if (target === index || target < 0 || target >= count) {
            return false;
          }

          return target;
        }

        switch (fill) {
          // compatibility
          case 'bottom':
            return 'start';

          case 'top':
            return 'end';

          case 'zero':
            return 'origin';
          // supported boundaries

          case 'origin':
          case 'start':
          case 'end':
            return fill;
          // invalid fill values

          default:
            return false;
        }
      }

      function computeBoundary(source) {
        var model = source.el._model || {};
        var scale = source.el._scale || {};
        var fill = source.fill;
        var target = null;
        var horizontal;

        if (isFinite(fill)) {
          return null;
        } // Backward compatibility: until v3, we still need to support boundary values set on
        // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
        // controllers might still use it (e.g. the Smith chart).


        if (fill === 'start') {
          target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
        } else if (fill === 'end') {
          target = model.scaleTop === undefined ? scale.top : model.scaleTop;
        } else if (model.scaleZero !== undefined) {
          target = model.scaleZero;
        } else if (scale.getBasePosition) {
          target = scale.getBasePosition();
        } else if (scale.getBasePixel) {
          target = scale.getBasePixel();
        }

        if (target !== undefined && target !== null) {
          if (target.x !== undefined && target.y !== undefined) {
            return target;
          }

          if (typeof target === 'number' && isFinite(target)) {
            horizontal = scale.isHorizontal();
            return {
              x: horizontal ? target : null,
              y: horizontal ? null : target
            };
          }
        }

        return null;
      }

      function resolveTarget(sources, index, propagate) {
        var source = sources[index];
        var fill = source.fill;
        var visited = [index];
        var target;

        if (!propagate) {
          return fill;
        }

        while (fill !== false && visited.indexOf(fill) === -1) {
          if (!isFinite(fill)) {
            return fill;
          }

          target = sources[fill];

          if (!target) {
            return false;
          }

          if (target.visible) {
            return fill;
          }

          visited.push(fill);
          fill = target.fill;
        }

        return false;
      }

      function createMapper(source) {
        var fill = source.fill;
        var type = 'dataset';

        if (fill === false) {
          return null;
        }

        if (!isFinite(fill)) {
          type = 'boundary';
        }

        return mappers[type](source);
      }

      function isDrawable(point) {
        return point && !point.skip;
      }

      function drawArea(ctx, curve0, curve1, len0, len1) {
        var i;

        if (!len0 || !len1) {
          return;
        } // building first area curve (normal)


        ctx.moveTo(curve0[0].x, curve0[0].y);

        for (i = 1; i < len0; ++i) {
          helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
        } // joining the two area curves


        ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

        for (i = len1 - 1; i > 0; --i) {
          helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
        }
      }

      function doFill(ctx, points, mapper, view, color, loop) {
        var count = points.length;
        var span = view.spanGaps;
        var curve0 = [];
        var curve1 = [];
        var len0 = 0;
        var len1 = 0;
        var i, ilen, index, p0, p1, d0, d1;
        ctx.beginPath();

        for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
          index = i % count;
          p0 = points[index]._view;
          p1 = mapper(p0, index, view);
          d0 = isDrawable(p0);
          d1 = isDrawable(p1);

          if (d0 && d1) {
            len0 = curve0.push(p0);
            len1 = curve1.push(p1);
          } else if (len0 && len1) {
            if (!span) {
              drawArea(ctx, curve0, curve1, len0, len1);
              len0 = len1 = 0;
              curve0 = [];
              curve1 = [];
            } else {
              if (d0) {
                curve0.push(p0);
              }

              if (d1) {
                curve1.push(p1);
              }
            }
          }
        }

        drawArea(ctx, curve0, curve1, len0, len1);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
      }

      return {
        id: 'filler',
        afterDatasetsUpdate: function afterDatasetsUpdate(chart, options) {
          var count = (chart.data.datasets || []).length;
          var propagate = options.propagate;
          var sources = [];
          var meta, i, el, source;

          for (i = 0; i < count; ++i) {
            meta = chart.getDatasetMeta(i);
            el = meta.dataset;
            source = null;

            if (el && el._model && el instanceof elements.Line) {
              source = {
                visible: chart.isDatasetVisible(i),
                fill: decodeFill(el, i, count),
                chart: chart,
                el: el
              };
            }

            meta.$filler = source;
            sources.push(source);
          }

          for (i = 0; i < count; ++i) {
            source = sources[i];

            if (!source) {
              continue;
            }

            source.fill = resolveTarget(sources, i, propagate);
            source.boundary = computeBoundary(source);
            source.mapper = createMapper(source);
          }
        },
        beforeDatasetDraw: function beforeDatasetDraw(chart, args) {
          var meta = args.meta.$filler;

          if (!meta) {
            return;
          }

          var ctx = chart.ctx;
          var el = meta.el;
          var view = el._view;
          var points = el._children || [];
          var mapper = meta.mapper;
          var color = view.backgroundColor || defaults.global.defaultColor;

          if (mapper && color && points.length) {
            helpers.canvas.clipArea(ctx, chart.chartArea);
            doFill(ctx, points, mapper, view, color, el._loop);
            helpers.canvas.unclipArea(ctx);
          }
        }
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/plugins/plugin.legend.js":
  /*!************************************************************!*\
    !*** ./node_modules/chart.js/src/plugins/plugin.legend.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcPluginsPluginLegendJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ../core/core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('global', {
      legend: {
        display: true,
        position: 'top',
        fullWidth: true,
        reverse: false,
        weight: 1000,
        // a callback that will handle
        onClick: function onClick(e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

          ci.update();
        },
        onHover: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function generateLabels(chart) {
            var data = chart.data;
            return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              };
            }, this) : [];
          }
        }
      },
      legendCallback: function legendCallback(chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');

        for (var i = 0; i < chart.data.datasets.length; i++) {
          text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

          if (chart.data.datasets[i].label) {
            text.push(chart.data.datasets[i].label);
          }

          text.push('</li>');
        }

        text.push('</ul>');
        return text.join('');
      }
    });

    module.exports = function (Chart) {
      var layout = Chart.layoutService;
      var noop = helpers.noop;
      /**
       * Helper function to get the box width based on the usePointStyle option
       * @param labelopts {Object} the label options on the legend
       * @param fontSize {Number} the label font size
       * @return {Number} width of the color box area
       */

      function getBoxWidth(labelOpts, fontSize) {
        return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;
      }

      Chart.Legend = Element.extend({
        initialize: function initialize(config) {
          helpers.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

          this.legendHitBoxes = []; // Are we in doughnut mode which has a different data type

          this.doughnutMode = false;
        },
        // These methods are ordered by lifecycle. Utilities then follow.
        // Any function defined here is inherited by all legend types.
        // Any function can be extended by the legend type
        beforeUpdate: noop,
        update: function update(maxWidth, maxHeight, margins) {
          var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

          me.beforeUpdate(); // Absorb the master measurements

          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = margins; // Dimensions

          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions(); // Labels

          me.beforeBuildLabels();
          me.buildLabels();
          me.afterBuildLabels(); // Fit

          me.beforeFit();
          me.fit();
          me.afterFit(); //

          me.afterUpdate();
          return me.minSize;
        },
        afterUpdate: noop,
        //
        beforeSetDimensions: noop,
        setDimensions: function setDimensions() {
          var me = this; // Set the unconstrained dimension before label rotation

          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight; // Reset position before calculating rotation

            me.top = 0;
            me.bottom = me.height;
          } // Reset padding


          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0; // Reset minSize

          me.minSize = {
            width: 0,
            height: 0
          };
        },
        afterSetDimensions: noop,
        //
        beforeBuildLabels: noop,
        buildLabels: function buildLabels() {
          var me = this;
          var labelOpts = me.options.labels || {};
          var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

          if (labelOpts.filter) {
            legendItems = legendItems.filter(function (item) {
              return labelOpts.filter(item, me.chart.data);
            });
          }

          if (me.options.reverse) {
            legendItems.reverse();
          }

          me.legendItems = legendItems;
        },
        afterBuildLabels: noop,
        //
        beforeFit: noop,
        fit: function fit() {
          var me = this;
          var opts = me.options;
          var labelOpts = opts.labels;
          var display = opts.display;
          var ctx = me.ctx;
          var globalDefault = defaults.global;
          var valueOrDefault = helpers.valueOrDefault;
          var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
          var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
          var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
          var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Reset hit boxes

          var hitboxes = me.legendHitBoxes = [];
          var minSize = me.minSize;
          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            minSize.width = me.maxWidth; // fill all the width

            minSize.height = display ? 10 : 0;
          } else {
            minSize.width = display ? 10 : 0;
            minSize.height = me.maxHeight; // fill all the height
          } // Increase sizes here


          if (display) {
            ctx.font = labelFont;

            if (isHorizontal) {
              // Labels
              // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
              var lineWidths = me.lineWidths = [0];
              var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;
              ctx.textAlign = 'left';
              ctx.textBaseline = 'top';
              helpers.each(me.legendItems, function (legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

                if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length] = me.left;
                } // Store the hitbox width and height here. Final position will be updated in `draw`


                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: width,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
              });
              minSize.height += totalHeight;
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me.columnWidths = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              var itemHeight = fontSize + vPadding;
              helpers.each(me.legendItems, function (legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

                if (currentColHeight + itemHeight > minSize.height) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth); // previous column width

                  currentColWidth = 0;
                  currentColHeight = 0;
                } // Get max width


                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                };
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              minSize.width += totalWidth;
            }
          }

          me.width = minSize.width;
          me.height = minSize.height;
        },
        afterFit: noop,
        // Shared Methods
        isHorizontal: function isHorizontal() {
          return this.options.position === 'top' || this.options.position === 'bottom';
        },
        // Actually draw the legend on the canvas
        draw: function draw() {
          var me = this;
          var opts = me.options;
          var labelOpts = opts.labels;
          var globalDefault = defaults.global;
          var lineDefault = globalDefault.elements.line;
          var legendWidth = me.width;
          var lineWidths = me.lineWidths;

          if (opts.display) {
            var ctx = me.ctx;
            var valueOrDefault = helpers.valueOrDefault;
            var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
            var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
            var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
            var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
            var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
            var cursor; // Canvas setup

            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor; // for strikethrough effect

            ctx.fillStyle = fontColor; // render in correct colour

            ctx.font = labelFont;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me.legendHitBoxes; // current position

            var drawLegendBox = function drawLegendBox(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return;
              } // Set the ctx for the box


              ctx.save();
              ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
              ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
              var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;

              if (ctx.setLineDash) {
                // IE 9 and 10 do not support line dash
                ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
              }

              if (opts.labels && opts.labels.usePointStyle) {
                // Recalculate x and y for drawPoint() because its expecting
                // x and y to be center of figure (instead of top left)
                var radius = fontSize * Math.SQRT2 / 2;
                var offSet = radius / Math.SQRT2;
                var centerX = x + offSet;
                var centerY = y + offSet; // Draw pointStyle as legend symbol

                helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
              } else {
                // Draw box as legend symbol
                if (!isLineWidthZero) {
                  ctx.strokeRect(x, y, boxWidth, fontSize);
                }

                ctx.fillRect(x, y, boxWidth, fontSize);
              }

              ctx.restore();
            };

            var fillText = function fillText(x, y, legendItem, textWidth) {
              var halfFontSize = fontSize / 2;
              var xLeft = boxWidth + halfFontSize + x;
              var yMiddle = y + halfFontSize;
              ctx.fillText(legendItem.text, xLeft, yMiddle);

              if (legendItem.hidden) {
                // Strikethrough the text if hidden
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(xLeft, yMiddle);
                ctx.lineTo(xLeft + textWidth, yMiddle);
                ctx.stroke();
              }
            }; // Horizontal


            var isHorizontal = me.isHorizontal();

            if (isHorizontal) {
              cursor = {
                x: me.left + (legendWidth - lineWidths[0]) / 2,
                y: me.top + labelOpts.padding,
                line: 0
              };
            } else {
              cursor = {
                x: me.left + labelOpts.padding,
                y: me.top + labelOpts.padding,
                line: 0
              };
            }

            var itemHeight = fontSize + labelOpts.padding;
            helpers.each(me.legendItems, function (legendItem, i) {
              var textWidth = ctx.measureText(legendItem.text).width;
              var width = boxWidth + fontSize / 2 + textWidth;
              var x = cursor.x;
              var y = cursor.y;

              if (isHorizontal) {
                if (x + width >= legendWidth) {
                  y = cursor.y += itemHeight;
                  cursor.line++;
                  x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;
                }
              } else if (y + itemHeight > me.bottom) {
                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                y = cursor.y = me.top + labelOpts.padding;
                cursor.line++;
              }

              drawLegendBox(x, y, legendItem);
              hitboxes[i].left = x;
              hitboxes[i].top = y; // Fill the actual label

              fillText(x, y, legendItem, textWidth);

              if (isHorizontal) {
                cursor.x += width + labelOpts.padding;
              } else {
                cursor.y += itemHeight;
              }
            });
          }
        },

        /**
         * Handle an event
         * @private
         * @param {IEvent} event - The event to handle
         * @return {Boolean} true if a change occured
         */
        handleEvent: function handleEvent(e) {
          var me = this;
          var opts = me.options;
          var type = e.type === 'mouseup' ? 'click' : e.type;
          var changed = false;

          if (type === 'mousemove') {
            if (!opts.onHover) {
              return;
            }
          } else if (type === 'click') {
            if (!opts.onClick) {
              return;
            }
          } else {
            return;
          } // Chart event already has relative position in it


          var x = e.x;
          var y = e.y;

          if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
            // See if we are touching one of the dataset boxes
            var lh = me.legendHitBoxes;

            for (var i = 0; i < lh.length; ++i) {
              var hitBox = lh[i];

              if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                // Touching an element
                if (type === 'click') {
                  // use e.native for backwards compatibility
                  opts.onClick.call(me, e["native"], me.legendItems[i]);
                  changed = true;
                  break;
                } else if (type === 'mousemove') {
                  // use e.native for backwards compatibility
                  opts.onHover.call(me, e["native"], me.legendItems[i]);
                  changed = true;
                  break;
                }
              }
            }
          }

          return changed;
        }
      });

      function createNewLegendAndAttach(chart, legendOpts) {
        var legend = new Chart.Legend({
          ctx: chart.ctx,
          options: legendOpts,
          chart: chart
        });
        layout.configure(chart, legend, legendOpts);
        layout.addBox(chart, legend);
        chart.legend = legend;
      }

      return {
        id: 'legend',
        beforeInit: function beforeInit(chart) {
          var legendOpts = chart.options.legend;

          if (legendOpts) {
            createNewLegendAndAttach(chart, legendOpts);
          }
        },
        beforeUpdate: function beforeUpdate(chart) {
          var legendOpts = chart.options.legend;
          var legend = chart.legend;

          if (legendOpts) {
            helpers.mergeIf(legendOpts, defaults.global.legend);

            if (legend) {
              layout.configure(chart, legend, legendOpts);
              legend.options = legendOpts;
            } else {
              createNewLegendAndAttach(chart, legendOpts);
            }
          } else if (legend) {
            layout.removeBox(chart, legend);
            delete chart.legend;
          }
        },
        afterEvent: function afterEvent(chart, e) {
          var legend = chart.legend;

          if (legend) {
            legend.handleEvent(e);
          }
        }
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/plugins/plugin.title.js":
  /*!***********************************************************!*\
    !*** ./node_modules/chart.js/src/plugins/plugin.title.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcPluginsPluginTitleJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var Element = __webpack_require__(
    /*! ../core/core.element */
    "./node_modules/chart.js/src/core/core.element.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    defaults._set('global', {
      title: {
        display: false,
        fontStyle: 'bold',
        fullWidth: true,
        lineHeight: 1.2,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000 // by default greater than legend (1000) to be above

      }
    });

    module.exports = function (Chart) {
      var layout = Chart.layoutService;
      var noop = helpers.noop;
      Chart.Title = Element.extend({
        initialize: function initialize(config) {
          var me = this;
          helpers.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

          me.legendHitBoxes = [];
        },
        // These methods are ordered by lifecycle. Utilities then follow.
        beforeUpdate: noop,
        update: function update(maxWidth, maxHeight, margins) {
          var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

          me.beforeUpdate(); // Absorb the master measurements

          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me.margins = margins; // Dimensions

          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions(); // Labels

          me.beforeBuildLabels();
          me.buildLabels();
          me.afterBuildLabels(); // Fit

          me.beforeFit();
          me.fit();
          me.afterFit(); //

          me.afterUpdate();
          return me.minSize;
        },
        afterUpdate: noop,
        //
        beforeSetDimensions: noop,
        setDimensions: function setDimensions() {
          var me = this; // Set the unconstrained dimension before label rotation

          if (me.isHorizontal()) {
            // Reset position before calculating rotation
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight; // Reset position before calculating rotation

            me.top = 0;
            me.bottom = me.height;
          } // Reset padding


          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0; // Reset minSize

          me.minSize = {
            width: 0,
            height: 0
          };
        },
        afterSetDimensions: noop,
        //
        beforeBuildLabels: noop,
        buildLabels: noop,
        afterBuildLabels: noop,
        //
        beforeFit: noop,
        fit: function fit() {
          var me = this;
          var valueOrDefault = helpers.valueOrDefault;
          var opts = me.options;
          var display = opts.display;
          var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
          var minSize = me.minSize;
          var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
          var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
          var textSize = display ? lineCount * lineHeight + opts.padding * 2 : 0;

          if (me.isHorizontal()) {
            minSize.width = me.maxWidth; // fill all the width

            minSize.height = textSize;
          } else {
            minSize.width = textSize;
            minSize.height = me.maxHeight; // fill all the height
          }

          me.width = minSize.width;
          me.height = minSize.height;
        },
        afterFit: noop,
        // Shared Methods
        isHorizontal: function isHorizontal() {
          var pos = this.options.position;
          return pos === 'top' || pos === 'bottom';
        },
        // Actually draw the title block on the canvas
        draw: function draw() {
          var me = this;
          var ctx = me.ctx;
          var valueOrDefault = helpers.valueOrDefault;
          var opts = me.options;
          var globalDefaults = defaults.global;

          if (opts.display) {
            var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
            var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
            var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
            var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
            var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
            var offset = lineHeight / 2 + opts.padding;
            var rotation = 0;
            var top = me.top;
            var left = me.left;
            var bottom = me.bottom;
            var right = me.right;
            var maxWidth, titleX, titleY;
            ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour

            ctx.font = titleFont; // Horizontal

            if (me.isHorizontal()) {
              titleX = left + (right - left) / 2; // midpoint of the width

              titleY = top + offset;
              maxWidth = right - left;
            } else {
              titleX = opts.position === 'left' ? left + offset : right - offset;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
            }

            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            var text = opts.text;

            if (helpers.isArray(text)) {
              var y = 0;

              for (var i = 0; i < text.length; ++i) {
                ctx.fillText(text[i], 0, y, maxWidth);
                y += lineHeight;
              }
            } else {
              ctx.fillText(text, 0, 0, maxWidth);
            }

            ctx.restore();
          }
        }
      });

      function createNewTitleBlockAndAttach(chart, titleOpts) {
        var title = new Chart.Title({
          ctx: chart.ctx,
          options: titleOpts,
          chart: chart
        });
        layout.configure(chart, title, titleOpts);
        layout.addBox(chart, title);
        chart.titleBlock = title;
      }

      return {
        id: 'title',
        beforeInit: function beforeInit(chart) {
          var titleOpts = chart.options.title;

          if (titleOpts) {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        },
        beforeUpdate: function beforeUpdate(chart) {
          var titleOpts = chart.options.title;
          var titleBlock = chart.titleBlock;

          if (titleOpts) {
            helpers.mergeIf(titleOpts, defaults.global.title);

            if (titleBlock) {
              layout.configure(chart, titleBlock, titleOpts);
              titleBlock.options = titleOpts;
            } else {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          } else if (titleBlock) {
            Chart.layoutService.removeBox(chart, titleBlock);
            delete chart.titleBlock;
          }
        }
      };
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/scales/scale.category.js":
  /*!************************************************************!*\
    !*** ./node_modules/chart.js/src/scales/scale.category.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcScalesScaleCategoryJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = function (Chart) {
      // Default config for a category scale
      var defaultConfig = {
        position: 'bottom'
      };
      var DatasetScale = Chart.Scale.extend({
        /**
        * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
        * else fall back to data.labels
        * @private
        */
        getLabels: function getLabels() {
          var data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
        },
        determineDataLimits: function determineDataLimits() {
          var me = this;
          var labels = me.getLabels();
          me.minIndex = 0;
          me.maxIndex = labels.length - 1;
          var findIndex;

          if (me.options.ticks.min !== undefined) {
            // user specified min value
            findIndex = labels.indexOf(me.options.ticks.min);
            me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
          }

          if (me.options.ticks.max !== undefined) {
            // user specified max value
            findIndex = labels.indexOf(me.options.ticks.max);
            me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
          }

          me.min = labels[me.minIndex];
          me.max = labels[me.maxIndex];
        },
        buildTicks: function buildTicks() {
          var me = this;
          var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

          me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
        },
        getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
          var me = this;
          var data = me.chart.data;
          var isHorizontal = me.isHorizontal();

          if (data.yLabels && !isHorizontal) {
            return me.getRightValue(data.datasets[datasetIndex].data[index]);
          }

          return me.ticks[index - me.minIndex];
        },
        // Used to get data value locations.  Value can either be an index or a numerical value
        getPixelForValue: function getPixelForValue(value, index) {
          var me = this;
          var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

          var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
          // not the index of the scale. We need to change that.

          var valueCategory;

          if (value !== undefined && value !== null) {
            valueCategory = me.isHorizontal() ? value.x : value.y;
          }

          if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
            var labels = me.getLabels();
            value = valueCategory || value;
            var idx = labels.indexOf(value);
            index = idx !== -1 ? idx : index;
          }

          if (me.isHorizontal()) {
            var valueWidth = me.width / offsetAmt;
            var widthOffset = valueWidth * (index - me.minIndex);

            if (offset) {
              widthOffset += valueWidth / 2;
            }

            return me.left + Math.round(widthOffset);
          }

          var valueHeight = me.height / offsetAmt;
          var heightOffset = valueHeight * (index - me.minIndex);

          if (offset) {
            heightOffset += valueHeight / 2;
          }

          return me.top + Math.round(heightOffset);
        },
        getPixelForTick: function getPixelForTick(index) {
          return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
        },
        getValueForPixel: function getValueForPixel(pixel) {
          var me = this;
          var offset = me.options.offset;
          var value;
          var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var horz = me.isHorizontal();
          var valueDimension = (horz ? me.width : me.height) / offsetAmt;
          pixel -= horz ? me.left : me.top;

          if (offset) {
            pixel -= valueDimension / 2;
          }

          if (pixel <= 0) {
            value = 0;
          } else {
            value = Math.round(pixel / valueDimension);
          }

          return value + me.minIndex;
        },
        getBasePixel: function getBasePixel() {
          return this.bottom;
        }
      });
      Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/scales/scale.linear.js":
  /*!**********************************************************!*\
    !*** ./node_modules/chart.js/src/scales/scale.linear.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcScalesScaleLinearJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var Ticks = __webpack_require__(
    /*! ../core/core.ticks */
    "./node_modules/chart.js/src/core/core.ticks.js");

    module.exports = function (Chart) {
      var defaultConfig = {
        position: 'left',
        ticks: {
          callback: Ticks.formatters.linear
        }
      };
      var LinearScale = Chart.LinearScaleBase.extend({
        determineDataLimits: function determineDataLimits() {
          var me = this;
          var opts = me.options;
          var chart = me.chart;
          var data = chart.data;
          var datasets = data.datasets;
          var isHorizontal = me.isHorizontal();
          var DEFAULT_MIN = 0;
          var DEFAULT_MAX = 1;

          function IDMatches(meta) {
            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
          } // First Calculate the range


          me.min = null;
          me.max = null;
          var hasStacks = opts.stacked;

          if (hasStacks === undefined) {
            helpers.each(datasets, function (dataset, datasetIndex) {
              if (hasStacks) {
                return;
              }

              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
                hasStacks = true;
              }
            });
          }

          if (opts.stacked || hasStacks) {
            var valuesPerStack = {};
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
              opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = {
                  positiveValues: [],
                  negativeValues: []
                };
              } // Store these per type


              var positiveValues = valuesPerStack[key].positiveValues;
              var negativeValues = valuesPerStack[key].negativeValues;

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);

                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }

                  positiveValues[index] = positiveValues[index] || 0;
                  negativeValues[index] = negativeValues[index] || 0;

                  if (opts.relativePoints) {
                    positiveValues[index] = 100;
                  } else if (value < 0) {
                    negativeValues[index] += value;
                  } else {
                    positiveValues[index] += value;
                  }
                });
              }
            });
            helpers.each(valuesPerStack, function (valuesForType) {
              var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
              var minVal = helpers.min(values);
              var maxVal = helpers.max(values);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            });
          } else {
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);

                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }

                  if (me.min === null) {
                    me.min = value;
                  } else if (value < me.min) {
                    me.min = value;
                  }

                  if (me.max === null) {
                    me.max = value;
                  } else if (value > me.max) {
                    me.max = value;
                  }
                });
              }
            });
          }

          me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
          me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

          this.handleTickRangeOptions();
        },
        getTickLimit: function getTickLimit() {
          var maxTicks;
          var me = this;
          var tickOpts = me.options.ticks;

          if (me.isHorizontal()) {
            maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
          } else {
            // The factor of 2 used to scale the font size has been experimentally determined.
            var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
            maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
          }

          return maxTicks;
        },
        // Called after the ticks are built. We need
        handleDirectionalChanges: function handleDirectionalChanges() {
          if (!this.isHorizontal()) {
            // We are in a vertical orientation. The top value is the highest. So reverse the array
            this.ticks.reverse();
          }
        },
        getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
        },
        // Utils
        getPixelForValue: function getPixelForValue(value) {
          // This must be called after fit has been run so that
          // this.left, this.top, this.right, and this.bottom have been defined
          var me = this;
          var start = me.start;
          var rightValue = +me.getRightValue(value);
          var pixel;
          var range = me.end - start;

          if (me.isHorizontal()) {
            pixel = me.left + me.width / range * (rightValue - start);
            return Math.round(pixel);
          }

          pixel = me.bottom - me.height / range * (rightValue - start);
          return Math.round(pixel);
        },
        getValueForPixel: function getValueForPixel(pixel) {
          var me = this;
          var isHorizontal = me.isHorizontal();
          var innerDimension = isHorizontal ? me.width : me.height;
          var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
          return me.start + (me.end - me.start) * offset;
        },
        getPixelForTick: function getPixelForTick(index) {
          return this.getPixelForValue(this.ticksAsNumbers[index]);
        }
      });
      Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/scales/scale.linearbase.js":
  /*!**************************************************************!*\
    !*** ./node_modules/chart.js/src/scales/scale.linearbase.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcScalesScaleLinearbaseJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var Ticks = __webpack_require__(
    /*! ../core/core.ticks */
    "./node_modules/chart.js/src/core/core.ticks.js");

    module.exports = function (Chart) {
      var noop = helpers.noop;
      Chart.LinearScaleBase = Chart.Scale.extend({
        getRightValue: function getRightValue(value) {
          if (typeof value === 'string') {
            return +value;
          }

          return Chart.Scale.prototype.getRightValue.call(this, value);
        },
        handleTickRangeOptions: function handleTickRangeOptions() {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
          // do nothing since that would make the chart weird. If the user really wants a weird chart
          // axis, they can manually override it

          if (tickOpts.beginAtZero) {
            var minSign = helpers.sign(me.min);
            var maxSign = helpers.sign(me.max);

            if (minSign < 0 && maxSign < 0) {
              // move the top up to 0
              me.max = 0;
            } else if (minSign > 0 && maxSign > 0) {
              // move the bottom down to 0
              me.min = 0;
            }
          }

          var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
          var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

          if (tickOpts.min !== undefined) {
            me.min = tickOpts.min;
          } else if (tickOpts.suggestedMin !== undefined) {
            if (me.min === null) {
              me.min = tickOpts.suggestedMin;
            } else {
              me.min = Math.min(me.min, tickOpts.suggestedMin);
            }
          }

          if (tickOpts.max !== undefined) {
            me.max = tickOpts.max;
          } else if (tickOpts.suggestedMax !== undefined) {
            if (me.max === null) {
              me.max = tickOpts.suggestedMax;
            } else {
              me.max = Math.max(me.max, tickOpts.suggestedMax);
            }
          }

          if (setMin !== setMax) {
            // We set the min or the max but not both.
            // So ensure that our range is good
            // Inverted or 0 length range can happen when
            // ticks.min is set, and no datasets are visible
            if (me.min >= me.max) {
              if (setMin) {
                me.max = me.min + 1;
              } else {
                me.min = me.max - 1;
              }
            }
          }

          if (me.min === me.max) {
            me.max++;

            if (!tickOpts.beginAtZero) {
              me.min--;
            }
          }
        },
        getTickLimit: noop,
        handleDirectionalChanges: noop,
        buildTicks: function buildTicks() {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
          // the axis area. For now, we say that the minimum tick spacing in pixels must be 50
          // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
          // the graph. Make sure we always have at least 2 ticks

          var maxTicks = me.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          var numericGeneratorOptions = {
            maxTicks: maxTicks,
            min: tickOpts.min,
            max: tickOpts.max,
            stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
          };
          var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);
          me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
          // range of the scale

          me.max = helpers.max(ticks);
          me.min = helpers.min(ticks);

          if (tickOpts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }
        },
        convertTicksToLabels: function convertTicksToLabels() {
          var me = this;
          me.ticksAsNumbers = me.ticks.slice();
          me.zeroLineIndex = me.ticks.indexOf(0);
          Chart.Scale.prototype.convertTicksToLabels.call(me);
        }
      });
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/scales/scale.logarithmic.js":
  /*!***************************************************************!*\
    !*** ./node_modules/chart.js/src/scales/scale.logarithmic.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcScalesScaleLogarithmicJs(module, exports, __webpack_require__) {
    "use strict";

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var Ticks = __webpack_require__(
    /*! ../core/core.ticks */
    "./node_modules/chart.js/src/core/core.ticks.js");

    module.exports = function (Chart) {
      var defaultConfig = {
        position: 'left',
        // label settings
        ticks: {
          callback: Ticks.formatters.logarithmic
        }
      };
      var LogarithmicScale = Chart.Scale.extend({
        determineDataLimits: function determineDataLimits() {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks;
          var chart = me.chart;
          var data = chart.data;
          var datasets = data.datasets;
          var valueOrDefault = helpers.valueOrDefault;
          var isHorizontal = me.isHorizontal();

          function IDMatches(meta) {
            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
          } // Calculate Range


          me.min = null;
          me.max = null;
          me.minNotZero = null;
          var hasStacks = opts.stacked;

          if (hasStacks === undefined) {
            helpers.each(datasets, function (dataset, datasetIndex) {
              if (hasStacks) {
                return;
              }

              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
                hasStacks = true;
              }
            });
          }

          if (opts.stacked || hasStacks) {
            var valuesPerStack = {};
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);
              var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
              opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                if (valuesPerStack[key] === undefined) {
                  valuesPerStack[key] = [];
                }

                helpers.each(dataset.data, function (rawValue, index) {
                  var values = valuesPerStack[key];
                  var value = +me.getRightValue(rawValue);

                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }

                  values[index] = values[index] || 0;

                  if (opts.relativePoints) {
                    values[index] = 100;
                  } else {
                    // Don't need to split positive and negative since the log scale can't handle a 0 crossing
                    values[index] += value;
                  }
                });
              }
            });
            helpers.each(valuesPerStack, function (valuesForType) {
              var minVal = helpers.min(valuesForType);
              var maxVal = helpers.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            });
          } else {
            helpers.each(datasets, function (dataset, datasetIndex) {
              var meta = chart.getDatasetMeta(datasetIndex);

              if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                helpers.each(dataset.data, function (rawValue, index) {
                  var value = +me.getRightValue(rawValue);

                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }

                  if (me.min === null) {
                    me.min = value;
                  } else if (value < me.min) {
                    me.min = value;
                  }

                  if (me.max === null) {
                    me.max = value;
                  } else if (value > me.max) {
                    me.max = value;
                  }

                  if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                    me.minNotZero = value;
                  }
                });
              }
            });
          }

          me.min = valueOrDefault(tickOpts.min, me.min);
          me.max = valueOrDefault(tickOpts.max, me.max);

          if (me.min === me.max) {
            if (me.min !== 0 && me.min !== null) {
              me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
              me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
            } else {
              me.min = 1;
              me.max = 10;
            }
          }
        },
        buildTicks: function buildTicks() {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks;
          var generationOptions = {
            min: tickOpts.min,
            max: tickOpts.max
          };
          var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);

          if (!me.isHorizontal()) {
            // We are in a vertical orientation. The top value is the highest. So reverse the array
            ticks.reverse();
          } // At this point, we need to update our max and min given the tick values since we have expanded the
          // range of the scale


          me.max = helpers.max(ticks);
          me.min = helpers.min(ticks);

          if (tickOpts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }
        },
        convertTicksToLabels: function convertTicksToLabels() {
          this.tickValues = this.ticks.slice();
          Chart.Scale.prototype.convertTicksToLabels.call(this);
        },
        // Get the correct tooltip label
        getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
        },
        getPixelForTick: function getPixelForTick(index) {
          return this.getPixelForValue(this.tickValues[index]);
        },
        getPixelForValue: function getPixelForValue(value) {
          var me = this;
          var start = me.start;
          var newVal = +me.getRightValue(value);
          var opts = me.options;
          var tickOpts = opts.ticks;
          var innerDimension, pixel, range;

          if (me.isHorizontal()) {
            range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0

            if (newVal === 0) {
              pixel = me.left;
            } else {
              innerDimension = me.width;
              pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
            }
          } else {
            // Bottom - top since pixels increase downward on a screen
            innerDimension = me.height;

            if (start === 0 && !tickOpts.reverse) {
              range = helpers.log10(me.end) - helpers.log10(me.minNotZero);

              if (newVal === start) {
                pixel = me.bottom;
              } else if (newVal === me.minNotZero) {
                pixel = me.bottom - innerDimension * 0.02;
              } else {
                pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
              }
            } else if (me.end === 0 && tickOpts.reverse) {
              range = helpers.log10(me.start) - helpers.log10(me.minNotZero);

              if (newVal === me.end) {
                pixel = me.top;
              } else if (newVal === me.minNotZero) {
                pixel = me.top + innerDimension * 0.02;
              } else {
                pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
              }
            } else if (newVal === 0) {
              pixel = tickOpts.reverse ? me.top : me.bottom;
            } else {
              range = helpers.log10(me.end) - helpers.log10(start);
              innerDimension = me.height;
              pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
            }
          }

          return pixel;
        },
        getValueForPixel: function getValueForPixel(pixel) {
          var me = this;
          var range = helpers.log10(me.end) - helpers.log10(me.start);
          var value, innerDimension;

          if (me.isHorizontal()) {
            innerDimension = me.width;
            value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
          } else {
            // todo: if start === 0
            innerDimension = me.height;
            value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
          }

          return value;
        }
      });
      Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/scales/scale.radialLinear.js":
  /*!****************************************************************!*\
    !*** ./node_modules/chart.js/src/scales/scale.radialLinear.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcScalesScaleRadialLinearJs(module, exports, __webpack_require__) {
    "use strict";

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js");

    var Ticks = __webpack_require__(
    /*! ../core/core.ticks */
    "./node_modules/chart.js/src/core/core.ticks.js");

    module.exports = function (Chart) {
      var globalDefaults = defaults.global;
      var defaultConfig = {
        display: true,
        // Boolean - Whether to animate scaling the chart from the centre
        animate: true,
        position: 'chartArea',
        angleLines: {
          display: true,
          color: 'rgba(0, 0, 0, 0.1)',
          lineWidth: 1
        },
        gridLines: {
          circular: false
        },
        // label settings
        ticks: {
          // Boolean - Show a backdrop to the scale label
          showLabelBackdrop: true,
          // String - The colour of the label backdrop
          backdropColor: 'rgba(255,255,255,0.75)',
          // Number - The backdrop padding above & below the label in pixels
          backdropPaddingY: 2,
          // Number - The backdrop padding to the side of the label in pixels
          backdropPaddingX: 2,
          callback: Ticks.formatters.linear
        },
        pointLabels: {
          // Boolean - if true, show point labels
          display: true,
          // Number - Point label font size in pixels
          fontSize: 10,
          // Function - Used to convert point labels
          callback: function callback(label) {
            return label;
          }
        }
      };

      function getValueCount(scale) {
        var opts = scale.options;
        return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
      }

      function getPointLabelFontOptions(scale) {
        var pointLabelOptions = scale.options.pointLabels;
        var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
        var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
        var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
        var font = helpers.fontString(fontSize, fontStyle, fontFamily);
        return {
          size: fontSize,
          style: fontStyle,
          family: fontFamily,
          font: font
        };
      }

      function measureLabelSize(ctx, fontSize, label) {
        if (helpers.isArray(label)) {
          return {
            w: helpers.longestText(ctx, ctx.font, label),
            h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize
          };
        }

        return {
          w: ctx.measureText(label).width,
          h: fontSize
        };
      }

      function determineLimits(angle, pos, size, min, max) {
        if (angle === min || angle === max) {
          return {
            start: pos - size / 2,
            end: pos + size / 2
          };
        } else if (angle < min || angle > max) {
          return {
            start: pos - size - 5,
            end: pos
          };
        }

        return {
          start: pos,
          end: pos + size + 5
        };
      }
      /**
       * Helper function to fit a radial linear scale with point labels
       */


      function fitWithPointLabels(scale) {
        /*
         * Right, this is really confusing and there is a lot of maths going on here
         * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
         *
         * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
         *
         * Solution:
         *
         * We assume the radius of the polygon is half the size of the canvas at first
         * at each index we check if the text overlaps.
         *
         * Where it does, we store that angle and that index.
         *
         * After finding the largest index and angle we calculate how much we need to remove
         * from the shape radius to move the point inwards by that x.
         *
         * We average the left and right distances to get the maximum shape radius that can fit in the box
         * along with labels.
         *
         * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
         * on each side, removing that from the size, halving it and adding the left x protrusion width.
         *
         * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
         * and position it in the most space efficient manner
         *
         * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
         */
        var plFont = getPointLabelFontOptions(scale); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
        // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points

        var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
        var furthestLimits = {
          r: scale.width,
          l: 0,
          t: scale.height,
          b: 0
        };
        var furthestAngles = {};
        var i, textSize, pointPosition;
        scale.ctx.font = plFont.font;
        scale._pointLabelSizes = [];
        var valueCount = getValueCount(scale);

        for (i = 0; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, largestPossibleRadius);
          textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
          scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers.toDegrees(angleRadians) % 360;
          var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
          var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

          if (hLimits.start < furthestLimits.l) {
            furthestLimits.l = hLimits.start;
            furthestAngles.l = angleRadians;
          }

          if (hLimits.end > furthestLimits.r) {
            furthestLimits.r = hLimits.end;
            furthestAngles.r = angleRadians;
          }

          if (vLimits.start < furthestLimits.t) {
            furthestLimits.t = vLimits.start;
            furthestAngles.t = angleRadians;
          }

          if (vLimits.end > furthestLimits.b) {
            furthestLimits.b = vLimits.end;
            furthestAngles.b = angleRadians;
          }
        }

        scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
      }
      /**
       * Helper function to fit a radial linear scale with no point labels
       */


      function _fit(scale) {
        var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
        scale.drawingArea = Math.round(largestPossibleRadius);
        scale.setCenterPoint(0, 0, 0, 0);
      }

      function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
          return 'center';
        } else if (angle < 180) {
          return 'left';
        }

        return 'right';
      }

      function fillText(ctx, text, position, fontSize) {
        if (helpers.isArray(text)) {
          var y = position.y;
          var spacing = 1.5 * fontSize;

          for (var i = 0; i < text.length; ++i) {
            ctx.fillText(text[i], position.x, y);
            y += spacing;
          }
        } else {
          ctx.fillText(text, position.x, position.y);
        }
      }

      function adjustPointPositionForLabelHeight(angle, textSize, position) {
        if (angle === 90 || angle === 270) {
          position.y -= textSize.h / 2;
        } else if (angle > 270 || angle < 90) {
          position.y -= textSize.h;
        }
      }

      function drawPointLabels(scale) {
        var ctx = scale.ctx;
        var valueOrDefault = helpers.valueOrDefault;
        var opts = scale.options;
        var angleLineOpts = opts.angleLines;
        var pointLabelOpts = opts.pointLabels;
        ctx.lineWidth = angleLineOpts.lineWidth;
        ctx.strokeStyle = angleLineOpts.color;
        var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

        var plFont = getPointLabelFontOptions(scale);
        ctx.textBaseline = 'top';

        for (var i = getValueCount(scale) - 1; i >= 0; i--) {
          if (angleLineOpts.display) {
            var outerPosition = scale.getPointPosition(i, outerDistance);
            ctx.beginPath();
            ctx.moveTo(scale.xCenter, scale.yCenter);
            ctx.lineTo(outerPosition.x, outerPosition.y);
            ctx.stroke();
            ctx.closePath();
          }

          if (pointLabelOpts.display) {
            // Extra 3px out for some label spacing
            var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5); // Keep this in loop since we may support array properties here

            var pointLabelFontColor = valueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
            ctx.font = plFont.font;
            ctx.fillStyle = pointLabelFontColor;
            var angleRadians = scale.getIndexAngle(i);
            var angle = helpers.toDegrees(angleRadians);
            ctx.textAlign = getTextAlignForAngle(angle);
            adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
            fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
          }
        }
      }

      function drawRadiusLine(scale, gridLineOpts, radius, index) {
        var ctx = scale.ctx;
        ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
        ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

        if (scale.options.gridLines.circular) {
          // Draw circular arcs between the points
          ctx.beginPath();
          ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.stroke();
        } else {
          // Draw straight lines connecting each index
          var valueCount = getValueCount(scale);

          if (valueCount === 0) {
            return;
          }

          ctx.beginPath();
          var pointPosition = scale.getPointPosition(0, radius);
          ctx.moveTo(pointPosition.x, pointPosition.y);

          for (var i = 1; i < valueCount; i++) {
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
          }

          ctx.closePath();
          ctx.stroke();
        }
      }

      function numberOrZero(param) {
        return helpers.isNumber(param) ? param : 0;
      }

      var LinearRadialScale = Chart.LinearScaleBase.extend({
        setDimensions: function setDimensions() {
          var me = this;
          var opts = me.options;
          var tickOpts = opts.ticks; // Set the unconstrained dimension before label rotation

          me.width = me.maxWidth;
          me.height = me.maxHeight;
          me.xCenter = Math.round(me.width / 2);
          me.yCenter = Math.round(me.height / 2);
          var minSize = helpers.min([me.height, me.width]);
          var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
          me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;
        },
        determineDataLimits: function determineDataLimits() {
          var me = this;
          var chart = me.chart;
          var min = Number.POSITIVE_INFINITY;
          var max = Number.NEGATIVE_INFINITY;
          helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
            if (chart.isDatasetVisible(datasetIndex)) {
              var meta = chart.getDatasetMeta(datasetIndex);
              helpers.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                min = Math.min(value, min);
                max = Math.max(value, max);
              });
            }
          });
          me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
          me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

          me.handleTickRangeOptions();
        },
        getTickLimit: function getTickLimit() {
          var tickOpts = this.options.ticks;
          var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
          return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
        },
        convertTicksToLabels: function convertTicksToLabels() {
          var me = this;
          Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me); // Point labels

          me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
        },
        getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
          return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
        },
        fit: function fit() {
          if (this.options.pointLabels.display) {
            fitWithPointLabels(this);
          } else {
            _fit(this);
          }
        },

        /**
         * Set radius reductions and determine new radius and center point
         * @private
         */
        setReductions: function setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
          var me = this;
          var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
          var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
          var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
          var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
          radiusReductionLeft = numberOrZero(radiusReductionLeft);
          radiusReductionRight = numberOrZero(radiusReductionRight);
          radiusReductionTop = numberOrZero(radiusReductionTop);
          radiusReductionBottom = numberOrZero(radiusReductionBottom);
          me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
          me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
        },
        setCenterPoint: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
          var me = this;
          var maxRight = me.width - rightMovement - me.drawingArea;
          var maxLeft = leftMovement + me.drawingArea;
          var maxTop = topMovement + me.drawingArea;
          var maxBottom = me.height - bottomMovement - me.drawingArea;
          me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
          me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);
        },
        getIndexAngle: function getIndexAngle(index) {
          var angleMultiplier = Math.PI * 2 / getValueCount(this);
          var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
          var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

          return index * angleMultiplier + startAngleRadians;
        },
        getDistanceFromCenterForValue: function getDistanceFromCenterForValue(value) {
          var me = this;

          if (value === null) {
            return 0; // null always in center
          } // Take into account half font size + the yPadding of the top value


          var scalingFactor = me.drawingArea / (me.max - me.min);

          if (me.options.ticks.reverse) {
            return (me.max - value) * scalingFactor;
          }

          return (value - me.min) * scalingFactor;
        },
        getPointPosition: function getPointPosition(index, distanceFromCenter) {
          var me = this;
          var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
          return {
            x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
            y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
          };
        },
        getPointPositionForValue: function getPointPositionForValue(index, value) {
          return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
        },
        getBasePosition: function getBasePosition() {
          var me = this;
          var min = me.min;
          var max = me.max;
          return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
        },
        draw: function draw() {
          var me = this;
          var opts = me.options;
          var gridLineOpts = opts.gridLines;
          var tickOpts = opts.ticks;
          var valueOrDefault = helpers.valueOrDefault;

          if (opts.display) {
            var ctx = me.ctx;
            var startAngle = this.getIndexAngle(0); // Tick Font

            var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
            var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
            var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
            var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
            helpers.each(me.ticks, function (label, index) {
              // Don't draw a centre value (if it is minimum)
              if (index > 0 || tickOpts.reverse) {
                var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

                if (gridLineOpts.display && index !== 0) {
                  drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
                }

                if (tickOpts.display) {
                  var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
                  ctx.font = tickLabelFont;
                  ctx.save();
                  ctx.translate(me.xCenter, me.yCenter);
                  ctx.rotate(startAngle);

                  if (tickOpts.showLabelBackdrop) {
                    var labelWidth = ctx.measureText(label).width;
                    ctx.fillStyle = tickOpts.backdropColor;
                    ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);
                  }

                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillStyle = tickFontColor;
                  ctx.fillText(label, 0, -yCenterOffset);
                  ctx.restore();
                }
              }
            });

            if (opts.angleLines.display || opts.pointLabels.display) {
              drawPointLabels(me);
            }
          }
        }
      });
      Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
    };
    /***/

  },

  /***/
  "./node_modules/chart.js/src/scales/scale.time.js":
  /*!********************************************************!*\
    !*** ./node_modules/chart.js/src/scales/scale.time.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartJsSrcScalesScaleTimeJs(module, exports, __webpack_require__) {
    "use strict";
    /* global window: false */

    var moment = __webpack_require__(
    /*! moment */
    "./node_modules/chart.js/node_modules/moment/moment.js");

    moment = typeof moment === 'function' ? moment : window.moment;

    var defaults = __webpack_require__(
    /*! ../core/core.defaults */
    "./node_modules/chart.js/src/core/core.defaults.js");

    var helpers = __webpack_require__(
    /*! ../helpers/index */
    "./node_modules/chart.js/src/helpers/index.js"); // Integer constants are from the ES6 spec.


    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
      },
      second: {
        common: true,
        size: 1000,
        steps: [1, 2, 5, 10, 30]
      },
      minute: {
        common: true,
        size: 60000,
        steps: [1, 2, 5, 10, 30]
      },
      hour: {
        common: true,
        size: 3600000,
        steps: [1, 2, 3, 6, 12]
      },
      day: {
        common: true,
        size: 86400000,
        steps: [1, 2, 5]
      },
      week: {
        common: false,
        size: 604800000,
        steps: [1, 2, 3, 4]
      },
      month: {
        common: true,
        size: 2.628e9,
        steps: [1, 2, 3]
      },
      quarter: {
        common: false,
        size: 7.884e9,
        steps: [1, 2, 3, 4]
      },
      year: {
        common: true,
        size: 3.154e10
      }
    };
    var UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
      return a - b;
    }

    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];

        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }

      return out;
    }
    /**
     * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
     * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
     * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
     * extremity (left + width or top + height). Note that it would be more optimized to directly
     * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
     * to create the lookup table. The table ALWAYS contains at least two items: min and max.
     *
     * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
     * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
     * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
     * If 'series', timestamps will be positioned at the same distance from each other. In this
     * case, only timestamps that break the time linearity are registered, meaning that in the
     * best case, all timestamps are linear, the table contains only min and max.
     */


    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === 'linear' || !timestamps.length) {
        return [{
          time: min,
          pos: 0
        }, {
          time: max,
          pos: 1
        }];
      }

      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];

        if (curr > min && curr < max) {
          items.push(curr);
        }
      }

      items.push(max);

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i]; // only add points that breaks the scale linearity

        if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }

      return table;
    } // @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;

      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];

        if (!i0) {
          // given value is outside table (before first item)
          return {
            lo: null,
            hi: i1
          };
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {
            lo: i0,
            hi: i1
          };
        }
      } // given value is outside table (after last item)


      return {
        lo: i1,
        hi: null
      };
    }
    /**
     * Linearly interpolates the given source `value` using the table items `skey` values and
     * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
     * returns the position for a timestamp equal to 42. If value is out of bounds, values at
     * index [0, 1] or [n - 1, n] are used for the interpolation.
     */


    function interpolate(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }
    /**
     * Convert the given value to a moment object using the given time options.
     * @see http://momentjs.com/docs/#/parsing/
     */


    function momentify(value, options) {
      var parser = options.parser;
      var format = options.parser || options.format;

      if (typeof parser === 'function') {
        return parser(value);
      }

      if (typeof value === 'string' && typeof format === 'string') {
        return moment(value, format);
      }

      if (!(value instanceof moment)) {
        value = moment(value);
      }

      if (value.isValid()) {
        return value;
      } // Labels are in an incompatible moment format and no `parser` has been provided.
      // The user might still use the deprecated `format` option to convert his inputs.


      if (typeof format === 'function') {
        return format(value);
      }

      return value;
    }

    function parse(input, scale) {
      if (helpers.isNullOrUndef(input)) {
        return null;
      }

      var options = scale.options.time;
      var value = momentify(scale.getRightValue(input), options);

      if (!value.isValid()) {
        return null;
      }

      if (options.round) {
        value.startOf(options.round);
      }

      return value.valueOf();
    }
    /**
     * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
     * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
     */


    function determineStepSize(min, max, unit, capacity) {
      var range = max - min;
      var interval = INTERVALS[unit];
      var milliseconds = interval.size;
      var steps = interval.steps;
      var i, ilen, factor;

      if (!steps) {
        return Math.ceil(range / ((capacity || 1) * milliseconds));
      }

      for (i = 0, ilen = steps.length; i < ilen; ++i) {
        factor = steps[i];

        if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
          break;
        }
      }

      return factor;
    }
    /**
     * Figures out what unit results in an appropriate number of auto-generated ticks
     */


    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;

      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }

      return UNITS[ilen - 1];
    }
    /**
     * Figures out what unit to format a set of ticks with
     */


    function determineUnitForFormatting(ticks, minUnit, min, max) {
      var duration = moment.duration(moment(max).diff(moment(min)));
      var ilen = UNITS.length;
      var i, unit;

      for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];

        if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
          return unit;
        }
      }

      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }

    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    /**
     * Generates a maximum of `capacity` timestamps between min and max, rounded to the
     * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
     * Important: this method can return ticks outside the min and max range, it's the
     * responsibility of the calling code to clamp values if needed.
     */


    function generate(min, max, capacity, options) {
      var timeOpts = options.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var major = determineMajorUnit(minor);
      var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
      var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
      var majorTicksEnabled = options.ticks.major.enabled;
      var interval = INTERVALS[minor];
      var first = moment(min);
      var last = moment(max);
      var ticks = [];
      var time;

      if (!stepSize) {
        stepSize = determineStepSize(min, max, minor, capacity);
      } // For 'week' unit, handle the first day of week option


      if (weekday) {
        first = first.isoWeekday(weekday);
        last = last.isoWeekday(weekday);
      } // Align first/last ticks on unit


      first = first.startOf(weekday ? 'day' : minor);
      last = last.startOf(weekday ? 'day' : minor); // Make sure that the last tick include max

      if (last < max) {
        last.add(1, minor);
      }

      time = moment(first);

      if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
        // Align the first tick on the previous `minor` unit aligned on the `major` unit:
        // we first aligned time on the previous `major` unit then add the number of full
        // stepSize there is between first and the previous major time.
        time.startOf(major);
        time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
      }

      for (; time < last; time.add(stepSize, minor)) {
        ticks.push(+time);
      }

      ticks.push(+time);
      return ticks;
    }
    /**
     * Returns the right and left offsets from edges in the form of {left, right}.
     * Offsets are added when the `offset` option is true.
     */


    function computeOffsets(table, ticks, min, max, options) {
      var left = 0;
      var right = 0;
      var upper, lower;

      if (options.offset && ticks.length) {
        if (!options.time.min) {
          upper = ticks.length > 1 ? ticks[1] : max;
          lower = ticks[0];
          left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
        }

        if (!options.time.max) {
          upper = ticks[ticks.length - 1];
          lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
          right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
        }
      }

      return {
        left: left,
        right: right
      };
    }

    function ticksFromTimestamps(values, majorUnit) {
      var ticks = [];
      var i, ilen, value, major;

      for (i = 0, ilen = values.length; i < ilen; ++i) {
        value = values[i];
        major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;
        ticks.push({
          value: value,
          major: major
        });
      }

      return ticks;
    }

    module.exports = function (Chart) {
      var defaultConfig = {
        position: 'bottom',

        /**
         * Data distribution along the scale:
         * - 'linear': data are spread according to their time (distances can vary),
         * - 'series': data are spread at the same distance from each other.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        distribution: 'linear',

        /**
         * Scale boundary strategy (bypassed by min/max time options)
         * - `data`: make sure data are fully visible, ticks outside are removed
         * - `ticks`: make sure ticks are fully visible, data outside are truncated
         * @see https://github.com/chartjs/Chart.js/pull/4556
         * @since 2.7.0
         */
        bounds: 'data',
        time: {
          parser: false,
          // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
          format: false,
          // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
          unit: false,
          // false == automatic or override with week, month, year, etc.
          round: false,
          // none, or override with week, month, year, etc.
          displayFormat: false,
          // DEPRECATED
          isoWeekday: false,
          // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
          minUnit: 'millisecond',
          // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
          displayFormats: {
            millisecond: 'h:mm:ss.SSS a',
            // 11:20:01.123 AM,
            second: 'h:mm:ss a',
            // 11:20:01 AM
            minute: 'h:mm a',
            // 11:20 AM
            hour: 'hA',
            // 5PM
            day: 'MMM D',
            // Sep 4
            week: 'll',
            // Week 46, or maybe "[W]WW - YYYY" ?
            month: 'MMM YYYY',
            // Sept 2015
            quarter: '[Q]Q - YYYY',
            // Q3
            year: 'YYYY' // 2015

          }
        },
        ticks: {
          autoSkip: false,

          /**
           * Ticks generation input values:
           * - 'auto': generates "optimal" ticks based on scale size and time options.
           * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
           * - 'labels': generates ticks from user given `data.labels` values ONLY.
           * @see https://github.com/chartjs/Chart.js/pull/4507
           * @since 2.7.0
           */
          source: 'auto',
          major: {
            enabled: false
          }
        }
      };
      var TimeScale = Chart.Scale.extend({
        initialize: function initialize() {
          if (!moment) {
            throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
          }

          this.mergeTicksOptions();
          Chart.Scale.prototype.initialize.call(this);
        },
        update: function update() {
          var me = this;
          var options = me.options; // DEPRECATIONS: output a message only one time per update

          if (options.time && options.time.format) {
            console.warn('options.time.format is deprecated and replaced by options.time.parser.');
          }

          return Chart.Scale.prototype.update.apply(me, arguments);
        },

        /**
         * Allows data to be referenced via 't' attribute
         */
        getRightValue: function getRightValue(rawValue) {
          if (rawValue && rawValue.t !== undefined) {
            rawValue = rawValue.t;
          }

          return Chart.Scale.prototype.getRightValue.call(this, rawValue);
        },
        determineDataLimits: function determineDataLimits() {
          var me = this;
          var chart = me.chart;
          var timeOpts = me.options.time;
          var min = MAX_INTEGER;
          var max = MIN_INTEGER;
          var timestamps = [];
          var datasets = [];
          var labels = [];
          var i, j, ilen, jlen, data, timestamp; // Convert labels to timestamps

          for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
            labels.push(parse(chart.data.labels[i], me));
          } // Convert data to timestamps


          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

              if (helpers.isObject(data[0])) {
                datasets[i] = [];

                for (j = 0, jlen = data.length; j < jlen; ++j) {
                  timestamp = parse(data[j], me);
                  timestamps.push(timestamp);
                  datasets[i][j] = timestamp;
                }
              } else {
                timestamps.push.apply(timestamps, labels);
                datasets[i] = labels.slice(0);
              }
            } else {
              datasets[i] = [];
            }
          }

          if (labels.length) {
            // Sort labels **after** data have been converted
            labels = arrayUnique(labels).sort(sorter);
            min = Math.min(min, labels[0]);
            max = Math.max(max, labels[labels.length - 1]);
          }

          if (timestamps.length) {
            timestamps = arrayUnique(timestamps).sort(sorter);
            min = Math.min(min, timestamps[0]);
            max = Math.max(max, timestamps[timestamps.length - 1]);
          }

          min = parse(timeOpts.min, me) || min;
          max = parse(timeOpts.max, me) || max; // In case there is no valid min/max, let's use today limits

          min = min === MAX_INTEGER ? +moment().startOf('day') : min;
          max = max === MIN_INTEGER ? +moment().endOf('day') + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

          me.min = Math.min(min, max);
          me.max = Math.max(min + 1, max); // PRIVATE

          me._horizontal = me.isHorizontal();
          me._table = [];
          me._timestamps = {
            data: timestamps,
            datasets: datasets,
            labels: labels
          };
        },
        buildTicks: function buildTicks() {
          var me = this;
          var min = me.min;
          var max = me.max;
          var options = me.options;
          var timeOpts = options.time;
          var timestamps = [];
          var ticks = [];
          var i, ilen, timestamp;

          switch (options.ticks.source) {
            case 'data':
              timestamps = me._timestamps.data;
              break;

            case 'labels':
              timestamps = me._timestamps.labels;
              break;

            case 'auto':
            default:
              timestamps = generate(min, max, me.getLabelCapacity(min), options);
          }

          if (options.bounds === 'ticks' && timestamps.length) {
            min = timestamps[0];
            max = timestamps[timestamps.length - 1];
          } // Enforce limits with user min/max options


          min = parse(timeOpts.min, me) || min;
          max = parse(timeOpts.max, me) || max; // Remove ticks outside the min/max range

          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            timestamp = timestamps[i];

            if (timestamp >= min && timestamp <= max) {
              ticks.push(timestamp);
            }
          }

          me.min = min;
          me.max = max; // PRIVATE

          me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
          me._majorUnit = determineMajorUnit(me._unit);
          me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
          me._offsets = computeOffsets(me._table, ticks, min, max, options);
          return ticksFromTimestamps(ticks, me._majorUnit);
        },
        getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
          var me = this;
          var data = me.chart.data;
          var timeOpts = me.options.time;
          var label = data.labels && index < data.labels.length ? data.labels[index] : '';
          var value = data.datasets[datasetIndex].data[index];

          if (helpers.isObject(value)) {
            label = me.getRightValue(value);
          }

          if (timeOpts.tooltipFormat) {
            label = momentify(label, timeOpts).format(timeOpts.tooltipFormat);
          }

          return label;
        },

        /**
         * Function to format an individual tick mark
         * @private
         */
        tickFormatFunction: function tickFormatFunction(tick, index, ticks, formatOverride) {
          var me = this;
          var options = me.options;
          var time = tick.valueOf();
          var formats = options.time.displayFormats;
          var minorFormat = formats[me._unit];
          var majorUnit = me._majorUnit;
          var majorFormat = formats[majorUnit];
          var majorTime = tick.clone().startOf(majorUnit).valueOf();
          var majorTickOpts = options.ticks.major;
          var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
          var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
          var tickOpts = major ? majorTickOpts : options.ticks.minor;
          var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);
          return formatter ? formatter(label, index, ticks) : label;
        },
        convertTicksToLabels: function convertTicksToLabels(ticks) {
          var labels = [];
          var i, ilen;

          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
          }

          return labels;
        },

        /**
         * @private
         */
        getPixelForOffset: function getPixelForOffset(time) {
          var me = this;
          var size = me._horizontal ? me.width : me.height;
          var start = me._horizontal ? me.left : me.top;
          var pos = interpolate(me._table, 'time', time, 'pos');
          return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
        },
        getPixelForValue: function getPixelForValue(value, index, datasetIndex) {
          var me = this;
          var time = null;

          if (index !== undefined && datasetIndex !== undefined) {
            time = me._timestamps.datasets[datasetIndex][index];
          }

          if (time === null) {
            time = parse(value, me);
          }

          if (time !== null) {
            return me.getPixelForOffset(time);
          }
        },
        getPixelForTick: function getPixelForTick(index) {
          var ticks = this.getTicks();
          return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
        },
        getValueForPixel: function getValueForPixel(pixel) {
          var me = this;
          var size = me._horizontal ? me.width : me.height;
          var start = me._horizontal ? me.left : me.top;
          var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
          var time = interpolate(me._table, 'pos', pos, 'time');
          return moment(time);
        },

        /**
         * Crude approximation of what the label width might be
         * @private
         */
        getLabelWidth: function getLabelWidth(label) {
          var me = this;
          var ticksOpts = me.options.ticks;
          var tickLabelWidth = me.ctx.measureText(label).width;
          var angle = helpers.toRadians(ticksOpts.maxRotation);
          var cosRotation = Math.cos(angle);
          var sinRotation = Math.sin(angle);
          var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);
          return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
        },

        /**
         * @private
         */
        getLabelCapacity: function getLabelCapacity(exampleTime) {
          var me = this;
          var formatOverride = me.options.time.displayFormats.millisecond; // Pick the longest format for guestimation

          var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
          var tickLabelWidth = me.getLabelWidth(exampleLabel);
          var innerWidth = me.isHorizontal() ? me.width : me.height;
          return Math.floor(innerWidth / tickLabelWidth);
        }
      });
      Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
    };
    /***/

  },

  /***/
  "./node_modules/chartjs-color-string/color-string.js":
  /*!***********************************************************!*\
    !*** ./node_modules/chartjs-color-string/color-string.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartjsColorStringColorStringJs(module, exports, __webpack_require__) {
    /* MIT license */
    var colorNames = __webpack_require__(
    /*! color-name */
    "./node_modules/color-name/index.js");

    module.exports = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };

    function getRgba(string) {
      if (!string) {
        return;
      }

      var abbr = /^#([a-fA-F0-9]{3})$/i,
          hex = /^#([a-fA-F0-9]{6})$/i,
          rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          keyword = /(\w+)/;
      var rgb = [0, 0, 0],
          a = 1,
          match = string.match(abbr);

      if (match) {
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
      } else if (match = string.match(hex)) {
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(keyword)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }

        rgb = colorNames[match[1]];

        if (!rgb) {
          return;
        }
      }

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }

      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }

      rgb[3] = a;
      return rgb;
    }

    function getHsla(string) {
      if (!string) {
        return;
      }

      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            s = scale(parseFloat(match[2]), 0, 100),
            l = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }

    function getHwb(string) {
      if (!string) {
        return;
      }

      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            w = scale(parseFloat(match[2]), 0, 100),
            b = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }

    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }

    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }

    function getAlpha(string) {
      var vals = getRgba(string);

      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    } // generators


    function hexString(rgb) {
      return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
    }

    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }

      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }

    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1;
      }

      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }

    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }

      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }

    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }

    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }

      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }

    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1;
      }

      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)


    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1;
      }

      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
    }

    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    } // helpers


    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    } //create a list of reverse color names


    var reverseNames = {};

    for (var name in colorNames) {
      reverseNames[colorNames[name]] = name;
    }
    /***/

  },

  /***/
  "./node_modules/chartjs-color/index.js":
  /*!*********************************************!*\
    !*** ./node_modules/chartjs-color/index.js ***!
    \*********************************************/

  /*! no static exports found */

  /***/
  function node_modulesChartjsColorIndexJs(module, exports, __webpack_require__) {
    /* MIT license */
    var convert = __webpack_require__(
    /*! color-convert */
    "./node_modules/color-convert/index.js");

    var string = __webpack_require__(
    /*! chartjs-color-string */
    "./node_modules/chartjs-color-string/color-string.js");

    var Color = function Color(obj) {
      if (obj instanceof Color) {
        return obj;
      }

      if (!(this instanceof Color)) {
        return new Color(obj);
      }

      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      }; // parse Color() argument

      var vals;

      if (typeof obj === 'string') {
        vals = string.getRgba(obj);

        if (vals) {
          this.setValues('rgb', vals);
        } else if (vals = string.getHsla(obj)) {
          this.setValues('hsl', vals);
        } else if (vals = string.getHwb(obj)) {
          this.setValues('hwb', vals);
        }
      } else if (typeof obj === 'object') {
        vals = obj;

        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals);
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals);
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals);
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals);
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals);
        }
      }
    };

    Color.prototype = {
      isValid: function isValid() {
        return this.valid;
      },
      rgb: function rgb() {
        return this.setSpace('rgb', arguments);
      },
      hsl: function hsl() {
        return this.setSpace('hsl', arguments);
      },
      hsv: function hsv() {
        return this.setSpace('hsv', arguments);
      },
      hwb: function hwb() {
        return this.setSpace('hwb', arguments);
      },
      cmyk: function cmyk() {
        return this.setSpace('cmyk', arguments);
      },
      rgbArray: function rgbArray() {
        return this.values.rgb;
      },
      hslArray: function hslArray() {
        return this.values.hsl;
      },
      hsvArray: function hsvArray() {
        return this.values.hsv;
      },
      hwbArray: function hwbArray() {
        var values = this.values;

        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }

        return values.hwb;
      },
      cmykArray: function cmykArray() {
        return this.values.cmyk;
      },
      rgbaArray: function rgbaArray() {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function hslaArray() {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function alpha(val) {
        if (val === undefined) {
          return this.values.alpha;
        }

        this.setValues('alpha', val);
        return this;
      },
      red: function red(val) {
        return this.setChannel('rgb', 0, val);
      },
      green: function green(val) {
        return this.setChannel('rgb', 1, val);
      },
      blue: function blue(val) {
        return this.setChannel('rgb', 2, val);
      },
      hue: function hue(val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }

        return this.setChannel('hsl', 0, val);
      },
      saturation: function saturation(val) {
        return this.setChannel('hsl', 1, val);
      },
      lightness: function lightness(val) {
        return this.setChannel('hsl', 2, val);
      },
      saturationv: function saturationv(val) {
        return this.setChannel('hsv', 1, val);
      },
      whiteness: function whiteness(val) {
        return this.setChannel('hwb', 1, val);
      },
      blackness: function blackness(val) {
        return this.setChannel('hwb', 2, val);
      },
      value: function value(val) {
        return this.setChannel('hsv', 2, val);
      },
      cyan: function cyan(val) {
        return this.setChannel('cmyk', 0, val);
      },
      magenta: function magenta(val) {
        return this.setChannel('cmyk', 1, val);
      },
      yellow: function yellow(val) {
        return this.setChannel('cmyk', 2, val);
      },
      black: function black(val) {
        return this.setChannel('cmyk', 3, val);
      },
      hexString: function hexString() {
        return string.hexString(this.values.rgb);
      },
      rgbString: function rgbString() {
        return string.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function rgbaString() {
        return string.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function percentString() {
        return string.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function hslString() {
        return string.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function hslaString() {
        return string.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function hwbString() {
        return string.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function keyword() {
        return string.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function rgbNumber() {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function luminosity() {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];

        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }

        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function contrast(color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();

        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }

        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function level(color2) {
        var contrastRatio = this.contrast(color2);

        if (contrastRatio >= 7.1) {
          return 'AAA';
        }

        return contrastRatio >= 4.5 ? 'AA' : '';
      },
      dark: function dark() {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128;
      },
      light: function light() {
        return !this.dark();
      },
      negate: function negate() {
        var rgb = [];

        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }

        this.setValues('rgb', rgb);
        return this;
      },
      lighten: function lighten(ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      darken: function darken(ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      saturate: function saturate(ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      desaturate: function desaturate(ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      whiten: function whiten(ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      blacken: function blacken(ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      greyscale: function greyscale() {
        var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [val, val, val]);
        return this;
      },
      clearer: function clearer(ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this;
      },
      opaquer: function opaquer(ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this;
      },
      rotate: function rotate(degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this;
      },

      /**
       * Ported from sass implementation in C
       * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
       */
      mix: function mix(mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function toJSON() {
        return this.rgb();
      },
      clone: function clone() {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);

            if (type === '[object Array]') {
              target[prop] = value.slice(0);
            } else if (type === '[object Number]') {
              target[prop] = value;
            } else {
              console.error('unexpected color value:', value);
            }
          }
        }

        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ['red', 'green', 'blue'],
      hsl: ['hue', 'saturation', 'lightness'],
      hsv: ['hue', 'saturation', 'value'],
      hwb: ['hue', 'whiteness', 'blackness'],
      cmyk: ['cyan', 'magenta', 'yellow', 'black']
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };

    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};

      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }

      if (values.alpha !== 1) {
        vals.a = values.alpha;
      } // {r: 255, g: 255, b: 255, a: 0.4}


      return vals;
    };

    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;

      if (space === 'alpha') {
        alpha = vals;
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }

        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];

        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }

        alpha = vals.alpha;
      }

      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

      if (space === 'alpha') {
        return false;
      }

      var capped; // cap values of the space prior converting all values

      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      } // convert to all the other color spaces


      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = convert[space][sname](values[space]);
        }
      }

      return true;
    };

    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];

      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args);
      }

      this.setValues(space, vals);
      return this;
    };

    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];

      if (val === undefined) {
        // color.red()
        return svalues[index];
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this;
      } // color.red(100)


      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };

    if (typeof window !== 'undefined') {
      window.Color = Color;
    }

    module.exports = Color;
    /***/
  },

  /***/
  "./node_modules/color-convert/conversions.js":
  /*!***************************************************!*\
    !*** ./node_modules/color-convert/conversions.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesColorConvertConversionsJs(module, exports) {
    /* MIT license */
    module.exports = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };

    function rgb2hsl(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          l;
      if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;
      h = Math.min(h * 60, 360);
      if (h < 0) h += 360;
      l = (min + max) / 2;
      if (max == min) s = 0;else if (l <= 0.5) s = delta / (max + min);else s = delta / (2 - max - min);
      return [h, s * 100, l * 100];
    }

    function rgb2hsv(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          v;
      if (max == 0) s = 0;else s = delta / max * 1000 / 10;
      if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;
      h = Math.min(h * 60, 360);
      if (h < 0) h += 360;
      v = max / 255 * 1000 / 10;
      return [h, s, v];
    }

    function rgb2hwb(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          h = rgb2hsl(rgb)[0],
          w = 1 / 255 * Math.min(r, Math.min(g, b)),
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    }

    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          c,
          m,
          y,
          k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    }

    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)];
    }

    function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }

    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function rgb2lch(args) {
      return lab2lch(rgb2lab(args));
    }

    function hsl2rgb(hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s == 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) t2 = l * (1 + s);else t2 = l + s - l * s;
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;
        if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;else if (2 * t3 < 1) val = t2;else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;else val = t1;
        rgb[i] = val * 255;
      }

      return rgb;
    }

    function hsl2hsv(hsl) {
      var h = hsl[0],
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          sv,
          v;

      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
      }

      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    }

    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args));
    }

    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args));
    }

    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args));
    }

    function hsv2rgb(hsv) {
      var h = hsv[0] / 60,
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          hi = Math.floor(h) % 6;
      var f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f)),
          v = 255 * v;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    }

    function hsv2hsl(hsv) {
      var h = hsv[0],
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          sl,
          l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }

    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args));
    }

    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args));
    }

    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args));
    } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    function hwb2rgb(hwb) {
      var h = hwb[0] / 360,
          wh = hwb[1] / 100,
          bl = hwb[2] / 100,
          ratio = wh + bl,
          i,
          v,
          f,
          n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) != 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    }

    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args));
    }

    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args));
    }

    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args));
    }

    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args));
    }

    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100,
          m = cmyk[1] / 100,
          y = cmyk[2] / 100,
          k = cmyk[3] / 100,
          r,
          g,
          b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    }

    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args));
    }

    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args));
    }

    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args));
    }

    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args));
    }

    function xyz2rgb(xyz) {
      var x = xyz[0] / 100,
          y = xyz[1] / 100,
          z = xyz[2] / 100,
          r,
          g,
          b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    }

    function xyz2lab(xyz) {
      var x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function xyz2lch(args) {
      return lab2lch(xyz2lab(args));
    }

    function lab2xyz(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          x,
          y,
          z,
          y2;

      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }

      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    }

    function lab2lch(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          hr,
          h,
          c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    }

    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args));
    }

    function lch2lab(lch) {
      var l = lch[0],
          c = lch[1],
          h = lch[2],
          a,
          b,
          hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    }

    function lch2xyz(args) {
      return lab2xyz(lch2lab(args));
    }

    function lch2rgb(args) {
      return lab2rgb(lch2lab(args));
    }

    function keyword2rgb(keyword) {
      return cssKeywords[keyword];
    }

    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args));
    }

    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args));
    }

    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args));
    }

    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args));
    }

    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args));
    }

    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args));
    }

    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseKeywords = {};

    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
    }
    /***/

  },

  /***/
  "./node_modules/color-convert/index.js":
  /*!*********************************************!*\
    !*** ./node_modules/color-convert/index.js ***!
    \*********************************************/

  /*! no static exports found */

  /***/
  function node_modulesColorConvertIndexJs(module, exports, __webpack_require__) {
    var conversions = __webpack_require__(
    /*! ./conversions */
    "./node_modules/color-convert/conversions.js");

    var convert = function convert() {
      return new Converter();
    };

    for (var func in conversions) {
      // export Raw versions
      convert[func + "Raw"] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
          return conversions[func](arg);
        };
      }(func);

      var pair = /(\w+)2(\w+)/.exec(func),
          from = pair[1],
          to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

      convert[from] = convert[from] || {};

      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
          var val = conversions[func](arg);
          if (typeof val == "string" || val === undefined) return val; // keyword

          for (var i = 0; i < val.length; i++) {
            val[i] = Math.round(val[i]);
          }

          return val;
        };
      }(func);
    }
    /* Converter does lazy conversion and caching */


    var Converter = function Converter() {
      this.convs = {};
    };
    /* Either get the values for a space or
      set the values for a space, depending on args */


    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];

      if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof values == "number") {
        values = Array.prototype.slice.call(args);
      }

      return this.setValues(space, values);
    };
    /* Set the values for a space, invalidating cache */


    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this;
    };
    /* Get the values for a space. If there's already
      a conversion for the space, fetch it, otherwise
      compute it */


    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];

      if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals;
      }

      return vals;
    };

    ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments);
      };
    });
    module.exports = convert;
    /***/
  },

  /***/
  "./node_modules/color-name/index.js":
  /*!******************************************!*\
    !*** ./node_modules/color-name/index.js ***!
    \******************************************/

  /*! no static exports found */

  /***/
  function node_modulesColorNameIndexJs(module, exports, __webpack_require__) {
    "use strict";

    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    /***/
  },

  /***/
  "./node_modules/events/events.js":
  /*!***************************************!*\
    !*** ./node_modules/events/events.js ***!
    \***************************************/

  /*! no static exports found */

  /***/
  function node_modulesEventsEventsJs(module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }

    module.exports = EventEmitter; // Backwards-compat with node 0.10.x

    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.

    EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.

    EventEmitter.prototype.setMaxListeners = function (n) {
      if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
      this._maxListeners = n;
      return this;
    };

    EventEmitter.prototype.emit = function (type) {
      var er, handler, len, args, i, listeners;
      if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.

      if (type === 'error') {
        if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
          er = arguments[1];

          if (er instanceof Error) {
            throw er; // Unhandled 'error' event
          } else {
            // At least give some kind of context to the user
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
            err.context = er;
            throw err;
          }
        }
      }

      handler = this._events[type];
      if (isUndefined(handler)) return false;

      if (isFunction(handler)) {
        switch (arguments.length) {
          // fast cases
          case 1:
            handler.call(this);
            break;

          case 2:
            handler.call(this, arguments[1]);
            break;

          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower

          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;

        for (i = 0; i < len; i++) {
          listeners[i].apply(this, args);
        }
      }

      return true;
    };

    EventEmitter.prototype.addListener = function (type, listener) {
      var m;
      if (!isFunction(listener)) throw TypeError('listener must be a function');
      if (!this._events) this._events = {}; // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".

      if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
      if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;else if (isObject(this._events[type])) // If we've already got an array, just append.
        this._events[type].push(listener);else // Adding the second element, need to change to array.
        this._events[type] = [this._events[type], listener]; // Check for listener leak

      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }

        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);

          if (typeof console.trace === 'function') {
            // not supported in IE 10
            console.trace();
          }
        }
      }

      return this;
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.once = function (type, listener) {
      if (!isFunction(listener)) throw TypeError('listener must be a function');
      var fired = false;

      function g() {
        this.removeListener(type, g);

        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }

      g.listener = listener;
      this.on(type, g);
      return this;
    }; // emits a 'removeListener' event iff the listener was removed


    EventEmitter.prototype.removeListener = function (type, listener) {
      var list, position, length, i;
      if (!isFunction(listener)) throw TypeError('listener must be a function');
      if (!this._events || !this._events[type]) return this;
      list = this._events[type];
      length = list.length;
      position = -1;

      if (list === listener || isFunction(list.listener) && list.listener === listener) {
        delete this._events[type];
        if (this._events.removeListener) this.emit('removeListener', type, listener);
      } else if (isObject(list)) {
        for (i = length; i-- > 0;) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            position = i;
            break;
          }
        }

        if (position < 0) return this;

        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }

        if (this._events.removeListener) this.emit('removeListener', type, listener);
      }

      return this;
    };

    EventEmitter.prototype.removeAllListeners = function (type) {
      var key, listeners;
      if (!this._events) return this; // not listening for removeListener, no need to emit

      if (!this._events.removeListener) {
        if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
        return this;
      } // emit removeListener for all listeners on all events


      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }

        this.removeAllListeners('removeListener');
        this._events = {};
        return this;
      }

      listeners = this._events[type];

      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        while (listeners.length) {
          this.removeListener(type, listeners[listeners.length - 1]);
        }
      }

      delete this._events[type];
      return this;
    };

    EventEmitter.prototype.listeners = function (type) {
      var ret;
      if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
      return ret;
    };

    EventEmitter.prototype.listenerCount = function (type) {
      if (this._events) {
        var evlistener = this._events[type];
        if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
      }

      return 0;
    };

    EventEmitter.listenerCount = function (emitter, type) {
      return emitter.listenerCount(type);
    };

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isUndefined(arg) {
      return arg === void 0;
    }
    /***/

  },

  /***/
  "./node_modules/ieee754/index.js":
  /*!***************************************!*\
    !*** ./node_modules/ieee754/index.js ***!
    \***************************************/

  /*! no static exports found */

  /***/
  function node_modulesIeee754IndexJs(module, exports) {
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;

      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;

      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }

      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);

        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }

        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }

        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = e << mLen | m;
      eLen += mLen;

      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    };
    /***/

  },

  /***/
  "./node_modules/isarray/index.js":
  /*!***************************************!*\
    !*** ./node_modules/isarray/index.js ***!
    \***************************************/

  /*! no static exports found */

  /***/
  function node_modulesIsarrayIndexJs(module, exports) {
    var toString = {}.toString;

    module.exports = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };
    /***/

  },

  /***/
  "./node_modules/jmespath/jmespath.js":
  /*!*******************************************!*\
    !*** ./node_modules/jmespath/jmespath.js ***!
    \*******************************************/

  /*! no static exports found */

  /***/
  function node_modulesJmespathJmespathJs(module, exports, __webpack_require__) {
    (function (exports) {
      "use strict";

      function isArray(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
          return false;
        }
      }

      function isObject(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
          return false;
        }
      }

      function strictDeepEqual(first, second) {
        // Check the scalar case first.
        if (first === second) {
          return true;
        } // Check if they are the same type.


        var firstType = Object.prototype.toString.call(first);

        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        } // We know that first and second have the same type so we can just check the
        // first type from now on.


        if (isArray(first) === true) {
          // Short circuit if they're not the same length;
          if (first.length !== second.length) {
            return false;
          }

          for (var i = 0; i < first.length; i++) {
            if (strictDeepEqual(first[i], second[i]) === false) {
              return false;
            }
          }

          return true;
        }

        if (isObject(first) === true) {
          // An object is equal if it has the same key/value pairs.
          var keysSeen = {};

          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }

              keysSeen[key] = true;
            }
          } // Now check that there aren't any keys in second that weren't
          // in first.


          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }

          return true;
        }

        return false;
      }

      function isFalse(obj) {
        // From the spec:
        // A false value corresponds to the following values:
        // Empty list
        // Empty object
        // Empty string
        // False boolean
        // null value
        // First check the scalar values.
        if (obj === "" || obj === false || obj === null) {
          return true;
        } else if (isArray(obj) && obj.length === 0) {
          // Check for an empty array.
          return true;
        } else if (isObject(obj)) {
          // Check for an empty object.
          for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }

          return true;
        } else {
          return false;
        }
      }

      function objValues(obj) {
        var keys = Object.keys(obj);
        var values = [];

        for (var i = 0; i < keys.length; i++) {
          values.push(obj[keys[i]]);
        }

        return values;
      }

      function merge(a, b) {
        var merged = {};

        for (var key in a) {
          merged[key] = a[key];
        }

        for (var key2 in b) {
          merged[key2] = b[key2];
        }

        return merged;
      }

      var trimLeft;

      if (typeof String.prototype.trimLeft === "function") {
        trimLeft = function trimLeft(str) {
          return str.trimLeft();
        };
      } else {
        trimLeft = function trimLeft(str) {
          return str.match(/^\s*(.*)/)[1];
        };
      } // Type constants used to define functions.


      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TOK_EOF = "EOF";
      var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
      var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
      var TOK_RBRACKET = "Rbracket";
      var TOK_RPAREN = "Rparen";
      var TOK_COMMA = "Comma";
      var TOK_COLON = "Colon";
      var TOK_RBRACE = "Rbrace";
      var TOK_NUMBER = "Number";
      var TOK_CURRENT = "Current";
      var TOK_EXPREF = "Expref";
      var TOK_PIPE = "Pipe";
      var TOK_OR = "Or";
      var TOK_AND = "And";
      var TOK_EQ = "EQ";
      var TOK_GT = "GT";
      var TOK_LT = "LT";
      var TOK_GTE = "GTE";
      var TOK_LTE = "LTE";
      var TOK_NE = "NE";
      var TOK_FLATTEN = "Flatten";
      var TOK_STAR = "Star";
      var TOK_FILTER = "Filter";
      var TOK_DOT = "Dot";
      var TOK_NOT = "Not";
      var TOK_LBRACE = "Lbrace";
      var TOK_LBRACKET = "Lbracket";
      var TOK_LPAREN = "Lparen";
      var TOK_LITERAL = "Literal"; // The "&", "[", "<", ">" tokens
      // are not in basicToken because
      // there are two token variants
      // ("&&", "[?", "<=", ">=").  This is specially handled
      // below.

      var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
      };
      var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
      };
      var skipChars = {
        " ": true,
        "\t": true,
        "\n": true
      };

      function isAlpha(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
      }

      function isNum(ch) {
        return ch >= "0" && ch <= "9" || ch === "-";
      }

      function isAlphaNum(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
      }

      function Lexer() {}

      Lexer.prototype = {
        tokenize: function tokenize(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;

          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start: start
              });
            } else if (basicTokens[stream[this._current]] !== undefined) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token = this._consumeNumber(stream);
              tokens.push(token);
            } else if (stream[this._current] === "[") {
              // No need to increment this._current.  This happens
              // in _consumeLBracket
              token = this._consumeLBracket(stream);
              tokens.push(token);
            } else if (stream[this._current] === "\"") {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start: start
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start: start
              });
            } else if (stream[this._current] === "`") {
              start = this._current;

              var literal = this._consumeLiteral(stream);

              tokens.push({
                type: TOK_LITERAL,
                value: literal,
                start: start
              });
            } else if (operatorStartToken[stream[this._current]] !== undefined) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== undefined) {
              // Ignore whitespace.
              this._current++;
            } else if (stream[this._current] === "&") {
              start = this._current;
              this._current++;

              if (stream[this._current] === "&") {
                this._current++;
                tokens.push({
                  type: TOK_AND,
                  value: "&&",
                  start: start
                });
              } else {
                tokens.push({
                  type: TOK_EXPREF,
                  value: "&",
                  start: start
                });
              }
            } else if (stream[this._current] === "|") {
              start = this._current;
              this._current++;

              if (stream[this._current] === "|") {
                this._current++;
                tokens.push({
                  type: TOK_OR,
                  value: "||",
                  start: start
                });
              } else {
                tokens.push({
                  type: TOK_PIPE,
                  value: "|",
                  start: start
                });
              }
            } else {
              var error = new Error("Unknown character:" + stream[this._current]);
              error.name = "LexerError";
              throw error;
            }
          }

          return tokens;
        },
        _consumeUnquotedIdentifier: function _consumeUnquotedIdentifier(stream) {
          var start = this._current;
          this._current++;

          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }

          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function _consumeQuotedIdentifier(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;

          while (stream[this._current] !== "\"" && this._current < maxLength) {
            // You can escape a double quote and you can escape an escape.
            var current = this._current;

            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "\"")) {
              current += 2;
            } else {
              current++;
            }

            this._current = current;
          }

          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function _consumeRawStringLiteral(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;

          while (stream[this._current] !== "'" && this._current < maxLength) {
            // You can escape a single quote and you can escape an escape.
            var current = this._current;

            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }

            this._current = current;
          }

          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
        },
        _consumeNumber: function _consumeNumber(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;

          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }

          var value = parseInt(stream.slice(start, this._current));
          return {
            type: TOK_NUMBER,
            value: value,
            start: start
          };
        },
        _consumeLBracket: function _consumeLBracket(stream) {
          var start = this._current;
          this._current++;

          if (stream[this._current] === "?") {
            this._current++;
            return {
              type: TOK_FILTER,
              value: "[?",
              start: start
            };
          } else if (stream[this._current] === "]") {
            this._current++;
            return {
              type: TOK_FLATTEN,
              value: "[]",
              start: start
            };
          } else {
            return {
              type: TOK_LBRACKET,
              value: "[",
              start: start
            };
          }
        },
        _consumeOperator: function _consumeOperator(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;

          if (startingChar === "!") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_NE,
                value: "!=",
                start: start
              };
            } else {
              return {
                type: TOK_NOT,
                value: "!",
                start: start
              };
            }
          } else if (startingChar === "<") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_LTE,
                value: "<=",
                start: start
              };
            } else {
              return {
                type: TOK_LT,
                value: "<",
                start: start
              };
            }
          } else if (startingChar === ">") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_GTE,
                value: ">=",
                start: start
              };
            } else {
              return {
                type: TOK_GT,
                value: ">",
                start: start
              };
            }
          } else if (startingChar === "=") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_EQ,
                value: "==",
                start: start
              };
            }
          }
        },
        _consumeLiteral: function _consumeLiteral(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;

          while (stream[this._current] !== "`" && this._current < maxLength) {
            // You can escape a literal char or you can escape the escape.
            var current = this._current;

            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
              current += 2;
            } else {
              current++;
            }

            this._current = current;
          }

          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");

          if (this._looksLikeJSON(literalString)) {
            literal = JSON.parse(literalString);
          } else {
            // Try to JSON parse it as "<literal>"
            literal = JSON.parse("\"" + literalString + "\"");
          } // +1 gets us to the ending "`", +1 to move on to the next char.


          this._current++;
          return literal;
        },
        _looksLikeJSON: function _looksLikeJSON(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex) {
              return false;
            }
          } else {
            return false;
          }
        }
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

      function Parser() {}

      Parser.prototype = {
        parse: function parse(expression) {
          this._loadTokens(expression);

          this.index = 0;
          var ast = this.expression(0);

          if (this._lookahead(0) !== TOK_EOF) {
            var t = this._lookaheadToken(0);

            var error = new Error("Unexpected token type: " + t.type + ", value: " + t.value);
            error.name = "ParserError";
            throw error;
          }

          return ast;
        },
        _loadTokens: function _loadTokens(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({
            type: TOK_EOF,
            value: "",
            start: expression.length
          });
          this.tokens = tokens;
        },
        expression: function expression(rbp) {
          var leftToken = this._lookaheadToken(0);

          this._advance();

          var left = this.nud(leftToken);

          var currentToken = this._lookahead(0);

          while (rbp < bindingPower[currentToken]) {
            this._advance();

            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }

          return left;
        },
        _lookahead: function _lookahead(number) {
          return this.tokens[this.index + number].type;
        },
        _lookaheadToken: function _lookaheadToken(number) {
          return this.tokens[this.index + number];
        },
        _advance: function _advance() {
          this.index++;
        },
        nud: function nud(token) {
          var left;
          var right;
          var expression;

          switch (token.type) {
            case TOK_LITERAL:
              return {
                type: "Literal",
                value: token.value
              };

            case TOK_UNQUOTEDIDENTIFIER:
              return {
                type: "Field",
                name: token.value
              };

            case TOK_QUOTEDIDENTIFIER:
              var node = {
                type: "Field",
                name: token.value
              };

              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
              } else {
                return node;
              }

              break;

            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return {
                type: "NotExpression",
                children: [right]
              };

            case TOK_STAR:
              left = {
                type: "Identity"
              };
              right = null;

              if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {
                  type: "Identity"
                };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }

              return {
                type: "ValueProjection",
                children: [left, right]
              };

            case TOK_FILTER:
              return this.led(token.type, {
                type: "Identity"
              });

            case TOK_LBRACE:
              return this._parseMultiselectHash();

            case TOK_FLATTEN:
              left = {
                type: TOK_FLATTEN,
                children: [{
                  type: "Identity"
                }]
              };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return {
                type: "Projection",
                children: [left, right]
              };

            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({
                  type: "Identity"
                }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();

                this._advance();

                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [{
                    type: "Identity"
                  }, right]
                };
              } else {
                return this._parseMultiselectList();
              }

              break;

            case TOK_CURRENT:
              return {
                type: TOK_CURRENT
              };

            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return {
                type: "ExpressionReference",
                children: [expression]
              };

            case TOK_LPAREN:
              var args = [];

              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = {
                    type: TOK_CURRENT
                  };

                  this._advance();
                } else {
                  expression = this.expression(0);
                }

                args.push(expression);
              }

              this._match(TOK_RPAREN);

              return args[0];

            default:
              this._errorToken(token);

          }
        },
        led: function led(tokenName, left) {
          var right;

          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;

              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {
                  type: "Subexpression",
                  children: [left, right]
                };
              } else {
                // Creating a projection.
                this._advance();

                right = this._parseProjectionRHS(rbp);
                return {
                  type: "ValueProjection",
                  children: [left, right]
                };
              }

              break;

            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return {
                type: TOK_PIPE,
                children: [left, right]
              };

            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return {
                type: "OrExpression",
                children: [left, right]
              };

            case TOK_AND:
              right = this.expression(bindingPower.And);
              return {
                type: "AndExpression",
                children: [left, right]
              };

            case TOK_LPAREN:
              var name = left.name;
              var args = [];
              var expression, node;

              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = {
                    type: TOK_CURRENT
                  };

                  this._advance();
                } else {
                  expression = this.expression(0);
                }

                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }

                args.push(expression);
              }

              this._match(TOK_RPAREN);

              node = {
                type: "Function",
                name: name,
                children: args
              };
              return node;

            case TOK_FILTER:
              var condition = this.expression(0);

              this._match(TOK_RBRACKET);

              if (this._lookahead(0) === TOK_FLATTEN) {
                right = {
                  type: "Identity"
                };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }

              return {
                type: "FilterProjection",
                children: [left, right, condition]
              };

            case TOK_FLATTEN:
              var leftNode = {
                type: TOK_FLATTEN,
                children: [left]
              };

              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);

              return {
                type: "Projection",
                children: [leftNode, rightNode]
              };

            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);

            case TOK_LBRACKET:
              var token = this._lookaheadToken(0);

              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              } else {
                this._match(TOK_STAR);

                this._match(TOK_RBRACKET);

                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [left, right]
                };
              }

              break;

            default:
              this._errorToken(this._lookaheadToken(0));

          }
        },
        _match: function _match(tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t = this._lookaheadToken(0);

            var error = new Error("Expected " + tokenType + ", got: " + t.type);
            error.name = "ParserError";
            throw error;
          }
        },
        _errorToken: function _errorToken(token) {
          var error = new Error("Invalid token (" + token.type + "): \"" + token.value + "\"");
          error.name = "ParserError";
          throw error;
        },
        _parseIndexExpression: function _parseIndexExpression() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: "Index",
              value: this._lookaheadToken(0).value
            };

            this._advance();

            this._match(TOK_RBRACKET);

            return node;
          }
        },
        _projectIfSlice: function _projectIfSlice(left, right) {
          var indexExpr = {
            type: "IndexExpression",
            children: [left, right]
          };

          if (right.type === "Slice") {
            return {
              type: "Projection",
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function _parseSliceExpression() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;

          var currentToken = this._lookahead(0);

          while (currentToken !== TOK_RBRACKET && index < 3) {
            if (currentToken === TOK_COLON) {
              index++;

              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index] = this._lookaheadToken(0).value;

              this._advance();
            } else {
              var t = this._lookahead(0);

              var error = new Error("Syntax error, unexpected token: " + t.value + "(" + t.type + ")");
              error.name = "Parsererror";
              throw error;
            }

            currentToken = this._lookahead(0);
          }

          this._match(TOK_RBRACKET);

          return {
            type: "Slice",
            children: parts
          };
        },
        _parseComparator: function _parseComparator(left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return {
            type: "Comparator",
            name: comparator,
            children: [left, right]
          };
        },
        _parseDotRHS: function _parseDotRHS(rbp) {
          var lookahead = this._lookahead(0);

          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];

          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);

            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);

            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function _parseProjectionRHS(rbp) {
          var right;

          if (bindingPower[this._lookahead(0)] < 10) {
            right = {
              type: "Identity"
            };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);

            right = this._parseDotRHS(rbp);
          } else {
            var t = this._lookaheadToken(0);

            var error = new Error("Sytanx error, unexpected token: " + t.value + "(" + t.type + ")");
            error.name = "ParserError";
            throw error;
          }

          return right;
        },
        _parseMultiselectList: function _parseMultiselectList() {
          var expressions = [];

          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);

            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);

              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error("Unexpected token Rbracket");
              }
            }
          }

          this._match(TOK_RBRACKET);

          return {
            type: "MultiSelectList",
            children: expressions
          };
        },
        _parseMultiselectHash: function _parseMultiselectHash() {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName, value, node;

          for (;;) {
            keyToken = this._lookaheadToken(0);

            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error("Expecting an identifier token, got: " + keyToken.type);
            }

            keyName = keyToken.value;

            this._advance();

            this._match(TOK_COLON);

            value = this.expression(0);
            node = {
              type: "KeyValuePair",
              name: keyName,
              value: value
            };
            pairs.push(node);

            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);

              break;
            }
          }

          return {
            type: "MultiSelectHash",
            children: pairs
          };
        }
      };

      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }

      TreeInterpreter.prototype = {
        search: function search(node, value) {
          return this.visit(node, value);
        },
        visit: function visit(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;

          switch (node.type) {
            case "Field":
              if (value === null) {
                return null;
              } else if (isObject(value)) {
                field = value[node.name];

                if (field === undefined) {
                  return null;
                } else {
                  return field;
                }
              } else {
                return null;
              }

              break;

            case "Subexpression":
              result = this.visit(node.children[0], value);

              for (i = 1; i < node.children.length; i++) {
                result = this.visit(node.children[1], result);

                if (result === null) {
                  return null;
                }
              }

              return result;

            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;

            case "Index":
              if (!isArray(value)) {
                return null;
              }

              var index = node.value;

              if (index < 0) {
                index = value.length + index;
              }

              result = value[index];

              if (result === undefined) {
                result = null;
              }

              return result;

            case "Slice":
              if (!isArray(value)) {
                return null;
              }

              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];

              if (step > 0) {
                for (i = start; i < stop; i += step) {
                  result.push(value[i]);
                }
              } else {
                for (i = start; i > stop; i += step) {
                  result.push(value[i]);
                }
              }

              return result;

            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);

              if (!isArray(base)) {
                return null;
              }

              collected = [];

              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);

                if (current !== null) {
                  collected.push(current);
                }
              }

              return collected;

            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);

              if (!isObject(base)) {
                return null;
              }

              collected = [];
              var values = objValues(base);

              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);

                if (current !== null) {
                  collected.push(current);
                }
              }

              return collected;

            case "FilterProjection":
              base = this.visit(node.children[0], value);

              if (!isArray(base)) {
                return null;
              }

              var filtered = [];
              var finalResults = [];

              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);

                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }

              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);

                if (current !== null) {
                  finalResults.push(current);
                }
              }

              return finalResults;

            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);

              switch (node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;

                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;

                case TOK_GT:
                  result = first > second;
                  break;

                case TOK_GTE:
                  result = first >= second;
                  break;

                case TOK_LT:
                  result = first < second;
                  break;

                case TOK_LTE:
                  result = first <= second;
                  break;

                default:
                  throw new Error("Unknown comparator: " + node.name);
              }

              return result;

            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);

              if (!isArray(original)) {
                return null;
              }

              var merged = [];

              for (i = 0; i < original.length; i++) {
                current = original[i];

                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }

              return merged;

            case "Identity":
              return value;

            case "MultiSelectList":
              if (value === null) {
                return null;
              }

              collected = [];

              for (i = 0; i < node.children.length; i++) {
                collected.push(this.visit(node.children[i], value));
              }

              return collected;

            case "MultiSelectHash":
              if (value === null) {
                return null;
              }

              collected = {};
              var child;

              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }

              return collected;

            case "OrExpression":
              matched = this.visit(node.children[0], value);

              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }

              return matched;

            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }

              return this.visit(node.children[1], value);

            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);

            case "Literal":
              return node.value;

            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);

            case TOK_CURRENT:
              return value;

            case "Function":
              var resolvedArgs = [];

              for (i = 0; i < node.children.length; i++) {
                resolvedArgs.push(this.visit(node.children[i], value));
              }

              return this.runtime.callFunction(node.name, resolvedArgs);

            case "ExpressionReference":
              var refNode = node.children[0]; // Tag the node with a specific attribute so the type
              // checker verify the type.

              refNode.jmespathType = TOK_EXPREF;
              return refNode;

            default:
              throw new Error("Unknown node type: " + node.type);
          }
        },
        computeSliceParams: function computeSliceParams(arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed = [null, null, null];

          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error = new Error("Invalid slice, step cannot be 0");
            error.name = "RuntimeError";
            throw error;
          }

          var stepValueNegative = step < 0 ? true : false;

          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }

          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }

          computed[0] = start;
          computed[1] = stop;
          computed[2] = step;
          return computed;
        },
        capSliceRange: function capSliceRange(arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;

            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }

          return actualValue;
        }
      };

      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          // name: [function, <signature>]
          // The <signature> can be:
          //
          // {
          //   args: [[type1, type2], [type1, type2]],
          //   variadic: true|false
          // }
          //
          // Each arg in the arg list is a list of valid types
          // (if the function is overloaded and supports multiple
          // types.  If the type is "any" then no type checking
          // occurs on the argument.  Variadic is optional
          // and if not provided is assumed to be false.
          abs: {
            _func: this._functionAbs,
            _signature: [{
              types: [TYPE_NUMBER]
            }]
          },
          avg: {
            _func: this._functionAvg,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER]
            }]
          },
          ceil: {
            _func: this._functionCeil,
            _signature: [{
              types: [TYPE_NUMBER]
            }]
          },
          contains: {
            _func: this._functionContains,
            _signature: [{
              types: [TYPE_STRING, TYPE_ARRAY]
            }, {
              types: [TYPE_ANY]
            }]
          },
          "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{
              types: [TYPE_STRING]
            }, {
              types: [TYPE_STRING]
            }]
          },
          floor: {
            _func: this._functionFloor,
            _signature: [{
              types: [TYPE_NUMBER]
            }]
          },
          length: {
            _func: this._functionLength,
            _signature: [{
              types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]
            }]
          },
          map: {
            _func: this._functionMap,
            _signature: [{
              types: [TYPE_EXPREF]
            }, {
              types: [TYPE_ARRAY]
            }]
          },
          max: {
            _func: this._functionMax,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]
            }]
          },
          "merge": {
            _func: this._functionMerge,
            _signature: [{
              types: [TYPE_OBJECT],
              variadic: true
            }]
          },
          "max_by": {
            _func: this._functionMaxBy,
            _signature: [{
              types: [TYPE_ARRAY]
            }, {
              types: [TYPE_EXPREF]
            }]
          },
          sum: {
            _func: this._functionSum,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER]
            }]
          },
          "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{
              types: [TYPE_STRING]
            }, {
              types: [TYPE_STRING]
            }]
          },
          min: {
            _func: this._functionMin,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]
            }]
          },
          "min_by": {
            _func: this._functionMinBy,
            _signature: [{
              types: [TYPE_ARRAY]
            }, {
              types: [TYPE_EXPREF]
            }]
          },
          type: {
            _func: this._functionType,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          keys: {
            _func: this._functionKeys,
            _signature: [{
              types: [TYPE_OBJECT]
            }]
          },
          values: {
            _func: this._functionValues,
            _signature: [{
              types: [TYPE_OBJECT]
            }]
          },
          sort: {
            _func: this._functionSort,
            _signature: [{
              types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]
            }]
          },
          "sort_by": {
            _func: this._functionSortBy,
            _signature: [{
              types: [TYPE_ARRAY]
            }, {
              types: [TYPE_EXPREF]
            }]
          },
          join: {
            _func: this._functionJoin,
            _signature: [{
              types: [TYPE_STRING]
            }, {
              types: [TYPE_ARRAY_STRING]
            }]
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{
              types: [TYPE_STRING, TYPE_ARRAY]
            }]
          },
          "to_array": {
            _func: this._functionToArray,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          "to_string": {
            _func: this._functionToString,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          "to_number": {
            _func: this._functionToNumber,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          "not_null": {
            _func: this._functionNotNull,
            _signature: [{
              types: [TYPE_ANY],
              variadic: true
            }]
          }
        };
      }

      Runtime.prototype = {
        callFunction: function callFunction(name, resolvedArgs) {
          var functionEntry = this.functionTable[name];

          if (functionEntry === undefined) {
            throw new Error("Unknown function: " + name + "()");
          }

          this._validateArgs(name, resolvedArgs, functionEntry._signature);

          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function _validateArgs(name, args, signature) {
          // Validating the args requires validating
          // the correct arity and the correct type of each arg.
          // If the last argument is declared as variadic, then we need
          // a minimum number of args to be required.  Otherwise it has to
          // be an exact amount.
          var pluralized;

          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? " argument" : " arguments";
              throw new Error("ArgumentError: " + name + "() " + "takes at least" + signature.length + pluralized + " but received " + args.length);
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " + "takes " + signature.length + pluralized + " but received " + args.length);
          }

          var currentSpec;
          var actualType;
          var typeMatched;

          for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);

            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                typeMatched = true;
                break;
              }
            }

            if (!typeMatched) {
              throw new Error("TypeError: " + name + "() " + "expected argument " + (i + 1) + " to be type " + currentSpec + " but received type " + actualType + " instead.");
            }
          }
        },
        _typeMatches: function _typeMatches(actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }

          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              // Otherwise we need to check subtypes.
              // I think this has potential to be improved.
              var subtype;

              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }

              for (var i = 0; i < argValue.length; i++) {
                if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {
                  return false;
                }
              }

              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function _getTypeName(obj) {
          switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;

            case "[object Number]":
              return TYPE_NUMBER;

            case "[object Array]":
              return TYPE_ARRAY;

            case "[object Boolean]":
              return TYPE_BOOLEAN;

            case "[object Null]":
              return TYPE_NULL;

            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }

          }
        },
        _functionStartsWith: function _functionStartsWith(resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function _functionEndsWith(resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function _functionReverse(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);

          if (typeName === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = "";

            for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
            }

            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function _functionAbs(resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function _functionCeil(resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function _functionAvg(resolvedArgs) {
          var sum = 0;
          var inputArray = resolvedArgs[0];

          for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
          }

          return sum / inputArray.length;
        },
        _functionContains: function _functionContains(resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function _functionFloor(resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function _functionLength(resolvedArgs) {
          if (!isObject(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            // As far as I can tell, there's no way to get the length
            // of an object without O(n) iteration through the object.
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function _functionMap(resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];

          for (var i = 0; i < elements.length; i++) {
            mapped.push(interpreter.visit(exprefNode, elements[i]));
          }

          return mapped;
        },
        _functionMerge: function _functionMerge(resolvedArgs) {
          var merged = {};

          for (var i = 0; i < resolvedArgs.length; i++) {
            var current = resolvedArgs[i];

            for (var key in current) {
              merged[key] = current[key];
            }
          }

          return merged;
        },
        _functionMax: function _functionMax(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);

            if (typeName === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];

              for (var i = 1; i < elements.length; i++) {
                if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
                }
              }

              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function _functionMin(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);

            if (typeName === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];

              for (var i = 1; i < elements.length; i++) {
                if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
                }
              }

              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function _functionSum(resolvedArgs) {
          var sum = 0;
          var listToSum = resolvedArgs[0];

          for (var i = 0; i < listToSum.length; i++) {
            sum += listToSum[i];
          }

          return sum;
        },
        _functionType: function _functionType(resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return "number";

            case TYPE_STRING:
              return "string";

            case TYPE_ARRAY:
              return "array";

            case TYPE_OBJECT:
              return "object";

            case TYPE_BOOLEAN:
              return "boolean";

            case TYPE_EXPREF:
              return "expref";

            case TYPE_NULL:
              return "null";
          }
        },
        _functionKeys: function _functionKeys(resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function _functionValues(resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys = Object.keys(obj);
          var values = [];

          for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
          }

          return values;
        },
        _functionJoin: function _functionJoin(resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function _functionToArray(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function _functionToString(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function _functionToNumber(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);

          var convertedValue;

          if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];

            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }

          return null;
        },
        _functionNotNull: function _functionNotNull(resolvedArgs) {
          for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
              return resolvedArgs[i];
            }
          }

          return null;
        },
        _functionSort: function _functionSort(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function _functionSortBy(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);

          if (sortedArray.length === 0) {
            return sortedArray;
          }

          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];

          var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));

          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
          }

          var that = this; // In order to get a stable sort out of an unstable
          // sort algorithm, we decorate/sort/undecorate (DSU)
          // by creating a new list of [index, element] pairs.
          // In the cmp function, if the evaluated elements are
          // equal, then the index will be used as the tiebreaker.
          // After the decorated list has been sorted, it will be
          // undecorated to extract the original elements.

          var decorated = [];

          for (var i = 0; i < sortedArray.length; i++) {
            decorated.push([i, sortedArray[i]]);
          }

          decorated.sort(function (a, b) {
            var exprA = interpreter.visit(exprefNode, a[1]);
            var exprB = interpreter.visit(exprefNode, b[1]);

            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA));
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB));
            }

            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              // If they're equal compare the items by their
              // order to maintain relative order of equal keys
              // (i.e. to get a stable sort).
              return a[0] - b[0];
            }
          }); // Undecorate: extract out the original list elements.

          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }

          return sortedArray;
        },
        _functionMaxBy: function _functionMaxBy(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;

          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);

            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i];
            }
          }

          return maxRecord;
        },
        _functionMinBy: function _functionMinBy(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;

          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);

            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i];
            }
          }

          return minRecord;
        },
        createKeyFunction: function createKeyFunction(exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;

          var keyFunc = function keyFunc(x) {
            var current = interpreter.visit(exprefNode, x);

            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);

              throw new Error(msg);
            }

            return current;
          };

          return keyFunc;
        }
      };

      function compile(stream) {
        var parser = new Parser();
        var ast = parser.parse(stream);
        return ast;
      }

      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }

      function search(data, expression) {
        var parser = new Parser(); // This needs to be improved.  Both the interpreter and runtime depend on
        // each other.  The runtime needs the interpreter to support exprefs.
        // There's likely a clean way to avoid the cyclic dependency.

        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser.parse(expression);
        return interpreter.search(node, data);
      }

      exports.tokenize = tokenize;
      exports.compile = compile;
      exports.search = search;
      exports.strictDeepEqual = strictDeepEqual;
    })(false ? undefined : exports);
    /***/

  },

  /***/
  "./node_modules/lodash/lodash.js":
  /*!***************************************!*\
    !*** ./node_modules/lodash/lodash.js ***!
    \***************************************/

  /*! no static exports found */

  /***/
  function node_modulesLodashLodashJs(module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */
    (function (module) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /**
      * @license
      * Lodash <https://lodash.com/>
      * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
      * Released under MIT license <https://lodash.com/license>
      * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
      * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      */


      ;
      (function () {
        /** Used as a safe reference for `undefined` in pre-ES5 environments. */
        var undefined;
        /** Used as the semantic version number. */

        var VERSION = '4.17.20';
        /** Used as the size to enable large array optimizations. */

        var LARGE_ARRAY_SIZE = 200;
        /** Error message constants. */

        var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
            FUNC_ERROR_TEXT = 'Expected a function';
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = '__lodash_hash_undefined__';
        /** Used as the maximum memoize cache size. */

        var MAX_MEMOIZE_SIZE = 500;
        /** Used as the internal argument placeholder. */

        var PLACEHOLDER = '__lodash_placeholder__';
        /** Used to compose bitmasks for cloning. */

        var CLONE_DEEP_FLAG = 1,
            CLONE_FLAT_FLAG = 2,
            CLONE_SYMBOLS_FLAG = 4;
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2;
        /** Used to compose bitmasks for function metadata. */

        var WRAP_BIND_FLAG = 1,
            WRAP_BIND_KEY_FLAG = 2,
            WRAP_CURRY_BOUND_FLAG = 4,
            WRAP_CURRY_FLAG = 8,
            WRAP_CURRY_RIGHT_FLAG = 16,
            WRAP_PARTIAL_FLAG = 32,
            WRAP_PARTIAL_RIGHT_FLAG = 64,
            WRAP_ARY_FLAG = 128,
            WRAP_REARG_FLAG = 256,
            WRAP_FLIP_FLAG = 512;
        /** Used as default options for `_.truncate`. */

        var DEFAULT_TRUNC_LENGTH = 30,
            DEFAULT_TRUNC_OMISSION = '...';
        /** Used to detect hot functions by number of calls within a span of milliseconds. */

        var HOT_COUNT = 800,
            HOT_SPAN = 16;
        /** Used to indicate the type of lazy iteratees. */

        var LAZY_FILTER_FLAG = 1,
            LAZY_MAP_FLAG = 2,
            LAZY_WHILE_FLAG = 3;
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0,
            MAX_SAFE_INTEGER = 9007199254740991,
            MAX_INTEGER = 1.7976931348623157e+308,
            NAN = 0 / 0;
        /** Used as references for the maximum length and index of an array. */

        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        /** Used to associate wrap methods with their bit flags. */

        var wrapFlags = [['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG]];
        /** `Object#toString` result references. */

        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            asyncTag = '[object AsyncFunction]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            domExcTag = '[object DOMException]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            nullTag = '[object Null]',
            objectTag = '[object Object]',
            promiseTag = '[object Promise]',
            proxyTag = '[object Proxy]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]',
            undefinedTag = '[object Undefined]',
            weakMapTag = '[object WeakMap]',
            weakSetTag = '[object WeakSet]';
        var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';
        /** Used to match empty string literals in compiled template source. */

        var reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        /** Used to match HTML entities and HTML characters. */

        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
            reUnescapedHtml = /[&<>"']/g,
            reHasEscapedHtml = RegExp(reEscapedHtml.source),
            reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        /** Used to match template delimiters. */

        var reEscape = /<%-([\s\S]+?)%>/g,
            reEvaluate = /<%([\s\S]+?)%>/g,
            reInterpolate = /<%=([\s\S]+?)%>/g;
        /** Used to match property names within property paths. */

        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/,
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */

        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
            reHasRegExpChar = RegExp(reRegExpChar.source);
        /** Used to match leading and trailing whitespace. */

        var reTrim = /^\s+|\s+$/g,
            reTrimStart = /^\s+/,
            reTrimEnd = /\s+$/;
        /** Used to match wrap detail comments. */

        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
            reSplitDetails = /,? & /;
        /** Used to match words composed of alphanumeric characters. */

        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        /** Used to match backslashes in property paths. */

        var reEscapeChar = /\\(\\)?/g;
        /**
         * Used to match
         * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
         */

        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        /** Used to match `RegExp` flags from their coerced string values. */

        var reFlags = /\w*$/;
        /** Used to detect bad signed hexadecimal string values. */

        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        /** Used to detect binary string values. */

        var reIsBinary = /^0b[01]+$/i;
        /** Used to detect host constructors (Safari). */

        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        /** Used to detect octal string values. */

        var reIsOctal = /^0o[0-7]+$/i;
        /** Used to detect unsigned integer values. */

        var reIsUint = /^(?:0|[1-9]\d*)$/;
        /** Used to match Latin Unicode letters (excluding mathematical operators). */

        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        /** Used to ensure capturing order of template delimiters. */

        var reNoMatch = /($^)/;
        /** Used to match unescaped characters in compiled string literals. */

        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        /** Used to compose unicode character classes. */

        var rsAstralRange = "\\ud800-\\udfff",
            rsComboMarksRange = "\\u0300-\\u036f",
            reComboHalfMarksRange = "\\ufe20-\\ufe2f",
            rsComboSymbolsRange = "\\u20d0-\\u20ff",
            rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
            rsDingbatRange = "\\u2700-\\u27bf",
            rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
            rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
            rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
            rsPunctuationRange = "\\u2000-\\u206f",
            rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
            rsVarRange = "\\ufe0e\\ufe0f",
            rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        /** Used to compose unicode capture groups. */

        var rsApos = "['\u2019]",
            rsAstral = '[' + rsAstralRange + ']',
            rsBreak = '[' + rsBreakRange + ']',
            rsCombo = '[' + rsComboRange + ']',
            rsDigits = '\\d+',
            rsDingbat = '[' + rsDingbatRange + ']',
            rsLower = '[' + rsLowerRange + ']',
            rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
            rsFitz = "\\ud83c[\\udffb-\\udfff]",
            rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
            rsNonAstral = '[^' + rsAstralRange + ']',
            rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            rsUpper = '[' + rsUpperRange + ']',
            rsZWJ = "\\u200d";
        /** Used to compose unicode regexes. */

        var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
            rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
            rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
            rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
            reOptMod = rsModifier + '?',
            rsOptVar = '[' + rsVarRange + ']?',
            rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
            rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
            rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
            rsSeq = rsOptVar + reOptMod + rsOptJoin,
            rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
            rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
        /** Used to match apostrophes. */

        var reApos = RegExp(rsApos, 'g');
        /**
         * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
         * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
         */

        var reComboMark = RegExp(rsCombo, 'g');
        /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

        var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
        /** Used to match complex or compound words. */

        var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
        /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

        var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
        /** Used to detect strings that need a more robust regexp to match words. */

        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        /** Used to assign default `context` object properties. */

        var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];
        /** Used to make template sourceURLs easier to identify. */

        var templateCounter = -1;
        /** Used to identify `toStringTag` values of typed arrays. */

        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        /** Used to identify `toStringTag` values supported by `_.clone`. */

        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        /** Used to map Latin Unicode letters to basic Latin letters. */

        var deburredLetters = {
          // Latin-1 Supplement block.
          '\xc0': 'A',
          '\xc1': 'A',
          '\xc2': 'A',
          '\xc3': 'A',
          '\xc4': 'A',
          '\xc5': 'A',
          '\xe0': 'a',
          '\xe1': 'a',
          '\xe2': 'a',
          '\xe3': 'a',
          '\xe4': 'a',
          '\xe5': 'a',
          '\xc7': 'C',
          '\xe7': 'c',
          '\xd0': 'D',
          '\xf0': 'd',
          '\xc8': 'E',
          '\xc9': 'E',
          '\xca': 'E',
          '\xcb': 'E',
          '\xe8': 'e',
          '\xe9': 'e',
          '\xea': 'e',
          '\xeb': 'e',
          '\xcc': 'I',
          '\xcd': 'I',
          '\xce': 'I',
          '\xcf': 'I',
          '\xec': 'i',
          '\xed': 'i',
          '\xee': 'i',
          '\xef': 'i',
          '\xd1': 'N',
          '\xf1': 'n',
          '\xd2': 'O',
          '\xd3': 'O',
          '\xd4': 'O',
          '\xd5': 'O',
          '\xd6': 'O',
          '\xd8': 'O',
          '\xf2': 'o',
          '\xf3': 'o',
          '\xf4': 'o',
          '\xf5': 'o',
          '\xf6': 'o',
          '\xf8': 'o',
          '\xd9': 'U',
          '\xda': 'U',
          '\xdb': 'U',
          '\xdc': 'U',
          '\xf9': 'u',
          '\xfa': 'u',
          '\xfb': 'u',
          '\xfc': 'u',
          '\xdd': 'Y',
          '\xfd': 'y',
          '\xff': 'y',
          '\xc6': 'Ae',
          '\xe6': 'ae',
          '\xde': 'Th',
          '\xfe': 'th',
          '\xdf': 'ss',
          // Latin Extended-A block.
          "\u0100": 'A',
          "\u0102": 'A',
          "\u0104": 'A',
          "\u0101": 'a',
          "\u0103": 'a',
          "\u0105": 'a',
          "\u0106": 'C',
          "\u0108": 'C',
          "\u010A": 'C',
          "\u010C": 'C',
          "\u0107": 'c',
          "\u0109": 'c',
          "\u010B": 'c',
          "\u010D": 'c',
          "\u010E": 'D',
          "\u0110": 'D',
          "\u010F": 'd',
          "\u0111": 'd',
          "\u0112": 'E',
          "\u0114": 'E',
          "\u0116": 'E',
          "\u0118": 'E',
          "\u011A": 'E',
          "\u0113": 'e',
          "\u0115": 'e',
          "\u0117": 'e',
          "\u0119": 'e',
          "\u011B": 'e',
          "\u011C": 'G',
          "\u011E": 'G',
          "\u0120": 'G',
          "\u0122": 'G',
          "\u011D": 'g',
          "\u011F": 'g',
          "\u0121": 'g',
          "\u0123": 'g',
          "\u0124": 'H',
          "\u0126": 'H',
          "\u0125": 'h',
          "\u0127": 'h',
          "\u0128": 'I',
          "\u012A": 'I',
          "\u012C": 'I',
          "\u012E": 'I',
          "\u0130": 'I',
          "\u0129": 'i',
          "\u012B": 'i',
          "\u012D": 'i',
          "\u012F": 'i',
          "\u0131": 'i',
          "\u0134": 'J',
          "\u0135": 'j',
          "\u0136": 'K',
          "\u0137": 'k',
          "\u0138": 'k',
          "\u0139": 'L',
          "\u013B": 'L',
          "\u013D": 'L',
          "\u013F": 'L',
          "\u0141": 'L',
          "\u013A": 'l',
          "\u013C": 'l',
          "\u013E": 'l',
          "\u0140": 'l',
          "\u0142": 'l',
          "\u0143": 'N',
          "\u0145": 'N',
          "\u0147": 'N',
          "\u014A": 'N',
          "\u0144": 'n',
          "\u0146": 'n',
          "\u0148": 'n',
          "\u014B": 'n',
          "\u014C": 'O',
          "\u014E": 'O',
          "\u0150": 'O',
          "\u014D": 'o',
          "\u014F": 'o',
          "\u0151": 'o',
          "\u0154": 'R',
          "\u0156": 'R',
          "\u0158": 'R',
          "\u0155": 'r',
          "\u0157": 'r',
          "\u0159": 'r',
          "\u015A": 'S',
          "\u015C": 'S',
          "\u015E": 'S',
          "\u0160": 'S',
          "\u015B": 's',
          "\u015D": 's',
          "\u015F": 's',
          "\u0161": 's',
          "\u0162": 'T',
          "\u0164": 'T',
          "\u0166": 'T',
          "\u0163": 't',
          "\u0165": 't',
          "\u0167": 't',
          "\u0168": 'U',
          "\u016A": 'U',
          "\u016C": 'U',
          "\u016E": 'U',
          "\u0170": 'U',
          "\u0172": 'U',
          "\u0169": 'u',
          "\u016B": 'u',
          "\u016D": 'u',
          "\u016F": 'u',
          "\u0171": 'u',
          "\u0173": 'u',
          "\u0174": 'W',
          "\u0175": 'w',
          "\u0176": 'Y',
          "\u0177": 'y',
          "\u0178": 'Y',
          "\u0179": 'Z',
          "\u017B": 'Z',
          "\u017D": 'Z',
          "\u017A": 'z',
          "\u017C": 'z',
          "\u017E": 'z',
          "\u0132": 'IJ',
          "\u0133": 'ij',
          "\u0152": 'Oe',
          "\u0153": 'oe',
          "\u0149": "'n",
          "\u017F": 's'
        };
        /** Used to map characters to HTML entities. */

        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        /** Used to map HTML entities to characters. */

        var htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'"
        };
        /** Used to escape characters for inclusion in compiled string literals. */

        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          "\u2028": 'u2028',
          "\u2029": 'u2029'
        };
        /** Built-in method references without a dependency on `root`. */

        var freeParseFloat = parseFloat,
            freeParseInt = parseInt;
        /** Detect free variable `global` from Node.js. */

        var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
        /** Detect free variable `self`. */

        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
        /** Used as a reference to the global object. */

        var root = freeGlobal || freeSelf || Function('return this')();
        /** Detect free variable `exports`. */

        var freeExports = true && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Detect free variable `process` from Node.js. */

        var freeProcess = moduleExports && freeGlobal.process;
        /** Used to access faster Node.js helpers. */

        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;

            if (types) {
              return types;
            } // Legacy `process.binding('util')` for Node.js < 10.


            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) {}
        }();
        /* Node.js helper references. */


        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
            nodeIsDate = nodeUtil && nodeUtil.isDate,
            nodeIsMap = nodeUtil && nodeUtil.isMap,
            nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
            nodeIsSet = nodeUtil && nodeUtil.isSet,
            nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        /*--------------------------------------------------------------------------*/

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */

        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);

            case 1:
              return func.call(thisArg, args[0]);

            case 2:
              return func.call(thisArg, args[0], args[1]);

            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }

          return func.apply(thisArg, args);
        }
        /**
         * A specialized version of `baseAggregator` for arrays.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */


        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }

          return accumulator;
        }
        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */


        function arrayEach(array, iteratee) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }

          return array;
        }
        /**
         * A specialized version of `_.forEachRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */


        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;

          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }

          return array;
        }
        /**
         * A specialized version of `_.every` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */


        function arrayEvery(array, predicate) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }

          return true;
        }
        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */


        function arrayFilter(array, predicate) {
          var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];

            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }

          return result;
        }
        /**
         * A specialized version of `_.includes` for arrays without support for
         * specifying an index to search from.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */


        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        /**
         * This function is like `arrayIncludes` except that it accepts a comparator.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */


        function arrayIncludesWith(array, value, comparator) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }

          return false;
        }
        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */


        function arrayMap(array, iteratee) {
          var index = -1,
              length = array == null ? 0 : array.length,
              result = Array(length);

          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }

          return result;
        }
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */


        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;

          while (++index < length) {
            array[offset + index] = values[index];
          }

          return array;
        }
        /**
         * A specialized version of `_.reduce` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the first element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */


        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1,
              length = array == null ? 0 : array.length;

          if (initAccum && length) {
            accumulator = array[++index];
          }

          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }

          return accumulator;
        }
        /**
         * A specialized version of `_.reduceRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the last element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */


        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;

          if (initAccum && length) {
            accumulator = array[--length];
          }

          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }

          return accumulator;
        }
        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */


        function arraySome(array, predicate) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }

          return false;
        }
        /**
         * Gets the size of an ASCII `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */


        var asciiSize = baseProperty('length');
        /**
         * Converts an ASCII `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */

        function asciiToArray(string) {
          return string.split('');
        }
        /**
         * Splits an ASCII `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */


        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        /**
         * The base implementation of methods like `_.findKey` and `_.findLastKey`,
         * without support for iteratee shorthands, which iterates over `collection`
         * using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */


        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function (value, key, collection) {
            if (predicate(value, key, collection)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length,
              index = fromIndex + (fromRight ? 1 : -1);

          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }

          return -1;
        }
        /**
         * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        /**
         * This function is like `baseIndexOf` except that it accepts a comparator.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1,
              length = array.length;

          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }

          return -1;
        }
        /**
         * The base implementation of `_.isNaN` without support for number objects.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         */


        function baseIsNaN(value) {
          return value !== value;
        }
        /**
         * The base implementation of `_.mean` and `_.meanBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the mean.
         */


        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */


        function baseProperty(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }
        /**
         * The base implementation of `_.propertyOf` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         */


        function basePropertyOf(object) {
          return function (key) {
            return object == null ? undefined : object[key];
          };
        }
        /**
         * The base implementation of `_.reduce` and `_.reduceRight`, without support
         * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initAccum Specify using the first or last element of
         *  `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */


        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function (value, index, collection) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define the
         * sort order of `array` and replaces criteria objects with their corresponding
         * values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */


        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);

          while (length--) {
            array[length] = array[length].value;
          }

          return array;
        }
        /**
         * The base implementation of `_.sum` and `_.sumBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */


        function baseSum(array, iteratee) {
          var result,
              index = -1,
              length = array.length;

          while (++index < length) {
            var current = iteratee(array[index]);

            if (current !== undefined) {
              result = result === undefined ? current : result + current;
            }
          }

          return result;
        }
        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */


        function baseTimes(n, iteratee) {
          var index = -1,
              result = Array(n);

          while (++index < n) {
            result[index] = iteratee(index);
          }

          return result;
        }
        /**
         * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
         * of key-value pairs for `object` corresponding to the property names of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the key-value pairs.
         */


        function baseToPairs(object, props) {
          return arrayMap(props, function (key) {
            return [key, object[key]];
          });
        }
        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */


        function baseUnary(func) {
          return function (value) {
            return func(value);
          };
        }
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */


        function baseValues(object, props) {
          return arrayMap(props, function (key) {
            return object[key];
          });
        }
        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */


        function cacheHas(cache, key) {
          return cache.has(key);
        }
        /**
         * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the first unmatched string symbol.
         */


        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1,
              length = strSymbols.length;

          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}

          return index;
        }
        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the last unmatched string symbol.
         */


        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;

          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}

          return index;
        }
        /**
         * Gets the number of `placeholder` occurrences in `array`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} placeholder The placeholder to search for.
         * @returns {number} Returns the placeholder count.
         */


        function countHolders(array, placeholder) {
          var length = array.length,
              result = 0;

          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }

          return result;
        }
        /**
         * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
         * letters to basic Latin letters.
         *
         * @private
         * @param {string} letter The matched letter to deburr.
         * @returns {string} Returns the deburred letter.
         */


        var deburrLetter = basePropertyOf(deburredLetters);
        /**
         * Used by `_.escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */

        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        /**
         * Used by `_.template` to escape characters for inclusion in compiled string literals.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */

        function escapeStringChar(chr) {
          return '\\' + stringEscapes[chr];
        }
        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */


        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }
        /**
         * Checks if `string` contains Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a symbol is found, else `false`.
         */


        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        /**
         * Checks if `string` contains a word composed of Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a word is found, else `false`.
         */


        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        /**
         * Converts `iterator` to an array.
         *
         * @private
         * @param {Object} iterator The iterator to convert.
         * @returns {Array} Returns the converted array.
         */


        function iteratorToArray(iterator) {
          var data,
              result = [];

          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }

          return result;
        }
        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */


        function mapToArray(map) {
          var index = -1,
              result = Array(map.size);
          map.forEach(function (value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */


        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }
        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */


        function replaceHolders(array, placeholder) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];

            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }

          return result;
        }
        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */


        function setToArray(set) {
          var index = -1,
              result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = value;
          });
          return result;
        }
        /**
         * Converts `set` to its value-value pairs.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the value-value pairs.
         */


        function setToPairs(set) {
          var index = -1,
              result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = [value, value];
          });
          return result;
        }
        /**
         * A specialized version of `_.indexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1,
              length = array.length;

          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }

          return -1;
        }
        /**
         * A specialized version of `_.lastIndexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;

          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }

          return index;
        }
        /**
         * Gets the number of symbols in `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the string size.
         */


        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        /**
         * Converts `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */


        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        /**
         * Used by `_.unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} chr The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */


        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        /**
         * Gets the size of a Unicode `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */

        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;

          while (reUnicode.test(string)) {
            ++result;
          }

          return result;
        }
        /**
         * Converts a Unicode `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */


        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        /**
         * Splits a Unicode `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */


        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        /*--------------------------------------------------------------------------*/

        /**
         * Create a new pristine `lodash` function using the `context` object.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Util
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns a new `lodash` function.
         * @example
         *
         * _.mixin({ 'foo': _.constant('foo') });
         *
         * var lodash = _.runInContext();
         * lodash.mixin({ 'bar': lodash.constant('bar') });
         *
         * _.isFunction(_.foo);
         * // => true
         * _.isFunction(_.bar);
         * // => false
         *
         * lodash.isFunction(lodash.foo);
         * // => false
         * lodash.isFunction(lodash.bar);
         * // => true
         *
         * // Create a suped-up `defer` in Node.js.
         * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
         */


        var runInContext = function runInContext(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          /** Built-in constructor references. */

          var Array = context.Array,
              Date = context.Date,
              Error = context.Error,
              Function = context.Function,
              Math = context.Math,
              Object = context.Object,
              RegExp = context.RegExp,
              String = context.String,
              TypeError = context.TypeError;
          /** Used for built-in method references. */

          var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
          /** Used to detect overreaching core-js shims. */

          var coreJsData = context['__core-js_shared__'];
          /** Used to resolve the decompiled source of functions. */

          var funcToString = funcProto.toString;
          /** Used to check objects for own properties. */

          var hasOwnProperty = objectProto.hasOwnProperty;
          /** Used to generate unique IDs. */

          var idCounter = 0;
          /** Used to detect methods masquerading as native. */

          var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
          }();
          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */


          var nativeObjectToString = objectProto.toString;
          /** Used to infer the `Object` constructor. */

          var objectCtorString = funcToString.call(Object);
          /** Used to restore the original `_` reference in `_.noConflict`. */

          var oldDash = root._;
          /** Used to detect if a method is native. */

          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
          /** Built-in value references. */

          var Buffer = moduleExports ? context.Buffer : undefined,
              Symbol = context.Symbol,
              Uint8Array = context.Uint8Array,
              allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
              getPrototype = overArg(Object.getPrototypeOf, Object),
              objectCreate = Object.create,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice,
              spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
              symIterator = Symbol ? Symbol.iterator : undefined,
              symToStringTag = Symbol ? Symbol.toStringTag : undefined;

          var defineProperty = function () {
            try {
              var func = getNative(Object, 'defineProperty');
              func({}, '', {});
              return func;
            } catch (e) {}
          }();
          /** Mocked built-ins. */


          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
              ctxNow = Date && Date.now !== root.Date.now && Date.now,
              ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          /* Built-in method references for those with the same name as other `lodash` methods. */

          var nativeCeil = Math.ceil,
              nativeFloor = Math.floor,
              nativeGetSymbols = Object.getOwnPropertySymbols,
              nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
              nativeIsFinite = context.isFinite,
              nativeJoin = arrayProto.join,
              nativeKeys = overArg(Object.keys, Object),
              nativeMax = Math.max,
              nativeMin = Math.min,
              nativeNow = Date.now,
              nativeParseInt = context.parseInt,
              nativeRandom = Math.random,
              nativeReverse = arrayProto.reverse;
          /* Built-in method references that are verified to be native. */

          var DataView = getNative(context, 'DataView'),
              Map = getNative(context, 'Map'),
              Promise = getNative(context, 'Promise'),
              Set = getNative(context, 'Set'),
              WeakMap = getNative(context, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
          /** Used to store function metadata. */

          var metaMap = WeakMap && new WeakMap();
          /** Used to lookup unminified function names. */

          var realNames = {};
          /** Used to detect maps, sets, and weakmaps. */

          var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
          /** Used to convert symbols to primitives and strings. */

          var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object which wraps `value` to enable implicit method
           * chain sequences. Methods that operate on and return arrays, collections,
           * and functions can be chained together. Methods that retrieve a single value
           * or may return a primitive value will automatically end the chain sequence
           * and return the unwrapped value. Otherwise, the value must be unwrapped
           * with `_#value`.
           *
           * Explicit chain sequences, which must be unwrapped with `_#value`, may be
           * enabled using `_.chain`.
           *
           * The execution of chained methods is lazy, that is, it's deferred until
           * `_#value` is implicitly or explicitly called.
           *
           * Lazy evaluation allows several methods to support shortcut fusion.
           * Shortcut fusion is an optimization to merge iteratee calls; this avoids
           * the creation of intermediate arrays and can greatly reduce the number of
           * iteratee executions. Sections of a chain sequence qualify for shortcut
           * fusion if the section is applied to an array and iteratees accept only
           * one argument. The heuristic for whether a section qualifies for shortcut
           * fusion is subject to change.
           *
           * Chaining is supported in custom builds as long as the `_#value` method is
           * directly or indirectly included in the build.
           *
           * In addition to lodash methods, wrappers have `Array` and `String` methods.
           *
           * The wrapper `Array` methods are:
           * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
           *
           * The wrapper `String` methods are:
           * `replace` and `split`
           *
           * The wrapper methods that support shortcut fusion are:
           * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
           * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
           * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
           *
           * The chainable wrapper methods are:
           * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
           * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
           * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
           * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
           * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
           * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
           * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
           * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
           * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
           * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
           * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
           * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
           * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
           * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
           * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
           * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
           * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
           * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
           * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
           * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
           * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
           * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
           * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
           * `zipObject`, `zipObjectDeep`, and `zipWith`
           *
           * The wrapper methods that are **not** chainable by default are:
           * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
           * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
           * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
           * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
           * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
           * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
           * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
           * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
           * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
           * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
           * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
           * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
           * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
           * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
           * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
           * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
           * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
           * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
           * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
           * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
           * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
           * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
           * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
           * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
           * `upperFirst`, `value`, and `words`
           *
           * @name _
           * @constructor
           * @category Seq
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // Returns an unwrapped value.
           * wrapped.reduce(_.add);
           * // => 6
           *
           * // Returns a wrapped value.
           * var squares = wrapped.map(square);
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */

          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }

              if (hasOwnProperty.call(value, '__wrapped__')) {
                return wrapperClone(value);
              }
            }

            return new LodashWrapper(value);
          }
          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} proto The object to inherit from.
           * @returns {Object} Returns the new object.
           */


          var baseCreate = function () {
            function object() {}

            return function (proto) {
              if (!isObject(proto)) {
                return {};
              }

              if (objectCreate) {
                return objectCreate(proto);
              }

              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          }();
          /**
           * The function whose prototype chain sequence wrappers inherit from.
           *
           * @private
           */


          function baseLodash() {// No operation performed.
          }
          /**
           * The base constructor for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap.
           * @param {boolean} [chainAll] Enable explicit method chain sequences.
           */


          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined;
          }
          /**
           * By default, the template delimiters used by lodash are like those in
           * embedded Ruby (ERB) as well as ES2015 template strings. Change the
           * following template settings to use alternative delimiters.
           *
           * @static
           * @memberOf _
           * @type {Object}
           */


          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'escape': reEscape,

            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'evaluate': reEvaluate,

            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'interpolate': reInterpolate,

            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            'variable': '',

            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            'imports': {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              '_': lodash
            }
          }; // Ensure wrappers are instances of `baseLodash`.

          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
           *
           * @private
           * @constructor
           * @param {*} value The value to wrap.
           */

          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          /**
           * Creates a clone of the lazy wrapper object.
           *
           * @private
           * @name clone
           * @memberOf LazyWrapper
           * @returns {Object} Returns the cloned `LazyWrapper` object.
           */


          function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result;
          }
          /**
           * Reverses the direction of lazy iteration.
           *
           * @private
           * @name reverse
           * @memberOf LazyWrapper
           * @returns {Object} Returns the new reversed `LazyWrapper` object.
           */


          function lazyReverse() {
            if (this.__filtered__) {
              var result = new LazyWrapper(this);
              result.__dir__ = -1;
              result.__filtered__ = true;
            } else {
              result = this.clone();
              result.__dir__ *= -1;
            }

            return result;
          }
          /**
           * Extracts the unwrapped value from its lazy wrapper.
           *
           * @private
           * @name value
           * @memberOf LazyWrapper
           * @returns {*} Returns the unwrapped value.
           */


          function lazyValue() {
            var array = this.__wrapped__.value(),
                dir = this.__dir__,
                isArr = isArray(array),
                isRight = dir < 0,
                arrLength = isArr ? array.length : 0,
                view = getView(0, arrLength, this.__views__),
                start = view.start,
                end = view.end,
                length = end - start,
                index = isRight ? end : start - 1,
                iteratees = this.__iteratees__,
                iterLength = iteratees.length,
                resIndex = 0,
                takeCount = nativeMin(length, this.__takeCount__);

            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }

            var result = [];

            outer: while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1,
                  value = array[index];

              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex],
                    iteratee = data.iteratee,
                    type = data.type,
                    computed = iteratee(value);

                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }

              result[resIndex++] = value;
            }

            return result;
          } // Ensure `LazyWrapper` is an instance of `baseLodash`.


          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function Hash(entries) {
            var index = -1,
                length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */


          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }
          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function hashGet(key) {
            var data = this.__data__;

            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }

            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }
          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }
          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */


          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          } // Add methods to `Hash`.


          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          /*------------------------------------------------------------------------*/

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function ListCache(entries) {
            var index = -1,
                length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */


          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function listCacheDelete(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);

            if (index < 0) {
              return false;
            }

            var lastIndex = data.length - 1;

            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }

            --this.size;
            return true;
          }
          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function listCacheGet(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }
          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */


          function listCacheSet(key, value) {
            var data = this.__data__,
                index = assocIndexOf(data, key);

            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }

            return this;
          } // Add methods to `ListCache`.


          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function MapCache(entries) {
            var index = -1,
                length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */


          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }
          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
          }
          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */


          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
                size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          } // Add methods to `MapCache`.


          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          /*------------------------------------------------------------------------*/

          /**
           *
           * Creates an array cache object to store unique values.
           *
           * @private
           * @constructor
           * @param {Array} [values] The values to cache.
           */

          function SetCache(values) {
            var index = -1,
                length = values == null ? 0 : values.length;
            this.__data__ = new MapCache();

            while (++index < length) {
              this.add(values[index]);
            }
          }
          /**
           * Adds `value` to the array cache.
           *
           * @private
           * @name add
           * @memberOf SetCache
           * @alias push
           * @param {*} value The value to cache.
           * @returns {Object} Returns the cache instance.
           */


          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);

            return this;
          }
          /**
           * Checks if `value` is in the array cache.
           *
           * @private
           * @name has
           * @memberOf SetCache
           * @param {*} value The value to search for.
           * @returns {number} Returns `true` if `value` is found, else `false`.
           */


          function setCacheHas(value) {
            return this.__data__.has(value);
          } // Add methods to `SetCache`.


          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */


          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function stackDelete(key) {
            var data = this.__data__,
                result = data['delete'](key);
            this.size = data.size;
            return result;
          }
          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function stackGet(key) {
            return this.__data__.get(key);
          }
          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function stackHas(key) {
            return this.__data__.has(key);
          }
          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */


          function stackSet(key, value) {
            var data = this.__data__;

            if (data instanceof ListCache) {
              var pairs = data.__data__;

              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }

              data = this.__data__ = new MapCache(pairs);
            }

            data.set(key, value);
            this.size = data.size;
            return this;
          } // Add methods to `Stack`.


          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */

          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
                isArg = !isArr && isArguments(value),
                isBuff = !isArr && !isArg && isBuffer(value),
                isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                skipIndexes = isArr || isArg || isBuff || isType,
                result = skipIndexes ? baseTimes(value.length, String) : [],
                length = result.length;

            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
              key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * A specialized version of `_.sample` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @returns {*} Returns the random element.
           */


          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined;
          }
          /**
           * A specialized version of `_.sampleSize` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */


          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          /**
           * A specialized version of `_.shuffle` for arrays.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */


          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          /**
           * This function is like `assignValue` except that it doesn't assign
           * `undefined` values.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */


          function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */


          function assignValue(object, key, value) {
            var objValue = object[key];

            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */


          function assocIndexOf(array, key) {
            var length = array.length;

            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }

            return -1;
          }
          /**
           * Aggregates elements of `collection` on `accumulator` with keys transformed
           * by `iteratee` and values set by `setter`.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform keys.
           * @param {Object} accumulator The initial aggregated object.
           * @returns {Function} Returns `accumulator`.
           */


          function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function (value, key, collection) {
              setter(accumulator, value, iteratee(value), collection);
            });
            return accumulator;
          }
          /**
           * The base implementation of `_.assign` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */


          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          /**
           * The base implementation of `_.assignIn` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */


          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          /**
           * The base implementation of `assignValue` and `assignMergeValue` without
           * value checks.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */


          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
              });
            } else {
              object[key] = value;
            }
          }
          /**
           * The base implementation of `_.at` without support for individual paths.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {string[]} paths The property paths to pick.
           * @returns {Array} Returns the picked elements.
           */


          function baseAt(object, paths) {
            var index = -1,
                length = paths.length,
                result = Array(length),
                skip = object == null;

            while (++index < length) {
              result[index] = skip ? undefined : get(object, paths[index]);
            }

            return result;
          }
          /**
           * The base implementation of `_.clamp` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           */


          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined) {
                number = number <= upper ? number : upper;
              }

              if (lower !== undefined) {
                number = number >= lower ? number : lower;
              }
            }

            return number;
          }
          /**
           * The base implementation of `_.clone` and `_.cloneDeep` which tracks
           * traversed objects.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Deep clone
           *  2 - Flatten inherited properties
           *  4 - Clone symbols
           * @param {Function} [customizer] The function to customize cloning.
           * @param {string} [key] The key of `value`.
           * @param {Object} [object] The parent object of `value`.
           * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
           * @returns {*} Returns the cloned value.
           */


          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result,
                isDeep = bitmask & CLONE_DEEP_FLAG,
                isFlat = bitmask & CLONE_FLAT_FLAG,
                isFull = bitmask & CLONE_SYMBOLS_FLAG;

            if (customizer) {
              result = object ? customizer(value, key, object, stack) : customizer(value);
            }

            if (result !== undefined) {
              return result;
            }

            if (!isObject(value)) {
              return value;
            }

            var isArr = isArray(value);

            if (isArr) {
              result = initCloneArray(value);

              if (!isDeep) {
                return copyArray(value, result);
              }
            } else {
              var tag = getTag(value),
                  isFunc = tag == funcTag || tag == genTag;

              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }

              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result = isFlat || isFunc ? {} : initCloneObject(value);

                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }

                result = initCloneByTag(value, tag, isDeep);
              }
            } // Check for circular references and return its corresponding clone.


            stack || (stack = new Stack());
            var stacked = stack.get(value);

            if (stacked) {
              return stacked;
            }

            stack.set(value, result);

            if (isSet(value)) {
              value.forEach(function (subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function (subValue, key) {
                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
              });
            }

            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined : keysFunc(value);
            arrayEach(props || value, function (subValue, key) {
              if (props) {
                key = subValue;
                subValue = value[key];
              } // Recursively populate clone (susceptible to call stack limits).


              assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
            return result;
          }
          /**
           * The base implementation of `_.conforms` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           */


          function baseConforms(source) {
            var props = keys(source);
            return function (object) {
              return baseConformsTo(object, source, props);
            };
          }
          /**
           * The base implementation of `_.conformsTo` which accepts `props` to check.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           */


          function baseConformsTo(object, source, props) {
            var length = props.length;

            if (object == null) {
              return !length;
            }

            object = Object(object);

            while (length--) {
              var key = props[length],
                  predicate = source[key],
                  value = object[key];

              if (value === undefined && !(key in object) || !predicate(value)) {
                return false;
              }
            }

            return true;
          }
          /**
           * The base implementation of `_.delay` and `_.defer` which accepts `args`
           * to provide to `func`.
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {Array} args The arguments to provide to `func`.
           * @returns {number|Object} Returns the timer id or timeout object.
           */


          function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            return setTimeout(function () {
              func.apply(undefined, args);
            }, wait);
          }
          /**
           * The base implementation of methods like `_.difference` without support
           * for excluding multiple arrays or iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Array} values The values to exclude.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           */


          function baseDifference(array, values, iteratee, comparator) {
            var index = -1,
                includes = arrayIncludes,
                isCommon = true,
                length = array.length,
                result = [],
                valuesLength = values.length;

            if (!length) {
              return result;
            }

            if (iteratee) {
              values = arrayMap(values, baseUnary(iteratee));
            }

            if (comparator) {
              includes = arrayIncludesWith;
              isCommon = false;
            } else if (values.length >= LARGE_ARRAY_SIZE) {
              includes = cacheHas;
              isCommon = false;
              values = new SetCache(values);
            }

            outer: while (++index < length) {
              var value = array[index],
                  computed = iteratee == null ? value : iteratee(value);
              value = comparator || value !== 0 ? value : 0;

              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;

                while (valuesIndex--) {
                  if (values[valuesIndex] === computed) {
                    continue outer;
                  }
                }

                result.push(value);
              } else if (!includes(values, computed, comparator)) {
                result.push(value);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.forEach` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */


          var baseEach = createBaseEach(baseForOwn);
          /**
           * The base implementation of `_.forEachRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */

          var baseEachRight = createBaseEach(baseForOwnRight, true);
          /**
           * The base implementation of `_.every` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`
           */

          function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
              result = !!predicate(value, index, collection);
              return result;
            });
            return result;
          }
          /**
           * The base implementation of methods like `_.max` and `_.min` which accepts a
           * `comparator` to determine the extremum value.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The iteratee invoked per iteration.
           * @param {Function} comparator The comparator used to compare values.
           * @returns {*} Returns the extremum value.
           */


          function baseExtremum(array, iteratee, comparator) {
            var index = -1,
                length = array.length;

            while (++index < length) {
              var value = array[index],
                  current = iteratee(value);

              if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current,
                    result = value;
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.fill` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           */


          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);

            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }

            end = end === undefined || end > length ? length : toInteger(end);

            if (end < 0) {
              end += length;
            }

            end = start > end ? 0 : toLength(end);

            while (start < end) {
              array[start++] = value;
            }

            return array;
          }
          /**
           * The base implementation of `_.filter` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */


          function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
              if (predicate(value, index, collection)) {
                result.push(value);
              }
            });
            return result;
          }
          /**
           * The base implementation of `_.flatten` with support for restricting flattening.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {number} depth The maximum recursion depth.
           * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
           * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
           * @param {Array} [result=[]] The initial result value.
           * @returns {Array} Returns the new flattened array.
           */


          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
                length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);

            while (++index < length) {
              var value = array[index];

              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  // Recursively flatten arrays (susceptible to call stack limits).
                  baseFlatten(value, depth - 1, predicate, isStrict, result);
                } else {
                  arrayPush(result, value);
                }
              } else if (!isStrict) {
                result[result.length] = value;
              }
            }

            return result;
          }
          /**
           * The base implementation of `baseForOwn` which iterates over `object`
           * properties returned by `keysFunc` and invokes `iteratee` for each property.
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */


          var baseFor = createBaseFor();
          /**
           * This function is like `baseFor` except that it iterates over properties
           * in the opposite order.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */

          var baseForRight = createBaseFor(true);
          /**
           * The base implementation of `_.forOwn` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */

          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
          }
          /**
           * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */


          function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
          }
          /**
           * The base implementation of `_.functions` which creates an array of
           * `object` function property names filtered from `props`.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} props The property names to filter.
           * @returns {Array} Returns the function names.
           */


          function baseFunctions(object, props) {
            return arrayFilter(props, function (key) {
              return isFunction(object[key]);
            });
          }
          /**
           * The base implementation of `_.get` without support for default values.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @returns {*} Returns the resolved value.
           */


          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0,
                length = path.length;

            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }

            return index && index == length ? object : undefined;
          }
          /**
           * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
           * `keysFunc` and `symbolsFunc` to get the enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @param {Function} symbolsFunc The function to get the symbols of `object`.
           * @returns {Array} Returns the array of property names and symbols.
           */


          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }
          /**
           * The base implementation of `getTag` without fallbacks for buggy environments.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */


          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }

            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          /**
           * The base implementation of `_.gt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           */


          function baseGt(value, other) {
            return value > other;
          }
          /**
           * The base implementation of `_.has` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */


          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          /**
           * The base implementation of `_.hasIn` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */


          function baseHasIn(object, key) {
            return object != null && key in Object(object);
          }
          /**
           * The base implementation of `_.inRange` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to check.
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           */


          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          /**
           * The base implementation of methods like `_.intersection`, without support
           * for iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of shared values.
           */


          function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes,
                length = arrays[0].length,
                othLength = arrays.length,
                othIndex = othLength,
                caches = Array(othLength),
                maxLength = Infinity,
                result = [];

            while (othIndex--) {
              var array = arrays[othIndex];

              if (othIndex && iteratee) {
                array = arrayMap(array, baseUnary(iteratee));
              }

              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }

            array = arrays[0];
            var index = -1,
                seen = caches[0];

            outer: while (++index < length && result.length < maxLength) {
              var value = array[index],
                  computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;

              if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                othIndex = othLength;

                while (--othIndex) {
                  var cache = caches[othIndex];

                  if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }

                if (seen) {
                  seen.push(computed);
                }

                result.push(value);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.invert` and `_.invertBy` which inverts
           * `object` with values transformed by `iteratee` and set by `setter`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform values.
           * @param {Object} accumulator The initial inverted object.
           * @returns {Function} Returns `accumulator`.
           */


          function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function (value, key, object) {
              setter(accumulator, iteratee(value), key, object);
            });
            return accumulator;
          }
          /**
           * The base implementation of `_.invoke` without support for individual
           * method arguments.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {Array} args The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           */


          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined : apply(func, object, args);
          }
          /**
           * The base implementation of `_.isArguments`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           */


          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          /**
           * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           */


          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          /**
           * The base implementation of `_.isDate` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           */


          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          /**
           * The base implementation of `_.isEqual` which supports partial comparisons
           * and tracks traversed objects.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Unordered comparison
           *  2 - Partial comparison
           * @param {Function} [customizer] The function to customize comparisons.
           * @param {Object} [stack] Tracks traversed `value` and `other` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */


          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }

            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }

            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          /**
           * A specialized version of `baseIsEqual` for arrays and objects which performs
           * deep comparisons and tracks traversed objects enabling objects with circular
           * references to be compared.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} [stack] Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */


          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = objIsArr ? arrayTag : getTag(object),
                othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag,
                othIsObj = othTag == objectTag,
                isSameTag = objTag == othTag;

            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }

              objIsArr = true;
              objIsObj = false;
            }

            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }

            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }

            if (!isSameTag) {
              return false;
            }

            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          /**
           * The base implementation of `_.isMap` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           */


          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          /**
           * The base implementation of `_.isMatch` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Array} matchData The property names, values, and compare flags to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           */


          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
                length = index,
                noCustomizer = !customizer;

            if (object == null) {
              return !length;
            }

            object = Object(object);

            while (index--) {
              var data = matchData[index];

              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }

            while (++index < length) {
              data = matchData[index];
              var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];

              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();

                if (customizer) {
                  var result = customizer(objValue, srcValue, key, object, source, stack);
                }

                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                  return false;
                }
              }
            }

            return true;
          }
          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */


          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }

            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          /**
           * The base implementation of `_.isRegExp` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           */


          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          /**
           * The base implementation of `_.isSet` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           */


          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          /**
           * The base implementation of `_.isTypedArray` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           */


          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          /**
           * The base implementation of `_.iteratee`.
           *
           * @private
           * @param {*} [value=_.identity] The value to convert to an iteratee.
           * @returns {Function} Returns the iteratee.
           */


          function baseIteratee(value) {
            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
            if (typeof value == 'function') {
              return value;
            }

            if (value == null) {
              return identity;
            }

            if (typeof value == 'object') {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }

            return property(value);
          }
          /**
           * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */


          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }

            var result = [];

            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */


          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }

            var isProto = isPrototype(object),
                result = [];

            for (var key in object) {
              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.lt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           */


          function baseLt(value, other) {
            return value < other;
          }
          /**
           * The base implementation of `_.map` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */


          function baseMap(collection, iteratee) {
            var index = -1,
                result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }
          /**
           * The base implementation of `_.matches` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           */


          function baseMatches(source) {
            var matchData = getMatchData(source);

            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }

            return function (object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          /**
           * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
           *
           * @private
           * @param {string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */


          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }

            return function (object) {
              var objValue = get(object, path);
              return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          /**
           * The base implementation of `_.merge` without support for multiple sources.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */


          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }

            baseFor(source, function (srcValue, key) {
              stack || (stack = new Stack());

              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

                if (newValue === undefined) {
                  newValue = srcValue;
                }

                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */


          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key),
                srcValue = safeGet(source, key),
                stacked = stack.get(srcValue);

            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }

            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;

            if (isCommon) {
              var isArr = isArray(srcValue),
                  isBuff = !isArr && isBuffer(srcValue),
                  isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;

              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;

                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }

            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack['delete'](srcValue);
            }

            assignMergeValue(object, key, newValue);
          }
          /**
           * The base implementation of `_.nth` which doesn't coerce arguments.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {number} n The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           */


          function baseNth(array, n) {
            var length = array.length;

            if (!length) {
              return;
            }

            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined;
          }
          /**
           * The base implementation of `_.orderBy` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {string[]} orders The sort orders of `iteratees`.
           * @returns {Array} Returns the new sorted array.
           */


          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function (iteratee) {
                if (isArray(iteratee)) {
                  return function (value) {
                    return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                  };
                }

                return iteratee;
              });
            } else {
              iteratees = [identity];
            }

            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result = baseMap(collection, function (value, key, collection) {
              var criteria = arrayMap(iteratees, function (iteratee) {
                return iteratee(value);
              });
              return {
                'criteria': criteria,
                'index': ++index,
                'value': value
              };
            });
            return baseSortBy(result, function (object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          /**
           * The base implementation of `_.pick` without support for individual
           * property identifiers.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @returns {Object} Returns the new object.
           */


          function basePick(object, paths) {
            return basePickBy(object, paths, function (value, path) {
              return hasIn(object, path);
            });
          }
          /**
           * The base implementation of  `_.pickBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @param {Function} predicate The function invoked per property.
           * @returns {Object} Returns the new object.
           */


          function basePickBy(object, paths, predicate) {
            var index = -1,
                length = paths.length,
                result = {};

            while (++index < length) {
              var path = paths[index],
                  value = baseGet(object, path);

              if (predicate(value, path)) {
                baseSet(result, castPath(path, object), value);
              }
            }

            return result;
          }
          /**
           * A specialized version of `baseProperty` which supports deep paths.
           *
           * @private
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           */


          function basePropertyDeep(path) {
            return function (object) {
              return baseGet(object, path);
            };
          }
          /**
           * The base implementation of `_.pullAllBy` without support for iteratee
           * shorthands.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           */


          function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                index = -1,
                length = values.length,
                seen = array;

            if (array === values) {
              values = copyArray(values);
            }

            if (iteratee) {
              seen = arrayMap(array, baseUnary(iteratee));
            }

            while (++index < length) {
              var fromIndex = 0,
                  value = values[index],
                  computed = iteratee ? iteratee(value) : value;

              while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }

                splice.call(array, fromIndex, 1);
              }
            }

            return array;
          }
          /**
           * The base implementation of `_.pullAt` without support for individual
           * indexes or capturing the removed elements.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {number[]} indexes The indexes of elements to remove.
           * @returns {Array} Returns `array`.
           */


          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0,
                lastIndex = length - 1;

            while (length--) {
              var index = indexes[length];

              if (length == lastIndex || index !== previous) {
                var previous = index;

                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }

            return array;
          }
          /**
           * The base implementation of `_.random` without support for returning
           * floating-point numbers.
           *
           * @private
           * @param {number} lower The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the random number.
           */


          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          /**
           * The base implementation of `_.range` and `_.rangeRight` which doesn't
           * coerce arguments.
           *
           * @private
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @param {number} step The value to increment or decrement by.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the range of numbers.
           */


          function baseRange(start, end, step, fromRight) {
            var index = -1,
                length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                result = Array(length);

            while (length--) {
              result[fromRight ? length : ++index] = start;
              start += step;
            }

            return result;
          }
          /**
           * The base implementation of `_.repeat` which doesn't coerce arguments.
           *
           * @private
           * @param {string} string The string to repeat.
           * @param {number} n The number of times to repeat the string.
           * @returns {string} Returns the repeated string.
           */


          function baseRepeat(string, n) {
            var result = '';

            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result;
            } // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.


            do {
              if (n % 2) {
                result += string;
              }

              n = nativeFloor(n / 2);

              if (n) {
                string += string;
              }
            } while (n);

            return result;
          }
          /**
           * The base implementation of `_.rest` which doesn't validate or coerce arguments.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           */


          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
          }
          /**
           * The base implementation of `_.sample`.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           */


          function baseSample(collection) {
            return arraySample(values(collection));
          }
          /**
           * The base implementation of `_.sampleSize` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */


          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          /**
           * The base implementation of `_.set`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */


          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }

            path = castPath(path, object);
            var index = -1,
                length = path.length,
                lastIndex = length - 1,
                nested = object;

            while (nested != null && ++index < length) {
              var key = toKey(path[index]),
                  newValue = value;

              if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                return object;
              }

              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined;

                if (newValue === undefined) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }

              assignValue(nested, key, newValue);
              nested = nested[key];
            }

            return object;
          }
          /**
           * The base implementation of `setData` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */


          var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
          };
          /**
           * The base implementation of `setToString` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */

          var baseSetToString = !defineProperty ? identity : function (func, string) {
            return defineProperty(func, 'toString', {
              'configurable': true,
              'enumerable': false,
              'value': constant(string),
              'writable': true
            });
          };
          /**
           * The base implementation of `_.shuffle`.
           *
           * @private
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */

          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          /**
           * The base implementation of `_.slice` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */


          function baseSlice(array, start, end) {
            var index = -1,
                length = array.length;

            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }

            end = end > length ? length : end;

            if (end < 0) {
              end += length;
            }

            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);

            while (++index < length) {
              result[index] = array[index + start];
            }

            return result;
          }
          /**
           * The base implementation of `_.some` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */


          function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function (value, index, collection) {
              result = predicate(value, index, collection);
              return !result;
            });
            return !!result;
          }
          /**
           * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
           * performs a binary search of `array` to determine the index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */


          function baseSortedIndex(array, value, retHighest) {
            var low = 0,
                high = array == null ? low : array.length;

            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1,
                    computed = array[mid];

                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }

              return high;
            }

            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          /**
           * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
           * which invokes `iteratee` for `value` and each element of `array` to compute
           * their sort ranking. The iteratee is invoked with one argument; (value).
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} iteratee The iteratee invoked per element.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */


          function baseSortedIndexBy(array, value, iteratee, retHighest) {
            var low = 0,
                high = array == null ? 0 : array.length;

            if (high === 0) {
              return 0;
            }

            value = iteratee(value);
            var valIsNaN = value !== value,
                valIsNull = value === null,
                valIsSymbol = isSymbol(value),
                valIsUndefined = value === undefined;

            while (low < high) {
              var mid = nativeFloor((low + high) / 2),
                  computed = iteratee(array[mid]),
                  othIsDefined = computed !== undefined,
                  othIsNull = computed === null,
                  othIsReflexive = computed === computed,
                  othIsSymbol = isSymbol(computed);

              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }

              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }

            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          /**
           * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
           * support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */


          function baseSortedUniq(array, iteratee) {
            var index = -1,
                length = array.length,
                resIndex = 0,
                result = [];

            while (++index < length) {
              var value = array[index],
                  computed = iteratee ? iteratee(value) : value;

              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result[resIndex++] = value === 0 ? 0 : value;
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.toNumber` which doesn't ensure correct
           * conversions of binary, hexadecimal, or octal string values.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           */


          function baseToNumber(value) {
            if (typeof value == 'number') {
              return value;
            }

            if (isSymbol(value)) {
              return NAN;
            }

            return +value;
          }
          /**
           * The base implementation of `_.toString` which doesn't convert nullish
           * values to empty strings.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           */


          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
              return value;
            }

            if (isArray(value)) {
              // Recursively convert values (susceptible to call stack limits).
              return arrayMap(value, baseToString) + '';
            }

            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : '';
            }

            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
           * The base implementation of `_.uniqBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */


          function baseUniq(array, iteratee, comparator) {
            var index = -1,
                includes = arrayIncludes,
                length = array.length,
                isCommon = true,
                result = [],
                seen = result;

            if (comparator) {
              isCommon = false;
              includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array);

              if (set) {
                return setToArray(set);
              }

              isCommon = false;
              includes = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee ? [] : result;
            }

            outer: while (++index < length) {
              var value = array[index],
                  computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;

              if (isCommon && computed === computed) {
                var seenIndex = seen.length;

                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }

                if (iteratee) {
                  seen.push(computed);
                }

                result.push(value);
              } else if (!includes(seen, computed, comparator)) {
                if (seen !== result) {
                  seen.push(computed);
                }

                result.push(value);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.unset`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The property path to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           */


          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          /**
           * The base implementation of `_.update`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to update.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */


          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          /**
           * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
           * without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {Function} predicate The function invoked per iteration.
           * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the slice of `array`.
           */


          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length,
                index = fromRight ? length : -1;

            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          /**
           * The base implementation of `wrapperValue` which returns the result of
           * performing a sequence of actions on the unwrapped `value`, where each
           * successive action is supplied the return value of the previous.
           *
           * @private
           * @param {*} value The unwrapped value.
           * @param {Array} actions Actions to perform to resolve the unwrapped value.
           * @returns {*} Returns the resolved value.
           */


          function baseWrapperValue(value, actions) {
            var result = value;

            if (result instanceof LazyWrapper) {
              result = result.value();
            }

            return arrayReduce(actions, function (result, action) {
              return action.func.apply(action.thisArg, arrayPush([result], action.args));
            }, result);
          }
          /**
           * The base implementation of methods like `_.xor`, without support for
           * iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of values.
           */


          function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;

            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }

            var index = -1,
                result = Array(length);

            while (++index < length) {
              var array = arrays[index],
                  othIndex = -1;

              while (++othIndex < length) {
                if (othIndex != index) {
                  result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                }
              }
            }

            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
          }
          /**
           * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
           *
           * @private
           * @param {Array} props The property identifiers.
           * @param {Array} values The property values.
           * @param {Function} assignFunc The function to assign values.
           * @returns {Object} Returns the new object.
           */


          function baseZipObject(props, values, assignFunc) {
            var index = -1,
                length = props.length,
                valsLength = values.length,
                result = {};

            while (++index < length) {
              var value = index < valsLength ? values[index] : undefined;
              assignFunc(result, props[index], value);
            }

            return result;
          }
          /**
           * Casts `value` to an empty array if it's not an array like object.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Array|Object} Returns the cast array-like object.
           */


          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          /**
           * Casts `value` to `identity` if it's not a function.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Function} Returns cast function.
           */


          function castFunction(value) {
            return typeof value == 'function' ? value : identity;
          }
          /**
           * Casts `value` to a path array if it's not one.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {Object} [object] The object to query keys on.
           * @returns {Array} Returns the cast property path array.
           */


          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }

            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          /**
           * A `baseRest` alias which can be replaced with `identity` by module
           * replacement plugins.
           *
           * @private
           * @type {Function}
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */


          var castRest = baseRest;
          /**
           * Casts `array` to a slice if it's needed.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {number} start The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the cast slice.
           */

          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          /**
           * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
           *
           * @private
           * @param {number|Object} id The timer id or timeout object of the timer to clear.
           */


          var clearTimeout = ctxClearTimeout || function (id) {
            return root.clearTimeout(id);
          };
          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */


          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }

            var length = buffer.length,
                result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }
          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */


          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }
          /**
           * Creates a clone of `dataView`.
           *
           * @private
           * @param {Object} dataView The data view to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned data view.
           */


          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          /**
           * Creates a clone of `regexp`.
           *
           * @private
           * @param {Object} regexp The regexp to clone.
           * @returns {Object} Returns the cloned regexp.
           */


          function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
          }
          /**
           * Creates a clone of the `symbol` object.
           *
           * @private
           * @param {Object} symbol The symbol object to clone.
           * @returns {Object} Returns the cloned symbol object.
           */


          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }
          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */


          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          /**
           * Compares values to sort them in ascending order.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {number} Returns the sort order indicator for `value`.
           */


          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined,
                  valIsNull = value === null,
                  valIsReflexive = value === value,
                  valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined,
                  othIsNull = other === null,
                  othIsReflexive = other === other,
                  othIsSymbol = isSymbol(other);

              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }

              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }

            return 0;
          }
          /**
           * Used by `_.orderBy` to compare multiple properties of a value to another
           * and stable sort them.
           *
           * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
           * specify an order of "desc" for descending or "asc" for ascending sort order
           * of corresponding values.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {boolean[]|string[]} orders The order to sort by for each property.
           * @returns {number} Returns the sort order indicator for `object`.
           */


          function compareMultiple(object, other, orders) {
            var index = -1,
                objCriteria = object.criteria,
                othCriteria = other.criteria,
                length = objCriteria.length,
                ordersLength = orders.length;

            while (++index < length) {
              var result = compareAscending(objCriteria[index], othCriteria[index]);

              if (result) {
                if (index >= ordersLength) {
                  return result;
                }

                var order = orders[index];
                return result * (order == 'desc' ? -1 : 1);
              }
            } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
            // that causes it, under certain circumstances, to provide the same value for
            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
            // for more details.
            //
            // This also ensures a stable sort in V8 and other engines.
            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


            return object.index - other.index;
          }
          /**
           * Creates an array that is the composition of partially applied arguments,
           * placeholders, and provided arguments into a single array of arguments.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to prepend to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */


          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1,
                argsLength = args.length,
                holdersLength = holders.length,
                leftIndex = -1,
                leftLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(leftLength + rangeLength),
                isUncurried = !isCurried;

            while (++leftIndex < leftLength) {
              result[leftIndex] = partials[leftIndex];
            }

            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[holders[argsIndex]] = args[argsIndex];
              }
            }

            while (rangeLength--) {
              result[leftIndex++] = args[argsIndex++];
            }

            return result;
          }
          /**
           * This function is like `composeArgs` except that the arguments composition
           * is tailored for `_.partialRight`.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to append to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */


          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1,
                argsLength = args.length,
                holdersIndex = -1,
                holdersLength = holders.length,
                rightIndex = -1,
                rightLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(rangeLength + rightLength),
                isUncurried = !isCurried;

            while (++argsIndex < rangeLength) {
              result[argsIndex] = args[argsIndex];
            }

            var offset = argsIndex;

            while (++rightIndex < rightLength) {
              result[offset + rightIndex] = partials[rightIndex];
            }

            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }

            return result;
          }
          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */


          function copyArray(source, array) {
            var index = -1,
                length = source.length;
            array || (array = Array(length));

            while (++index < length) {
              array[index] = source[index];
            }

            return array;
          }
          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */


          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1,
                length = props.length;

            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

              if (newValue === undefined) {
                newValue = source[key];
              }

              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }

            return object;
          }
          /**
           * Copies own symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */


          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          /**
           * Copies own and inherited symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */


          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          /**
           * Creates a function like `_.groupBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} [initializer] The accumulator object initializer.
           * @returns {Function} Returns the new aggregator function.
           */


          function createAggregator(setter, initializer) {
            return function (collection, iteratee) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator,
                  accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee, 2), accumulator);
            };
          }
          /**
           * Creates a function like `_.assign`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */


          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                  length = sources.length,
                  customizer = length > 1 ? sources[length - 1] : undefined,
                  guard = length > 2 ? sources[2] : undefined;
              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }

              object = Object(object);

              while (++index < length) {
                var source = sources[index];

                if (source) {
                  assigner(object, source, index, customizer);
                }
              }

              return object;
            });
          }
          /**
           * Creates a `baseEach` or `baseEachRight` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */


          function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
              if (collection == null) {
                return collection;
              }

              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
              }

              var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);

              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }

              return collection;
            };
          }
          /**
           * Creates a base function for methods like `_.forIn` and `_.forOwn`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */


          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;

              while (length--) {
                var key = props[fromRight ? length : ++index];

                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }

              return object;
            };
          }
          /**
           * Creates a function that wraps `func` to invoke it with the optional `this`
           * binding of `thisArg`.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);

            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }

            return wrapper;
          }
          /**
           * Creates a function like `_.lowerFirst`.
           *
           * @private
           * @param {string} methodName The name of the `String` case method to use.
           * @returns {Function} Returns the new case function.
           */


          function createCaseFirst(methodName) {
            return function (string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          /**
           * Creates a function like `_.camelCase`.
           *
           * @private
           * @param {Function} callback The function to combine each word.
           * @returns {Function} Returns the new compounder function.
           */


          function createCompounder(callback) {
            return function (string) {
              return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
            };
          }
          /**
           * Creates a function that produces an instance of `Ctor` regardless of
           * whether it was invoked as part of a `new` expression or by `call` or `apply`.
           *
           * @private
           * @param {Function} Ctor The constructor to wrap.
           * @returns {Function} Returns the new wrapped function.
           */


          function createCtor(Ctor) {
            return function () {
              // Use a `switch` statement to work with class constructors. See
              // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
              // for more details.
              var args = arguments;

              switch (args.length) {
                case 0:
                  return new Ctor();

                case 1:
                  return new Ctor(args[0]);

                case 2:
                  return new Ctor(args[0], args[1]);

                case 3:
                  return new Ctor(args[0], args[1], args[2]);

                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);

                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }

              var thisBinding = baseCreate(Ctor.prototype),
                  result = Ctor.apply(thisBinding, args); // Mimic the constructor's `return` behavior.
              // See https://es5.github.io/#x13.2.2 for more details.

              return isObject(result) ? result : thisBinding;
            };
          }
          /**
           * Creates a function that wraps `func` to enable currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {number} arity The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);

            function wrapper() {
              var length = arguments.length,
                  args = Array(length),
                  index = length,
                  placeholder = getHolder(wrapper);

              while (index--) {
                args[index] = arguments[index];
              }

              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;

              if (length < arity) {
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
              }

              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }

            return wrapper;
          }
          /**
           * Creates a `_.find` or `_.findLast` function.
           *
           * @private
           * @param {Function} findIndexFunc The function to find the collection index.
           * @returns {Function} Returns the new find function.
           */


          function createFind(findIndexFunc) {
            return function (collection, predicate, fromIndex) {
              var iterable = Object(collection);

              if (!isArrayLike(collection)) {
                var iteratee = getIteratee(predicate, 3);
                collection = keys(collection);

                predicate = function predicate(key) {
                  return iteratee(iterable[key], key, iterable);
                };
              }

              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
          }
          /**
           * Creates a `_.flow` or `_.flowRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new flow function.
           */


          function createFlow(fromRight) {
            return flatRest(function (funcs) {
              var length = funcs.length,
                  index = length,
                  prereq = LodashWrapper.prototype.thru;

              if (fromRight) {
                funcs.reverse();
              }

              while (index--) {
                var func = funcs[index];

                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }

                if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                  var wrapper = new LodashWrapper([], true);
                }
              }

              index = wrapper ? index : length;

              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func),
                    data = funcName == 'wrapper' ? getData(func) : undefined;

                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }

              return function () {
                var args = arguments,
                    value = args[0];

                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }

                var index = 0,
                    result = length ? funcs[index].apply(this, args) : value;

                while (++index < length) {
                  result = funcs[index].call(this, result);
                }

                return result;
              };
            });
          }
          /**
           * Creates a function that wraps `func` to invoke it with optional `this`
           * binding of `thisArg`, partial application, and currying.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [partialsRight] The arguments to append to those provided
           *  to the new function.
           * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG,
                isBind = bitmask & WRAP_BIND_FLAG,
                isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                isFlip = bitmask & WRAP_FLIP_FLAG,
                Ctor = isBindKey ? undefined : createCtor(func);

            function wrapper() {
              var length = arguments.length,
                  args = Array(length),
                  index = length;

              while (index--) {
                args[index] = arguments[index];
              }

              if (isCurried) {
                var placeholder = getHolder(wrapper),
                    holdersCount = countHolders(args, placeholder);
              }

              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }

              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }

              length -= holdersCount;

              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
              }

              var thisBinding = isBind ? thisArg : this,
                  fn = isBindKey ? thisBinding[func] : func;
              length = args.length;

              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }

              if (isAry && ary < length) {
                args.length = ary;
              }

              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }

              return fn.apply(thisBinding, args);
            }

            return wrapper;
          }
          /**
           * Creates a function like `_.invertBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} toIteratee The function to resolve iteratees.
           * @returns {Function} Returns the new inverter function.
           */


          function createInverter(setter, toIteratee) {
            return function (object, iteratee) {
              return baseInverter(object, setter, toIteratee(iteratee), {});
            };
          }
          /**
           * Creates a function that performs a mathematical operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @param {number} [defaultValue] The value used for `undefined` arguments.
           * @returns {Function} Returns the new mathematical operation function.
           */


          function createMathOperation(operator, defaultValue) {
            return function (value, other) {
              var result;

              if (value === undefined && other === undefined) {
                return defaultValue;
              }

              if (value !== undefined) {
                result = value;
              }

              if (other !== undefined) {
                if (result === undefined) {
                  return other;
                }

                if (typeof value == 'string' || typeof other == 'string') {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }

                result = operator(value, other);
              }

              return result;
            };
          }
          /**
           * Creates a function like `_.over`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over iteratees.
           * @returns {Function} Returns the new over function.
           */


          function createOver(arrayFunc) {
            return flatRest(function (iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function (args) {
                var thisArg = this;
                return arrayFunc(iteratees, function (iteratee) {
                  return apply(iteratee, thisArg, args);
                });
              });
            });
          }
          /**
           * Creates the padding for `string` based on `length`. The `chars` string
           * is truncated if the number of characters exceeds `length`.
           *
           * @private
           * @param {number} length The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padding for `string`.
           */


          function createPadding(length, chars) {
            chars = chars === undefined ? ' ' : baseToString(chars);
            var charsLength = chars.length;

            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }

            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
          }
          /**
           * Creates a function that wraps `func` to invoke it with the `this` binding
           * of `thisArg` and `partials` prepended to the arguments it receives.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} partials The arguments to prepend to those provided to
           *  the new function.
           * @returns {Function} Returns the new wrapped function.
           */


          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);

            function wrapper() {
              var argsIndex = -1,
                  argsLength = arguments.length,
                  leftIndex = -1,
                  leftLength = partials.length,
                  args = Array(leftLength + argsLength),
                  fn = this && this !== root && this instanceof wrapper ? Ctor : func;

              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }

              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }

              return apply(fn, isBind ? thisArg : this, args);
            }

            return wrapper;
          }
          /**
           * Creates a `_.range` or `_.rangeRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new range function.
           */


          function createRange(fromRight) {
            return function (start, end, step) {
              if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                end = step = undefined;
              } // Ensure the sign of `-0` is preserved.


              start = toFinite(start);

              if (end === undefined) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }

              step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          /**
           * Creates a function that performs a relational operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @returns {Function} Returns the new relational operation function.
           */


          function createRelationalOperation(operator) {
            return function (value, other) {
              if (!(typeof value == 'string' && typeof other == 'string')) {
                value = toNumber(value);
                other = toNumber(other);
              }

              return operator(value, other);
            };
          }
          /**
           * Creates a function that wraps `func` to continue currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {Function} wrapFunc The function to create the `func` wrapper.
           * @param {*} placeholder The placeholder value.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG,
                newHolders = isCurry ? holders : undefined,
                newHoldersRight = isCurry ? undefined : holders,
                newPartials = isCurry ? partials : undefined,
                newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }

            var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
            var result = wrapFunc.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }

            result.placeholder = placeholder;
            return setWrapToString(result, func, bitmask);
          }
          /**
           * Creates a function like `_.round`.
           *
           * @private
           * @param {string} methodName The name of the `Math` method to use when rounding.
           * @returns {Function} Returns the new round function.
           */


          function createRound(methodName) {
            var func = Math[methodName];
            return function (number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);

              if (precision && nativeIsFinite(number)) {
                // Shift with exponential notation to avoid floating-point issues.
                // See [MDN](https://mdn.io/round#Examples) for more details.
                var pair = (toString(number) + 'e').split('e'),
                    value = func(pair[0] + 'e' + (+pair[1] + precision));
                pair = (toString(value) + 'e').split('e');
                return +(pair[0] + 'e' + (+pair[1] - precision));
              }

              return func(number);
            };
          }
          /**
           * Creates a set object of `values`.
           *
           * @private
           * @param {Array} values The values to add to the set.
           * @returns {Object} Returns the new set.
           */


          var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
            return new Set(values);
          };
          /**
           * Creates a `_.toPairs` or `_.toPairsIn` function.
           *
           * @private
           * @param {Function} keysFunc The function to get the keys of a given object.
           * @returns {Function} Returns the new pairs function.
           */

          function createToPairs(keysFunc) {
            return function (object) {
              var tag = getTag(object);

              if (tag == mapTag) {
                return mapToArray(object);
              }

              if (tag == setTag) {
                return setToPairs(object);
              }

              return baseToPairs(object, keysFunc(object));
            };
          }
          /**
           * Creates a function that either curries or invokes `func` with optional
           * `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags.
           *    1 - `_.bind`
           *    2 - `_.bindKey`
           *    4 - `_.curry` or `_.curryRight` of a bound function
           *    8 - `_.curry`
           *   16 - `_.curryRight`
           *   32 - `_.partial`
           *   64 - `_.partialRight`
           *  128 - `_.rearg`
           *  256 - `_.ary`
           *  512 - `_.flip`
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to be partially applied.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;

            if (!isBindKey && typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            var length = partials ? partials.length : 0;

            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined;
            }

            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;

            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials,
                  holdersRight = holders;
              partials = holders = undefined;
            }

            var data = isBindKey ? undefined : getData(func);
            var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

            if (data) {
              mergeData(newData, data);
            }

            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }

            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result = createPartial(func, bitmask, thisArg, partials);
            } else {
              result = createHybrid.apply(undefined, newData);
            }

            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result, newData), func, bitmask);
          }
          /**
           * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
           * of source objects to the destination object for all destination properties
           * that resolve to `undefined`.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to assign.
           * @param {Object} object The parent object of `objValue`.
           * @returns {*} Returns the value to assign.
           */


          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }

            return objValue;
          }
          /**
           * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
           * objects into destination objects that are passed thru.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to merge.
           * @param {Object} object The parent object of `objValue`.
           * @param {Object} source The parent object of `srcValue`.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           * @returns {*} Returns the value to assign.
           */


          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
              stack['delete'](srcValue);
            }

            return objValue;
          }
          /**
           * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
           * objects.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {string} key The key of the property to inspect.
           * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
           */


          function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value;
          }
          /**
           * A specialized version of `baseIsEqualDeep` for arrays with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Array} array The array to compare.
           * @param {Array} other The other array to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `array` and `other` objects.
           * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
           */


          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                arrLength = array.length,
                othLength = other.length;

            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            } // Check that cyclic values are equal.


            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);

            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }

            var index = -1,
                result = true,
                seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            stack.set(array, other);
            stack.set(other, array); // Ignore non-index properties.

            while (++index < arrLength) {
              var arrValue = array[index],
                  othValue = other[index];

              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }

              if (compared !== undefined) {
                if (compared) {
                  continue;
                }

                result = false;
                break;
              } // Recursively compare arrays (susceptible to call stack limits).


              if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
              }
            }

            stack['delete'](array);
            stack['delete'](other);
            return result;
          }
          /**
           * A specialized version of `baseIsEqualDeep` for comparing objects of
           * the same `toStringTag`.
           *
           * **Note:** This function only supports comparing values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {string} tag The `toStringTag` of the objects to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */


          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }

                object = object.buffer;
                other = other.buffer;

              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                  return false;
                }

                return true;

              case boolTag:
              case dateTag:
              case numberTag:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other);

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case regexpTag:
              case stringTag:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == other + '';

              case mapTag:
                var convert = mapToArray;

              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);

                if (object.size != other.size && !isPartial) {
                  return false;
                } // Assume cyclic values are equal.


                var stacked = stack.get(object);

                if (stacked) {
                  return stacked == other;
                }

                bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack['delete'](object);
                return result;

              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }

            }

            return false;
          }
          /**
           * A specialized version of `baseIsEqualDeep` for objects with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */


          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                objProps = getAllKeys(object),
                objLength = objProps.length,
                othProps = getAllKeys(other),
                othLength = othProps.length;

            if (objLength != othLength && !isPartial) {
              return false;
            }

            var index = objLength;

            while (index--) {
              var key = objProps[index];

              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            } // Check that cyclic values are equal.


            var objStacked = stack.get(object);
            var othStacked = stack.get(other);

            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }

            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;

            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key],
                  othValue = other[key];

              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              } // Recursively compare objects (susceptible to call stack limits).


              if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
              }

              skipCtor || (skipCtor = key == 'constructor');
            }

            if (result && !skipCtor) {
              var objCtor = object.constructor,
                  othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

              if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                result = false;
              }
            }

            stack['delete'](object);
            stack['delete'](other);
            return result;
          }
          /**
           * A specialized version of `baseRest` which flattens the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */


          function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + '');
          }
          /**
           * Creates an array of own enumerable property names and symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */


          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          /**
           * Creates an array of own and inherited enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */


          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          /**
           * Gets metadata for `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {*} Returns the metadata for `func`.
           */


          var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
          };
          /**
           * Gets the name of `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {string} Returns the function name.
           */

          function getFuncName(func) {
            var result = func.name + '',
                array = realNames[result],
                length = hasOwnProperty.call(realNames, result) ? array.length : 0;

            while (length--) {
              var data = array[length],
                  otherFunc = data.func;

              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }

            return result;
          }
          /**
           * Gets the argument placeholder value for `func`.
           *
           * @private
           * @param {Function} func The function to inspect.
           * @returns {*} Returns the placeholder value.
           */


          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
            return object.placeholder;
          }
          /**
           * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
           * this function returns the custom method, otherwise it returns `baseIteratee`.
           * If arguments are provided, the chosen function is invoked with them and
           * its result is returned.
           *
           * @private
           * @param {*} [value] The value to convert to an iteratee.
           * @param {number} [arity] The arity of the created iteratee.
           * @returns {Function} Returns the chosen function or its result.
           */


          function getIteratee() {
            var result = lodash.iteratee || iteratee;
            result = result === iteratee ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result;
          }
          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */


          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }
          /**
           * Gets the property names, values, and compare flags of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the match data of `object`.
           */


          function getMatchData(object) {
            var result = keys(object),
                length = result.length;

            while (length--) {
              var key = result[length],
                  value = object[key];
              result[length] = [key, value, isStrictComparable(value)];
            }

            return result;
          }
          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */


          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }
          /**
           * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the raw `toStringTag`.
           */


          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
                tag = value[symToStringTag];

            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}

            var result = nativeObjectToString.call(value);

            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }

            return result;
          }
          /**
           * Creates an array of the own enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */


          var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
            if (object == null) {
              return [];
            }

            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function (symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          /**
           * Creates an array of the own and inherited enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */

          var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
            var result = [];

            while (object) {
              arrayPush(result, getSymbols(object));
              object = getPrototype(object);
            }

            return result;
          };
          /**
           * Gets the `toStringTag` of `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */

          var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function getTag(value) {
              var result = baseGetTag(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : '';

              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return promiseTag;

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return weakMapTag;
                }
              }

              return result;
            };
          }
          /**
           * Gets the view, applying any `transforms` to the `start` and `end` positions.
           *
           * @private
           * @param {number} start The start of the view.
           * @param {number} end The end of the view.
           * @param {Array} transforms The transformations to apply to the view.
           * @returns {Object} Returns an object containing the `start` and `end`
           *  positions of the view.
           */


          function getView(start, end, transforms) {
            var index = -1,
                length = transforms.length;

            while (++index < length) {
              var data = transforms[index],
                  size = data.size;

              switch (data.type) {
                case 'drop':
                  start += size;
                  break;

                case 'dropRight':
                  end -= size;
                  break;

                case 'take':
                  end = nativeMin(end, start + size);
                  break;

                case 'takeRight':
                  start = nativeMax(start, end - size);
                  break;
              }
            }

            return {
              'start': start,
              'end': end
            };
          }
          /**
           * Extracts wrapper details from the `source` body comment.
           *
           * @private
           * @param {string} source The source to inspect.
           * @returns {Array} Returns the wrapper details.
           */


          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          /**
           * Checks if `path` exists on `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @param {Function} hasFunc The function to check properties.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           */


          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1,
                length = path.length,
                result = false;

            while (++index < length) {
              var key = toKey(path[index]);

              if (!(result = object != null && hasFunc(object, key))) {
                break;
              }

              object = object[key];
            }

            if (result || ++index != length) {
              return result;
            }

            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */


          function initCloneArray(array) {
            var length = array.length,
                result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }

            return result;
          }
          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */


          function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */


          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;

            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case dataViewTag:
                return cloneDataView(object, isDeep);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);

              case mapTag:
                return new Ctor();

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                return cloneRegExp(object);

              case setTag:
                return new Ctor();

              case symbolTag:
                return cloneSymbol(object);
            }
          }
          /**
           * Inserts wrapper `details` in a comment at the top of the `source` body.
           *
           * @private
           * @param {string} source The source to modify.
           * @returns {Array} details The details to insert.
           * @returns {string} Returns the modified source.
           */


          function insertWrapDetails(source, details) {
            var length = details.length;

            if (!length) {
              return source;
            }

            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
            details = details.join(length > 2 ? ', ' : ' ');
            return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
          }
          /**
           * Checks if `value` is a flattenable `arguments` object or array.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
           */


          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */


          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }
          /**
           * Checks if the given arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
           *  else `false`.
           */


          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }

            var type = typeof index;

            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
              return eq(object[index], value);
            }

            return false;
          }
          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */


          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }

            var type = typeof value;

            if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
              return true;
            }

            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }
          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */


          function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }
          /**
           * Checks if `func` has a lazy counterpart.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
           *  else `false`.
           */


          function isLaziable(func) {
            var funcName = getFuncName(func),
                other = lodash[funcName];

            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
              return false;
            }

            if (func === other) {
              return true;
            }

            var data = getData(other);
            return !!data && func === data[0];
          }
          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */


          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          /**
           * Checks if `func` is capable of being masked.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
           */


          var isMaskable = coreJsData ? isFunction : stubFalse;
          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */

          function isPrototype(value) {
            var Ctor = value && value.constructor,
                proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }
          /**
           * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` if suitable for strict
           *  equality comparisons, else `false`.
           */


          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          /**
           * A specialized version of `matchesProperty` for source values suitable
           * for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {string} key The key of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */


          function matchesStrictComparable(key, srcValue) {
            return function (object) {
              if (object == null) {
                return false;
              }

              return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
          }
          /**
           * A specialized version of `_.memoize` which clears the memoized function's
           * cache when it exceeds `MAX_MEMOIZE_SIZE`.
           *
           * @private
           * @param {Function} func The function to have its output memoized.
           * @returns {Function} Returns the new memoized function.
           */


          function memoizeCapped(func) {
            var result = memoize(func, function (key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }

              return key;
            });
            var cache = result.cache;
            return result;
          }
          /**
           * Merges the function metadata of `source` into `data`.
           *
           * Merging metadata reduces the number of wrappers used to invoke a function.
           * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
           * may be applied regardless of execution order. Methods like `_.ary` and
           * `_.rearg` modify function arguments, making the order in which they are
           * executed important, preventing the merging of metadata. However, we make
           * an exception for a safe combined case where curried functions have `_.ary`
           * and or `_.rearg` applied.
           *
           * @private
           * @param {Array} data The destination metadata.
           * @param {Array} source The source metadata.
           * @returns {Array} Returns `data`.
           */


          function mergeData(data, source) {
            var bitmask = data[1],
                srcBitmask = source[1],
                newBitmask = bitmask | srcBitmask,
                isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG; // Exit early if metadata can't be merged.

            if (!(isCommon || isCombo)) {
              return data;
            } // Use source `thisArg` if available.


            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2]; // Set when currying a bound function.

              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            } // Compose partial arguments.


            var value = source[3];

            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            } // Compose partial right arguments.


            value = source[5];

            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            } // Use source `argPos` if available.


            value = source[7];

            if (value) {
              data[7] = value;
            } // Use source `ary` if it's smaller.


            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            } // Use source `arity` if one is not provided.


            if (data[9] == null) {
              data[9] = source[9];
            } // Use source `func` and merge bitmasks.


            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */


          function nativeKeysIn(object) {
            var result = [];

            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * Converts `value` to a string using `Object.prototype.toString`.
           *
           * @private
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           */


          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          /**
           * A specialized version of `baseRest` which transforms the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @param {Function} transform The rest array transform.
           * @returns {Function} Returns the new function.
           */


          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function () {
              var args = arguments,
                  index = -1,
                  length = nativeMax(args.length - start, 0),
                  array = Array(length);

              while (++index < length) {
                array[index] = args[start + index];
              }

              index = -1;
              var otherArgs = Array(start + 1);

              while (++index < start) {
                otherArgs[index] = args[index];
              }

              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }
          /**
           * Gets the parent value at `path` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} path The path to get the parent value of.
           * @returns {*} Returns the parent value.
           */


          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          /**
           * Reorder `array` according to the specified indexes where the element at
           * the first index is assigned as the first element, the element at
           * the second index is assigned as the second element, and so on.
           *
           * @private
           * @param {Array} array The array to reorder.
           * @param {Array} indexes The arranged array indexes.
           * @returns {Array} Returns `array`.
           */


          function reorder(array, indexes) {
            var arrLength = array.length,
                length = nativeMin(indexes.length, arrLength),
                oldArray = copyArray(array);

            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }

            return array;
          }
          /**
           * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */


          function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') {
              return;
            }

            if (key == '__proto__') {
              return;
            }

            return object[key];
          }
          /**
           * Sets metadata for `func`.
           *
           * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
           * period of time, it will trip its breaker and transition to an identity
           * function to avoid garbage collection pauses in V8. See
           * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
           * for more details.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */


          var setData = shortOut(baseSetData);
          /**
           * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @returns {number|Object} Returns the timer id or timeout object.
           */

          var setTimeout = ctxSetTimeout || function (func, wait) {
            return root.setTimeout(func, wait);
          };
          /**
           * Sets the `toString` method of `func` to return `string`.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */


          var setToString = shortOut(baseSetToString);
          /**
           * Sets the `toString` method of `wrapper` to mimic the source of `reference`
           * with wrapper details in a comment at the top of the source body.
           *
           * @private
           * @param {Function} wrapper The function to modify.
           * @param {Function} reference The reference function.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Function} Returns `wrapper`.
           */

          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + '';
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          /**
           * Creates a function that'll short out and invoke `identity` instead
           * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
           * milliseconds.
           *
           * @private
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new shortable function.
           */


          function shortOut(func) {
            var count = 0,
                lastCalled = 0;
            return function () {
              var stamp = nativeNow(),
                  remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;

              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }

              return func.apply(undefined, arguments);
            };
          }
          /**
           * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @param {number} [size=array.length] The size of `array`.
           * @returns {Array} Returns `array`.
           */


          function shuffleSelf(array, size) {
            var index = -1,
                length = array.length,
                lastIndex = length - 1;
            size = size === undefined ? length : size;

            while (++index < size) {
              var rand = baseRandom(index, lastIndex),
                  value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }

            array.length = size;
            return array;
          }
          /**
           * Converts `string` to a property path array.
           *
           * @private
           * @param {string} string The string to convert.
           * @returns {Array} Returns the property path array.
           */


          var stringToPath = memoizeCapped(function (string) {
            var result = [];

            if (string.charCodeAt(0) === 46
            /* . */
            ) {
                result.push('');
              }

            string.replace(rePropName, function (match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
            });
            return result;
          });
          /**
           * Converts `value` to a string key if it's not a string or symbol.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {string|symbol} Returns the key.
           */

          function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) {
              return value;
            }

            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to convert.
           * @returns {string} Returns the source code.
           */


          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}

              try {
                return func + '';
              } catch (e) {}
            }

            return '';
          }
          /**
           * Updates wrapper `details` based on `bitmask` flags.
           *
           * @private
           * @returns {Array} details The details to modify.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Array} Returns `details`.
           */


          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function (pair) {
              var value = '_.' + pair[0];

              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          /**
           * Creates a clone of `wrapper`.
           *
           * @private
           * @param {Object} wrapper The wrapper to clone.
           * @returns {Object} Returns the cloned wrapper.
           */


          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }

            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ = copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result;
          }
          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements split into groups the length of `size`.
           * If `array` can't be split evenly, the final chunk will be the remaining
           * elements.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to process.
           * @param {number} [size=1] The length of each chunk
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the new array of chunks.
           * @example
           *
           * _.chunk(['a', 'b', 'c', 'd'], 2);
           * // => [['a', 'b'], ['c', 'd']]
           *
           * _.chunk(['a', 'b', 'c', 'd'], 3);
           * // => [['a', 'b', 'c'], ['d']]
           */


          function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
              size = 1;
            } else {
              size = nativeMax(toInteger(size), 0);
            }

            var length = array == null ? 0 : array.length;

            if (!length || size < 1) {
              return [];
            }

            var index = 0,
                resIndex = 0,
                result = Array(nativeCeil(length / size));

            while (index < length) {
              result[resIndex++] = baseSlice(array, index, index += size);
            }

            return result;
          }
          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are falsey.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to compact.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */


          function compact(array) {
            var index = -1,
                length = array == null ? 0 : array.length,
                resIndex = 0,
                result = [];

            while (++index < length) {
              var value = array[index];

              if (value) {
                result[resIndex++] = value;
              }
            }

            return result;
          }
          /**
           * Creates a new array concatenating `array` with any additional arrays
           * and/or values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to concatenate.
           * @param {...*} [values] The values to concatenate.
           * @returns {Array} Returns the new concatenated array.
           * @example
           *
           * var array = [1];
           * var other = _.concat(array, 2, [3], [[4]]);
           *
           * console.log(other);
           * // => [1, 2, 3, [4]]
           *
           * console.log(array);
           * // => [1]
           */


          function concat() {
            var length = arguments.length;

            if (!length) {
              return [];
            }

            var args = Array(length - 1),
                array = arguments[0],
                index = length;

            while (index--) {
              args[index - 1] = arguments[index];
            }

            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          /**
           * Creates an array of `array` values not included in the other given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * **Note:** Unlike `_.pullAll`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.without, _.xor
           * @example
           *
           * _.difference([2, 1], [2, 3]);
           * // => [1]
           */


          var difference = baseRest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
          });
          /**
           * This method is like `_.difference` except that it accepts `iteratee` which
           * is invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */

          var differenceBy = baseRest(function (array, values) {
            var iteratee = last(values);

            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }

            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
          });
          /**
           * This method is like `_.difference` except that it accepts `comparator`
           * which is invoked to compare elements of `array` to `values`. The order and
           * references of result values are determined by the first array. The comparator
           * is invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           *
           * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }]
           */

          var differenceWith = baseRest(function (array, values) {
            var comparator = last(values);

            if (isArrayLikeObject(comparator)) {
              comparator = undefined;
            }

            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
          });
          /**
           * Creates a slice of `array` with `n` elements dropped from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.drop([1, 2, 3]);
           * // => [2, 3]
           *
           * _.drop([1, 2, 3], 2);
           * // => [3]
           *
           * _.drop([1, 2, 3], 5);
           * // => []
           *
           * _.drop([1, 2, 3], 0);
           * // => [1, 2, 3]
           */

          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          /**
           * Creates a slice of `array` with `n` elements dropped from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRight([1, 2, 3]);
           * // => [1, 2]
           *
           * _.dropRight([1, 2, 3], 2);
           * // => [1]
           *
           * _.dropRight([1, 2, 3], 5);
           * // => []
           *
           * _.dropRight([1, 2, 3], 0);
           * // => [1, 2, 3]
           */


          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          /**
           * Creates a slice of `array` excluding elements dropped from the end.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.dropRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropRightWhile(users, ['active', false]);
           * // => objects for ['barney']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropRightWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */


          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          /**
           * Creates a slice of `array` excluding elements dropped from the beginning.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.dropWhile(users, function(o) { return !o.active; });
           * // => objects for ['pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropWhile(users, ['active', false]);
           * // => objects for ['pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */


          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          /**
           * Fills elements of `array` with `value` from `start` up to, but not
           * including, `end`.
           *
           * **Note:** This method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Array
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.fill(array, 'a');
           * console.log(array);
           * // => ['a', 'a', 'a']
           *
           * _.fill(Array(3), 2);
           * // => [2, 2, 2]
           *
           * _.fill([4, 6, 8, 10], '*', 1, 3);
           * // => [4, '*', '*', 10]
           */


          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }

            return baseFill(array, value, start, end);
          }
          /**
           * This method is like `_.find` except that it returns the index of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.findIndex(users, function(o) { return o.user == 'barney'; });
           * // => 0
           *
           * // The `_.matches` iteratee shorthand.
           * _.findIndex(users, { 'user': 'fred', 'active': false });
           * // => 1
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findIndex(users, ['active', false]);
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.findIndex(users, 'active');
           * // => 2
           */


          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = fromIndex == null ? 0 : toInteger(fromIndex);

            if (index < 0) {
              index = nativeMax(length + index, 0);
            }

            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
           * // => 2
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastIndex(users, { 'user': 'barney', 'active': true });
           * // => 0
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastIndex(users, ['active', false]);
           * // => 2
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastIndex(users, 'active');
           * // => 0
           */


          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = length - 1;

            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }

            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          /**
           * Flattens `array` a single level deep.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flatten([1, [2, [3, [4]], 5]]);
           * // => [1, 2, [3, [4]], 5]
           */


          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          /**
           * Recursively flattens `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flattenDeep([1, [2, [3, [4]], 5]]);
           * // => [1, 2, 3, 4, 5]
           */


          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          /**
           * Recursively flatten `array` up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * var array = [1, [2, [3, [4]], 5]];
           *
           * _.flattenDepth(array, 1);
           * // => [1, 2, [3, [4]], 5]
           *
           * _.flattenDepth(array, 2);
           * // => [1, 2, 3, [4], 5]
           */


          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          /**
           * The inverse of `_.toPairs`; this method returns an object composed
           * from key-value `pairs`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} pairs The key-value pairs.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.fromPairs([['a', 1], ['b', 2]]);
           * // => { 'a': 1, 'b': 2 }
           */


          function fromPairs(pairs) {
            var index = -1,
                length = pairs == null ? 0 : pairs.length,
                result = {};

            while (++index < length) {
              var pair = pairs[index];
              result[pair[0]] = pair[1];
            }

            return result;
          }
          /**
           * Gets the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias first
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the first element of `array`.
           * @example
           *
           * _.head([1, 2, 3]);
           * // => 1
           *
           * _.head([]);
           * // => undefined
           */


          function head(array) {
            return array && array.length ? array[0] : undefined;
          }
          /**
           * Gets the index at which the first occurrence of `value` is found in `array`
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it's used as the
           * offset from the end of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.indexOf([1, 2, 1, 2], 2);
           * // => 1
           *
           * // Search from the `fromIndex`.
           * _.indexOf([1, 2, 1, 2], 2, 2);
           * // => 3
           */


          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = fromIndex == null ? 0 : toInteger(fromIndex);

            if (index < 0) {
              index = nativeMax(length + index, 0);
            }

            return baseIndexOf(array, value, index);
          }
          /**
           * Gets all but the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           */


          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          /**
           * Creates an array of unique values that are included in all given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersection([2, 1], [2, 3]);
           * // => [2]
           */


          var intersection = baseRest(function (arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          /**
           * This method is like `_.intersection` except that it accepts `iteratee`
           * which is invoked for each element of each `arrays` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [2.1]
           *
           * // The `_.property` iteratee shorthand.
           * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }]
           */

          var intersectionBy = baseRest(function (arrays) {
            var iteratee = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);

            if (iteratee === last(mapped)) {
              iteratee = undefined;
            } else {
              mapped.pop();
            }

            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
          });
          /**
           * This method is like `_.intersection` except that it accepts `comparator`
           * which is invoked to compare elements of `arrays`. The order and references
           * of result values are determined by the first array. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.intersectionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }]
           */

          var intersectionWith = baseRest(function (arrays) {
            var comparator = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == 'function' ? comparator : undefined;

            if (comparator) {
              mapped.pop();
            }

            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
          });
          /**
           * Converts all elements in `array` into a string separated by `separator`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to convert.
           * @param {string} [separator=','] The element separator.
           * @returns {string} Returns the joined string.
           * @example
           *
           * _.join(['a', 'b', 'c'], '~');
           * // => 'a~b~c'
           */

          function join(array, separator) {
            return array == null ? '' : nativeJoin.call(array, separator);
          }
          /**
           * Gets the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the last element of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           */


          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined;
          }
          /**
           * This method is like `_.indexOf` except that it iterates over elements of
           * `array` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 1, 2], 2);
           * // => 3
           *
           * // Search from the `fromIndex`.
           * _.lastIndexOf([1, 2, 1, 2], 2, 2);
           * // => 1
           */


          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = length;

            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }

            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          /**
           * Gets the element at index `n` of `array`. If `n` is negative, the nth
           * element from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.11.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=0] The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           *
           * _.nth(array, 1);
           * // => 'b'
           *
           * _.nth(array, -2);
           * // => 'c';
           */


          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
          }
          /**
           * Removes all given values from `array` using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
           * to remove elements from an array by predicate.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...*} [values] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pull(array, 'a', 'c');
           * console.log(array);
           * // => ['b', 'b']
           */


          var pull = baseRest(pullAll);
          /**
           * This method is like `_.pull` except that it accepts an array of values to remove.
           *
           * **Note:** Unlike `_.difference`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pullAll(array, ['a', 'c']);
           * console.log(array);
           * // => ['b', 'b']
           */

          function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
          }
          /**
           * This method is like `_.pullAll` except that it accepts `iteratee` which is
           * invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The iteratee is invoked with one argument: (value).
           *
           * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
           *
           * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
           * console.log(array);
           * // => [{ 'x': 2 }]
           */


          function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
          }
          /**
           * This method is like `_.pullAll` except that it accepts `comparator` which
           * is invoked to compare elements of `array` to `values`. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
           *
           * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
           * console.log(array);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
           */


          function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
          }
          /**
           * Removes elements from `array` corresponding to `indexes` and returns an
           * array of removed elements.
           *
           * **Note:** Unlike `_.at`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...(number|number[])} [indexes] The indexes of elements to remove.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           * var pulled = _.pullAt(array, [1, 3]);
           *
           * console.log(array);
           * // => ['a', 'c']
           *
           * console.log(pulled);
           * // => ['b', 'd']
           */


          var pullAt = flatRest(function (array, indexes) {
            var length = array == null ? 0 : array.length,
                result = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result;
          });
          /**
           * Removes all elements from `array` that `predicate` returns truthy for
           * and returns an array of the removed elements. The predicate is invoked
           * with three arguments: (value, index, array).
           *
           * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
           * to pull elements from an array by value.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4];
           * var evens = _.remove(array, function(n) {
           *   return n % 2 == 0;
           * });
           *
           * console.log(array);
           * // => [1, 3]
           *
           * console.log(evens);
           * // => [2, 4]
           */

          function remove(array, predicate) {
            var result = [];

            if (!(array && array.length)) {
              return result;
            }

            var index = -1,
                indexes = [],
                length = array.length;
            predicate = getIteratee(predicate, 3);

            while (++index < length) {
              var value = array[index];

              if (predicate(value, index, array)) {
                result.push(value);
                indexes.push(index);
              }
            }

            basePullAt(array, indexes);
            return result;
          }
          /**
           * Reverses `array` so that the first element becomes the last, the second
           * element becomes the second to last, and so on.
           *
           * **Note:** This method mutates `array` and is based on
           * [`Array#reverse`](https://mdn.io/Array/reverse).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.reverse(array);
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */


          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          /**
           * Creates a slice of `array` from `start` up to, but not including, `end`.
           *
           * **Note:** This method is used instead of
           * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
           * returned.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */


          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined ? length : toInteger(end);
            }

            return baseSlice(array, start, end);
          }
          /**
           * Uses a binary search to determine the lowest index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([30, 50], 40);
           * // => 1
           */


          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          /**
           * This method is like `_.sortedIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
           * // => 0
           */


          function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
          }
          /**
           * This method is like `_.indexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
           * // => 1
           */


          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;

            if (length) {
              var index = baseSortedIndex(array, value);

              if (index < length && eq(array[index], value)) {
                return index;
              }
            }

            return -1;
          }
          /**
           * This method is like `_.sortedIndex` except that it returns the highest
           * index at which `value` should be inserted into `array` in order to
           * maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
           * // => 4
           */


          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          /**
           * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 1
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
           * // => 1
           */


          function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
          }
          /**
           * This method is like `_.lastIndexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
           * // => 3
           */


          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;

            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;

              if (eq(array[index], value)) {
                return index;
              }
            }

            return -1;
          }
          /**
           * This method is like `_.uniq` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniq([1, 1, 2]);
           * // => [1, 2]
           */


          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          /**
           * This method is like `_.uniqBy` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
           * // => [1.1, 2.3]
           */


          function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
          }
          /**
           * Gets all but the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.tail([1, 2, 3]);
           * // => [2, 3]
           */


          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          /**
           * Creates a slice of `array` with `n` elements taken from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.take([1, 2, 3]);
           * // => [1]
           *
           * _.take([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.take([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.take([1, 2, 3], 0);
           * // => []
           */


          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          /**
           * Creates a slice of `array` with `n` elements taken from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRight([1, 2, 3]);
           * // => [3]
           *
           * _.takeRight([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.takeRight([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.takeRight([1, 2, 3], 0);
           * // => []
           */


          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          /**
           * Creates a slice of `array` with elements taken from the end. Elements are
           * taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.takeRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeRightWhile(users, ['active', false]);
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeRightWhile(users, 'active');
           * // => []
           */


          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          /**
           * Creates a slice of `array` with elements taken from the beginning. Elements
           * are taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.takeWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeWhile(users, ['active', false]);
           * // => objects for ['barney', 'fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeWhile(users, 'active');
           * // => []
           */


          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          /**
           * Creates an array of unique values, in order, from all given arrays using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.union([2], [1, 2]);
           * // => [2, 1]
           */


          var union = baseRest(function (arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          /**
           * This method is like `_.union` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which uniqueness is computed. Result values are chosen from the first
           * array in which the value occurs. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.unionBy([2.1], [1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */

          var unionBy = baseRest(function (arrays) {
            var iteratee = last(arrays);

            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }

            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
          });
          /**
           * This method is like `_.union` except that it accepts `comparator` which
           * is invoked to compare elements of `arrays`. Result values are chosen from
           * the first array in which the value occurs. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.unionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */

          var unionWith = baseRest(function (arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
          });
          /**
           * Creates a duplicate-free version of an array, using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons, in which only the first occurrence of each element
           * is kept. The order of result values is determined by the order they occur
           * in the array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniq([2, 1, 2]);
           * // => [2, 1]
           */

          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          /**
           * This method is like `_.uniq` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * uniqueness is computed. The order of result values is determined by the
           * order they occur in the array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */


          function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
          }
          /**
           * This method is like `_.uniq` except that it accepts `comparator` which
           * is invoked to compare elements of `array`. The order of result values is
           * determined by the order they occur in the array.The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.uniqWith(objects, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
           */


          function uniqWith(array, comparator) {
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return array && array.length ? baseUniq(array, undefined, comparator) : [];
          }
          /**
           * This method is like `_.zip` except that it accepts an array of grouped
           * elements and creates an array regrouping the elements to their pre-zip
           * configuration.
           *
           * @static
           * @memberOf _
           * @since 1.2.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           *
           * _.unzip(zipped);
           * // => [['a', 'b'], [1, 2], [true, false]]
           */


          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }

            var length = 0;
            array = arrayFilter(array, function (group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function (index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          /**
           * This method is like `_.unzip` except that it accepts `iteratee` to specify
           * how regrouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  regrouped values.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
           * // => [[1, 10, 100], [2, 20, 200]]
           *
           * _.unzipWith(zipped, _.add);
           * // => [3, 30, 300]
           */


          function unzipWith(array, iteratee) {
            if (!(array && array.length)) {
              return [];
            }

            var result = unzip(array);

            if (iteratee == null) {
              return result;
            }

            return arrayMap(result, function (group) {
              return apply(iteratee, undefined, group);
            });
          }
          /**
           * Creates an array excluding all given values using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.pull`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...*} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.xor
           * @example
           *
           * _.without([2, 1, 2, 3], 1, 2);
           * // => [3]
           */


          var without = baseRest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
          });
          /**
           * Creates an array of unique values that is the
           * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
           * of the given arrays. The order of result values is determined by the order
           * they occur in the arrays.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.without
           * @example
           *
           * _.xor([2, 1], [2, 3]);
           * // => [1, 3]
           */

          var xor = baseRest(function (arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          /**
           * This method is like `_.xor` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which by which they're compared. The order of result values is determined
           * by the order they occur in the arrays. The iteratee is invoked with one
           * argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2, 3.4]
           *
           * // The `_.property` iteratee shorthand.
           * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */

          var xorBy = baseRest(function (arrays) {
            var iteratee = last(arrays);

            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }

            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
          });
          /**
           * This method is like `_.xor` except that it accepts `comparator` which is
           * invoked to compare elements of `arrays`. The order of result values is
           * determined by the order they occur in the arrays. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.xorWith(objects, others, _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */

          var xorWith = baseRest(function (arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
          });
          /**
           * Creates an array of grouped elements, the first of which contains the
           * first elements of the given arrays, the second of which contains the
           * second elements of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           */

          var zip = baseRest(unzip);
          /**
           * This method is like `_.fromPairs` except that it accepts two arrays,
           * one of property identifiers and one of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 0.4.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObject(['a', 'b'], [1, 2]);
           * // => { 'a': 1, 'b': 2 }
           */

          function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
          }
          /**
           * This method is like `_.zipObject` except that it supports property paths.
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
           * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
           */


          function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
          }
          /**
           * This method is like `_.zip` except that it accepts `iteratee` to specify
           * how grouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  grouped values.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
           *   return a + b + c;
           * });
           * // => [111, 222]
           */


          var zipWith = baseRest(function (arrays) {
            var length = arrays.length,
                iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee);
          });
          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` wrapper instance that wraps `value` with explicit method
           * chain sequences enabled. The result of such sequences must be unwrapped
           * with `_#value`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Seq
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36 },
           *   { 'user': 'fred',    'age': 40 },
           *   { 'user': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _
           *   .chain(users)
           *   .sortBy('age')
           *   .map(function(o) {
           *     return o.user + ' is ' + o.age;
           *   })
           *   .head()
           *   .value();
           * // => 'pebbles is 1'
           */

          function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
          }
          /**
           * This method invokes `interceptor` and returns `value`. The interceptor
           * is invoked with one argument; (value). The purpose of this method is to
           * "tap into" a method chain sequence in order to modify intermediate results.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3])
           *  .tap(function(array) {
           *    // Mutate input array.
           *    array.pop();
           *  })
           *  .reverse()
           *  .value();
           * // => [2, 1]
           */


          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          /**
           * This method is like `_.tap` except that it returns the result of `interceptor`.
           * The purpose of this method is to "pass thru" values replacing intermediate
           * results in a method chain sequence.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns the result of `interceptor`.
           * @example
           *
           * _('  abc  ')
           *  .chain()
           *  .trim()
           *  .thru(function(value) {
           *    return [value];
           *  })
           *  .value();
           * // => ['abc']
           */


          function thru(value, interceptor) {
            return interceptor(value);
          }
          /**
           * This method is the wrapper version of `_.at`.
           *
           * @name at
           * @memberOf _
           * @since 1.0.0
           * @category Seq
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _(object).at(['a[0].b.c', 'a[1]']).value();
           * // => [3, 4]
           */


          var wrapperAt = flatRest(function (paths) {
            var length = paths.length,
                start = length ? paths[0] : 0,
                value = this.__wrapped__,
                interceptor = function interceptor(object) {
              return baseAt(object, paths);
            };

            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }

            value = value.slice(start, +start + (length ? 1 : 0));

            value.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });

            return new LodashWrapper(value, this.__chain__).thru(function (array) {
              if (length && !array.length) {
                array.push(undefined);
              }

              return array;
            });
          });
          /**
           * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
           *
           * @name chain
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // A sequence without explicit chaining.
           * _(users).head();
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // A sequence with explicit chaining.
           * _(users)
           *   .chain()
           *   .head()
           *   .pick('user')
           *   .value();
           * // => { 'user': 'barney' }
           */

          function wrapperChain() {
            return chain(this);
          }
          /**
           * Executes the chain sequence and returns the wrapped result.
           *
           * @name commit
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapped = _(array).push(3);
           *
           * console.log(array);
           * // => [1, 2]
           *
           * wrapped = wrapped.commit();
           * console.log(array);
           * // => [1, 2, 3]
           *
           * wrapped.last();
           * // => 3
           *
           * console.log(array);
           * // => [1, 2, 3]
           */


          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          /**
           * Gets the next value on a wrapped object following the
           * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
           *
           * @name next
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the next iterator value.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 1 }
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 2 }
           *
           * wrapped.next();
           * // => { 'done': true, 'value': undefined }
           */


          function wrapperNext() {
            if (this.__values__ === undefined) {
              this.__values__ = toArray(this.value());
            }

            var done = this.__index__ >= this.__values__.length,
                value = done ? undefined : this.__values__[this.__index__++];
            return {
              'done': done,
              'value': value
            };
          }
          /**
           * Enables the wrapper to be iterable.
           *
           * @name Symbol.iterator
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the wrapper object.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped[Symbol.iterator]() === wrapped;
           * // => true
           *
           * Array.from(wrapped);
           * // => [1, 2]
           */


          function wrapperToIterator() {
            return this;
          }
          /**
           * Creates a clone of the chain sequence planting `value` as the wrapped value.
           *
           * @name plant
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @param {*} value The value to plant.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2]).map(square);
           * var other = wrapped.plant([3, 4]);
           *
           * other.value();
           * // => [9, 16]
           *
           * wrapped.value();
           * // => [1, 4]
           */


          function wrapperPlant(value) {
            var result,
                parent = this;

            while (parent instanceof baseLodash) {
              var clone = wrapperClone(parent);
              clone.__index__ = 0;
              clone.__values__ = undefined;

              if (result) {
                previous.__wrapped__ = clone;
              } else {
                result = clone;
              }

              var previous = clone;
              parent = parent.__wrapped__;
            }

            previous.__wrapped__ = value;
            return result;
          }
          /**
           * This method is the wrapper version of `_.reverse`.
           *
           * **Note:** This method mutates the wrapped array.
           *
           * @name reverse
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _(array).reverse().value()
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */


          function wrapperReverse() {
            var value = this.__wrapped__;

            if (value instanceof LazyWrapper) {
              var wrapped = value;

              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }

              wrapped = wrapped.reverse();

              wrapped.__actions__.push({
                'func': thru,
                'args': [reverse],
                'thisArg': undefined
              });

              return new LodashWrapper(wrapped, this.__chain__);
            }

            return this.thru(reverse);
          }
          /**
           * Executes the chain sequence to resolve the unwrapped value.
           *
           * @name value
           * @memberOf _
           * @since 0.1.0
           * @alias toJSON, valueOf
           * @category Seq
           * @returns {*} Returns the resolved unwrapped value.
           * @example
           *
           * _([1, 2, 3]).value();
           * // => [1, 2, 3]
           */


          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the number of times the key was returned by `iteratee`. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': 1, '6': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */


          var countBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              ++result[key];
            } else {
              baseAssignValue(result, key, 1);
            }
          });
          /**
           * Checks if `predicate` returns truthy for **all** elements of `collection`.
           * Iteration is stopped once `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * **Note:** This method returns `true` for
           * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
           * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
           * elements of empty collections.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes'], Boolean);
           * // => false
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.every(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.every(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.every(users, 'active');
           * // => false
           */

          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;

            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined;
            }

            return func(collection, getIteratee(predicate, 3));
          }
          /**
           * Iterates over elements of `collection`, returning an array of all elements
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * **Note:** Unlike `_.remove`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.reject
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.filter(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, { 'age': 36, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.filter(users, 'active');
           * // => objects for ['barney']
           *
           * // Combining several predicates using `_.overEvery` or `_.overSome`.
           * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
           * // => objects for ['fred', 'barney']
           */


          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          /**
           * Iterates over elements of `collection`, returning the first element
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': true },
           *   { 'user': 'fred',    'age': 40, 'active': false },
           *   { 'user': 'pebbles', 'age': 1,  'active': true }
           * ];
           *
           * _.find(users, function(o) { return o.age < 40; });
           * // => object for 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.find(users, { 'age': 1, 'active': true });
           * // => object for 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.find(users, ['active', false]);
           * // => object for 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.find(users, 'active');
           * // => object for 'barney'
           */


          var find = createFind(findIndex);
          /**
           * This method is like `_.find` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=collection.length-1] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(n) {
           *   return n % 2 == 1;
           * });
           * // => 3
           */

          var findLast = createFind(findLastIndex);
          /**
           * Creates a flattened array of values by running each element in `collection`
           * thru `iteratee` and flattening the mapped results. The iteratee is invoked
           * with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [n, n];
           * }
           *
           * _.flatMap([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */

          function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
          }
          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDeep([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */


          function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
          }
          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDepth([1, 2], duplicate, 2);
           * // => [[1, 1], [2, 2]]
           */


          function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee), depth);
          }
          /**
           * Iterates over elements of `collection` and invokes `iteratee` for each element.
           * The iteratee is invoked with three arguments: (value, index|key, collection).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * **Note:** As with other "Collections" methods, objects with a "length"
           * property are iterated like arrays. To avoid this behavior use `_.forIn`
           * or `_.forOwn` for object iteration.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias each
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEachRight
           * @example
           *
           * _.forEach([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `1` then `2`.
           *
           * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */


          function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee, 3));
          }
          /**
           * This method is like `_.forEach` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @alias eachRight
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEach
           * @example
           *
           * _.forEachRight([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `2` then `1`.
           */


          function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee, 3));
          }
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The order of grouped values
           * is determined by the order they occur in `collection`. The corresponding
           * value of each key is an array of elements responsible for generating the
           * key. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': [4.2], '6': [6.1, 6.3] }
           *
           * // The `_.property` iteratee shorthand.
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */


          var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              result[key].push(value);
            } else {
              baseAssignValue(result, key, [value]);
            }
          });
          /**
           * Checks if `value` is in `collection`. If `collection` is a string, it's
           * checked for a substring of `value`, otherwise
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * is used for equality comparisons. If `fromIndex` is negative, it's used as
           * the offset from the end of `collection`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {boolean} Returns `true` if `value` is found, else `false`.
           * @example
           *
           * _.includes([1, 2, 3], 1);
           * // => true
           *
           * _.includes([1, 2, 3], 1, 2);
           * // => false
           *
           * _.includes({ 'a': 1, 'b': 2 }, 1);
           * // => true
           *
           * _.includes('abcd', 'bc');
           * // => true
           */

          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;

            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }

            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          /**
           * Invokes the method at `path` of each element in `collection`, returning
           * an array of the results of each invoked method. Any additional arguments
           * are provided to each invoked method. If `path` is a function, it's invoked
           * for, and `this` bound to, each element in `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array|Function|string} path The path of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [args] The arguments to invoke each method with.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invokeMap([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */


          var invokeMap = baseRest(function (collection, path, args) {
            var index = -1,
                isFunc = typeof path == 'function',
                result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value) {
              result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result;
          });
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the last element responsible for generating the key. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var array = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.keyBy(array, function(o) {
           *   return String.fromCharCode(o.code);
           * });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.keyBy(array, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           */

          var keyBy = createAggregator(function (result, value, key) {
            baseAssignValue(result, key, value);
          });
          /**
           * Creates an array of values by running each element in `collection` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
           *
           * The guarded methods are:
           * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
           * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
           * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
           * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * _.map([4, 8], square);
           * // => [16, 64]
           *
           * _.map({ 'a': 4, 'b': 8 }, square);
           * // => [16, 64] (iteration order is not guaranteed)
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, 'user');
           * // => ['barney', 'fred']
           */

          function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
          }
          /**
           * This method is like `_.sortBy` except that it allows specifying the sort
           * orders of the iteratees to sort by. If `orders` is unspecified, all values
           * are sorted in ascending order. Otherwise, specify an order of "desc" for
           * descending or "asc" for ascending sort order of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @param {string[]} [orders] The sort orders of `iteratees`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 34 },
           *   { 'user': 'fred',   'age': 40 },
           *   { 'user': 'barney', 'age': 36 }
           * ];
           *
           * // Sort by `user` in ascending order and by `age` in descending order.
           * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
           */


          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }

            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }

            orders = guard ? undefined : orders;

            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }

            return baseOrderBy(collection, iteratees, orders);
          }
          /**
           * Creates an array of elements split into two groups, the first of which
           * contains elements `predicate` returns truthy for, the second of which
           * contains elements `predicate` returns falsey for. The predicate is
           * invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of grouped elements.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': false },
           *   { 'user': 'fred',    'age': 40, 'active': true },
           *   { 'user': 'pebbles', 'age': 1,  'active': false }
           * ];
           *
           * _.partition(users, function(o) { return o.active; });
           * // => objects for [['fred'], ['barney', 'pebbles']]
           *
           * // The `_.matches` iteratee shorthand.
           * _.partition(users, { 'age': 1, 'active': false });
           * // => objects for [['pebbles'], ['barney', 'fred']]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.partition(users, ['active', false]);
           * // => objects for [['barney', 'pebbles'], ['fred']]
           *
           * // The `_.property` iteratee shorthand.
           * _.partition(users, 'active');
           * // => objects for [['fred'], ['barney', 'pebbles']]
           */


          var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
          }, function () {
            return [[], []];
          });
          /**
           * Reduces `collection` to a value which is the accumulated result of running
           * each element in `collection` thru `iteratee`, where each successive
           * invocation is supplied the return value of the previous. If `accumulator`
           * is not given, the first element of `collection` is used as the initial
           * value. The iteratee is invoked with four arguments:
           * (accumulator, value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.reduce`, `_.reduceRight`, and `_.transform`.
           *
           * The guarded methods are:
           * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
           * and `sortBy`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduceRight
           * @example
           *
           * _.reduce([1, 2], function(sum, n) {
           *   return sum + n;
           * }, 0);
           * // => 3
           *
           * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           *   return result;
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
           */

          function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce,
                initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
          }
          /**
           * This method is like `_.reduce` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduce
           * @example
           *
           * var array = [[0, 1], [2, 3], [4, 5]];
           *
           * _.reduceRight(array, function(flattened, other) {
           *   return flattened.concat(other);
           * }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */


          function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce,
                initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
          }
          /**
           * The opposite of `_.filter`; this method returns the elements of `collection`
           * that `predicate` does **not** return truthy for.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.filter
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': true }
           * ];
           *
           * _.reject(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.reject(users, { 'age': 40, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.reject(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.reject(users, 'active');
           * // => objects for ['barney']
           */


          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          /**
           * Gets a random element from `collection`.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           */


          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          /**
           * Gets `n` random elements at unique keys from `collection` up to the
           * size of `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @param {number} [n=1] The number of elements to sample.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the random elements.
           * @example
           *
           * _.sampleSize([1, 2, 3], 2);
           * // => [3, 1]
           *
           * _.sampleSize([1, 2, 3], 4);
           * // => [2, 3, 1]
           */


          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
              n = 1;
            } else {
              n = toInteger(n);
            }

            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          /**
           * Creates an array of shuffled values, using a version of the
           * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           * @example
           *
           * _.shuffle([1, 2, 3, 4]);
           * // => [4, 1, 3, 2]
           */


          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          /**
           * Gets the size of `collection` by returning its length for array-like
           * values or the number of own enumerable string keyed properties for objects.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns the collection size.
           * @example
           *
           * _.size([1, 2, 3]);
           * // => 3
           *
           * _.size({ 'a': 1, 'b': 2 });
           * // => 2
           *
           * _.size('pebbles');
           * // => 7
           */


          function size(collection) {
            if (collection == null) {
              return 0;
            }

            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }

            var tag = getTag(collection);

            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }

            return baseKeys(collection).length;
          }
          /**
           * Checks if `predicate` returns truthy for **any** element of `collection`.
           * Iteration is stopped once `predicate` returns truthy. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var users = [
           *   { 'user': 'barney', 'active': true },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.some(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.some(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.some(users, 'active');
           * // => true
           */


          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;

            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined;
            }

            return func(collection, getIteratee(predicate, 3));
          }
          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection thru each iteratee. This method
           * performs a stable sort, that is, it preserves the original sort order of
           * equal elements. The iteratees are invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 30 },
           *   { 'user': 'barney', 'age': 34 }
           * ];
           *
           * _.sortBy(users, [function(o) { return o.user; }]);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
           *
           * _.sortBy(users, ['user', 'age']);
           * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
           */


          var sortBy = baseRest(function (collection, iteratees) {
            if (collection == null) {
              return [];
            }

            var length = iteratees.length;

            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }

            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          /*------------------------------------------------------------------------*/

          /**
           * Gets the timestamp of the number of milliseconds that have elapsed since
           * the Unix epoch (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Date
           * @returns {number} Returns the timestamp.
           * @example
           *
           * _.defer(function(stamp) {
           *   console.log(_.now() - stamp);
           * }, _.now());
           * // => Logs the number of milliseconds it took for the deferred invocation.
           */

          var now = ctxNow || function () {
            return root.Date.now();
          };
          /*------------------------------------------------------------------------*/

          /**
           * The opposite of `_.before`; this method creates a function that invokes
           * `func` once it's called `n` or more times.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {number} n The number of calls before `func` is invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => Logs 'done saving!' after the two async saves have completed.
           */


          function after(n, func) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            n = toInteger(n);
            return function () {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          /**
           * Creates a function that invokes `func`, with up to `n` arguments,
           * ignoring any additional arguments.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @param {number} [n=func.length] The arity cap.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.ary(parseInt, 1));
           * // => [6, 8, 10]
           */


          function ary(func, n, guard) {
            n = guard ? undefined : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
          }
          /**
           * Creates a function that invokes `func`, with the `this` binding and arguments
           * of the created function, while it's called less than `n` times. Subsequent
           * calls to the created function return the result of the last `func` invocation.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {number} n The number of calls at which `func` is no longer invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * jQuery(element).on('click', _.before(5, addContactToList));
           * // => Allows adding up to 4 contacts to the list.
           */


          function before(n, func) {
            var result;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            n = toInteger(n);
            return function () {
              if (--n > 0) {
                result = func.apply(this, arguments);
              }

              if (n <= 1) {
                func = undefined;
              }

              return result;
            };
          }
          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and `partials` prepended to the arguments it receives.
           *
           * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for partially applied arguments.
           *
           * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
           * property of bound functions.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * function greet(greeting, punctuation) {
           *   return greeting + ' ' + this.user + punctuation;
           * }
           *
           * var object = { 'user': 'fred' };
           *
           * var bound = _.bind(greet, object, 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bind(greet, object, _, '!');
           * bound('hi');
           * // => 'hi fred!'
           */


          var bind = baseRest(function (func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;

            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }

            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          /**
           * Creates a function that invokes the method at `object[key]` with `partials`
           * prepended to the arguments it receives.
           *
           * This method differs from `_.bind` by allowing bound functions to reference
           * methods that may be redefined or don't yet exist. See
           * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
           * for more details.
           *
           * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Function
           * @param {Object} object The object to invoke the method on.
           * @param {string} key The key of the method.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'user': 'fred',
           *   'greet': function(greeting, punctuation) {
           *     return greeting + ' ' + this.user + punctuation;
           *   }
           * };
           *
           * var bound = _.bindKey(object, 'greet', 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * object.greet = function(greeting, punctuation) {
           *   return greeting + 'ya ' + this.user + punctuation;
           * };
           *
           * bound('!');
           * // => 'hiya fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bindKey(object, 'greet', _, '!');
           * bound('hi');
           * // => 'hiya fred!'
           */

          var bindKey = baseRest(function (object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;

            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }

            return createWrap(key, bitmask, object, partials, holders);
          });
          /**
           * Creates a function that accepts arguments of `func` and either invokes
           * `func` returning its result, if at least `arity` number of arguments have
           * been provided, or returns a function that accepts the remaining `func`
           * arguments, and so on. The arity of `func` may be specified if `func.length`
           * is not sufficient.
           *
           * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curry(abc);
           *
           * curried(1)(2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(1)(_, 3)(2);
           * // => [1, 2, 3]
           */

          function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result;
          }
          /**
           * This method is like `_.curry` except that arguments are applied to `func`
           * in the manner of `_.partialRight` instead of `_.partial`.
           *
           * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curryRight(abc);
           *
           * curried(3)(2)(1);
           * // => [1, 2, 3]
           *
           * curried(2, 3)(1);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(3)(1, _)(2);
           * // => [1, 2, 3]
           */


          function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result;
          }
          /**
           * Creates a debounced function that delays invoking `func` until after `wait`
           * milliseconds have elapsed since the last time the debounced function was
           * invoked. The debounced function comes with a `cancel` method to cancel
           * delayed `func` invocations and a `flush` method to immediately invoke them.
           * Provide `options` to indicate whether `func` should be invoked on the
           * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
           * with the last arguments provided to the debounced function. Subsequent
           * calls to the debounced function return the result of the last `func`
           * invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the debounced function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.debounce` and `_.throttle`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to debounce.
           * @param {number} [wait=0] The number of milliseconds to delay.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=false]
           *  Specify invoking on the leading edge of the timeout.
           * @param {number} [options.maxWait]
           *  The maximum time `func` is allowed to be delayed before it's invoked.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // Avoid costly calculations while the window size is in flux.
           * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
           *
           * // Invoke `sendMail` when clicked, debouncing subsequent calls.
           * jQuery(element).on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * }));
           *
           * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
           * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
           * var source = new EventSource('/stream');
           * jQuery(source).on('message', debounced);
           *
           * // Cancel the trailing debounced invocation.
           * jQuery(window).on('popstate', debounced.cancel);
           */


          function debounce(func, wait, options) {
            var lastArgs,
                lastThis,
                maxWait,
                result,
                timerId,
                lastCallTime,
                lastInvokeTime = 0,
                leading = false,
                maxing = false,
                trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            wait = toNumber(wait) || 0;

            if (isObject(options)) {
              leading = !!options.leading;
              maxing = 'maxWait' in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            function invokeFunc(time) {
              var args = lastArgs,
                  thisArg = lastThis;
              lastArgs = lastThis = undefined;
              lastInvokeTime = time;
              result = func.apply(thisArg, args);
              return result;
            }

            function leadingEdge(time) {
              // Reset any `maxWait` timer.
              lastInvokeTime = time; // Start the timer for the trailing edge.

              timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

              return leading ? invokeFunc(time) : result;
            }

            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime,
                  timeSinceLastInvoke = time - lastInvokeTime,
                  timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }

            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime,
                  timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
              // trailing edge, the system time has gone backwards and we're treating
              // it as the trailing edge, or we've hit the `maxWait` limit.

              return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }

            function timerExpired() {
              var time = now();

              if (shouldInvoke(time)) {
                return trailingEdge(time);
              } // Restart the timer.


              timerId = setTimeout(timerExpired, remainingWait(time));
            }

            function trailingEdge(time) {
              timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
              // debounced at least once.

              if (trailing && lastArgs) {
                return invokeFunc(time);
              }

              lastArgs = lastThis = undefined;
              return result;
            }

            function cancel() {
              if (timerId !== undefined) {
                clearTimeout(timerId);
              }

              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined;
            }

            function flush() {
              return timerId === undefined ? result : trailingEdge(now());
            }

            function debounced() {
              var time = now(),
                  isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;

              if (isInvoking) {
                if (timerId === undefined) {
                  return leadingEdge(lastCallTime);
                }

                if (maxing) {
                  // Handle invocations in a tight loop.
                  clearTimeout(timerId);
                  timerId = setTimeout(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }

              if (timerId === undefined) {
                timerId = setTimeout(timerExpired, wait);
              }

              return result;
            }

            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          /**
           * Defers invoking the `func` until the current call stack has cleared. Any
           * additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to defer.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) {
           *   console.log(text);
           * }, 'deferred');
           * // => Logs 'deferred' after one millisecond.
           */


          var defer = baseRest(function (func, args) {
            return baseDelay(func, 1, args);
          });
          /**
           * Invokes `func` after `wait` milliseconds. Any additional arguments are
           * provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) {
           *   console.log(text);
           * }, 1000, 'later');
           * // => Logs 'later' after one second.
           */

          var delay = baseRest(function (func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          /**
           * Creates a function that invokes `func` with arguments reversed.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to flip arguments for.
           * @returns {Function} Returns the new flipped function.
           * @example
           *
           * var flipped = _.flip(function() {
           *   return _.toArray(arguments);
           * });
           *
           * flipped('a', 'b', 'c', 'd');
           * // => ['d', 'c', 'b', 'a']
           */

          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided, it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is used as the map cache key. The `func`
           * is invoked with the `this` binding of the memoized function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the
           * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
           * method interface of `clear`, `delete`, `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoized function.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           * var other = { 'c': 3, 'd': 4 };
           *
           * var values = _.memoize(_.values);
           * values(object);
           * // => [1, 2]
           *
           * values(other);
           * // => [3, 4]
           *
           * object.a = 2;
           * values(object);
           * // => [1, 2]
           *
           * // Modify the result cache.
           * values.cache.set(object, ['a', 'b']);
           * values(object);
           * // => ['a', 'b']
           *
           * // Replace `_.memoize.Cache`.
           * _.memoize.Cache = WeakMap;
           */


          function memoize(func, resolver) {
            if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            var memoized = function memoized() {
              var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;

              if (cache.has(key)) {
                return cache.get(key);
              }

              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result) || cache;
              return result;
            };

            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          } // Expose `MapCache`.


          memoize.Cache = MapCache;
          /**
           * Creates a function that negates the result of the predicate `func`. The
           * `func` predicate is invoked with the `this` binding and arguments of the
           * created function.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} predicate The predicate to negate.
           * @returns {Function} Returns the new negated function.
           * @example
           *
           * function isEven(n) {
           *   return n % 2 == 0;
           * }
           *
           * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
           * // => [1, 3, 5]
           */

          function negate(predicate) {
            if (typeof predicate != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            return function () {
              var args = arguments;

              switch (args.length) {
                case 0:
                  return !predicate.call(this);

                case 1:
                  return !predicate.call(this, args[0]);

                case 2:
                  return !predicate.call(this, args[0], args[1]);

                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }

              return !predicate.apply(this, args);
            };
          }
          /**
           * Creates a function that is restricted to invoking `func` once. Repeat calls
           * to the function return the value of the first invocation. The `func` is
           * invoked with the `this` binding and arguments of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // => `createApplication` is invoked once
           */


          function once(func) {
            return before(2, func);
          }
          /**
           * Creates a function that invokes `func` with its arguments transformed.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Function
           * @param {Function} func The function to wrap.
           * @param {...(Function|Function[])} [transforms=[_.identity]]
           *  The argument transforms.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function doubled(n) {
           *   return n * 2;
           * }
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var func = _.overArgs(function(x, y) {
           *   return [x, y];
           * }, [square, doubled]);
           *
           * func(9, 3);
           * // => [81, 6]
           *
           * func(10, 5);
           * // => [100, 10]
           */


          var overArgs = castRest(function (func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function (args) {
              var index = -1,
                  length = nativeMin(args.length, funcsLength);

              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }

              return apply(func, this, args);
            });
          });
          /**
           * Creates a function that invokes `func` with `partials` prepended to the
           * arguments it receives. This method is like `_.bind` except it does **not**
           * alter the `this` binding.
           *
           * The `_.partial.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 0.2.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var sayHelloTo = _.partial(greet, 'hello');
           * sayHelloTo('fred');
           * // => 'hello fred'
           *
           * // Partially applied with placeholders.
           * var greetFred = _.partial(greet, _, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           */

          var partial = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
          });
          /**
           * This method is like `_.partial` except that partially applied arguments
           * are appended to the arguments it receives.
           *
           * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var greetFred = _.partialRight(greet, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           *
           * // Partially applied with placeholders.
           * var sayHelloTo = _.partialRight(greet, 'hello', _);
           * sayHelloTo('fred');
           * // => 'hello fred'
           */

          var partialRight = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
          });
          /**
           * Creates a function that invokes `func` with arguments arranged according
           * to the specified `indexes` where the argument value at the first index is
           * provided as the first argument, the argument value at the second index is
           * provided as the second argument, and so on.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to rearrange arguments for.
           * @param {...(number|number[])} indexes The arranged argument indexes.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var rearged = _.rearg(function(a, b, c) {
           *   return [a, b, c];
           * }, [2, 0, 1]);
           *
           * rearged('b', 'c', 'a')
           * // => ['a', 'b', 'c']
           */

          var rearg = flatRest(function (func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
          });
          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * created function and arguments from `start` and beyond provided as
           * an array.
           *
           * **Note:** This method is based on the
           * [rest parameter](https://mdn.io/rest_parameters).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.rest(function(what, names) {
           *   return what + ' ' + _.initial(names).join(', ') +
           *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
           * });
           *
           * say('hello', 'fred', 'barney', 'pebbles');
           * // => 'hello fred, barney, & pebbles'
           */

          function rest(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            start = start === undefined ? start : toInteger(start);
            return baseRest(func, start);
          }
          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * create function and an array of arguments much like
           * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
           *
           * **Note:** This method is based on the
           * [spread operator](https://mdn.io/spread_operator).
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Function
           * @param {Function} func The function to spread arguments over.
           * @param {number} [start=0] The start position of the spread.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.spread(function(who, what) {
           *   return who + ' says ' + what;
           * });
           *
           * say(['fred', 'hello']);
           * // => 'fred says hello'
           *
           * var numbers = Promise.all([
           *   Promise.resolve(40),
           *   Promise.resolve(36)
           * ]);
           *
           * numbers.then(_.spread(function(x, y) {
           *   return x + y;
           * }));
           * // => a Promise of 76
           */


          function spread(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function (args) {
              var array = args[start],
                  otherArgs = castSlice(args, 0, start);

              if (array) {
                arrayPush(otherArgs, array);
              }

              return apply(func, this, otherArgs);
            });
          }
          /**
           * Creates a throttled function that only invokes `func` at most once per
           * every `wait` milliseconds. The throttled function comes with a `cancel`
           * method to cancel delayed `func` invocations and a `flush` method to
           * immediately invoke them. Provide `options` to indicate whether `func`
           * should be invoked on the leading and/or trailing edge of the `wait`
           * timeout. The `func` is invoked with the last arguments provided to the
           * throttled function. Subsequent calls to the throttled function return the
           * result of the last `func` invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the throttled function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.throttle` and `_.debounce`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to throttle.
           * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=true]
           *  Specify invoking on the leading edge of the timeout.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // Avoid excessively updating the position while scrolling.
           * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
           *
           * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
           * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
           * jQuery(element).on('click', throttled);
           *
           * // Cancel the trailing throttled invocation.
           * jQuery(window).on('popstate', throttled.cancel);
           */


          function throttle(func, wait, options) {
            var leading = true,
                trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            if (isObject(options)) {
              leading = 'leading' in options ? !!options.leading : leading;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            return debounce(func, wait, {
              'leading': leading,
              'maxWait': wait,
              'trailing': trailing
            });
          }
          /**
           * Creates a function that accepts up to one argument, ignoring any
           * additional arguments.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.unary(parseInt));
           * // => [6, 8, 10]
           */


          function unary(func) {
            return ary(func, 1);
          }
          /**
           * Creates a function that provides `value` to `wrapper` as its first
           * argument. Any additional arguments provided to the function are appended
           * to those provided to the `wrapper`. The wrapper is invoked with the `this`
           * binding of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {*} value The value to wrap.
           * @param {Function} [wrapper=identity] The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('fred, barney, & pebbles');
           * // => '<p>fred, barney, &amp; pebbles</p>'
           */


          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Casts `value` as an array if it's not one.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Lang
           * @param {*} value The value to inspect.
           * @returns {Array} Returns the cast array.
           * @example
           *
           * _.castArray(1);
           * // => [1]
           *
           * _.castArray({ 'a': 1 });
           * // => [{ 'a': 1 }]
           *
           * _.castArray('abc');
           * // => ['abc']
           *
           * _.castArray(null);
           * // => [null]
           *
           * _.castArray(undefined);
           * // => [undefined]
           *
           * _.castArray();
           * // => []
           *
           * var array = [1, 2, 3];
           * console.log(_.castArray(array) === array);
           * // => true
           */


          function castArray() {
            if (!arguments.length) {
              return [];
            }

            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          /**
           * Creates a shallow clone of `value`.
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
           * and supports cloning arrays, array buffers, booleans, date objects, maps,
           * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
           * arrays. The own enumerable properties of `arguments` objects are cloned
           * as plain objects. An empty object is returned for uncloneable values such
           * as error objects, functions, DOM nodes, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to clone.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeep
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var shallow = _.clone(objects);
           * console.log(shallow[0] === objects[0]);
           * // => true
           */


          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          /**
           * This method is like `_.clone` except that it accepts `customizer` which
           * is invoked to produce the cloned value. If `customizer` returns `undefined`,
           * cloning is handled by the method instead. The `customizer` is invoked with
           * up to four arguments; (value [, index|key, object, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeepWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(false);
           *   }
           * }
           *
           * var el = _.cloneWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 0
           */


          function cloneWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          /**
           * This method is like `_.clone` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @returns {*} Returns the deep cloned value.
           * @see _.clone
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var deep = _.cloneDeep(objects);
           * console.log(deep[0] === objects[0]);
           * // => false
           */


          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          /**
           * This method is like `_.cloneWith` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the deep cloned value.
           * @see _.cloneWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(true);
           *   }
           * }
           *
           * var el = _.cloneDeepWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 20
           */


          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          /**
           * Checks if `object` conforms to `source` by invoking the predicate
           * properties of `source` with the corresponding property values of `object`.
           *
           * **Note:** This method is equivalent to `_.conforms` when `source` is
           * partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
           * // => true
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
           * // => false
           */


          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */


          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          /**
           * Checks if `value` is greater than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           * @see _.lt
           * @example
           *
           * _.gt(3, 1);
           * // => true
           *
           * _.gt(3, 3);
           * // => false
           *
           * _.gt(1, 3);
           * // => false
           */


          var gt = createRelationalOperation(baseGt);
          /**
           * Checks if `value` is greater than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than or equal to
           *  `other`, else `false`.
           * @see _.lte
           * @example
           *
           * _.gte(3, 1);
           * // => true
           *
           * _.gte(3, 3);
           * // => true
           *
           * _.gte(1, 3);
           * // => false
           */

          var gte = createRelationalOperation(function (value, other) {
            return value >= other;
          });
          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */

          var isArguments = baseIsArguments(function () {
            return arguments;
          }()) ? baseIsArguments : function (value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          };
          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */

          var isArray = Array.isArray;
          /**
           * Checks if `value` is classified as an `ArrayBuffer` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           * @example
           *
           * _.isArrayBuffer(new ArrayBuffer(2));
           * // => true
           *
           * _.isArrayBuffer(new Array(2));
           * // => false
           */

          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */

          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */


          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          /**
           * Checks if `value` is classified as a boolean primitive or object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
           * @example
           *
           * _.isBoolean(false);
           * // => true
           *
           * _.isBoolean(null);
           * // => false
           */


          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */


          var isBuffer = nativeIsBuffer || stubFalse;
          /**
           * Checks if `value` is classified as a `Date` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           *
           * _.isDate('Mon April 23 2012');
           * // => false
           */

          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          /**
           * Checks if `value` is likely a DOM element.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           *
           * _.isElement('<body>');
           * // => false
           */

          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          /**
           * Checks if `value` is an empty object, collection, map, or set.
           *
           * Objects are considered empty if they have no own enumerable string keyed
           * properties.
           *
           * Array-like values such as `arguments` objects, arrays, buffers, strings, or
           * jQuery-like collections are considered empty if they have a `length` of `0`.
           * Similarly, maps and sets are considered empty if they have a `size` of `0`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty(null);
           * // => true
           *
           * _.isEmpty(true);
           * // => true
           *
           * _.isEmpty(1);
           * // => true
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({ 'a': 1 });
           * // => false
           */


          function isEmpty(value) {
            if (value == null) {
              return true;
            }

            if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }

            var tag = getTag(value);

            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }

            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }

            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }

            return true;
          }
          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent.
           *
           * **Note:** This method supports comparing arrays, array buffers, booleans,
           * date objects, error objects, maps, numbers, `Object` objects, regexes,
           * sets, strings, symbols, and typed arrays. `Object` objects are compared
           * by their own, not inherited, enumerable properties. Functions and DOM
           * nodes are compared by strict equality, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.isEqual(object, other);
           * // => true
           *
           * object === other;
           * // => false
           */


          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          /**
           * This method is like `_.isEqual` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with up to
           * six arguments: (objValue, othValue [, index|key, object, other, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, othValue) {
           *   if (isGreeting(objValue) && isGreeting(othValue)) {
           *     return true;
           *   }
           * }
           *
           * var array = ['hello', 'goodbye'];
           * var other = ['hi', 'goodbye'];
           *
           * _.isEqualWith(array, other, customizer);
           * // => true
           */


          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
          }
          /**
           * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
           * `SyntaxError`, `TypeError`, or `URIError` object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
           * @example
           *
           * _.isError(new Error);
           * // => true
           *
           * _.isError(Error);
           * // => false
           */


          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }

            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
          }
          /**
           * Checks if `value` is a finite primitive number.
           *
           * **Note:** This method is based on
           * [`Number.isFinite`](https://mdn.io/Number/isFinite).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
           * @example
           *
           * _.isFinite(3);
           * // => true
           *
           * _.isFinite(Number.MIN_VALUE);
           * // => true
           *
           * _.isFinite(Infinity);
           * // => false
           *
           * _.isFinite('3');
           * // => false
           */


          function isFinite(value) {
            return typeof value == 'number' && nativeIsFinite(value);
          }
          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */


          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            } // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.


            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          /**
           * Checks if `value` is an integer.
           *
           * **Note:** This method is based on
           * [`Number.isInteger`](https://mdn.io/Number/isInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
           * @example
           *
           * _.isInteger(3);
           * // => true
           *
           * _.isInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isInteger(Infinity);
           * // => false
           *
           * _.isInteger('3');
           * // => false
           */


          function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value);
          }
          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */


          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */


          function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
          }
          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */


          function isObjectLike(value) {
            return value != null && typeof value == 'object';
          }
          /**
           * Checks if `value` is classified as a `Map` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           * @example
           *
           * _.isMap(new Map);
           * // => true
           *
           * _.isMap(new WeakMap);
           * // => false
           */


          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          /**
           * Performs a partial deep comparison between `object` and `source` to
           * determine if `object` contains equivalent property values.
           *
           * **Note:** This method is equivalent to `_.matches` when `source` is
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.isMatch(object, { 'b': 2 });
           * // => true
           *
           * _.isMatch(object, { 'b': 1 });
           * // => false
           */

          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          /**
           * This method is like `_.isMatch` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with five
           * arguments: (objValue, srcValue, index|key, object, source).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, srcValue) {
           *   if (isGreeting(objValue) && isGreeting(srcValue)) {
           *     return true;
           *   }
           * }
           *
           * var object = { 'greeting': 'hello' };
           * var source = { 'greeting': 'hi' };
           *
           * _.isMatchWith(object, source, customizer);
           * // => true
           */


          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          /**
           * Checks if `value` is `NaN`.
           *
           * **Note:** This method is based on
           * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
           * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
           * `undefined` and other non-number values.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */


          function isNaN(value) {
            // An `NaN` primitive is the only value that is not equal to itself.
            // Perform the `toStringTag` check first to avoid errors with some
            // ActiveX objects in IE.
            return isNumber(value) && value != +value;
          }
          /**
           * Checks if `value` is a pristine native function.
           *
           * **Note:** This method can't reliably detect native functions in the presence
           * of the core-js package because core-js circumvents this kind of detection.
           * Despite multiple requests, the core-js maintainer has made it clear: any
           * attempt to fix the detection will be obstructed. As a result, we're left
           * with little choice but to throw an error. Unfortunately, this also affects
           * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
           * which rely on core-js.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           * @example
           *
           * _.isNative(Array.prototype.push);
           * // => true
           *
           * _.isNative(_);
           * // => false
           */


          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error(CORE_ERROR_TEXT);
            }

            return baseIsNative(value);
          }
          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(void 0);
           * // => false
           */


          function isNull(value) {
            return value === null;
          }
          /**
           * Checks if `value` is `null` or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
           * @example
           *
           * _.isNil(null);
           * // => true
           *
           * _.isNil(void 0);
           * // => true
           *
           * _.isNil(NaN);
           * // => false
           */


          function isNil(value) {
            return value == null;
          }
          /**
           * Checks if `value` is classified as a `Number` primitive or object.
           *
           * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
           * classified as numbers, use the `_.isFinite` method.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a number, else `false`.
           * @example
           *
           * _.isNumber(3);
           * // => true
           *
           * _.isNumber(Number.MIN_VALUE);
           * // => true
           *
           * _.isNumber(Infinity);
           * // => true
           *
           * _.isNumber('3');
           * // => false
           */


          function isNumber(value) {
            return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * @static
           * @memberOf _
           * @since 0.8.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */


          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }

            var proto = getPrototype(value);

            if (proto === null) {
              return true;
            }

            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          /**
           * Checks if `value` is classified as a `RegExp` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           * @example
           *
           * _.isRegExp(/abc/);
           * // => true
           *
           * _.isRegExp('/abc/');
           * // => false
           */


          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          /**
           * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
           * double precision number which isn't the result of a rounded unsafe integer.
           *
           * **Note:** This method is based on
           * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
           * @example
           *
           * _.isSafeInteger(3);
           * // => true
           *
           * _.isSafeInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isSafeInteger(Infinity);
           * // => false
           *
           * _.isSafeInteger('3');
           * // => false
           */

          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          /**
           * Checks if `value` is classified as a `Set` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           * @example
           *
           * _.isSet(new Set);
           * // => true
           *
           * _.isSet(new WeakSet);
           * // => false
           */


          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          /**
           * Checks if `value` is classified as a `String` primitive or object.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a string, else `false`.
           * @example
           *
           * _.isString('abc');
           * // => true
           *
           * _.isString(1);
           * // => false
           */

          function isString(value) {
            return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          /**
           * Checks if `value` is classified as a `Symbol` primitive or object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
           * @example
           *
           * _.isSymbol(Symbol.iterator);
           * // => true
           *
           * _.isSymbol('abc');
           * // => false
           */


          function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */


          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           *
           * _.isUndefined(null);
           * // => false
           */

          function isUndefined(value) {
            return value === undefined;
          }
          /**
           * Checks if `value` is classified as a `WeakMap` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
           * @example
           *
           * _.isWeakMap(new WeakMap);
           * // => true
           *
           * _.isWeakMap(new Map);
           * // => false
           */


          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          /**
           * Checks if `value` is classified as a `WeakSet` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
           * @example
           *
           * _.isWeakSet(new WeakSet);
           * // => true
           *
           * _.isWeakSet(new Set);
           * // => false
           */


          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          /**
           * Checks if `value` is less than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           * @see _.gt
           * @example
           *
           * _.lt(1, 3);
           * // => true
           *
           * _.lt(3, 3);
           * // => false
           *
           * _.lt(3, 1);
           * // => false
           */


          var lt = createRelationalOperation(baseLt);
          /**
           * Checks if `value` is less than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than or equal to
           *  `other`, else `false`.
           * @see _.gte
           * @example
           *
           * _.lte(1, 3);
           * // => true
           *
           * _.lte(3, 3);
           * // => true
           *
           * _.lte(3, 1);
           * // => false
           */

          var lte = createRelationalOperation(function (value, other) {
            return value <= other;
          });
          /**
           * Converts `value` to an array.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Array} Returns the converted array.
           * @example
           *
           * _.toArray({ 'a': 1, 'b': 2 });
           * // => [1, 2]
           *
           * _.toArray('abc');
           * // => ['a', 'b', 'c']
           *
           * _.toArray(1);
           * // => []
           *
           * _.toArray(null);
           * // => []
           */

          function toArray(value) {
            if (!value) {
              return [];
            }

            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }

            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }

            var tag = getTag(value),
                func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          /**
           * Converts `value` to a finite number.
           *
           * @static
           * @memberOf _
           * @since 4.12.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted number.
           * @example
           *
           * _.toFinite(3.2);
           * // => 3.2
           *
           * _.toFinite(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toFinite(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toFinite('3.2');
           * // => 3.2
           */


          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }

            value = toNumber(value);

            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }

            return value === value ? value : 0;
          }
          /**
           * Converts `value` to an integer.
           *
           * **Note:** This method is loosely based on
           * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toInteger(3.2);
           * // => 3
           *
           * _.toInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toInteger(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toInteger('3.2');
           * // => 3
           */


          function toInteger(value) {
            var result = toFinite(value),
                remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
          }
          /**
           * Converts `value` to an integer suitable for use as the length of an
           * array-like object.
           *
           * **Note:** This method is based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toLength(3.2);
           * // => 3
           *
           * _.toLength(Number.MIN_VALUE);
           * // => 0
           *
           * _.toLength(Infinity);
           * // => 4294967295
           *
           * _.toLength('3.2');
           * // => 3
           */


          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          /**
           * Converts `value` to a number.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           * @example
           *
           * _.toNumber(3.2);
           * // => 3.2
           *
           * _.toNumber(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toNumber(Infinity);
           * // => Infinity
           *
           * _.toNumber('3.2');
           * // => 3.2
           */


          function toNumber(value) {
            if (typeof value == 'number') {
              return value;
            }

            if (isSymbol(value)) {
              return NAN;
            }

            if (isObject(value)) {
              var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
              value = isObject(other) ? other + '' : other;
            }

            if (typeof value != 'string') {
              return value === 0 ? value : +value;
            }

            value = value.replace(reTrim, '');
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          /**
           * Converts `value` to a plain object flattening inherited enumerable string
           * keyed properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */


          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          /**
           * Converts `value` to a safe integer. A safe integer can be compared and
           * represented correctly.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toSafeInteger(3.2);
           * // => 3
           *
           * _.toSafeInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toSafeInteger(Infinity);
           * // => 9007199254740991
           *
           * _.toSafeInteger('3.2');
           * // => 3
           */


          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          /**
           * Converts `value` to a string. An empty string is returned for `null`
           * and `undefined` values. The sign of `-0` is preserved.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.toString(null);
           * // => ''
           *
           * _.toString(-0);
           * // => '-0'
           *
           * _.toString([1, 2, 3]);
           * // => '1,2,3'
           */


          function toString(value) {
            return value == null ? '' : baseToString(value);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Assigns own enumerable string keyed properties of source objects to the
           * destination object. Source objects are applied from left to right.
           * Subsequent sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object` and is loosely based on
           * [`Object.assign`](https://mdn.io/Object/assign).
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assignIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assign({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'c': 3 }
           */


          var assign = createAssigner(function (object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }

            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          /**
           * This method is like `_.assign` except that it iterates over own and
           * inherited source properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extend
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assign
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assignIn({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
           */

          var assignIn = createAssigner(function (object, source) {
            copyObject(source, keysIn(source), object);
          });
          /**
           * This method is like `_.assignIn` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extendWith
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignInWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */

          var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          /**
           * This method is like `_.assign` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignInWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */

          var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          /**
           * Creates an array of values corresponding to `paths` of `object`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Array} Returns the picked values.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _.at(object, ['a[0].b.c', 'a[1]']);
           * // => [3, 4]
           */

          var at = flatRest(baseAt);
          /**
           * Creates an object that inherits from the `prototype` object. If a
           * `properties` object is given, its own enumerable string keyed properties
           * are assigned to the created object.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Object
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, {
           *   'constructor': Circle
           * });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */

          function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties == null ? result : baseAssign(result, properties);
          }
          /**
           * Assigns own and inherited enumerable string keyed properties of source
           * objects to the destination object for all destination properties that
           * resolve to `undefined`. Source objects are applied from left to right.
           * Once a property is set, additional values of the same property are ignored.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaultsDeep
           * @example
           *
           * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */


          var defaults = baseRest(function (object, sources) {
            object = Object(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }

            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;

              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];

                if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }

            return object;
          });
          /**
           * This method is like `_.defaults` except that it recursively assigns
           * default properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaults
           * @example
           *
           * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
           * // => { 'a': { 'b': 2, 'c': 3 } }
           */

          var defaultsDeep = baseRest(function (args) {
            args.push(undefined, customDefaultsMerge);
            return apply(mergeWith, undefined, args);
          });
          /**
           * This method is like `_.find` except that it returns the key of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findKey(users, function(o) { return o.age < 40; });
           * // => 'barney' (iteration order is not guaranteed)
           *
           * // The `_.matches` iteratee shorthand.
           * _.findKey(users, { 'age': 1, 'active': true });
           * // => 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findKey(users, 'active');
           * // => 'barney'
           */

          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          /**
           * This method is like `_.findKey` except that it iterates over elements of
           * a collection in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findLastKey(users, function(o) { return o.age < 40; });
           * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastKey(users, { 'age': 36, 'active': true });
           * // => 'barney'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastKey(users, 'active');
           * // => 'pebbles'
           */


          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          /**
           * Iterates over own and inherited enumerable string keyed properties of an
           * object and invokes `iteratee` for each property. The iteratee is invoked
           * with three arguments: (value, key, object). Iteratee functions may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forInRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forIn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
           */


          function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
          }
          /**
           * This method is like `_.forIn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forInRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
           */


          function forInRight(object, iteratee) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
          }
          /**
           * Iterates over own enumerable string keyed properties of an object and
           * invokes `iteratee` for each property. The iteratee is invoked with three
           * arguments: (value, key, object). Iteratee functions may exit iteration
           * early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwnRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */


          function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3));
          }
          /**
           * This method is like `_.forOwn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwnRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
           */


          function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
          }
          /**
           * Creates an array of function property names from own enumerable properties
           * of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functionsIn
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functions(new Foo);
           * // => ['a', 'b']
           */


          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          /**
           * Creates an array of function property names from own and inherited
           * enumerable properties of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functions
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functionsIn(new Foo);
           * // => ['a', 'b', 'c']
           */


          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          /**
           * Gets the value at `path` of `object`. If the resolved value is
           * `undefined`, the `defaultValue` is returned in its place.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.get(object, 'a[0].b.c');
           * // => 3
           *
           * _.get(object, ['a', '0', 'b', 'c']);
           * // => 3
           *
           * _.get(object, 'a.b.c', 'default');
           * // => 'default'
           */


          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }
          /**
           * Checks if `path` is a direct property of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = { 'a': { 'b': 2 } };
           * var other = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.has(object, 'a');
           * // => true
           *
           * _.has(object, 'a.b');
           * // => true
           *
           * _.has(object, ['a', 'b']);
           * // => true
           *
           * _.has(other, 'a');
           * // => false
           */


          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          /**
           * Checks if `path` is a direct or inherited property of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.hasIn(object, 'a');
           * // => true
           *
           * _.hasIn(object, 'a.b');
           * // => true
           *
           * _.hasIn(object, ['a', 'b']);
           * // => true
           *
           * _.hasIn(object, 'b');
           * // => false
           */


          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          /**
           * Creates an object composed of the inverted keys and values of `object`.
           * If `object` contains duplicate values, subsequent values overwrite
           * property assignments of previous values.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Object
           * @param {Object} object The object to invert.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invert(object);
           * // => { '1': 'c', '2': 'b' }
           */


          var invert = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value);
            }

            result[value] = key;
          }, constant(identity));
          /**
           * This method is like `_.invert` except that the inverted object is generated
           * from the results of running each element of `object` thru `iteratee`. The
           * corresponding inverted value of each inverted key is an array of keys
           * responsible for generating the inverted value. The iteratee is invoked
           * with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Object
           * @param {Object} object The object to invert.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invertBy(object);
           * // => { '1': ['a', 'c'], '2': ['b'] }
           *
           * _.invertBy(object, function(value) {
           *   return 'group' + value;
           * });
           * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
           */

          var invertBy = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value);
            }

            if (hasOwnProperty.call(result, value)) {
              result[value].push(key);
            } else {
              result[value] = [key];
            }
          }, getIteratee);
          /**
           * Invokes the method at `path` of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
           *
           * _.invoke(object, 'a[0].b.c.slice', 1, 3);
           * // => [2, 3]
           */

          var invoke = baseRest(baseInvoke);
          /**
           * Creates an array of the own enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects. See the
           * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * for more details.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keys(new Foo);
           * // => ['a', 'b'] (iteration order is not guaranteed)
           *
           * _.keys('hi');
           * // => ['0', '1']
           */

          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */


          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          /**
           * The opposite of `_.mapValues`; this method creates an object with the
           * same values as `object` and keys generated by running each own enumerable
           * string keyed property of `object` thru `iteratee`. The iteratee is invoked
           * with three arguments: (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapValues
           * @example
           *
           * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
           *   return key + value;
           * });
           * // => { 'a1': 1, 'b2': 2 }
           */


          function mapKeys(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, iteratee(value, key, object), value);
            });
            return result;
          }
          /**
           * Creates an object with the same keys as `object` and values generated
           * by running each own enumerable string keyed property of `object` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapKeys
           * @example
           *
           * var users = {
           *   'fred':    { 'user': 'fred',    'age': 40 },
           *   'pebbles': { 'user': 'pebbles', 'age': 1 }
           * };
           *
           * _.mapValues(users, function(o) { return o.age; });
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           *
           * // The `_.property` iteratee shorthand.
           * _.mapValues(users, 'age');
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           */


          function mapValues(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, key, iteratee(value, key, object));
            });
            return result;
          }
          /**
           * This method is like `_.assign` except that it recursively merges own and
           * inherited enumerable string keyed properties of source objects into the
           * destination object. Source properties that resolve to `undefined` are
           * skipped if a destination value exists. Array and plain object properties
           * are merged recursively. Other objects and value types are overridden by
           * assignment. Source objects are applied from left to right. Subsequent
           * sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {
           *   'a': [{ 'b': 2 }, { 'd': 4 }]
           * };
           *
           * var other = {
           *   'a': [{ 'c': 3 }, { 'e': 5 }]
           * };
           *
           * _.merge(object, other);
           * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
           */


          var merge = createAssigner(function (object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          /**
           * This method is like `_.merge` except that it accepts `customizer` which
           * is invoked to produce the merged values of the destination and source
           * properties. If `customizer` returns `undefined`, merging is handled by the
           * method instead. The `customizer` is invoked with six arguments:
           * (objValue, srcValue, key, object, source, stack).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   if (_.isArray(objValue)) {
           *     return objValue.concat(srcValue);
           *   }
           * }
           *
           * var object = { 'a': [1], 'b': [2] };
           * var other = { 'a': [3], 'b': [4] };
           *
           * _.mergeWith(object, other, customizer);
           * // => { 'a': [1, 3], 'b': [2, 4] }
           */

          var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          /**
           * The opposite of `_.pick`; this method creates an object composed of the
           * own and inherited enumerable property paths of `object` that are not omitted.
           *
           * **Note:** This method is considerably slower than `_.pick`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to omit.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omit(object, ['a', 'c']);
           * // => { 'b': '2' }
           */

          var omit = flatRest(function (object, paths) {
            var result = {};

            if (object == null) {
              return result;
            }

            var isDeep = false;
            paths = arrayMap(paths, function (path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result);

            if (isDeep) {
              result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }

            var length = paths.length;

            while (length--) {
              baseUnset(result, paths[length]);
            }

            return result;
          });
          /**
           * The opposite of `_.pickBy`; this method creates an object composed of
           * the own and inherited enumerable string keyed properties of `object` that
           * `predicate` doesn't return truthy for. The predicate is invoked with two
           * arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omitBy(object, _.isNumber);
           * // => { 'b': '2' }
           */

          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          /**
           * Creates an object composed of the picked `object` properties.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pick(object, ['a', 'c']);
           * // => { 'a': 1, 'c': 3 }
           */


          var pick = flatRest(function (object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          /**
           * Creates an object composed of the `object` properties `predicate` returns
           * truthy for. The predicate is invoked with two arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pickBy(object, _.isNumber);
           * // => { 'a': 1, 'c': 3 }
           */

          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }

            var props = arrayMap(getAllKeysIn(object), function (prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function (value, path) {
              return predicate(value, path[0]);
            });
          }
          /**
           * This method is like `_.get` except that if the resolved value is a
           * function it's invoked with the `this` binding of its parent object and
           * its result is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to resolve.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
           *
           * _.result(object, 'a[0].b.c1');
           * // => 3
           *
           * _.result(object, 'a[0].b.c2');
           * // => 4
           *
           * _.result(object, 'a[0].b.c3', 'default');
           * // => 'default'
           *
           * _.result(object, 'a[0].b.c3', _.constant('default'));
           * // => 'default'
           */


          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1,
                length = path.length; // Ensure the loop is entered when path is empty.

            if (!length) {
              length = 1;
              object = undefined;
            }

            while (++index < length) {
              var value = object == null ? undefined : object[toKey(path[index])];

              if (value === undefined) {
                index = length;
                value = defaultValue;
              }

              object = isFunction(value) ? value.call(object) : value;
            }

            return object;
          }
          /**
           * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
           * it's created. Arrays are created for missing index properties while objects
           * are created for all other missing properties. Use `_.setWith` to customize
           * `path` creation.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.set(object, 'a[0].b.c', 4);
           * console.log(object.a[0].b.c);
           * // => 4
           *
           * _.set(object, ['x', '0', 'y', 'z'], 5);
           * console.log(object.x[0].y.z);
           * // => 5
           */


          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          /**
           * This method is like `_.set` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.setWith(object, '[0][1]', 'a', Object);
           * // => { '0': { '1': 'a' } }
           */


          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          /**
           * Creates an array of own enumerable string keyed-value pairs for `object`
           * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
           * entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entries
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairs(new Foo);
           * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
           */


          var toPairs = createToPairs(keys);
          /**
           * Creates an array of own and inherited enumerable string keyed-value pairs
           * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
           * or set, its entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entriesIn
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairsIn(new Foo);
           * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
           */

          var toPairsIn = createToPairs(keysIn);
          /**
           * An alternative to `_.reduce`; this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own
           * enumerable string keyed properties thru `iteratee`, with each invocation
           * potentially mutating the `accumulator` object. If `accumulator` is not
           * provided, a new object with the same `[[Prototype]]` will be used. The
           * iteratee is invoked with four arguments: (accumulator, value, key, object).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.transform([2, 3, 4], function(result, n) {
           *   result.push(n *= n);
           *   return n % 2 == 0;
           * }, []);
           * // => [4, 9]
           *
           * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] }
           */

          function transform(object, iteratee, accumulator) {
            var isArr = isArray(object),
                isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee = getIteratee(iteratee, 4);

            if (accumulator == null) {
              var Ctor = object && object.constructor;

              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }

            (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
              return iteratee(accumulator, value, index, object);
            });
            return accumulator;
          }
          /**
           * Removes the property at `path` of `object`.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 7 } }] };
           * _.unset(object, 'a[0].b.c');
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           *
           * _.unset(object, ['a', '0', 'b', 'c']);
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           */


          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          /**
           * This method is like `_.set` except that accepts `updater` to produce the
           * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
           * is invoked with one argument: (value).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.update(object, 'a[0].b.c', function(n) { return n * n; });
           * console.log(object.a[0].b.c);
           * // => 9
           *
           * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
           * console.log(object.x[0].y.z);
           * // => 0
           */


          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          /**
           * This method is like `_.update` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.updateWith(object, '[0][1]', _.constant('a'), Object);
           * // => { '0': { '1': 'a' } }
           */


          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          /**
           * Creates an array of the own enumerable string keyed property values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.values(new Foo);
           * // => [1, 2] (iteration order is not guaranteed)
           *
           * _.values('hi');
           * // => ['h', 'i']
           */


          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          /**
           * Creates an array of the own and inherited enumerable string keyed property
           * values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.valuesIn(new Foo);
           * // => [1, 2, 3] (iteration order is not guaranteed)
           */


          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          /*------------------------------------------------------------------------*/

          /**
           * Clamps `number` within the inclusive `lower` and `upper` bounds.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Number
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           * @example
           *
           * _.clamp(-10, -5, 5);
           * // => -5
           *
           * _.clamp(10, -5, 5);
           * // => 5
           */


          function clamp(number, lower, upper) {
            if (upper === undefined) {
              upper = lower;
              lower = undefined;
            }

            if (upper !== undefined) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }

            if (lower !== undefined) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }

            return baseClamp(toNumber(number), lower, upper);
          }
          /**
           * Checks if `n` is between `start` and up to, but not including, `end`. If
           * `end` is not specified, it's set to `start` with `start` then set to `0`.
           * If `start` is greater than `end` the params are swapped to support
           * negative ranges.
           *
           * @static
           * @memberOf _
           * @since 3.3.0
           * @category Number
           * @param {number} number The number to check.
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           * @see _.range, _.rangeRight
           * @example
           *
           * _.inRange(3, 2, 4);
           * // => true
           *
           * _.inRange(4, 8);
           * // => true
           *
           * _.inRange(4, 2);
           * // => false
           *
           * _.inRange(2, 2);
           * // => false
           *
           * _.inRange(1.2, 2);
           * // => true
           *
           * _.inRange(5.2, 4);
           * // => false
           *
           * _.inRange(-3, -2, -6);
           * // => true
           */


          function inRange(number, start, end) {
            start = toFinite(start);

            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }

            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          /**
           * Produces a random number between the inclusive `lower` and `upper` bounds.
           * If only one argument is provided a number between `0` and the given number
           * is returned. If `floating` is `true`, or either `lower` or `upper` are
           * floats, a floating-point number is returned instead of an integer.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Number
           * @param {number} [lower=0] The lower bound.
           * @param {number} [upper=1] The upper bound.
           * @param {boolean} [floating] Specify returning a floating-point number.
           * @returns {number} Returns the random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */


          function random(lower, upper, floating) {
            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined;
            }

            if (floating === undefined) {
              if (typeof upper == 'boolean') {
                floating = upper;
                upper = undefined;
              } else if (typeof lower == 'boolean') {
                floating = lower;
                lower = undefined;
              }
            }

            if (lower === undefined && upper === undefined) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);

              if (upper === undefined) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }

            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }

            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
            }

            return baseRandom(lower, upper);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the camel cased string.
           * @example
           *
           * _.camelCase('Foo Bar');
           * // => 'fooBar'
           *
           * _.camelCase('--foo-bar--');
           * // => 'fooBar'
           *
           * _.camelCase('__FOO_BAR__');
           * // => 'fooBar'
           */


          var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? capitalize(word) : word);
          });
          /**
           * Converts the first character of `string` to upper case and the remaining
           * to lower case.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to capitalize.
           * @returns {string} Returns the capitalized string.
           * @example
           *
           * _.capitalize('FRED');
           * // => 'Fred'
           */

          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          /**
           * Deburrs `string` by converting
           * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
           * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
           * letters to basic Latin letters and removing
           * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to deburr.
           * @returns {string} Returns the deburred string.
           * @example
           *
           * _.deburr('déjà vu');
           * // => 'deja vu'
           */


          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
          }
          /**
           * Checks if `string` ends with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=string.length] The position to search up to.
           * @returns {boolean} Returns `true` if `string` ends with `target`,
           *  else `false`.
           * @example
           *
           * _.endsWith('abc', 'c');
           * // => true
           *
           * _.endsWith('abc', 'b');
           * // => false
           *
           * _.endsWith('abc', 'b', 2);
           * // => true
           */


          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          /**
           * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
           * corresponding HTML entities.
           *
           * **Note:** No other characters are escaped. To escape additional
           * characters use a third-party library like [_he_](https://mths.be/he).
           *
           * Though the ">" character is escaped for symmetry, characters like
           * ">" and "/" don't need escaping in HTML and have no special meaning
           * unless they're part of a tag or unquoted attribute value. See
           * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
           * (under "semi-related fun fact") for more details.
           *
           * When working with HTML you should always
           * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
           * XSS vectors.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('fred, barney, & pebbles');
           * // => 'fred, barney, &amp; pebbles'
           */


          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          /**
           * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
           * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escapeRegExp('[lodash](https://lodash.com/)');
           * // => '\[lodash\]\(https://lodash\.com/\)'
           */


          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
          }
          /**
           * Converts `string` to
           * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the kebab cased string.
           * @example
           *
           * _.kebabCase('Foo Bar');
           * // => 'foo-bar'
           *
           * _.kebabCase('fooBar');
           * // => 'foo-bar'
           *
           * _.kebabCase('__FOO_BAR__');
           * // => 'foo-bar'
           */


          var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
          });
          /**
           * Converts `string`, as space separated words, to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.lowerCase('--Foo-Bar--');
           * // => 'foo bar'
           *
           * _.lowerCase('fooBar');
           * // => 'foo bar'
           *
           * _.lowerCase('__FOO_BAR__');
           * // => 'foo bar'
           */

          var lowerCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toLowerCase();
          });
          /**
           * Converts the first character of `string` to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.lowerFirst('Fred');
           * // => 'fred'
           *
           * _.lowerFirst('FRED');
           * // => 'fRED'
           */

          var lowerFirst = createCaseFirst('toLowerCase');
          /**
           * Pads `string` on the left and right sides if it's shorter than `length`.
           * Padding characters are truncated if they can't be evenly divided by `length`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.pad('abc', 8);
           * // => '  abc   '
           *
           * _.pad('abc', 8, '_-');
           * // => '_-abc_-_'
           *
           * _.pad('abc', 3);
           * // => 'abc'
           */

          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;

            if (!length || strLength >= length) {
              return string;
            }

            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          /**
           * Pads `string` on the right side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padEnd('abc', 6);
           * // => 'abc   '
           *
           * _.padEnd('abc', 6, '_-');
           * // => 'abc_-_'
           *
           * _.padEnd('abc', 3);
           * // => 'abc'
           */


          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          /**
           * Pads `string` on the left side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padStart('abc', 6);
           * // => '   abc'
           *
           * _.padStart('abc', 6, '_-');
           * // => '_-_abc'
           *
           * _.padStart('abc', 3);
           * // => 'abc'
           */


          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          /**
           * Converts `string` to an integer of the specified radix. If `radix` is
           * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
           * hexadecimal, in which case a `radix` of `16` is used.
           *
           * **Note:** This method aligns with the
           * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category String
           * @param {string} string The string to convert.
           * @param {number} [radix=10] The radix to interpret `value` by.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           *
           * _.map(['6', '08', '10'], _.parseInt);
           * // => [6, 8, 10]
           */


          function parseInt(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }

            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
          }
          /**
           * Repeats the given string `n` times.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to repeat.
           * @param {number} [n=1] The number of times to repeat the string.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the repeated string.
           * @example
           *
           * _.repeat('*', 3);
           * // => '***'
           *
           * _.repeat('abc', 2);
           * // => 'abcabc'
           *
           * _.repeat('abc', 0);
           * // => ''
           */


          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
              n = 1;
            } else {
              n = toInteger(n);
            }

            return baseRepeat(toString(string), n);
          }
          /**
           * Replaces matches for `pattern` in `string` with `replacement`.
           *
           * **Note:** This method is based on
           * [`String#replace`](https://mdn.io/String/replace).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to modify.
           * @param {RegExp|string} pattern The pattern to replace.
           * @param {Function|string} replacement The match replacement.
           * @returns {string} Returns the modified string.
           * @example
           *
           * _.replace('Hi Fred', 'Fred', 'Barney');
           * // => 'Hi Barney'
           */


          function replace() {
            var args = arguments,
                string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          /**
           * Converts `string` to
           * [snake case](https://en.wikipedia.org/wiki/Snake_case).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the snake cased string.
           * @example
           *
           * _.snakeCase('Foo Bar');
           * // => 'foo_bar'
           *
           * _.snakeCase('fooBar');
           * // => 'foo_bar'
           *
           * _.snakeCase('--FOO-BAR--');
           * // => 'foo_bar'
           */


          var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
          });
          /**
           * Splits `string` by `separator`.
           *
           * **Note:** This method is based on
           * [`String#split`](https://mdn.io/String/split).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to split.
           * @param {RegExp|string} separator The separator pattern to split by.
           * @param {number} [limit] The length to truncate results to.
           * @returns {Array} Returns the string segments.
           * @example
           *
           * _.split('a-b-c', '-', 2);
           * // => ['a', 'b']
           */

          function split(string, separator, limit) {
            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined;
            }

            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;

            if (!limit) {
              return [];
            }

            string = toString(string);

            if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);

              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }

            return string.split(separator, limit);
          }
          /**
           * Converts `string` to
           * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
           *
           * @static
           * @memberOf _
           * @since 3.1.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the start cased string.
           * @example
           *
           * _.startCase('--foo-bar--');
           * // => 'Foo Bar'
           *
           * _.startCase('fooBar');
           * // => 'Foo Bar'
           *
           * _.startCase('__FOO_BAR__');
           * // => 'FOO BAR'
           */


          var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + upperFirst(word);
          });
          /**
           * Checks if `string` starts with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=0] The position to search from.
           * @returns {boolean} Returns `true` if `string` starts with `target`,
           *  else `false`.
           * @example
           *
           * _.startsWith('abc', 'a');
           * // => true
           *
           * _.startsWith('abc', 'b');
           * // => false
           *
           * _.startsWith('abc', 'b', 1);
           * // => true
           */

          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          /**
           * Creates a compiled template function that can interpolate data properties
           * in "interpolate" delimiters, HTML-escape interpolated data properties in
           * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
           * properties may be accessed as free variables in the template. If a setting
           * object is given, it takes precedence over `_.templateSettings` values.
           *
           * **Note:** In the development build `_.template` utilizes
           * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
           * for easier debugging.
           *
           * For more information on precompiling templates see
           * [lodash's custom builds documentation](https://lodash.com/custom-builds).
           *
           * For more information on Chrome extension sandboxes see
           * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The template string.
           * @param {Object} [options={}] The options object.
           * @param {RegExp} [options.escape=_.templateSettings.escape]
           *  The HTML "escape" delimiter.
           * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
           *  The "evaluate" delimiter.
           * @param {Object} [options.imports=_.templateSettings.imports]
           *  An object to import into the template as free variables.
           * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
           *  The "interpolate" delimiter.
           * @param {string} [options.sourceURL='lodash.templateSources[n]']
           *  The sourceURL of the compiled template.
           * @param {string} [options.variable='obj']
           *  The data object variable name.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the compiled template function.
           * @example
           *
           * // Use the "interpolate" delimiter to create a compiled template.
           * var compiled = _.template('hello <%= user %>!');
           * compiled({ 'user': 'fred' });
           * // => 'hello fred!'
           *
           * // Use the HTML "escape" delimiter to escape data property values.
           * var compiled = _.template('<b><%- value %></b>');
           * compiled({ 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
           * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the internal `print` function in "evaluate" delimiters.
           * var compiled = _.template('<% print("hello " + user); %>!');
           * compiled({ 'user': 'barney' });
           * // => 'hello barney!'
           *
           * // Use the ES template literal delimiter as an "interpolate" delimiter.
           * // Disable support by replacing the "interpolate" delimiter.
           * var compiled = _.template('hello ${ user }!');
           * compiled({ 'user': 'pebbles' });
           * // => 'hello pebbles!'
           *
           * // Use backslashes to treat delimiters as plain text.
           * var compiled = _.template('<%= "\\<%- value %\\>" %>');
           * compiled({ 'value': 'ignored' });
           * // => '<%- value %>'
           *
           * // Use the `imports` option to import `jQuery` as `jq`.
           * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
           * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the `sourceURL` option to specify a custom sourceURL for the template.
           * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
           *
           * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
           * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           * //   var __t, __p = '';
           * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
           * //   return __p;
           * // }
           *
           * // Use custom template delimiters.
           * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
           * var compiled = _.template('hello {{ user }}!');
           * compiled({ 'user': 'mustache' });
           * // => 'hello mustache!'
           *
           * // Use the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and stack traces.
           * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */


          function template(string, options, guard) {
            // Based on John Resig's `tmpl` implementation
            // (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = lodash.templateSettings;

            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined;
            }

            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
                importsKeys = keys(imports),
                importsValues = baseValues(imports, importsKeys);
            var isEscaping,
                isEvaluating,
                index = 0,
                interpolate = options.interpolate || reNoMatch,
                source = "__p += '"; // Compile the regexp to match each delimiter.

            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
            // The sourceURL gets injected into the source that's eval-ed, so be careful
            // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
            // and escape the comment, thus injecting code that gets evaled.

            var sourceURL = '//# sourceURL=' + (hasOwnProperty.call(options, 'sourceURL') ? (options.sourceURL + '').replace(/\s/g, ' ') : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }

              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }

              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }

              index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
              // order to produce the correct `offset` value.

              return match;
            });
            source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.

            var variable = hasOwnProperty.call(options, 'variable') && options.variable;

            if (!variable) {
              source = 'with (obj) {\n' + source + '\n}\n';
            } // Cleanup code by stripping empty strings.


            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

            source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
            var result = attempt(function () {
              return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            }); // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.

            result.source = source;

            if (isError(result)) {
              throw result;
            }

            return result;
          }
          /**
           * Converts `string`, as a whole, to lower case just like
           * [String#toLowerCase](https://mdn.io/toLowerCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.toLower('--Foo-Bar--');
           * // => '--foo-bar--'
           *
           * _.toLower('fooBar');
           * // => 'foobar'
           *
           * _.toLower('__FOO_BAR__');
           * // => '__foo_bar__'
           */


          function toLower(value) {
            return toString(value).toLowerCase();
          }
          /**
           * Converts `string`, as a whole, to upper case just like
           * [String#toUpperCase](https://mdn.io/toUpperCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.toUpper('--foo-bar--');
           * // => '--FOO-BAR--'
           *
           * _.toUpper('fooBar');
           * // => 'FOOBAR'
           *
           * _.toUpper('__foo_bar__');
           * // => '__FOO_BAR__'
           */


          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          /**
           * Removes leading and trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trim('  abc  ');
           * // => 'abc'
           *
           * _.trim('-_-abc-_-', '_-');
           * // => 'abc'
           *
           * _.map(['  foo  ', '  bar  '], _.trim);
           * // => ['foo', 'bar']
           */


          function trim(string, chars, guard) {
            string = toString(string);

            if (string && (guard || chars === undefined)) {
              return string.replace(reTrim, '');
            }

            if (!string || !(chars = baseToString(chars))) {
              return string;
            }

            var strSymbols = stringToArray(string),
                chrSymbols = stringToArray(chars),
                start = charsStartIndex(strSymbols, chrSymbols),
                end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join('');
          }
          /**
           * Removes trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimEnd('  abc  ');
           * // => '  abc'
           *
           * _.trimEnd('-_-abc-_-', '_-');
           * // => '-_-abc'
           */


          function trimEnd(string, chars, guard) {
            string = toString(string);

            if (string && (guard || chars === undefined)) {
              return string.replace(reTrimEnd, '');
            }

            if (!string || !(chars = baseToString(chars))) {
              return string;
            }

            var strSymbols = stringToArray(string),
                end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join('');
          }
          /**
           * Removes leading whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimStart('  abc  ');
           * // => 'abc  '
           *
           * _.trimStart('-_-abc-_-', '_-');
           * // => 'abc-_-'
           */


          function trimStart(string, chars, guard) {
            string = toString(string);

            if (string && (guard || chars === undefined)) {
              return string.replace(reTrimStart, '');
            }

            if (!string || !(chars = baseToString(chars))) {
              return string;
            }

            var strSymbols = stringToArray(string),
                start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join('');
          }
          /**
           * Truncates `string` if it's longer than the given maximum string length.
           * The last characters of the truncated string are replaced with the omission
           * string which defaults to "...".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to truncate.
           * @param {Object} [options={}] The options object.
           * @param {number} [options.length=30] The maximum string length.
           * @param {string} [options.omission='...'] The string to indicate text is omitted.
           * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
           * @returns {string} Returns the truncated string.
           * @example
           *
           * _.truncate('hi-diddly-ho there, neighborino');
           * // => 'hi-diddly-ho there, neighbo...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': ' '
           * });
           * // => 'hi-diddly-ho there,...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': /,? +/
           * });
           * // => 'hi-diddly-ho there...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'omission': ' [...]'
           * });
           * // => 'hi-diddly-ho there, neig [...]'
           */


          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH,
                omission = DEFAULT_TRUNC_OMISSION;

            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? toInteger(options.length) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            }

            string = toString(string);
            var strLength = string.length;

            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }

            if (length >= strLength) {
              return string;
            }

            var end = length - stringSize(omission);

            if (end < 1) {
              return omission;
            }

            var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

            if (separator === undefined) {
              return result + omission;
            }

            if (strSymbols) {
              end += result.length - end;
            }

            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match,
                    substring = result;

                if (!separator.global) {
                  separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                }

                separator.lastIndex = 0;

                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }

                result = result.slice(0, newEnd === undefined ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result.lastIndexOf(separator);

              if (index > -1) {
                result = result.slice(0, index);
              }
            }

            return result + omission;
          }
          /**
           * The inverse of `_.escape`; this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
           * their corresponding characters.
           *
           * **Note:** No other HTML entities are unescaped. To unescape additional
           * HTML entities use a third-party library like [_he_](https://mths.be/he).
           *
           * @static
           * @memberOf _
           * @since 0.6.0
           * @category String
           * @param {string} [string=''] The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('fred, barney, &amp; pebbles');
           * // => 'fred, barney, & pebbles'
           */


          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          /**
           * Converts `string`, as space separated words, to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.upperCase('--foo-bar');
           * // => 'FOO BAR'
           *
           * _.upperCase('fooBar');
           * // => 'FOO BAR'
           *
           * _.upperCase('__foo_bar__');
           * // => 'FOO BAR'
           */


          var upperCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toUpperCase();
          });
          /**
           * Converts the first character of `string` to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.upperFirst('fred');
           * // => 'Fred'
           *
           * _.upperFirst('FRED');
           * // => 'FRED'
           */

          var upperFirst = createCaseFirst('toUpperCase');
          /**
           * Splits `string` into an array of its words.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {RegExp|string} [pattern] The pattern to match words.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the words of `string`.
           * @example
           *
           * _.words('fred, barney, & pebbles');
           * // => ['fred', 'barney', 'pebbles']
           *
           * _.words('fred, barney, & pebbles', /[^, ]+/g);
           * // => ['fred', 'barney', '&', 'pebbles']
           */

          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;

            if (pattern === undefined) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }

            return string.match(pattern) || [];
          }
          /*------------------------------------------------------------------------*/

          /**
           * Attempts to invoke `func`, returning either the result or the caught error
           * object. Any additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Function} func The function to attempt.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {*} Returns the `func` result or error object.
           * @example
           *
           * // Avoid throwing errors for invalid selectors.
           * var elements = _.attempt(function(selector) {
           *   return document.querySelectorAll(selector);
           * }, '>_>');
           *
           * if (_.isError(elements)) {
           *   elements = [];
           * }
           */


          var attempt = baseRest(function (func, args) {
            try {
              return apply(func, undefined, args);
            } catch (e) {
              return isError(e) ? e : new Error(e);
            }
          });
          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method.
           *
           * **Note:** This method doesn't set the "length" property of bound functions.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...(string|string[])} methodNames The object method names to bind.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'click': function() {
           *     console.log('clicked ' + this.label);
           *   }
           * };
           *
           * _.bindAll(view, ['click']);
           * jQuery(element).on('click', view.click);
           * // => Logs 'clicked docs' when clicked.
           */

          var bindAll = flatRest(function (object, methodNames) {
            arrayEach(methodNames, function (key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          /**
           * Creates a function that iterates over `pairs` and invokes the corresponding
           * function of the first predicate to return truthy. The predicate-function
           * pairs are invoked with the `this` binding and arguments of the created
           * function.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Array} pairs The predicate-function pairs.
           * @returns {Function} Returns the new composite function.
           * @example
           *
           * var func = _.cond([
           *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
           *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
           *   [_.stubTrue,                      _.constant('no match')]
           * ]);
           *
           * func({ 'a': 1, 'b': 2 });
           * // => 'matches A'
           *
           * func({ 'a': 0, 'b': 1 });
           * // => 'matches B'
           *
           * func({ 'a': '1', 'b': '2' });
           * // => 'no match'
           */

          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length,
                toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function (pair) {
              if (typeof pair[1] != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }

              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function (args) {
              var index = -1;

              while (++index < length) {
                var pair = pairs[index];

                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          /**
           * Creates a function that invokes the predicate properties of `source` with
           * the corresponding property values of a given object, returning `true` if
           * all predicates return truthy, else `false`.
           *
           * **Note:** The created function is equivalent to `_.conformsTo` with
           * `source` partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 2, 'b': 1 },
           *   { 'a': 1, 'b': 2 }
           * ];
           *
           * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
           * // => [{ 'a': 1, 'b': 2 }]
           */


          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new constant function.
           * @example
           *
           * var objects = _.times(2, _.constant({ 'a': 1 }));
           *
           * console.log(objects);
           * // => [{ 'a': 1 }, { 'a': 1 }]
           *
           * console.log(objects[0] === objects[1]);
           * // => true
           */


          function constant(value) {
            return function () {
              return value;
            };
          }
          /**
           * Checks `value` to determine whether a default value should be returned in
           * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
           * or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Util
           * @param {*} value The value to check.
           * @param {*} defaultValue The default value.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * _.defaultTo(1, 10);
           * // => 1
           *
           * _.defaultTo(undefined, 10);
           * // => 10
           */


          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          /**
           * Creates a function that returns the result of invoking the given functions
           * with the `this` binding of the created function, where each successive
           * invocation is supplied the return value of the previous.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flowRight
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flow([_.add, square]);
           * addSquare(1, 2);
           * // => 9
           */


          var flow = createFlow();
          /**
           * This method is like `_.flow` except that it creates a function that
           * invokes the given functions from right to left.
           *
           * @static
           * @since 3.0.0
           * @memberOf _
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flow
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flowRight([square, _.add]);
           * addSquare(1, 2);
           * // => 9
           */

          var flowRight = createFlow(true);
          /**
           * This method returns the first argument it receives.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'a': 1 };
           *
           * console.log(_.identity(object) === object);
           * // => true
           */

          function identity(value) {
            return value;
          }
          /**
           * Creates a function that invokes `func` with the arguments of the created
           * function. If `func` is a property name, the created function returns the
           * property value for a given element. If `func` is an array or object, the
           * created function returns `true` for elements that contain the equivalent
           * source properties, otherwise it returns `false`.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Util
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @returns {Function} Returns the callback.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
           * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, _.iteratee(['user', 'fred']));
           * // => [{ 'user': 'fred', 'age': 40 }]
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, _.iteratee('user'));
           * // => ['barney', 'fred']
           *
           * // Create custom iteratee shorthands.
           * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
           *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
           *     return func.test(string);
           *   };
           * });
           *
           * _.filter(['abc', 'def'], /ef/);
           * // => ['def']
           */


          function iteratee(func) {
            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that performs a partial deep comparison between a given
           * object and `source`, returning `true` if the given object has equivalent
           * property values, else `false`.
           *
           * **Note:** The created function is equivalent to `_.isMatch` with `source`
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * **Note:** Multiple values can be checked by combining several matchers
           * using `_.overSome`
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
           * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
           *
           * // Checking for several possible values
           * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
           * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
           */


          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that performs a partial deep comparison between the
           * value at `path` of a given object to `srcValue`, returning `true` if the
           * object value is equivalent, else `false`.
           *
           * **Note:** Partial comparisons will match empty array and empty object
           * `srcValue` values against any array or object value, respectively. See
           * `_.isEqual` for a list of supported value comparisons.
           *
           * **Note:** Multiple values can be checked by combining several matchers
           * using `_.overSome`
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.find(objects, _.matchesProperty('a', 4));
           * // => { 'a': 4, 'b': 5, 'c': 6 }
           *
           * // Checking for several possible values
           * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
           * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
           */


          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that invokes the method at `path` of a given object.
           * Any additional arguments are provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': _.constant(2) } },
           *   { 'a': { 'b': _.constant(1) } }
           * ];
           *
           * _.map(objects, _.method('a.b'));
           * // => [2, 1]
           *
           * _.map(objects, _.method(['a', 'b']));
           * // => [2, 1]
           */


          var method = baseRest(function (path, args) {
            return function (object) {
              return baseInvoke(object, path, args);
            };
          });
          /**
           * The opposite of `_.method`; this method creates a function that invokes
           * the method at a given path of `object`. Any additional arguments are
           * provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Object} object The object to query.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var array = _.times(3, _.constant),
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.methodOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
           * // => [2, 0]
           */

          var methodOf = baseRest(function (object, args) {
            return function (path) {
              return baseInvoke(object, path, args);
            };
          });
          /**
           * Adds all own enumerable string keyed function properties of a source
           * object to the destination object. If `object` is a function, then methods
           * are added to its prototype as well.
           *
           * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
           * avoid conflicts caused by modifying the original.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Function|Object} [object=lodash] The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
           * @returns {Function|Object} Returns `object`.
           * @example
           *
           * function vowels(string) {
           *   return _.filter(string, function(v) {
           *     return /[aeiou]/i.test(v);
           *   });
           * }
           *
           * _.mixin({ 'vowels': vowels });
           * _.vowels('fred');
           * // => ['e']
           *
           * _('fred').vowels().value();
           * // => ['e']
           *
           * _.mixin({ 'vowels': vowels }, { 'chain': false });
           * _('fred').vowels();
           * // => ['e']
           */

          function mixin(object, source, options) {
            var props = keys(source),
                methodNames = baseFunctions(source, props);

            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }

            var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
                isFunc = isFunction(object);
            arrayEach(methodNames, function (methodName) {
              var func = source[methodName];
              object[methodName] = func;

              if (isFunc) {
                object.prototype[methodName] = function () {
                  var chainAll = this.__chain__;

                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = copyArray(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }

                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          /**
           * Reverts the `_` variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */


          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }

            return this;
          }
          /**
           * This method returns `undefined`.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Util
           * @example
           *
           * _.times(2, _.noop);
           * // => [undefined, undefined]
           */


          function noop() {// No operation performed.
          }
          /**
           * Creates a function that gets the argument at index `n`. If `n` is negative,
           * the nth argument from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [n=0] The index of the argument to return.
           * @returns {Function} Returns the new pass-thru function.
           * @example
           *
           * var func = _.nthArg(1);
           * func('a', 'b', 'c', 'd');
           * // => 'b'
           *
           * var func = _.nthArg(-2);
           * func('a', 'b', 'c', 'd');
           * // => 'c'
           */


          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function (args) {
              return baseNth(args, n);
            });
          }
          /**
           * Creates a function that invokes `iteratees` with the arguments it receives
           * and returns their results.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.over([Math.max, Math.min]);
           *
           * func(1, 2, 3, 4);
           * // => [4, 1]
           */


          var over = createOver(arrayMap);
          /**
           * Creates a function that checks if **all** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * Following shorthands are possible for providing predicates.
           * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
           * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overEvery([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => false
           *
           * func(NaN);
           * // => false
           */

          var overEvery = createOver(arrayEvery);
          /**
           * Creates a function that checks if **any** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * Following shorthands are possible for providing predicates.
           * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
           * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overSome([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => true
           *
           * func(NaN);
           * // => false
           *
           * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
           * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
           */

          var overSome = createOver(arraySome);
          /**
           * Creates a function that returns the value at `path` of a given object.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': 2 } },
           *   { 'a': { 'b': 1 } }
           * ];
           *
           * _.map(objects, _.property('a.b'));
           * // => [2, 1]
           *
           * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
           * // => [1, 2]
           */

          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          /**
           * The opposite of `_.property`; this method creates a function that returns
           * the value at a given path of `object`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} object The object to query.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var array = [0, 1, 2],
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
           * // => [2, 0]
           */


          function propertyOf(object) {
            return function (path) {
              return object == null ? undefined : baseGet(object, path);
            };
          }
          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to, but not including, `end`. A step of `-1` is used if a negative
           * `start` is specified without an `end` or `step`. If `end` is not specified,
           * it's set to `start` with `start` then set to `0`.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.rangeRight
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(-4);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */


          var range = createRange();
          /**
           * This method is like `_.range` except that it populates values in
           * descending order.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.range
           * @example
           *
           * _.rangeRight(4);
           * // => [3, 2, 1, 0]
           *
           * _.rangeRight(-4);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 5);
           * // => [4, 3, 2, 1]
           *
           * _.rangeRight(0, 20, 5);
           * // => [15, 10, 5, 0]
           *
           * _.rangeRight(0, -4, -1);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.rangeRight(0);
           * // => []
           */

          var rangeRight = createRange(true);
          /**
           * This method returns a new empty array.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Array} Returns the new empty array.
           * @example
           *
           * var arrays = _.times(2, _.stubArray);
           *
           * console.log(arrays);
           * // => [[], []]
           *
           * console.log(arrays[0] === arrays[1]);
           * // => false
           */

          function stubArray() {
            return [];
          }
          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */


          function stubFalse() {
            return false;
          }
          /**
           * This method returns a new empty object.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Object} Returns the new empty object.
           * @example
           *
           * var objects = _.times(2, _.stubObject);
           *
           * console.log(objects);
           * // => [{}, {}]
           *
           * console.log(objects[0] === objects[1]);
           * // => false
           */


          function stubObject() {
            return {};
          }
          /**
           * This method returns an empty string.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {string} Returns the empty string.
           * @example
           *
           * _.times(2, _.stubString);
           * // => ['', '']
           */


          function stubString() {
            return '';
          }
          /**
           * This method returns `true`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `true`.
           * @example
           *
           * _.times(2, _.stubTrue);
           * // => [true, true]
           */


          function stubTrue() {
            return true;
          }
          /**
           * Invokes the iteratee `n` times, returning an array of the results of
           * each invocation. The iteratee is invoked with one argument; (index).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.times(3, String);
           * // => ['0', '1', '2']
           *
           *  _.times(4, _.constant(0));
           * // => [0, 0, 0, 0]
           */


          function times(n, iteratee) {
            n = toInteger(n);

            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }

            var index = MAX_ARRAY_LENGTH,
                length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);

            while (++index < n) {
              iteratee(index);
            }

            return result;
          }
          /**
           * Converts `value` to a property path array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {*} value The value to convert.
           * @returns {Array} Returns the new property path array.
           * @example
           *
           * _.toPath('a.b.c');
           * // => ['a', 'b', 'c']
           *
           * _.toPath('a[0].b.c');
           * // => ['a', '0', 'b', 'c']
           */


          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }

            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          /**
           * Generates a unique ID. If `prefix` is given, the ID is appended to it.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {string} [prefix=''] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */


          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          /*------------------------------------------------------------------------*/

          /**
           * Adds two numbers.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {number} augend The first number in an addition.
           * @param {number} addend The second number in an addition.
           * @returns {number} Returns the total.
           * @example
           *
           * _.add(6, 4);
           * // => 10
           */


          var add = createMathOperation(function (augend, addend) {
            return augend + addend;
          }, 0);
          /**
           * Computes `number` rounded up to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round up.
           * @param {number} [precision=0] The precision to round up to.
           * @returns {number} Returns the rounded up number.
           * @example
           *
           * _.ceil(4.006);
           * // => 5
           *
           * _.ceil(6.004, 2);
           * // => 6.01
           *
           * _.ceil(6040, -2);
           * // => 6100
           */

          var ceil = createRound('ceil');
          /**
           * Divide two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} dividend The first number in a division.
           * @param {number} divisor The second number in a division.
           * @returns {number} Returns the quotient.
           * @example
           *
           * _.divide(6, 4);
           * // => 1.5
           */

          var divide = createMathOperation(function (dividend, divisor) {
            return dividend / divisor;
          }, 1);
          /**
           * Computes `number` rounded down to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round down.
           * @param {number} [precision=0] The precision to round down to.
           * @returns {number} Returns the rounded down number.
           * @example
           *
           * _.floor(4.006);
           * // => 4
           *
           * _.floor(0.046, 2);
           * // => 0.04
           *
           * _.floor(4060, -2);
           * // => 4000
           */

          var floor = createRound('floor');
          /**
           * Computes the maximum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * _.max([]);
           * // => undefined
           */

          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
          }
          /**
           * This method is like `_.max` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.maxBy(objects, function(o) { return o.n; });
           * // => { 'n': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.maxBy(objects, 'n');
           * // => { 'n': 2 }
           */


          function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
          }
          /**
           * Computes the mean of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the mean.
           * @example
           *
           * _.mean([4, 2, 8, 6]);
           * // => 5
           */


          function mean(array) {
            return baseMean(array, identity);
          }
          /**
           * This method is like `_.mean` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be averaged.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the mean.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.meanBy(objects, function(o) { return o.n; });
           * // => 5
           *
           * // The `_.property` iteratee shorthand.
           * _.meanBy(objects, 'n');
           * // => 5
           */


          function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2));
          }
          /**
           * Computes the minimum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * _.min([]);
           * // => undefined
           */


          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
          }
          /**
           * This method is like `_.min` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.minBy(objects, function(o) { return o.n; });
           * // => { 'n': 1 }
           *
           * // The `_.property` iteratee shorthand.
           * _.minBy(objects, 'n');
           * // => { 'n': 1 }
           */


          function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
          }
          /**
           * Multiply two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} multiplier The first number in a multiplication.
           * @param {number} multiplicand The second number in a multiplication.
           * @returns {number} Returns the product.
           * @example
           *
           * _.multiply(6, 4);
           * // => 24
           */


          var multiply = createMathOperation(function (multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          /**
           * Computes `number` rounded to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round.
           * @param {number} [precision=0] The precision to round to.
           * @returns {number} Returns the rounded number.
           * @example
           *
           * _.round(4.006);
           * // => 4
           *
           * _.round(4.006, 2);
           * // => 4.01
           *
           * _.round(4060, -2);
           * // => 4100
           */

          var round = createRound('round');
          /**
           * Subtract two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {number} minuend The first number in a subtraction.
           * @param {number} subtrahend The second number in a subtraction.
           * @returns {number} Returns the difference.
           * @example
           *
           * _.subtract(6, 4);
           * // => 2
           */

          var subtract = createMathOperation(function (minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          /**
           * Computes the sum of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.sum([4, 2, 8, 6]);
           * // => 20
           */

          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          /**
           * This method is like `_.sum` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be summed.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the sum.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.sumBy(objects, function(o) { return o.n; });
           * // => 20
           *
           * // The `_.property` iteratee shorthand.
           * _.sumBy(objects, 'n');
           * // => 20
           */


          function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
          }
          /*------------------------------------------------------------------------*/
          // Add methods that return wrapped values in chain sequences.


          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith; // Add aliases.

          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith; // Add methods to `lodash.prototype`.

          mixin(lodash, lodash);
          /*------------------------------------------------------------------------*/
          // Add methods that return unwrapped values in chain sequences.

          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst; // Add aliases.

          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), {
            'chain': false
          });
          /*------------------------------------------------------------------------*/

          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type {string}
           */

          lodash.VERSION = VERSION; // Assign default placeholders.

          arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
            lodash[methodName].placeholder = lodash;
          }); // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.

          arrayEach(['drop', 'take'], function (methodName, index) {
            LazyWrapper.prototype[methodName] = function (n) {
              n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
              var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();

              if (result.__filtered__) {
                result.__takeCount__ = nativeMin(n, result.__takeCount__);
              } else {
                result.__views__.push({
                  'size': nativeMin(n, MAX_ARRAY_LENGTH),
                  'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                });
              }

              return result;
            };

            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
              return this.reverse()[methodName](n).reverse();
            };
          }); // Add `LazyWrapper` methods that accept an `iteratee` value.

          arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
            var type = index + 1,
                isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

            LazyWrapper.prototype[methodName] = function (iteratee) {
              var result = this.clone();

              result.__iteratees__.push({
                'iteratee': getIteratee(iteratee, 3),
                'type': type
              });

              result.__filtered__ = result.__filtered__ || isFilter;
              return result;
            };
          }); // Add `LazyWrapper` methods for `_.head` and `_.last`.

          arrayEach(['head', 'last'], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');

            LazyWrapper.prototype[methodName] = function () {
              return this[takeName](1).value()[0];
            };
          }); // Add `LazyWrapper` methods for `_.initial` and `_.tail`.

          arrayEach(['initial', 'tail'], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');

            LazyWrapper.prototype[methodName] = function () {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });

          LazyWrapper.prototype.compact = function () {
            return this.filter(identity);
          };

          LazyWrapper.prototype.find = function (predicate) {
            return this.filter(predicate).head();
          };

          LazyWrapper.prototype.findLast = function (predicate) {
            return this.reverse().find(predicate);
          };

          LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
            if (typeof path == 'function') {
              return new LazyWrapper(this);
            }

            return this.map(function (value) {
              return baseInvoke(value, path, args);
            });
          });

          LazyWrapper.prototype.reject = function (predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };

          LazyWrapper.prototype.slice = function (start, end) {
            start = toInteger(start);
            var result = this;

            if (result.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result);
            }

            if (start < 0) {
              result = result.takeRight(-start);
            } else if (start) {
              result = result.drop(start);
            }

            if (end !== undefined) {
              end = toInteger(end);
              result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }

            return result;
          };

          LazyWrapper.prototype.takeRightWhile = function (predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };

          LazyWrapper.prototype.toArray = function () {
            return this.take(MAX_ARRAY_LENGTH);
          }; // Add `LazyWrapper` methods to `lodash.prototype`.


          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                isTaker = /^(?:head|last)$/.test(methodName),
                lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
                retUnwrapped = isTaker || /^find/.test(methodName);

            if (!lodashFunc) {
              return;
            }

            lodash.prototype[methodName] = function () {
              var value = this.__wrapped__,
                  args = isTaker ? [1] : arguments,
                  isLazy = value instanceof LazyWrapper,
                  iteratee = args[0],
                  useLazy = isLazy || isArray(value);

              var interceptor = function interceptor(value) {
                var result = lodashFunc.apply(lodash, arrayPush([value], args));
                return isTaker && chainAll ? result[0] : result;
              };

              if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                isLazy = useLazy = false;
              }

              var chainAll = this.__chain__,
                  isHybrid = !!this.__actions__.length,
                  isUnwrapped = retUnwrapped && !chainAll,
                  onlyLazy = isLazy && !isHybrid;

              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result = func.apply(value, args);

                result.__actions__.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': undefined
                });

                return new LodashWrapper(result, chainAll);
              }

              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }

              result = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
            };
          }); // Add `Array` methods to `lodash.prototype`.

          arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
            var func = arrayProto[methodName],
                chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                retUnwrapped = /^(?:pop|shift)$/.test(methodName);

            lodash.prototype[methodName] = function () {
              var args = arguments;

              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }

              return this[chainName](function (value) {
                return func.apply(isArray(value) ? value : [], args);
              });
            };
          }); // Map minified method names to their real names.

          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];

            if (lodashFunc) {
              var key = lodashFunc.name + '';

              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }

              realNames[key].push({
                'name': methodName,
                'func': lodashFunc
              });
            }
          });
          realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
            'name': 'wrapper',
            'func': undefined
          }]; // Add methods to `LazyWrapper`.

          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to the `lodash` wrapper.

          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases.

          lodash.prototype.first = lodash.prototype.head;

          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }

          return lodash;
        };
        /*--------------------------------------------------------------------------*/
        // Export lodash.


        var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like:


        if (true) {
          // Expose Lodash on the global object to prevent errors when Lodash is
          // loaded by a script tag in the presence of an AMD loader.
          // See http://requirejs.org/docs/errors.html#mismatch for more details.
          // Use `_.noConflict` to remove Lodash from the global object.
          root._ = _; // Define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module.

          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return _;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } // Check for `exports` after `define` in case a build optimizer adds it.
        else {}
      }).call(this);
      /* WEBPACK VAR INJECTION */
    }).call(this, __webpack_require__(
    /*! ./../webpack/buildin/module.js */
    "./node_modules/webpack/buildin/module.js")(module));
    /***/
  },

  /***/
  "./node_modules/ng2-completer/__ivy_ngcc__/esm2015/ng2-completer.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/ng2-completer/__ivy_ngcc__/esm2015/ng2-completer.js ***!
    \**************************************************************************/

  /*! exports provided: CompleterCmp, CompleterListItemCmp, CompleterService, CtrCompleter, CtrDropdown, CtrInput, CtrList, CtrRow, LocalData, LocalDataFactory, Ng2CompleterModule, RemoteData, RemoteDataFactory, ɵa, ɵb */

  /***/
  function node_modulesNg2Completer__ivy_ngcc__Esm2015Ng2CompleterJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompleterCmp", function () {
      return CompleterCmp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompleterListItemCmp", function () {
      return CompleterListItemCmp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompleterService", function () {
      return CompleterService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CtrCompleter", function () {
      return CtrCompleter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CtrDropdown", function () {
      return CtrDropdown;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CtrInput", function () {
      return CtrInput;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CtrList", function () {
      return CtrList;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CtrRow", function () {
      return CtrRow;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LocalData", function () {
      return LocalData;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LocalDataFactory", function () {
      return LocalDataFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Ng2CompleterModule", function () {
      return Ng2CompleterModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RemoteData", function () {
      return RemoteData;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RemoteDataFactory", function () {
      return RemoteDataFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return CtrListContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return CompleterBaseData;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_common_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/common/http */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js");
    /**
     * @license ng2-completer
     * MIT license
     */


    function CompleterListItemCmp_span_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var part_r1 = ctx.$implicit;

        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", part_r1.isMatch ? ctx_r0.matchClass : null);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](part_r1.text);
      }
    }

    var _c0 = function _c0(a0, a1) {
      return {
        "completer-title": a0,
        "completer-description": a1
      };
    };

    var _c1 = ["ctrInput"];

    function CompleterCmp_div_3_div_1_div_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 10);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r7._textSearching);
      }
    }

    function CompleterCmp_div_3_div_1_div_2_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 11);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r8._textNoResults);
      }
    }

    function CompleterCmp_div_3_div_1_div_3_div_2_img_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "img", 21);
      }

      if (rf & 2) {
        var item_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("src", item_r10.image, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"]);
      }
    }

    function CompleterCmp_div_3_div_1_div_3_div_2_div_2_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 22);
      }
    }

    function CompleterCmp_div_3_div_1_div_3_div_2_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 18);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CompleterCmp_div_3_div_1_div_3_div_2_img_1_Template, 1, 1, "img", 19);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CompleterCmp_div_3_div_1_div_3_div_2_div_2_Template, 1, 0, "div", 20);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var item_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", item_r10.image != "");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", item_r10.image === "");
      }
    }

    function CompleterCmp_div_3_div_1_div_3_completer_list_item_5_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "completer-list-item", 23);
      }

      if (rf & 2) {
        var item_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("text", item_r10.description)("matchClass", ctx_r13.matchClass)("searchStr", ctx_r13.searchStr)("type", "description");
      }
    }

    var _c2 = function _c2(a0) {
      return {
        "completer-item-text-image": a0
      };
    };

    function CompleterCmp_div_3_div_1_div_3_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 12);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 13);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CompleterCmp_div_3_div_1_div_3_div_2_Template, 3, 2, "div", 14);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "div", 15);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](4, "completer-list-item", 16);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, CompleterCmp_div_3_div_1_div_3_completer_list_item_5_Template, 1, 4, "completer-list-item", 17);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var item_r10 = ctx.$implicit;
        var rowIndex_r11 = ctx.index;

        var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ctrRow", rowIndex_r11)("dataItem", item_r10);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", item_r10.image || item_r10.image === "");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](9, _c2, item_r10.image || item_r10.image === ""));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("text", item_r10.title)("matchClass", ctx_r9.matchClass)("searchStr", ctx_r9.searchStr)("type", "title");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", item_r10.description && item_r10.description != "");
      }
    }

    function CompleterCmp_div_3_div_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CompleterCmp_div_3_div_1_div_1_Template, 2, 1, "div", 7);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CompleterCmp_div_3_div_1_div_2_Template, 2, 1, "div", 8);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, CompleterCmp_div_3_div_1_div_3_Template, 6, 11, "div", 9);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        var searchActive_r3 = ctx_r19.searching;
        var items_r2 = ctx_r19.results;

        var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", searchActive_r3 && ctx_r6.displaySearching);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !searchActive_r3 && (!items_r2 || (items_r2 == null ? null : items_r2.length) === 0));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", items_r2);
      }
    }

    function CompleterCmp_div_3_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CompleterCmp_div_3_div_1_Template, 4, 3, "div", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var items_r2 = ctx.results;
        var searchActive_r3 = ctx.searching;
        var isInitialized_r4 = ctx.searchInitialized;
        var isOpen_r5 = ctx.isOpen;

        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", isInitialized_r4 && isOpen_r5 && ((items_r2 == null ? null : items_r2.length) > 0 || ctx_r1.displayNoResults && !searchActive_r3 || searchActive_r3 && ctx_r1.displaySearching));
      }
    }

    var MAX_CHARS = 524288; // the default max length per the html maxlength attribute

    var MIN_SEARCH_LENGTH = 3;
    var PAUSE = 10;
    var TEXT_SEARCHING = "Searching...";
    var TEXT_NO_RESULTS = "No results found";
    var CLEAR_TIMEOUT = 50;

    function isNil(value) {
      return typeof value === "undefined" || value === null;
    }

    var CompleterBaseData =
    /*#__PURE__*/
    function (_rxjs__WEBPACK_IMPORT) {
      _inherits(CompleterBaseData, _rxjs__WEBPACK_IMPORT);

      var _super2 = _createSuper(CompleterBaseData);

      function CompleterBaseData() {
        var _this2;

        _classCallCheck(this, CompleterBaseData);

        _this2 = _super2.call(this);
        _this2._searchFields = null;
        _this2._titleField = null;
        _this2._descriptionField = undefined;
        _this2._imageField = undefined;
        return _this2;
      }

      _createClass(CompleterBaseData, [{
        key: "cancel",
        value: function cancel() {
          return;
        }
      }, {
        key: "searchFields",
        value: function searchFields(_searchFields) {
          this._searchFields = _searchFields;
          return this;
        }
      }, {
        key: "titleField",
        value: function titleField(_titleField) {
          this._titleField = _titleField;
          return this;
        }
      }, {
        key: "descriptionField",
        value: function descriptionField(_descriptionField) {
          this._descriptionField = _descriptionField;
          return this;
        }
      }, {
        key: "imageField",
        value: function imageField(_imageField) {
          this._imageField = _imageField;
          return this;
        }
      }, {
        key: "convertToItem",
        value: function convertToItem(data) {
          var image = null;
          var formattedText;
          var formattedDesc = null;

          if (this._titleField) {
            formattedText = this.extractTitle(data);
          } else {
            formattedText = data;
          }

          if (typeof formattedText !== "string") {
            formattedText = JSON.stringify(formattedText);
          }

          if (this._descriptionField) {
            formattedDesc = this.extractValue(data, this._descriptionField);
          }

          if (this._imageField) {
            image = this.extractValue(data, this._imageField);
          }

          if (isNil(formattedText)) {
            return null;
          }

          return {
            description: formattedDesc,
            image: image,
            originalObject: data,
            title: formattedText
          };
        }
      }, {
        key: "extractMatches",
        value: function extractMatches(data, term) {
          var _this3 = this;

          var matches = [];
          var searchFields = this._searchFields ? this._searchFields.split(",") : null;

          if (this._searchFields !== null && this._searchFields !== undefined && term !== "") {
            matches = data.filter(function (item) {
              var values = searchFields ? _this3.extractBySearchFields(searchFields, item) : [item];
              return values.some(function (value) {
                return value.toString().toLowerCase().indexOf(term.toString().toLowerCase()) >= 0;
              });
            });
          } else {
            matches = data;
          }

          return matches;
        }
      }, {
        key: "extractTitle",
        value: function extractTitle(item) {
          var _this4 = this;

          // split title fields and run extractValue for each and join with ' '
          if (!this._titleField) {
            return "";
          }

          return this._titleField.split(",").map(function (field) {
            return _this4.extractValue(item, field);
          }).reduce(function (acc, titlePart) {
            return acc ? "".concat(acc, " ").concat(titlePart) : titlePart;
          });
        }
      }, {
        key: "extractValue",
        value: function extractValue(obj, key) {
          var keys;
          var result;

          if (key) {
            keys = key.split(".");
            result = obj;

            var _iterator = _createForOfIteratorHelper(keys),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                key = _step.value;

                if (result) {
                  result = result[key];
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            result = obj;
          }

          return result;
        }
      }, {
        key: "processResults",
        value: function processResults(matches) {
          var i;
          var results = [];

          if (matches && matches.length > 0) {
            for (i = 0; i < matches.length; i++) {
              var item = this.convertToItem(matches[i]);

              if (item) {
                results.push(item);
              }
            }
          }

          return results;
        }
      }, {
        key: "extractBySearchFields",
        value: function extractBySearchFields(searchFields, item) {
          var _this5 = this;

          return searchFields.map(function (searchField) {
            return _this5.extractValue(item, searchField);
          }).filter(function (value) {
            return !!value;
          });
        }
      }]);

      return CompleterBaseData;
    }(rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]);

    var LocalData =
    /*#__PURE__*/
    function (_CompleterBaseData) {
      _inherits(LocalData, _CompleterBaseData);

      var _super3 = _createSuper(LocalData);

      function LocalData() {
        var _this6;

        _classCallCheck(this, LocalData);

        _this6 = _super3.call(this);
        _this6.dataSourceChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        _this6._data = [];
        _this6.savedTerm = null;
        return _this6;
      }

      _createClass(LocalData, [{
        key: "data",
        value: function data(_data) {
          var _this7 = this;

          if (_data instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
            var data$ = _data;
            data$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["catchError"])(function () {
              return [];
            })).subscribe(function (res) {
              _this7._data = res;

              if (_this7.savedTerm) {
                _this7.search(_this7.savedTerm);
              }

              _this7.dataSourceChange.emit();
            });
          } else {
            this._data = _data;
          }

          this.dataSourceChange.emit();
          return this;
        }
      }, {
        key: "search",
        value: function search(term) {
          if (!this._data) {
            this.savedTerm = term;
          } else {
            this.savedTerm = null;
            var matches = this.extractMatches(this._data, term);
            this.next(this.processResults(matches));
          }
        }
      }, {
        key: "convertToItem",
        value: function convertToItem(data) {
          return _get(_getPrototypeOf(LocalData.prototype), "convertToItem", this).call(this, data);
        }
      }]);

      return LocalData;
    }(CompleterBaseData);

    var RemoteData =
    /*#__PURE__*/
    function (_CompleterBaseData2) {
      _inherits(RemoteData, _CompleterBaseData2);

      var _super4 = _createSuper(RemoteData);

      function RemoteData(http) {
        var _this8;

        _classCallCheck(this, RemoteData);

        _this8 = _super4.call(this);
        _this8.http = http;
        _this8.dataSourceChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        _this8._remoteUrl = null;
        _this8.remoteSearch = null;
        _this8._urlFormater = null;
        _this8._dataField = null;
        return _this8;
      }

      _createClass(RemoteData, [{
        key: "remoteUrl",
        value: function remoteUrl(_remoteUrl) {
          this._remoteUrl = _remoteUrl;
          this.dataSourceChange.emit();
          return this;
        }
      }, {
        key: "urlFormater",
        value: function urlFormater(_urlFormater) {
          this._urlFormater = _urlFormater;
        }
      }, {
        key: "dataField",
        value: function dataField(_dataField) {
          this._dataField = _dataField;
        }
      }, {
        key: "requestOptions",
        value: function requestOptions(_requestOptions) {
          this._requestOptions = _requestOptions;
        }
      }, {
        key: "search",
        value: function search(term) {
          var _this9 = this;

          this.cancel(); // let params = {};

          var url = "";

          if (this._urlFormater) {
            url = this._urlFormater(term);
          } else {
            url = this._remoteUrl + encodeURIComponent(term);
          }

          this.remoteSearch = this.http.get(url, Object.assign({}, this._requestOptions)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["map"])(function (data) {
            var matches = _this9.extractValue(data, _this9._dataField);

            return _this9.extractMatches(matches, term);
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["catchError"])(function () {
            return [];
          })).subscribe(function (matches) {
            var results = _this9.processResults(matches);

            _this9.next(results);
          });
        }
      }, {
        key: "cancel",
        value: function cancel() {
          if (this.remoteSearch) {
            this.remoteSearch.unsubscribe();
          }
        }
      }, {
        key: "convertToItem",
        value: function convertToItem(data) {
          return _get(_getPrototypeOf(RemoteData.prototype), "convertToItem", this).call(this, data);
        }
      }]);

      return RemoteData;
    }(CompleterBaseData);

    var LocalDataFactory =
    /*#__PURE__*/
    function () {
      function LocalDataFactory() {
        _classCallCheck(this, LocalDataFactory);
      }

      _createClass(LocalDataFactory, [{
        key: "create",
        value: function create() {
          return new LocalData();
        }
      }]);

      return LocalDataFactory;
    }();

    LocalDataFactory.ɵfac = function LocalDataFactory_Factory(t) {
      return new (t || LocalDataFactory)();
    };

    LocalDataFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: LocalDataFactory,
      factory: LocalDataFactory.ɵfac
    });

    var RemoteDataFactory =
    /*#__PURE__*/
    function () {
      function RemoteDataFactory(http) {
        _classCallCheck(this, RemoteDataFactory);

        this.http = http;
      }

      _createClass(RemoteDataFactory, [{
        key: "create",
        value: function create() {
          return new RemoteData(this.http);
        }
      }]);

      return RemoteDataFactory;
    }();

    RemoteDataFactory.ɵfac = function RemoteDataFactory_Factory(t) {
      return new (t || RemoteDataFactory)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_4__["HttpClient"]));
    };

    RemoteDataFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: RemoteDataFactory,
      factory: RemoteDataFactory.ɵfac
    });
    RemoteDataFactory = Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_4__["HttpClient"]])], RemoteDataFactory);

    var CompleterService =
    /*#__PURE__*/
    function () {
      function CompleterService(localDataFactory, // Using any instead of () => LocalData because of AoT errors
      remoteDataFactory // Using any instead of () => LocalData because of AoT errors
      ) {
        _classCallCheck(this, CompleterService);

        this.localDataFactory = localDataFactory;
        this.remoteDataFactory = remoteDataFactory;
      }

      _createClass(CompleterService, [{
        key: "local",
        value: function local(data) {
          var searchFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var titleField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
          var localData = this.localDataFactory.create();
          return localData.data(data).searchFields(searchFields).titleField(titleField);
        }
      }, {
        key: "remote",
        value: function remote(url) {
          var searchFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var titleField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
          var remoteData = this.remoteDataFactory.create();
          return remoteData.remoteUrl(url).searchFields(searchFields).titleField(titleField);
        }
      }]);

      return CompleterService;
    }();

    CompleterService.ɵfac = function CompleterService_Factory(t) {
      return new (t || CompleterService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](LocalDataFactory), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](RemoteDataFactory // Using any instead of () => LocalData because of AoT errors
      ));
    };

    CompleterService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: CompleterService,
      factory: CompleterService.ɵfac
    });
    CompleterService = Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [LocalDataFactory, RemoteDataFactory // Using any instead of () => LocalData because of AoT errors
    ])], CompleterService);

    var CtrCompleter =
    /*#__PURE__*/
    function () {
      function CtrCompleter() {
        _classCallCheck(this, CtrCompleter);

        this.selected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.highlighted = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.dataSourceChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.list = null;
        this.dropdown = null;
        this._hasHighlighted = false;
        this._hasSelected = false;
        this._cancelBlur = false;
        this._isOpen = false;
        this._autoHighlightIndex = null;
      }

      _createClass(CtrCompleter, [{
        key: "registerList",
        value: function registerList(list) {
          this.list = list;
        }
      }, {
        key: "registerDropdown",
        value: function registerDropdown(dropdown) {
          this.dropdown = dropdown;
        }
      }, {
        key: "onHighlighted",
        value: function onHighlighted(item) {
          this.highlighted.emit(item);
          this._hasHighlighted = !!item;
        }
      }, {
        key: "onSelected",
        value: function onSelected(item) {
          var clearList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          this.selected.emit(item);

          if (item) {
            this._hasSelected = true;
          }

          if (clearList) {
            this.clear();
          }
        }
      }, {
        key: "onDataSourceChange",
        value: function onDataSourceChange() {
          if (this.hasSelected) {
            this.selected.emit(null);
            this._hasSelected = false;
          }

          this.dataSourceChange.emit();
        }
      }, {
        key: "search",
        value: function search(term) {
          if (this._hasSelected) {
            this.selected.emit(null);
            this._hasSelected = false;
          }

          if (this.list) {
            this.list.search(term);
          }
        }
      }, {
        key: "clear",
        value: function clear() {
          this._hasHighlighted = false;
          this.isOpen = false;

          if (this.dropdown) {
            this.dropdown.clear();
          }

          if (this.list) {
            this.list.clear();
          }
        }
      }, {
        key: "selectCurrent",
        value: function selectCurrent() {
          if (this.dropdown) {
            this.dropdown.selectCurrent();
          }
        }
      }, {
        key: "nextRow",
        value: function nextRow() {
          if (this.dropdown) {
            this.dropdown.nextRow();
          }
        }
      }, {
        key: "prevRow",
        value: function prevRow() {
          if (this.dropdown) {
            this.dropdown.prevRow();
          }
        }
      }, {
        key: "hasHighlighted",
        value: function hasHighlighted() {
          return this._hasHighlighted;
        }
      }, {
        key: "cancelBlur",
        value: function cancelBlur(cancel) {
          this._cancelBlur = cancel;
        }
      }, {
        key: "isCancelBlur",
        value: function isCancelBlur() {
          return this._cancelBlur;
        }
      }, {
        key: "open",
        value: function open() {
          if (!this._isOpen && !!this.list) {
            this.isOpen = true;
            this.list.open();
          }
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this._isOpen;
        },
        set: function set(open) {
          this._isOpen = open;
          this.opened.emit(this._isOpen);

          if (this.list) {
            this.list.isOpen(open);
          }
        }
      }, {
        key: "autoHighlightIndex",
        get: function get() {
          return this._autoHighlightIndex;
        },
        set: function set(index) {
          this._autoHighlightIndex = index;

          if (this.dropdown) {
            this.dropdown.highlightRow(this._autoHighlightIndex);
          }
        }
      }, {
        key: "hasSelected",
        get: function get() {
          return this._hasSelected;
        }
      }]);

      return CtrCompleter;
    }();

    CtrCompleter.ɵfac = function CtrCompleter_Factory(t) {
      return new (t || CtrCompleter)();
    };

    CtrCompleter.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
      type: CtrCompleter,
      selectors: [["", "ctrCompleter", ""]],
      outputs: {
        selected: "selected",
        highlighted: "highlighted",
        opened: "opened",
        dataSourceChange: "dataSourceChange"
      }
    });
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrCompleter.prototype, "selected", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrCompleter.prototype, "highlighted", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrCompleter.prototype, "opened", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrCompleter.prototype, "dataSourceChange", void 0);

    var CtrRowItem = function CtrRowItem(row, index) {
      _classCallCheck(this, CtrRowItem);

      this.row = row;
      this.index = index;
    };

    var CtrDropdown =
    /*#__PURE__*/
    function () {
      function CtrDropdown(completer, el, zone) {
        _classCallCheck(this, CtrDropdown);

        this.completer = completer;
        this.el = el;
        this.zone = zone;
        this.rows = [];
        this.isScrollOn = false;
        this._rowMouseDown = false;
        this.completer.registerDropdown(this);
      }

      _createClass(CtrDropdown, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.completer.registerDropdown(null);
        }
      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this10 = this;

          var css = getComputedStyle(this.el.nativeElement);
          var autoHighlightIndex = this.completer.autoHighlightIndex;
          this.isScrollOn = !!css.maxHeight && css.overflowY === "auto";

          if (autoHighlightIndex) {
            this.zone.run(function () {
              _this10.highlightRow(autoHighlightIndex);
            });
          }
        }
      }, {
        key: "onMouseDown",
        value: function onMouseDown(event) {
          var _this11 = this;

          // Support for canceling blur on IE (issue #158)
          if (!this._rowMouseDown) {
            this.completer.cancelBlur(true);
            this.zone.run(function () {
              _this11.completer.cancelBlur(false);
            });
          } else {
            this._rowMouseDown = false;
          }
        }
      }, {
        key: "registerRow",
        value: function registerRow(row) {
          var arrIndex = this.rows.findIndex(function (_row) {
            return _row.index === row.index;
          });

          if (arrIndex >= 0) {
            this.rows[arrIndex] = row;
          } else {
            this.rows.push(row);
          }
        }
      }, {
        key: "unregisterRow",
        value: function unregisterRow(rowIndex) {
          var arrIndex = this.rows.findIndex(function (_row) {
            return _row.index === rowIndex;
          });
          this.rows.splice(arrIndex, 1);

          if (this.currHighlighted && rowIndex === this.currHighlighted.index) {
            this.highlightRow(null);
          }
        }
      }, {
        key: "highlightRow",
        value: function highlightRow(index) {
          var highlighted = this.rows.find(function (row) {
            return row.index === index;
          });

          if (isNil(index) || index < 0) {
            if (this.currHighlighted) {
              this.currHighlighted.row.setHighlighted(false);
            }

            this.currHighlighted = undefined;
            this.completer.onHighlighted(null);
            return;
          }

          if (!highlighted) {
            return;
          }

          if (this.currHighlighted) {
            this.currHighlighted.row.setHighlighted(false);
          }

          this.currHighlighted = highlighted;
          this.currHighlighted.row.setHighlighted(true);
          this.completer.onHighlighted(this.currHighlighted.row.getDataItem());

          if (this.isScrollOn && this.currHighlighted) {
            var rowTop = this.dropdownRowTop();

            if (!rowTop) {
              return;
            }

            if (rowTop < 0) {
              this.dropdownScrollTopTo(rowTop - 1);
            } else {
              var row = this.currHighlighted.row.getNativeElement();

              if (this.dropdownHeight() < row.getBoundingClientRect().bottom) {
                this.dropdownScrollTopTo(this.dropdownRowOffsetHeight(row));

                if (this.el.nativeElement.getBoundingClientRect().bottom - this.dropdownRowOffsetHeight(row) < row.getBoundingClientRect().top) {
                  this.dropdownScrollTopTo(row.getBoundingClientRect().top - (this.el.nativeElement.getBoundingClientRect().top + parseInt(getComputedStyle(this.el.nativeElement).paddingTop, 10)));
                }
              }
            }
          }
        }
      }, {
        key: "clear",
        value: function clear() {
          this.rows = [];
        }
      }, {
        key: "onSelected",
        value: function onSelected(item) {
          this.completer.onSelected(item);
        }
      }, {
        key: "rowMouseDown",
        value: function rowMouseDown() {
          this._rowMouseDown = true;
        }
      }, {
        key: "selectCurrent",
        value: function selectCurrent() {
          if (!!this.currHighlighted && !!this.currHighlighted.row) {
            this.onSelected(this.currHighlighted.row.getDataItem());
          } else if (this.rows.length > 0) {
            this.onSelected(this.rows[0].row.getDataItem());
          }
        }
      }, {
        key: "nextRow",
        value: function nextRow() {
          var nextRowIndex = 0;

          if (this.currHighlighted) {
            nextRowIndex = this.currHighlighted.index + 1;
          }

          this.highlightRow(nextRowIndex);
        }
      }, {
        key: "prevRow",
        value: function prevRow() {
          var nextRowIndex = -1;

          if (this.currHighlighted) {
            nextRowIndex = this.currHighlighted.index - 1;
          }

          this.highlightRow(nextRowIndex);
        }
      }, {
        key: "dropdownScrollTopTo",
        value: function dropdownScrollTopTo(offset) {
          this.el.nativeElement.scrollTop = this.el.nativeElement.scrollTop + offset;
        }
      }, {
        key: "dropdownRowTop",
        value: function dropdownRowTop() {
          if (!this.currHighlighted) {
            return;
          }

          return this.currHighlighted.row.getNativeElement().getBoundingClientRect().top - (this.el.nativeElement.getBoundingClientRect().top + parseInt(getComputedStyle(this.el.nativeElement).paddingTop, 10));
        }
      }, {
        key: "dropdownHeight",
        value: function dropdownHeight() {
          return this.el.nativeElement.getBoundingClientRect().top + parseInt(getComputedStyle(this.el.nativeElement).maxHeight, 10);
        }
      }, {
        key: "dropdownRowOffsetHeight",
        value: function dropdownRowOffsetHeight(row) {
          var css = getComputedStyle(row.parentElement);
          return row.parentElement.offsetHeight + parseInt(css.marginTop, 10) + parseInt(css.marginBottom, 10);
        }
      }]);

      return CtrDropdown;
    }();

    CtrDropdown.ɵfac = function CtrDropdown_Factory(t) {
      return new (t || CtrDropdown)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](CtrCompleter, 1), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]));
    };

    CtrDropdown.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
      type: CtrDropdown,
      selectors: [["", "ctrDropdown", ""]],
      hostBindings: function CtrDropdown_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("mousedown", function CtrDropdown_mousedown_HostBindingHandler($event) {
            return ctx.onMouseDown($event);
          });
        }
      }
    });
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("mousedown", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrDropdown.prototype, "onMouseDown", null);
    CtrDropdown = Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"])()), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [CtrCompleter, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]])], CtrDropdown); // keyboard events

    var KEY_DW = 40;
    var KEY_RT = 39;
    var KEY_UP = 38;
    var KEY_LF = 37;
    var KEY_ES = 27;
    var KEY_EN = 13;
    var KEY_TAB = 9;
    var KEY_BK = 8;
    var KEY_SH = 16;
    var KEY_CL = 20;
    var KEY_F1 = 112;
    var KEY_F12 = 123;

    var CtrInput =
    /*#__PURE__*/
    function () {
      function CtrInput(completer, ngModel, el) {
        var _this12 = this;

        _classCallCheck(this, CtrInput);

        this.completer = completer;
        this.ngModel = ngModel;
        this.el = el;
        this.clearSelected = false;
        this.clearUnselected = false;
        this.overrideSuggested = false;
        this.fillHighlighted = true;
        this.openOnFocus = false;
        this.openOnClick = false;
        this.selectOnClick = false;
        this.selectOnFocus = false;
        this.ngModelChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this._searchStr = "";
        this._displayStr = "";
        this.blurTimer = null;
        this.completer.selected.subscribe(function (item) {
          if (!item) {
            return;
          }

          if (_this12.clearSelected) {
            _this12.searchStr = "";
          } else {
            _this12.searchStr = item.title;
          }

          _this12.ngModelChange.emit(_this12.searchStr);
        });
        this.completer.highlighted.subscribe(function (item) {
          if (_this12.fillHighlighted) {
            if (item) {
              _this12._displayStr = item.title;

              _this12.ngModelChange.emit(item.title);
            } else {
              _this12._displayStr = _this12.searchStr;

              _this12.ngModelChange.emit(_this12.searchStr);
            }
          }
        });
        this.completer.dataSourceChange.subscribe(function () {
          _this12.completer.search(_this12.searchStr);
        });

        if (this.ngModel.valueChanges) {
          this.ngModel.valueChanges.subscribe(function (value) {
            if (!isNil(value) && _this12._displayStr !== value) {
              if (_this12.searchStr !== value) {
                _this12.completer.search(value);
              }

              _this12.searchStr = value;
            }
          });
        }
      }

      _createClass(CtrInput, [{
        key: "keyupHandler",
        value: function keyupHandler(event) {
          if (event.keyCode === KEY_LF || event.keyCode === KEY_RT || event.keyCode === KEY_TAB) {
            // do nothing
            return;
          }

          if (event.keyCode === KEY_UP || event.keyCode === KEY_EN) {
            event.preventDefault();
          } else if (event.keyCode === KEY_DW) {
            event.preventDefault();
            this.completer.search(this.searchStr);
          } else if (event.keyCode === KEY_ES) {
            if (this.completer.isOpen) {
              this.restoreSearchValue();
              this.completer.clear();
              event.stopPropagation();
              event.preventDefault();
            }
          }
        }
      }, {
        key: "pasteHandler",
        value: function pasteHandler(event) {
          this.completer.open();
        }
      }, {
        key: "keydownHandler",
        value: function keydownHandler(event) {
          var keyCode = event.keyCode || event.which;

          if (keyCode === KEY_EN) {
            if (this.completer.hasHighlighted()) {
              event.preventDefault();
            }

            this.handleSelection();
          } else if (keyCode === KEY_DW) {
            event.preventDefault();
            this.completer.open();
            this.completer.nextRow();
          } else if (keyCode === KEY_UP) {
            event.preventDefault();
            this.completer.prevRow();
          } else if (keyCode === KEY_TAB) {
            this.handleSelection();
          } else if (keyCode === KEY_BK) {
            this.completer.open();
          } else if (keyCode === KEY_ES) {
            // This is very specific to IE10/11 #272
            // without this, IE clears the input text
            event.preventDefault();

            if (this.completer.isOpen) {
              event.stopPropagation();
            }
          } else {
            if (keyCode !== 0 && keyCode !== KEY_SH && keyCode !== KEY_CL && (keyCode <= KEY_F1 || keyCode >= KEY_F12) && !event.ctrlKey && !event.metaKey && !event.altKey) {
              this.completer.open();
            }
          }
        }
      }, {
        key: "onBlur",
        value: function onBlur(event) {
          var _this13 = this;

          // Check if we need to cancel Blur for IE
          if (this.completer.isCancelBlur()) {
            setTimeout(function () {
              // get the focus back
              _this13.el.nativeElement.focus();
            }, 0);
            return;
          }

          if (this.completer.isOpen) {
            this.blurTimer = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["timer"])(200).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(function () {
              return _this13.doBlur();
            });
          }
        }
      }, {
        key: "onfocus",
        value: function onfocus() {
          if (this.blurTimer) {
            this.blurTimer.unsubscribe();
            this.blurTimer = null;
          }

          if (this.selectOnFocus) {
            this.el.nativeElement.select();
          }

          if (this.openOnFocus) {
            this.completer.open();
          }
        }
      }, {
        key: "onClick",
        value: function onClick(event) {
          if (this.selectOnClick) {
            this.el.nativeElement.select();
          }

          if (this.openOnClick) {
            if (this.completer.isOpen) {
              this.completer.clear();
            } else {
              this.completer.open();
            }
          }
        }
      }, {
        key: "handleSelection",
        value: function handleSelection() {
          if (this.completer.hasHighlighted()) {
            this._searchStr = "";
            this.completer.selectCurrent();
          } else if (this.overrideSuggested) {
            this.completer.onSelected({
              title: this.searchStr,
              originalObject: null
            });
          } else {
            if (this.clearUnselected && !this.completer.hasSelected) {
              this.searchStr = "";
              this.ngModelChange.emit(this.searchStr);
            }

            this.completer.clear();
          }
        }
      }, {
        key: "restoreSearchValue",
        value: function restoreSearchValue() {
          if (this.fillHighlighted) {
            if (this._displayStr !== this.searchStr) {
              this._displayStr = this.searchStr;
              this.ngModelChange.emit(this.searchStr);
            }
          }
        }
      }, {
        key: "doBlur",
        value: function doBlur() {
          if (this.blurTimer) {
            this.blurTimer.unsubscribe();
            this.blurTimer = null;
          }

          if (this.overrideSuggested) {
            this.completer.onSelected({
              title: this.searchStr,
              originalObject: null
            });
          } else {
            if (this.clearUnselected && !this.completer.hasSelected) {
              this.searchStr = "";
              this.ngModelChange.emit(this.searchStr);
            } else {
              this.restoreSearchValue();
            }
          }

          this.completer.clear();
        }
      }, {
        key: "searchStr",
        get: function get() {
          return this._searchStr;
        },
        set: function set(term) {
          this._searchStr = term;
          this._displayStr = term;
        }
      }]);

      return CtrInput;
    }();

    CtrInput.ɵfac = function CtrInput_Factory(t) {
      return new (t || CtrInput)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](CtrCompleter, 1), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_forms__WEBPACK_IMPORTED_MODULE_5__["NgModel"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]));
    };

    CtrInput.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
      type: CtrInput,
      selectors: [["", "ctrInput", ""]],
      hostBindings: function CtrInput_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keyup", function CtrInput_keyup_HostBindingHandler($event) {
            return ctx.keyupHandler($event);
          })("paste", function CtrInput_paste_HostBindingHandler($event) {
            return ctx.pasteHandler($event);
          })("keydown", function CtrInput_keydown_HostBindingHandler($event) {
            return ctx.keydownHandler($event);
          })("blur", function CtrInput_blur_HostBindingHandler($event) {
            return ctx.onBlur($event);
          })("focus", function CtrInput_focus_HostBindingHandler() {
            return ctx.onfocus();
          })("click", function CtrInput_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          });
        }
      },
      inputs: {
        clearSelected: "clearSelected",
        clearUnselected: "clearUnselected",
        overrideSuggested: "overrideSuggested",
        fillHighlighted: "fillHighlighted",
        openOnFocus: "openOnFocus",
        openOnClick: "openOnClick",
        selectOnClick: "selectOnClick",
        selectOnFocus: "selectOnFocus"
      },
      outputs: {
        ngModelChange: "ngModelChange"
      }
    });
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("clearSelected"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "clearSelected", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("clearUnselected"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "clearUnselected", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("overrideSuggested"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "overrideSuggested", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("fillHighlighted"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "fillHighlighted", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("openOnFocus"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "openOnFocus", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("openOnClick"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "openOnClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("selectOnClick"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "selectOnClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("selectOnFocus"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrInput.prototype, "selectOnFocus", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"])], CtrInput.prototype, "ngModelChange", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("keyup", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrInput.prototype, "keyupHandler", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("paste", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrInput.prototype, "pasteHandler", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("keydown", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrInput.prototype, "keydownHandler", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("blur", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrInput.prototype, "onBlur", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("focus", []), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", []), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrInput.prototype, "onfocus", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("click", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrInput.prototype, "onClick", null);
    CtrInput = Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"])()), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [CtrCompleter, _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NgModel"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])], CtrInput);

    var CtrListContext = function CtrListContext(results, searching, searchInitialized, isOpen) {
      _classCallCheck(this, CtrListContext);

      this.results = results;
      this.searching = searching;
      this.searchInitialized = searchInitialized;
      this.isOpen = isOpen;
    };

    var CtrList =
    /*#__PURE__*/
    function () {
      function CtrList(completer, templateRef, viewContainer, cd, zone) {
        _classCallCheck(this, CtrList);

        this.completer = completer;
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.cd = cd;
        this.zone = zone;
        this.ctrListMinSearchLength = MIN_SEARCH_LENGTH;
        this.ctrListPause = PAUSE;
        this.ctrListAutoMatch = false;
        this.ctrListAutoHighlight = false;
        this.ctrListDisplaySearching = true;
        this._dataService = null; // private results: CompleterItem[] = [];

        this.term = null; // private searching = false;

        this.searchTimer = null;
        this.clearTimer = null;
        this.ctx = new CtrListContext([], false, false, false);
        this._initialValue = null;
        this.viewRef = null;
      }

      _createClass(CtrList, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.completer.registerList(this);
          this.viewRef = this.viewContainer.createEmbeddedView(this.templateRef, new CtrListContext([], false, false, false));
        }
      }, {
        key: "search",
        value: function search(term) {
          var _this14 = this;

          if (!isNil(term) && term.length >= this.ctrListMinSearchLength && this.term !== term) {
            if (this.searchTimer) {
              this.searchTimer.unsubscribe();
              this.searchTimer = null;
            }

            if (!this.ctx.searching) {
              if (this.ctrListDisplaySearching) {
                this.ctx.results = [];
              }

              this.ctx.searching = true;
              this.ctx.searchInitialized = true;
              this.refreshTemplate();
            }

            if (this.clearTimer) {
              this.clearTimer.unsubscribe();
            }

            this.searchTimer = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["timer"])(this.ctrListPause).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(function () {
              _this14.searchTimerComplete(term);
            });
          } else if (!isNil(term) && term.length < this.ctrListMinSearchLength) {
            this.clear();
            this.term = "";
          }
        }
      }, {
        key: "clear",
        value: function clear() {
          var _this15 = this;

          if (this.searchTimer) {
            this.searchTimer.unsubscribe();
          }

          this.clearTimer = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["timer"])(CLEAR_TIMEOUT).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(function () {
            _this15._clear();
          });
        }
      }, {
        key: "open",
        value: function open() {
          if (!this.ctx.searchInitialized) {
            this.search("");
          }

          this.refreshTemplate();
        }
      }, {
        key: "isOpen",
        value: function isOpen(open) {
          this.ctx.isOpen = open;
        }
      }, {
        key: "_clear",
        value: function _clear() {
          if (this.searchTimer) {
            this.searchTimer.unsubscribe();
            this.searchTimer = null;
          }

          if (this.dataService) {
            this.dataService.cancel();
          }

          this.viewContainer.clear();
          this.viewRef = null;
        }
      }, {
        key: "searchTimerComplete",
        value: function searchTimerComplete(term) {
          // Begin the search
          if (isNil(term) || term.length < this.ctrListMinSearchLength) {
            this.ctx.searching = false;
            return;
          }

          this.term = term;

          if (this._dataService) {
            this._dataService.search(term);
          }
        }
      }, {
        key: "refreshTemplate",
        value: function refreshTemplate() {
          // create the template if it doesn't exist
          if (!this.viewRef) {
            this.viewRef = this.viewContainer.createEmbeddedView(this.templateRef, this.ctx);
          } else if (!this.viewRef.destroyed) {
            // refresh the template
            this.viewRef.context.isOpen = this.ctx.isOpen;
            this.viewRef.context.results = this.ctx.results;
            this.viewRef.context.searching = this.ctx.searching;
            this.viewRef.context.searchInitialized = this.ctx.searchInitialized;
            this.viewRef.detectChanges();
          }

          this.cd.markForCheck();
        }
      }, {
        key: "getBestMatchIndex",
        value: function getBestMatchIndex() {
          var _this16 = this;

          if (!this.ctx.results || !this.term) {
            return null;
          } // First try to find the exact term


          var bestMatch = this.ctx.results.findIndex(function (item) {
            return item.title.toLowerCase() === _this16.term.toLocaleLowerCase();
          }); // If not try to find the first item that starts with the term

          if (bestMatch < 0) {
            bestMatch = this.ctx.results.findIndex(function (item) {
              return item.title.toLowerCase().startsWith(_this16.term.toLocaleLowerCase());
            });
          } // If not try to find the first item that includes the term


          if (bestMatch < 0) {
            bestMatch = this.ctx.results.findIndex(function (item) {
              return item.title.toLowerCase().includes(_this16.term.toLocaleLowerCase());
            });
          }

          return bestMatch < 0 ? null : bestMatch;
        }
      }, {
        key: "dataServiceSubscribe",
        value: function dataServiceSubscribe() {
          var _this17 = this;

          if (this._dataService) {
            this._dataService.subscribe(function (results) {
              _this17.ctx.searchInitialized = true;
              _this17.ctx.searching = false;
              _this17.ctx.results = results;

              if (_this17.ctrListAutoMatch && results && results.length === 1 && results[0].title && !isNil(_this17.term) && results[0].title.toLocaleLowerCase() === _this17.term.toLocaleLowerCase()) {
                // Do automatch
                _this17.completer.onSelected(results[0]);

                return;
              }

              _this17.refreshTemplate();

              if (_this17.ctrListAutoHighlight) {
                _this17.completer.autoHighlightIndex = _this17.getBestMatchIndex();
              }
            }, function (error) {
              // tslint:disable-next-line:no-console
              console.error(error); // tslint:disable-next-line:no-console

              console.error("Unexpected error in dataService: errors should be handled by the dataService Observable");
              return [];
            });

            if (this._dataService.dataSourceChange) {
              this._dataService.dataSourceChange.subscribe(function () {
                _this17.term = null;
                _this17.ctx.searchInitialized = false;
                _this17.ctx.searching = false;
                _this17.ctx.results = [];

                _this17.refreshTemplate();

                _this17.completer.onDataSourceChange();
              });
            }
          }
        }
      }, {
        key: "dataService",
        set: function set(newService) {
          this._dataService = newService;
          this.dataServiceSubscribe();
        }
      }, {
        key: "initialValue",
        set: function set(value) {
          var _this18 = this;

          if (this._dataService && typeof this._dataService.convertToItem === "function") {
            this.zone.run(function () {
              var initialItem = _this18._dataService && _this18._dataService.convertToItem(value);

              if (initialItem) {
                _this18.completer.onSelected(initialItem, false);
              }
            });
          } else if (!this._dataService) {
            this._initialValue = value;
          }
        }
      }]);

      return CtrList;
    }();

    CtrList.ɵfac = function CtrList_Factory(t) {
      return new (t || CtrList)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](CtrCompleter, 1), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]));
    };

    CtrList.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
      type: CtrList,
      selectors: [["", "ctrList", ""]],
      inputs: {
        ctrListMinSearchLength: "ctrListMinSearchLength",
        ctrListPause: "ctrListPause",
        ctrListAutoMatch: "ctrListAutoMatch",
        ctrListAutoHighlight: "ctrListAutoHighlight",
        ctrListDisplaySearching: "ctrListDisplaySearching",
        dataService: ["ctrList", "dataService"],
        initialValue: ["ctrListInitialValue", "initialValue"]
      }
    });
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrList.prototype, "ctrListMinSearchLength", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrList.prototype, "ctrListPause", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrList.prototype, "ctrListAutoMatch", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrList.prototype, "ctrListAutoHighlight", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CtrList.prototype, "ctrListDisplaySearching", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("ctrList"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object])], CtrList.prototype, "dataService", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])("ctrListInitialValue"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object])], CtrList.prototype, "initialValue", null);
    CtrList = Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__param"])(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"])()), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [CtrCompleter, _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]])], CtrList);

    var CtrRow =
    /*#__PURE__*/
    function () {
      function CtrRow(el, renderer, dropdown) {
        _classCallCheck(this, CtrRow);

        this.el = el;
        this.renderer = renderer;
        this.dropdown = dropdown;
        this.selected = false;
        this._rowIndex = 0;
        this._item = null;
      }

      _createClass(CtrRow, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._rowIndex) {
            this.dropdown.unregisterRow(this._rowIndex);
          }
        }
      }, {
        key: "onClick",
        value: function onClick(event) {
          this.dropdown.onSelected(this._item);
        }
      }, {
        key: "onMouseEnter",
        value: function onMouseEnter(event) {
          this.dropdown.highlightRow(this._rowIndex);
        }
      }, {
        key: "onMouseDown",
        value: function onMouseDown(event) {
          this.dropdown.rowMouseDown();
        }
      }, {
        key: "setHighlighted",
        value: function setHighlighted(selected) {
          this.selected = selected;

          if (this.selected) {
            this.renderer.addClass(this.el.nativeElement, "completer-selected-row");
          } else {
            this.renderer.removeClass(this.el.nativeElement, "completer-selected-row");
          }
        }
      }, {
        key: "getNativeElement",
        value: function getNativeElement() {
          return this.el.nativeElement;
        }
      }, {
        key: "getDataItem",
        value: function getDataItem() {
          return this._item;
        }
      }, {
        key: "ctrRow",
        set: function set(index) {
          this._rowIndex = index;
          this.dropdown.registerRow(new CtrRowItem(this, this._rowIndex));
        }
      }, {
        key: "dataItem",
        set: function set(item) {
          this._item = item;
        }
      }]);

      return CtrRow;
    }();

    CtrRow.ɵfac = function CtrRow_Factory(t) {
      return new (t || CtrRow)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["Renderer2"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](CtrDropdown, 1));
    };

    CtrRow.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
      type: CtrRow,
      selectors: [["", "ctrRow", ""]],
      hostBindings: function CtrRow_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CtrRow_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          })("mouseenter", function CtrRow_mouseenter_HostBindingHandler($event) {
            return ctx.onMouseEnter($event);
          })("mousedown", function CtrRow_mousedown_HostBindingHandler($event) {
            return ctx.onMouseDown($event);
          });
        }
      },
      inputs: {
        ctrRow: "ctrRow",
        dataItem: "dataItem"
      }
    });
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Number), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Number])], CtrRow.prototype, "ctrRow", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object])], CtrRow.prototype, "dataItem", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("click", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrRow.prototype, "onClick", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("mouseenter", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrRow.prototype, "onMouseEnter", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("mousedown", ["$event"]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object]), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:returntype", void 0)], CtrRow.prototype, "onMouseDown", null);
    CtrRow = Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__param"])(2, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"])()), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Renderer2"], CtrDropdown])], CtrRow);

    var CompleterListItemCmp =
    /*#__PURE__*/
    function () {
      function CompleterListItemCmp() {
        _classCallCheck(this, CompleterListItemCmp);

        this.text = "";
        this.searchStr = "";
        this.matchClass = "";
        this.type = "";
        this.parts = [];
      }

      _createClass(CompleterListItemCmp, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          if (!this.searchStr) {
            this.parts.push({
              isMatch: false,
              text: this.text
            });
            return;
          }

          var matchStr = this.text.toLowerCase();
          var matchPos = matchStr.indexOf(this.searchStr.toLowerCase());
          var startIndex = 0;

          while (matchPos >= 0) {
            var matchText = this.text.slice(matchPos, matchPos + this.searchStr.length);

            if (matchPos === 0) {
              this.parts.push({
                isMatch: true,
                text: matchText
              });
              startIndex += this.searchStr.length;
            } else if (matchPos > 0) {
              var matchPart = this.text.slice(startIndex, matchPos);
              this.parts.push({
                isMatch: false,
                text: matchPart
              });
              this.parts.push({
                isMatch: true,
                text: matchText
              });
              startIndex += this.searchStr.length + matchPart.length;
            }

            matchPos = matchStr.indexOf(this.searchStr.toLowerCase(), startIndex);
          }

          if (startIndex < this.text.length) {
            this.parts.push({
              isMatch: false,
              text: this.text.slice(startIndex, this.text.length)
            });
          }
        }
      }]);

      return CompleterListItemCmp;
    }();

    CompleterListItemCmp.ɵfac = function CompleterListItemCmp_Factory(t) {
      return new (t || CompleterListItemCmp)();
    };

    CompleterListItemCmp.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CompleterListItemCmp,
      selectors: [["completer-list-item"]],
      inputs: {
        text: "text",
        searchStr: "searchStr",
        matchClass: "matchClass",
        type: "type"
      },
      decls: 2,
      vars: 5,
      consts: [[1, "completer-list-item-holder", 3, "ngClass"], ["class", "completer-list-item", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "completer-list-item", 3, "ngClass"]],
      template: function CompleterListItemCmp_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CompleterListItemCmp_span_1_Template, 2, 2, "span", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](2, _c0, ctx.type === "title", ctx.type === "description"));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.parts);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["NgClass"], _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgForOf"]],
      encapsulation: 2
    });
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", String)], CompleterListItemCmp.prototype, "text", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", String)], CompleterListItemCmp.prototype, "searchStr", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", String)], CompleterListItemCmp.prototype, "matchClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", String)], CompleterListItemCmp.prototype, "type", void 0);

    var noop = function noop() {
      return;
    };

    var COMPLETER_CONTROL_VALUE_ACCESSOR = {
      multi: true,
      provide: _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NG_VALUE_ACCESSOR"],
      useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(function () {
        return CompleterCmp;
      })
    };

    var CompleterCmp =
    /*#__PURE__*/
    function () {
      function CompleterCmp(completerService, cdr) {
        _classCallCheck(this, CompleterCmp);

        this.completerService = completerService;
        this.cdr = cdr;
        this.inputName = "";
        this.inputId = "";
        this.pause = PAUSE;
        this.minSearchLength = MIN_SEARCH_LENGTH;
        this.maxChars = MAX_CHARS;
        this.overrideSuggested = false;
        this.clearSelected = false;
        this.clearUnselected = false;
        this.fillHighlighted = true;
        this.placeholder = "";
        this.autoMatch = false;
        this.disableInput = false;
        this.autofocus = false;
        this.openOnFocus = false;
        this.openOnClick = false;
        this.selectOnClick = false;
        this.selectOnFocus = false;
        this.autoHighlight = false;
        this.selected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.highlighted = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.blurEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.click = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.focusEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.keyup = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.keydown = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.control = new _angular_forms__WEBPACK_IMPORTED_MODULE_5__["FormControl"]("");
        this.displaySearching = true;
        this.displayNoResults = true;
        this._textNoResults = TEXT_NO_RESULTS;
        this._textSearching = TEXT_SEARCHING;
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
        this._focus = false;
        this._open = false;
        this._searchStr = "";
      }

      _createClass(CompleterCmp, [{
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this19 = this;

          if (this.autofocus) {
            this._focus = true;
          }

          if (!this.completer) {
            return;
          }

          this.completer.selected.subscribe(function (item) {
            _this19.selected.emit(item);
          });
          this.completer.highlighted.subscribe(function (item) {
            _this19.highlighted.emit(item);
          });
          this.completer.opened.subscribe(function (isOpen) {
            _this19._open = isOpen;

            _this19.opened.emit(isOpen);
          });
        }
      }, {
        key: "ngAfterViewChecked",
        value: function ngAfterViewChecked() {
          var _this20 = this;

          if (this._focus) {
            setTimeout(function () {
              if (!!_this20.ctrInput) {
                _this20.ctrInput.nativeElement.focus();

                _this20._focus = false;
              }
            }, 0);
          }
        }
      }, {
        key: "onTouched",
        value: function onTouched() {
          this._onTouchedCallback();
        }
      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.searchStr = value;
        }
      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disableInput = isDisabled;
        }
      }, {
        key: "onBlur",
        value: function onBlur() {
          this.blurEvent.emit();
          this.onTouched();
          this.cdr.detectChanges();
        }
      }, {
        key: "onFocus",
        value: function onFocus() {
          this.focusEvent.emit();
          this.onTouched();
        }
      }, {
        key: "onClick",
        value: function onClick(event) {
          this.click.emit(event);
          this.onTouched();
        }
      }, {
        key: "onKeyup",
        value: function onKeyup(event) {
          this.keyup.emit(event);
          event.stopPropagation();
        }
      }, {
        key: "onKeydown",
        value: function onKeydown(event) {
          this.keydown.emit(event);
          event.stopPropagation();
        }
      }, {
        key: "onChange",
        value: function onChange(value) {
          this.value = value;
        }
      }, {
        key: "open",
        value: function open() {
          if (!this.completer) {
            return;
          }

          this.completer.open();
        }
      }, {
        key: "close",
        value: function close() {
          if (!this.completer) {
            return;
          }

          this.completer.clear();
        }
      }, {
        key: "focus",
        value: function focus() {
          if (this.ctrInput) {
            this.ctrInput.nativeElement.focus();
          } else {
            this._focus = true;
          }
        }
      }, {
        key: "blur",
        value: function blur() {
          if (this.ctrInput) {
            this.ctrInput.nativeElement.blur();
          } else {
            this._focus = false;
          }
        }
      }, {
        key: "isOpen",
        value: function isOpen() {
          return this._open;
        }
      }, {
        key: "value",
        get: function get() {
          return this.searchStr;
        },
        set: function set(v) {
          if (v !== this.searchStr) {
            this.searchStr = v;
          } // Propagate the change in any case


          this._onChangeCallback(v);
        }
      }, {
        key: "searchStr",
        get: function get() {
          return this._searchStr;
        },
        set: function set(value) {
          if (typeof value === "string" || isNil(value)) {
            this._searchStr = value;
          } else {
            this._searchStr = JSON.stringify(value);
          }
        }
      }, {
        key: "datasource",
        set: function set(source) {
          if (source) {
            if (source instanceof Array) {
              this.dataService = this.completerService.local(source);
            } else if (typeof source === "string") {
              this.dataService = this.completerService.remote(source);
            } else {
              this.dataService = source;
            }
          }
        }
      }, {
        key: "textNoResults",
        set: function set(text) {
          if (this._textNoResults !== text) {
            this._textNoResults = text;
            this.displayNoResults = !!this._textNoResults && this._textNoResults !== "false";
          }
        }
      }, {
        key: "textSearching",
        set: function set(text) {
          if (this._textSearching !== text) {
            this._textSearching = text;
            this.displaySearching = !!this._textSearching && this._textSearching !== "false";
          }
        }
      }]);

      return CompleterCmp;
    }();

    CompleterCmp.ɵfac = function CompleterCmp_Factory(t) {
      return new (t || CompleterCmp)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](CompleterService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]));
    };

    CompleterCmp.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CompleterCmp,
      selectors: [["ng2-completer"]],
      viewQuery: function CompleterCmp_Query(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](CtrCompleter, true);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c1, true);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.completer = _t.first);
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.ctrInput = _t.first);
        }
      },
      inputs: {
        inputName: "inputName",
        inputId: "inputId",
        pause: "pause",
        minSearchLength: "minSearchLength",
        maxChars: "maxChars",
        overrideSuggested: "overrideSuggested",
        clearSelected: "clearSelected",
        clearUnselected: "clearUnselected",
        fillHighlighted: "fillHighlighted",
        placeholder: "placeholder",
        autoMatch: "autoMatch",
        disableInput: "disableInput",
        autofocus: "autofocus",
        openOnFocus: "openOnFocus",
        openOnClick: "openOnClick",
        selectOnClick: "selectOnClick",
        selectOnFocus: "selectOnFocus",
        autoHighlight: "autoHighlight",
        datasource: "datasource",
        dataService: "dataService",
        textNoResults: "textNoResults",
        textSearching: "textSearching",
        matchClass: "matchClass",
        fieldTabindex: "fieldTabindex",
        inputClass: "inputClass",
        initialValue: "initialValue"
      },
      outputs: {
        selected: "selected",
        highlighted: "highlighted",
        blurEvent: "blur",
        click: "click",
        focusEvent: "focus",
        opened: "opened",
        keyup: "keyup",
        keydown: "keydown"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([COMPLETER_CONTROL_VALUE_ACCESSOR])],
      decls: 4,
      vars: 23,
      consts: [["ctrCompleter", "", 1, "completer-holder"], ["type", "search", "ctrInput", "", "autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", 1, "completer-input", 3, "ngClass", "ngModel", "placeholder", "tabindex", "disabled", "clearSelected", "clearUnselected", "overrideSuggested", "openOnFocus", "fillHighlighted", "openOnClick", "selectOnClick", "selectOnFocus", "ngModelChange", "blur", "focus", "keyup", "keydown", "click"], ["ctrInput", ""], ["class", "completer-dropdown-holder", 4, "ctrList", "ctrListMinSearchLength", "ctrListPause", "ctrListAutoMatch", "ctrListInitialValue", "ctrListAutoHighlight", "ctrListDisplaySearching"], [1, "completer-dropdown-holder"], ["class", "completer-dropdown", "ctrDropdown", "", 4, "ngIf"], ["ctrDropdown", "", 1, "completer-dropdown"], ["class", "completer-searching", 4, "ngIf"], ["class", "completer-no-results", 4, "ngIf"], ["class", "completer-row-wrapper", 4, "ngFor", "ngForOf"], [1, "completer-searching"], [1, "completer-no-results"], [1, "completer-row-wrapper"], [1, "completer-row", 3, "ctrRow", "dataItem"], ["class", "completer-image-holder", 4, "ngIf"], [1, "completer-item-text", 3, "ngClass"], [1, "completer-title", 3, "text", "matchClass", "searchStr", "type"], ["class", "completer-description", 3, "text", "matchClass", "searchStr", "type", 4, "ngIf"], [1, "completer-image-holder"], ["class", "completer-image", 3, "src", 4, "ngIf"], ["class", "completer-image-default", 4, "ngIf"], [1, "completer-image", 3, "src"], [1, "completer-image-default"], [1, "completer-description", 3, "text", "matchClass", "searchStr", "type"]],
      template: function CompleterCmp_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "input", 1, 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function CompleterCmp_Template_input_ngModelChange_1_listener($event) {
            return ctx.searchStr = $event;
          })("ngModelChange", function CompleterCmp_Template_input_ngModelChange_1_listener($event) {
            return ctx.onChange($event);
          })("blur", function CompleterCmp_Template_input_blur_1_listener() {
            return ctx.onBlur();
          })("focus", function CompleterCmp_Template_input_focus_1_listener() {
            return ctx.onFocus();
          })("keyup", function CompleterCmp_Template_input_keyup_1_listener($event) {
            return ctx.onKeyup($event);
          })("keydown", function CompleterCmp_Template_input_keydown_1_listener($event) {
            return ctx.onKeydown($event);
          })("click", function CompleterCmp_Template_input_click_1_listener($event) {
            return ctx.onClick($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, CompleterCmp_div_3_Template, 2, 1, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx.inputClass)("ngModel", ctx.searchStr)("placeholder", ctx.placeholder)("tabindex", ctx.fieldTabindex)("disabled", ctx.disableInput)("clearSelected", ctx.clearSelected)("clearUnselected", ctx.clearUnselected)("overrideSuggested", ctx.overrideSuggested)("openOnFocus", ctx.openOnFocus)("fillHighlighted", ctx.fillHighlighted)("openOnClick", ctx.openOnClick)("selectOnClick", ctx.selectOnClick)("selectOnFocus", ctx.selectOnFocus);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("id", ctx.inputId.length > 0 ? ctx.inputId : null)("name", ctx.inputName)("maxlength", ctx.maxChars);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ctrList", ctx.dataService)("ctrListMinSearchLength", ctx.minSearchLength)("ctrListPause", ctx.pause)("ctrListAutoMatch", ctx.autoMatch)("ctrListInitialValue", ctx.initialValue)("ctrListAutoHighlight", ctx.autoHighlight)("ctrListDisplaySearching", ctx.displaySearching);
        }
      },
      directives: [CtrCompleter, _angular_forms__WEBPACK_IMPORTED_MODULE_5__["DefaultValueAccessor"], CtrInput, _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgClass"], _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NgModel"], _angular_forms__WEBPACK_IMPORTED_MODULE_5__["MaxLengthValidator"], CtrList, _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgIf"], CtrDropdown, _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgForOf"], CtrRow, CompleterListItemCmp],
      styles: [".completer-dropdown[_ngcontent-%COMP%] {\n        border-color: #ececec;\n        border-width: 1px;\n        border-style: solid;\n        border-radius: 2px;\n        width: 250px;\n        padding: 6px;\n        cursor: pointer;\n        z-index: 9999;\n        position: absolute;\n        margin-top: -6px;\n        background-color: #ffffff;\n    }\n\n    .completer-row[_ngcontent-%COMP%] {\n        padding: 5px;\n        color: #000000;\n        margin-bottom: 4px;\n        clear: both;\n        display: inline-block;\n        width: 103%;\n    }\n\n    .completer-selected-row[_ngcontent-%COMP%] {\n        background-color: lightblue;\n        color: #ffffff;\n    }\n\n    .completer-description[_ngcontent-%COMP%] {\n        font-size: 14px;\n    }\n\n    .completer-image-default[_ngcontent-%COMP%] {\n        width: 16px;\n        height: 16px;\n        background-image: url(\"demo/res/img/default.png\");\n    }\n\n    .completer-image-holder[_ngcontent-%COMP%] {\n        float: left;\n        width: 10%;\n    }\n    .completer-item-text-image[_ngcontent-%COMP%] {\n        float: right;\n        width: 90%;\n    }"]
    });
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "dataService", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "inputName", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", String)], CompleterCmp.prototype, "inputId", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "pause", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "minSearchLength", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "maxChars", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "overrideSuggested", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "clearSelected", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "clearUnselected", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "fillHighlighted", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "placeholder", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "matchClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "fieldTabindex", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "autoMatch", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "disableInput", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "inputClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "autofocus", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "openOnFocus", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "openOnClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "selectOnClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "selectOnFocus", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "initialValue", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "autoHighlight", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "selected", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "highlighted", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])("blur"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "blurEvent", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "click", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])("focus"), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "focusEvent", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "opened", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"])], CompleterCmp.prototype, "keyup", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"])], CompleterCmp.prototype, "keydown", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"])(CtrCompleter, {
      "static": false
    }), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "completer", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"])("ctrInput", {
      "static": false
    }), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object)], CompleterCmp.prototype, "ctrInput", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [Object])], CompleterCmp.prototype, "datasource", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [String])], CompleterCmp.prototype, "textNoResults", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [String])], CompleterCmp.prototype, "textSearching", null);
    CompleterCmp = Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_3__["__metadata"])("design:paramtypes", [CompleterService, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]])], CompleterCmp);
    var Ng2CompleterModule_1;
    var providers = [CompleterService, LocalDataFactory, RemoteDataFactory];

    var Ng2CompleterModule = Ng2CompleterModule_1 =
    /*#__PURE__*/
    function () {
      function Ng2CompleterModule() {
        _classCallCheck(this, Ng2CompleterModule);
      }

      _createClass(Ng2CompleterModule, null, [{
        key: "forRoot",
        value: function forRoot() {
          return {
            ngModule: Ng2CompleterModule_1,
            providers: providers
          };
        }
      }, {
        key: "forChild",
        value: function forChild() {
          return {
            ngModule: Ng2CompleterModule_1,
            providers: providers
          };
        }
      }]);

      return Ng2CompleterModule;
    }();

    Ng2CompleterModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: Ng2CompleterModule
    });
    Ng2CompleterModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function Ng2CompleterModule_Factory(t) {
        return new (t || Ng2CompleterModule)();
      },
      providers: providers,
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_5__["FormsModule"]]]
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](LocalDataFactory, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"]
      }], null, null);
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](RemoteDataFactory, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"]
      }], function () {
        return [{
          type: _angular_common_http__WEBPACK_IMPORTED_MODULE_4__["HttpClient"]
        }];
      }, null);
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CompleterService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"]
      }], function () {
        return [{
          type: LocalDataFactory
        }, {
          type: RemoteDataFactory // Using any instead of () => LocalData because of AoT errors

        }];
      }, null);
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CtrCompleter, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
        args: [{
          selector: "[ctrCompleter]"
        }]
      }], function () {
        return [];
      }, {
        selected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        highlighted: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        opened: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        dataSourceChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CtrDropdown, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
        args: [{
          selector: "[ctrDropdown]"
        }]
      }], function () {
        return [{
          type: CtrCompleter,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"]
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
        }];
      }, {
        onMouseDown: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["mousedown", ["$event"]]
        }]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CtrInput, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
        args: [{
          selector: "[ctrInput]"
        }]
      }], function () {
        return [{
          type: CtrCompleter,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"]
          }]
        }, {
          type: _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NgModel"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
        }];
      }, {
        clearSelected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["clearSelected"]
        }],
        clearUnselected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["clearUnselected"]
        }],
        overrideSuggested: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["overrideSuggested"]
        }],
        fillHighlighted: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["fillHighlighted"]
        }],
        openOnFocus: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["openOnFocus"]
        }],
        openOnClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["openOnClick"]
        }],
        selectOnClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["selectOnClick"]
        }],
        selectOnFocus: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["selectOnFocus"]
        }],
        ngModelChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        keyupHandler: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["keyup", ["$event"]]
        }],
        pasteHandler: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["paste", ["$event"]]
        }],
        keydownHandler: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["keydown", ["$event"]]
        }],
        onBlur: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["blur", ["$event"]]
        }],
        onfocus: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["focus", []]
        }],
        onClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["click", ["$event"]]
        }]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CtrList, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
        args: [{
          selector: "[ctrList]"
        }]
      }], function () {
        return [{
          type: CtrCompleter,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"]
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
        }];
      }, {
        ctrListMinSearchLength: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        ctrListPause: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        ctrListAutoMatch: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        ctrListAutoHighlight: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        ctrListDisplaySearching: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        dataService: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["ctrList"]
        }],
        initialValue: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"],
          args: ["ctrListInitialValue"]
        }]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CtrRow, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
        args: [{
          selector: "[ctrRow]"
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Renderer2"]
        }, {
          type: CtrDropdown,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"]
          }]
        }];
      }, {
        ctrRow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        dataItem: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        onClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["click", ["$event"]]
        }],
        onMouseEnter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["mouseenter", ["$event"]]
        }],
        onMouseDown: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ["mousedown", ["$event"]]
        }]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CompleterListItemCmp, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: "completer-list-item",
          template: "<span class=\"completer-list-item-holder\" [ngClass]= \"{'completer-title': type === 'title', 'completer-description': type === 'description'}\" >\n        <span class=\"completer-list-item\" *ngFor=\"let part of parts\" [ngClass]= \"part.isMatch ? matchClass : null\">{{part.text}}</span>\n    </span>"
        }]
      }], function () {
        return [];
      }, {
        text: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        searchStr: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        matchClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        type: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CompleterCmp, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: "ng2-completer",
          template: "\n        <div class=\"completer-holder\" ctrCompleter>\n            <input #ctrInput [attr.id]=\"inputId.length > 0 ? inputId : null\" type=\"search\"\n                class=\"completer-input\" ctrInput [ngClass]=\"inputClass\"\n                [(ngModel)]=\"searchStr\" (ngModelChange)=\"onChange($event)\"\n                [attr.name]=\"inputName\" [placeholder]=\"placeholder\"\n                [attr.maxlength]=\"maxChars\" [tabindex]=\"fieldTabindex\" [disabled]=\"disableInput\"\n                [clearSelected]=\"clearSelected\" [clearUnselected]=\"clearUnselected\"\n                [overrideSuggested]=\"overrideSuggested\" [openOnFocus]=\"openOnFocus\" [fillHighlighted]=\"fillHighlighted\"\n                [openOnClick]=\"openOnClick\" [selectOnClick]=\"selectOnClick\" [selectOnFocus]=\"selectOnFocus\"\n                (blur)=\"onBlur()\" (focus)=\"onFocus()\" (keyup)=\"onKeyup($event)\"\n                (keydown)=\"onKeydown($event)\" (click)=\"onClick($event)\"\n                autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" />\n\n            <div class=\"completer-dropdown-holder\"\n                *ctrList=\"dataService;\n                    minSearchLength: minSearchLength;\n                    pause: pause;\n                    autoMatch: autoMatch;\n                    initialValue: initialValue;\n                    autoHighlight: autoHighlight;\n                    displaySearching: displaySearching;\n                    let items = results;\n                    let searchActive = searching;\n                    let isInitialized = searchInitialized;\n                    let isOpen = isOpen;\">\n                <div class=\"completer-dropdown\" ctrDropdown\n                    *ngIf=\"isInitialized && isOpen && (( items?.length > 0|| (displayNoResults && !searchActive)) || (searchActive && displaySearching))\">\n                    <div *ngIf=\"searchActive && displaySearching\" class=\"completer-searching\">{{ _textSearching }}</div>\n                    <div *ngIf=\"!searchActive && (!items || items?.length === 0)\"\n                    class=\"completer-no-results\">{{ _textNoResults }}</div>\n                    <div class=\"completer-row-wrapper\" *ngFor=\"let item of items; let rowIndex=index\">\n                        <div class=\"completer-row\" [ctrRow]=\"rowIndex\" [dataItem]=\"item\">\n                            <div *ngIf=\"item.image || item.image === ''\" class=\"completer-image-holder\">\n                                <img *ngIf=\"item.image != ''\" src=\"{{item.image}}\" class=\"completer-image\" />\n                                <div *ngIf=\"item.image === ''\" class=\"completer-image-default\"></div>\n                            </div>\n                            <div class=\"completer-item-text\"\n                            [ngClass]=\"{'completer-item-text-image': item.image || item.image === '' }\">\n                                <completer-list-item\n                                class=\"completer-title\" [text]=\"item.title\" [matchClass]=\"matchClass\"\n                                [searchStr]=\"searchStr\" [type]=\"'title'\"></completer-list-item>\n                                <completer-list-item *ngIf=\"item.description && item.description != ''\"\n                                class=\"completer-description\" [text]=\"item.description\"\n                                    [matchClass]=\"matchClass\" [searchStr]=\"searchStr\" [type]=\"'description'\">\n                                </completer-list-item>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    ",
          styles: ["\n    .completer-dropdown {\n        border-color: #ececec;\n        border-width: 1px;\n        border-style: solid;\n        border-radius: 2px;\n        width: 250px;\n        padding: 6px;\n        cursor: pointer;\n        z-index: 9999;\n        position: absolute;\n        margin-top: -6px;\n        background-color: #ffffff;\n    }\n\n    .completer-row {\n        padding: 5px;\n        color: #000000;\n        margin-bottom: 4px;\n        clear: both;\n        display: inline-block;\n        width: 103%;\n    }\n\n    .completer-selected-row {\n        background-color: lightblue;\n        color: #ffffff;\n    }\n\n    .completer-description {\n        font-size: 14px;\n    }\n\n    .completer-image-default {\n        width: 16px;\n        height: 16px;\n        background-image: url(\"demo/res/img/default.png\");\n    }\n\n    .completer-image-holder {\n        float: left;\n        width: 10%;\n    }\n    .completer-item-text-image {\n        float: right;\n        width: 90%;\n    }\n    "],
          providers: [COMPLETER_CONTROL_VALUE_ACCESSOR]
        }]
      }], function () {
        return [{
          type: CompleterService
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]
        }];
      }, {
        inputName: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        inputId: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        pause: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        minSearchLength: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        maxChars: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        overrideSuggested: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        clearSelected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        clearUnselected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        fillHighlighted: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        placeholder: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        autoMatch: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        disableInput: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        autofocus: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        openOnFocus: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        openOnClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        selectOnClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        selectOnFocus: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        autoHighlight: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        selected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        highlighted: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        blurEvent: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"],
          args: ["blur"]
        }],
        click: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        focusEvent: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"],
          args: ["focus"]
        }],
        opened: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        keyup: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        keydown: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        datasource: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        dataService: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        textNoResults: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        textSearching: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        matchClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        fieldTabindex: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        inputClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        initialValue: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        completer: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
          args: [CtrCompleter, {
            "static": false
          }]
        }],
        ctrInput: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
          args: ["ctrInput", {
            "static": false
          }]
        }]
      });
    })();

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](Ng2CompleterModule, {
        declarations: function declarations() {
          return [CompleterListItemCmp, CtrCompleter, CtrDropdown, CtrInput, CtrList, CtrRow, CompleterCmp];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_5__["FormsModule"]];
        },
        exports: function exports() {
          return [CompleterListItemCmp, CtrCompleter, CtrDropdown, CtrInput, CtrList, CtrRow, CompleterCmp];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](Ng2CompleterModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          declarations: [CompleterListItemCmp, CtrCompleter, CtrDropdown, CtrInput, CtrList, CtrRow, CompleterCmp],
          exports: [CompleterListItemCmp, CtrCompleter, CtrDropdown, CtrInput, CtrList, CtrRow, CompleterCmp],
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_5__["FormsModule"]],
          providers: providers
        }]
      }], null, null);
    })(); //# sourceMappingURL=ng2-completer.js.map

    /***/

  },

  /***/
  "./node_modules/ng2-file-upload/__ivy_ngcc__/fesm2015/ng2-file-upload.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/ng2-file-upload/__ivy_ngcc__/fesm2015/ng2-file-upload.js ***!
    \*******************************************************************************/

  /*! exports provided: FileDropDirective, FileItem, FileLikeObject, FileSelectDirective, FileUploadModule, FileUploader */

  /***/
  function node_modulesNg2FileUpload__ivy_ngcc__Fesm2015Ng2FileUploadJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FileDropDirective", function () {
      return FileDropDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FileItem", function () {
      return FileItem;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FileLikeObject", function () {
      return FileLikeObject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FileSelectDirective", function () {
      return FileSelectDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FileUploadModule", function () {
      return FileUploadModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FileUploader", function () {
      return FileUploader;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} node
     * @return {?}
     */


    function isElement(node) {
      return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }

    var FileLikeObject =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} fileOrInput
       */
      function FileLikeObject(fileOrInput) {
        _classCallCheck(this, FileLikeObject);

        this.rawFile = fileOrInput;
        /** @type {?} */

        var isInput = isElement(fileOrInput);
        /** @type {?} */

        var fakePathOrObject = isInput ? fileOrInput.value : fileOrInput;
        /** @type {?} */

        var postfix = typeof fakePathOrObject === 'string' ? 'FakePath' : 'Object';
        /** @type {?} */

        var method = '_createFrom' + postfix;

        /** @type {?} */
        this[method](fakePathOrObject);
      }
      /**
       * @param {?} path
       * @return {?}
       */


      _createClass(FileLikeObject, [{
        key: "_createFromFakePath",
        value: function _createFromFakePath(path) {
          this.lastModifiedDate = void 0;
          this.size = void 0;
          this.type = 'like/' + path.slice(path.lastIndexOf('.') + 1).toLowerCase();
          this.name = path.slice(path.lastIndexOf('/') + path.lastIndexOf('\\') + 2);
        }
        /**
         * @param {?} object
         * @return {?}
         */

      }, {
        key: "_createFromObject",
        value: function _createFromObject(object) {
          this.size = object.size;
          this.type = object.type;
          this.name = object.name;
        }
      }]);

      return FileLikeObject;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var FileItem =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} uploader
       * @param {?} some
       * @param {?} options
       */
      function FileItem(uploader, some, options) {
        _classCallCheck(this, FileItem);

        this.url = '/';
        this.headers = [];
        this.withCredentials = true;
        this.formData = [];
        this.isReady = false;
        this.isUploading = false;
        this.isUploaded = false;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = false;
        this.progress = 0;
        this.index = void 0;
        this.uploader = uploader;
        this.some = some;
        this.options = options;
        this.file = new FileLikeObject(some);
        this._file = some;

        if (uploader.options) {
          this.method = uploader.options.method || 'POST';
          this.alias = uploader.options.itemAlias || 'file';
        }

        this.url = uploader.options.url;
      }
      /**
       * @return {?}
       */


      _createClass(FileItem, [{
        key: "upload",
        value: function upload() {
          try {
            this.uploader.uploadItem(this);
          } catch (e) {
            this.uploader._onCompleteItem(this, '', 0, {});

            this.uploader._onErrorItem(this, '', 0, {});
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "cancel",
        value: function cancel() {
          this.uploader.cancelItem(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "remove",
        value: function remove() {
          this.uploader.removeFromQueue(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "onBeforeUpload",
        value: function onBeforeUpload() {
          return void 0;
        }
        /**
         * @param {?} form
         * @return {?}
         */

      }, {
        key: "onBuildForm",
        value: function onBuildForm(form) {
          return {
            form: form
          };
        }
        /**
         * @param {?} progress
         * @return {?}
         */

      }, {
        key: "onProgress",
        value: function onProgress(progress) {
          return {
            progress: progress
          };
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onSuccess",
        value: function onSuccess(response, status, headers) {
          return {
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onError",
        value: function onError(response, status, headers) {
          return {
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onCancel",
        value: function onCancel(response, status, headers) {
          return {
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onComplete",
        value: function onComplete(response, status, headers) {
          return {
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @return {?}
         */

      }, {
        key: "_onBeforeUpload",
        value: function _onBeforeUpload() {
          this.isReady = true;
          this.isUploading = true;
          this.isUploaded = false;
          this.isSuccess = false;
          this.isCancel = false;
          this.isError = false;
          this.progress = 0;
          this.onBeforeUpload();
        }
        /**
         * @param {?} form
         * @return {?}
         */

      }, {
        key: "_onBuildForm",
        value: function _onBuildForm(form) {
          this.onBuildForm(form);
        }
        /**
         * @param {?} progress
         * @return {?}
         */

      }, {
        key: "_onProgress",
        value: function _onProgress(progress) {
          this.progress = progress;
          this.onProgress(progress);
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onSuccess",
        value: function _onSuccess(response, status, headers) {
          this.isReady = false;
          this.isUploading = false;
          this.isUploaded = true;
          this.isSuccess = true;
          this.isCancel = false;
          this.isError = false;
          this.progress = 100;
          this.index = void 0;
          this.onSuccess(response, status, headers);
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onError",
        value: function _onError(response, status, headers) {
          this.isReady = false;
          this.isUploading = false;
          this.isUploaded = true;
          this.isSuccess = false;
          this.isCancel = false;
          this.isError = true;
          this.progress = 0;
          this.index = void 0;
          this.onError(response, status, headers);
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onCancel",
        value: function _onCancel(response, status, headers) {
          this.isReady = false;
          this.isUploading = false;
          this.isUploaded = false;
          this.isSuccess = false;
          this.isCancel = true;
          this.isError = false;
          this.progress = 0;
          this.index = void 0;
          this.onCancel(response, status, headers);
        }
        /**
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onComplete",
        value: function _onComplete(response, status, headers) {
          this.onComplete(response, status, headers);

          if (this.uploader.options.removeAfterUpload) {
            this.remove();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "_prepareToUploading",
        value: function _prepareToUploading() {
          this.index = this.index || ++this.uploader._nextIndex;
          this.isReady = true;
        }
      }]);

      return FileItem;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var FileType =
    /*#__PURE__*/
    function () {
      function FileType() {
        _classCallCheck(this, FileType);
      }

      _createClass(FileType, null, [{
        key: "getMimeClass",

        /**
         * @param {?} file
         * @return {?}
         */
        value: function getMimeClass(file) {
          /** @type {?} */
          var mimeClass = 'application';

          if (this.mime_psd.indexOf(file.type) !== -1) {
            mimeClass = 'image';
          } else if (file.type.match('image.*')) {
            mimeClass = 'image';
          } else if (file.type.match('video.*')) {
            mimeClass = 'video';
          } else if (file.type.match('audio.*')) {
            mimeClass = 'audio';
          } else if (file.type === 'application/pdf') {
            mimeClass = 'pdf';
          } else if (this.mime_compress.indexOf(file.type) !== -1) {
            mimeClass = 'compress';
          } else if (this.mime_doc.indexOf(file.type) !== -1) {
            mimeClass = 'doc';
          } else if (this.mime_xsl.indexOf(file.type) !== -1) {
            mimeClass = 'xls';
          } else if (this.mime_ppt.indexOf(file.type) !== -1) {
            mimeClass = 'ppt';
          }

          if (mimeClass === 'application') {
            mimeClass = this.fileTypeDetection(file.name);
          }

          return mimeClass;
        }
        /**
         * @param {?} inputFilename
         * @return {?}
         */

      }, {
        key: "fileTypeDetection",
        value: function fileTypeDetection(inputFilename) {
          /** @type {?} */
          var types = {
            'jpg': 'image',
            'jpeg': 'image',
            'tif': 'image',
            'psd': 'image',
            'bmp': 'image',
            'png': 'image',
            'nef': 'image',
            'tiff': 'image',
            'cr2': 'image',
            'dwg': 'image',
            'cdr': 'image',
            'ai': 'image',
            'indd': 'image',
            'pin': 'image',
            'cdp': 'image',
            'skp': 'image',
            'stp': 'image',
            '3dm': 'image',
            'mp3': 'audio',
            'wav': 'audio',
            'wma': 'audio',
            'mod': 'audio',
            'm4a': 'audio',
            'compress': 'compress',
            'zip': 'compress',
            'rar': 'compress',
            '7z': 'compress',
            'lz': 'compress',
            'z01': 'compress',
            'bz2': 'compress',
            'gz': 'compress',
            'pdf': 'pdf',
            'xls': 'xls',
            'xlsx': 'xls',
            'ods': 'xls',
            'mp4': 'video',
            'avi': 'video',
            'wmv': 'video',
            'mpg': 'video',
            'mts': 'video',
            'flv': 'video',
            '3gp': 'video',
            'vob': 'video',
            'm4v': 'video',
            'mpeg': 'video',
            'm2ts': 'video',
            'mov': 'video',
            'doc': 'doc',
            'docx': 'doc',
            'eps': 'doc',
            'txt': 'doc',
            'odt': 'doc',
            'rtf': 'doc',
            'ppt': 'ppt',
            'pptx': 'ppt',
            'pps': 'ppt',
            'ppsx': 'ppt',
            'odp': 'ppt'
          };
          /** @type {?} */

          var chunks = inputFilename.split('.');

          if (chunks.length < 2) {
            return 'application';
          }
          /** @type {?} */


          var extension = chunks[chunks.length - 1].toLowerCase();

          if (types[extension] === undefined) {
            return 'application';
          } else {
            return types[extension];
          }
        }
      }]);

      return FileType;
    }();
    /*  MS office  */


    FileType.mime_doc = ['application/msword', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'application/vnd.ms-word.document.macroEnabled.12', 'application/vnd.ms-word.template.macroEnabled.12'];
    FileType.mime_xsl = ['application/vnd.ms-excel', 'application/vnd.ms-excel', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'application/vnd.ms-excel.sheet.macroEnabled.12', 'application/vnd.ms-excel.template.macroEnabled.12', 'application/vnd.ms-excel.addin.macroEnabled.12', 'application/vnd.ms-excel.sheet.binary.macroEnabled.12'];
    FileType.mime_ppt = ['application/vnd.ms-powerpoint', 'application/vnd.ms-powerpoint', 'application/vnd.ms-powerpoint', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'application/vnd.openxmlformats-officedocument.presentationml.template', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow', 'application/vnd.ms-powerpoint.addin.macroEnabled.12', 'application/vnd.ms-powerpoint.presentation.macroEnabled.12', 'application/vnd.ms-powerpoint.presentation.macroEnabled.12', 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12'];
    /* PSD */

    FileType.mime_psd = ['image/photoshop', 'image/x-photoshop', 'image/psd', 'application/photoshop', 'application/psd', 'zz-application/zz-winassoc-psd'];
    /* Compressed files */

    FileType.mime_compress = ['application/x-gtar', 'application/x-gcompress', 'application/compress', 'application/x-tar', 'application/x-rar-compressed', 'application/octet-stream', 'application/x-zip-compressed', 'application/zip-compressed', 'application/x-7z-compressed', 'application/gzip', 'application/x-bzip2'];

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} value
     * @return {?}
     */


    function _isFile(value) {
      return File && value instanceof File;
    }
    /**
     * @record
     */


    function Headers() {}

    if (false) {}
    /**
     * @record
     */


    function FileUploaderOptions() {}

    if (false) {}

    var FileUploader =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} options
       */
      function FileUploader(options) {
        _classCallCheck(this, FileUploader);

        this.isUploading = false;
        this.queue = [];
        this.progress = 0;
        this._nextIndex = 0;
        this.options = {
          autoUpload: false,
          isHTML5: true,
          filters: [],
          removeAfterUpload: false,
          disableMultipart: false,
          formatDataFunction:
          /**
          * @param {?} item
          * @return {?}
          */
          function formatDataFunction(item) {
            return item._file;
          },
          formatDataFunctionIsAsync: false
        };
        this.setOptions(options);
        this.response = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }
      /**
       * @param {?} options
       * @return {?}
       */


      _createClass(FileUploader, [{
        key: "setOptions",
        value: function setOptions(options) {
          this.options = Object.assign(this.options, options);
          this.authToken = this.options.authToken;
          this.authTokenHeader = this.options.authTokenHeader || 'Authorization';
          this.autoUpload = this.options.autoUpload;
          this.options.filters.unshift({
            name: 'queueLimit',
            fn: this._queueLimitFilter
          });

          if (this.options.maxFileSize) {
            this.options.filters.unshift({
              name: 'fileSize',
              fn: this._fileSizeFilter
            });
          }

          if (this.options.allowedFileType) {
            this.options.filters.unshift({
              name: 'fileType',
              fn: this._fileTypeFilter
            });
          }

          if (this.options.allowedMimeType) {
            this.options.filters.unshift({
              name: 'mimeType',
              fn: this._mimeTypeFilter
            });
          }

          for (var i = 0; i < this.queue.length; i++) {
            this.queue[i].url = this.options.url;
          }
        }
        /**
         * @param {?} files
         * @param {?=} options
         * @param {?=} filters
         * @return {?}
         */

      }, {
        key: "addToQueue",
        value: function addToQueue(files, options, filters) {
          var _this21 = this;

          /** @type {?} */
          var list = [];

          var _iterator2 = _createForOfIteratorHelper(files),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var file = _step2.value;
              list.push(file);
            }
            /** @type {?} */

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var arrayOfFilters = this._getFilters(filters);
          /** @type {?} */


          var count = this.queue.length;
          /** @type {?} */

          var addedFileItems = [];
          list.map(
          /**
          * @param {?} some
          * @return {?}
          */
          function (some) {
            if (!options) {
              options = _this21.options;
            }
            /** @type {?} */


            var temp = new FileLikeObject(some);

            if (_this21._isValidFile(temp, arrayOfFilters, options)) {
              /** @type {?} */
              var fileItem = new FileItem(_this21, some, options);
              addedFileItems.push(fileItem);

              _this21.queue.push(fileItem);

              _this21._onAfterAddingFile(fileItem);
            } else {
              /** @type {?} */
              var filter = arrayOfFilters[_this21._failFilterIndex];

              _this21._onWhenAddingFileFailed(temp, filter, options);
            }
          });

          if (this.queue.length !== count) {
            this._onAfterAddingAll(addedFileItems);

            this.progress = this._getTotalProgress();
          }

          this._render();

          if (this.options.autoUpload) {
            this.uploadAll();
          }
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "removeFromQueue",
        value: function removeFromQueue(value) {
          /** @type {?} */
          var index = this.getIndexOfItem(value);
          /** @type {?} */

          var item = this.queue[index];

          if (item.isUploading) {
            item.cancel();
          }

          this.queue.splice(index, 1);
          this.progress = this._getTotalProgress();
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearQueue",
        value: function clearQueue() {
          while (this.queue.length) {
            this.queue[0].remove();
          }

          this.progress = 0;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "uploadItem",
        value: function uploadItem(value) {
          /** @type {?} */
          var index = this.getIndexOfItem(value);
          /** @type {?} */

          var item = this.queue[index];
          /** @type {?} */

          var transport = this.options.isHTML5 ? '_xhrTransport' : '_iframeTransport';

          item._prepareToUploading();

          if (this.isUploading) {
            return;
          }

          this.isUploading = true;

          /** @type {?} */
          this[transport](item);
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "cancelItem",
        value: function cancelItem(value) {
          /** @type {?} */
          var index = this.getIndexOfItem(value);
          /** @type {?} */

          var item = this.queue[index];
          /** @type {?} */

          var prop = this.options.isHTML5 ? item._xhr : item._form;

          if (item && item.isUploading) {
            prop.abort();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "uploadAll",
        value: function uploadAll() {
          /** @type {?} */
          var items = this.getNotUploadedItems().filter(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return !item.isUploading;
          });

          if (!items.length) {
            return;
          }

          items.map(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return item._prepareToUploading();
          });
          items[0].upload();
        }
        /**
         * @return {?}
         */

      }, {
        key: "cancelAll",
        value: function cancelAll() {
          /** @type {?} */
          var items = this.getNotUploadedItems();
          items.map(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return item.cancel();
          });
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isFile",
        value: function isFile(value) {
          return _isFile(value);
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isFileLikeObject",
        value: function isFileLikeObject(value) {
          return value instanceof FileLikeObject;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "getIndexOfItem",
        value: function getIndexOfItem(value) {
          return typeof value === 'number' ? value : this.queue.indexOf(value);
        }
        /**
         * @return {?}
         */

      }, {
        key: "getNotUploadedItems",
        value: function getNotUploadedItems() {
          return this.queue.filter(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return !item.isUploaded;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "getReadyItems",
        value: function getReadyItems() {
          return this.queue.filter(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return item.isReady && !item.isUploading;
          }).sort(
          /**
          * @param {?} item1
          * @param {?} item2
          * @return {?}
          */
          function (item1, item2) {
            return item1.index - item2.index;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          return void 0;
        }
        /**
         * @param {?} fileItems
         * @return {?}
         */

      }, {
        key: "onAfterAddingAll",
        value: function onAfterAddingAll(fileItems) {
          return {
            fileItems: fileItems
          };
        }
        /**
         * @param {?} fileItem
         * @param {?} form
         * @return {?}
         */

      }, {
        key: "onBuildItemForm",
        value: function onBuildItemForm(fileItem, form) {
          return {
            fileItem: fileItem,
            form: form
          };
        }
        /**
         * @param {?} fileItem
         * @return {?}
         */

      }, {
        key: "onAfterAddingFile",
        value: function onAfterAddingFile(fileItem) {
          return {
            fileItem: fileItem
          };
        }
        /**
         * @param {?} item
         * @param {?} filter
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "onWhenAddingFileFailed",
        value: function onWhenAddingFileFailed(item, filter, options) {
          return {
            item: item,
            filter: filter,
            options: options
          };
        }
        /**
         * @param {?} fileItem
         * @return {?}
         */

      }, {
        key: "onBeforeUploadItem",
        value: function onBeforeUploadItem(fileItem) {
          return {
            fileItem: fileItem
          };
        }
        /**
         * @param {?} fileItem
         * @param {?} progress
         * @return {?}
         */

      }, {
        key: "onProgressItem",
        value: function onProgressItem(fileItem, progress) {
          return {
            fileItem: fileItem,
            progress: progress
          };
        }
        /**
         * @param {?} progress
         * @return {?}
         */

      }, {
        key: "onProgressAll",
        value: function onProgressAll(progress) {
          return {
            progress: progress
          };
        }
        /**
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onSuccessItem",
        value: function onSuccessItem(item, response, status, headers) {
          return {
            item: item,
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onErrorItem",
        value: function onErrorItem(item, response, status, headers) {
          return {
            item: item,
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onCancelItem",
        value: function onCancelItem(item, response, status, headers) {
          return {
            item: item,
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "onCompleteItem",
        value: function onCompleteItem(item, response, status, headers) {
          return {
            item: item,
            response: response,
            status: status,
            headers: headers
          };
        }
        /**
         * @return {?}
         */

      }, {
        key: "onCompleteAll",
        value: function onCompleteAll() {
          return void 0;
        }
        /**
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_mimeTypeFilter",
        value: function _mimeTypeFilter(item) {
          return !(this.options.allowedMimeType && this.options.allowedMimeType.indexOf(item.type) === -1);
        }
        /**
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_fileSizeFilter",
        value: function _fileSizeFilter(item) {
          return !(this.options.maxFileSize && item.size > this.options.maxFileSize);
        }
        /**
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_fileTypeFilter",
        value: function _fileTypeFilter(item) {
          return !(this.options.allowedFileType && this.options.allowedFileType.indexOf(FileType.getMimeClass(item)) === -1);
        }
        /**
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onErrorItem",
        value: function _onErrorItem(item, response, status, headers) {
          item._onError(response, status, headers);

          this.onErrorItem(item, response, status, headers);
        }
        /**
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onCompleteItem",
        value: function _onCompleteItem(item, response, status, headers) {
          item._onComplete(response, status, headers);

          this.onCompleteItem(item, response, status, headers);
          /** @type {?} */

          var nextItem = this.getReadyItems()[0];
          this.isUploading = false;

          if (nextItem) {
            nextItem.upload();
            return;
          }

          this.onCompleteAll();
          this.progress = this._getTotalProgress();

          this._render();
        }
        /**
         * @protected
         * @param {?} parsedHeaders
         * @return {?}
         */

      }, {
        key: "_headersGetter",
        value: function _headersGetter(parsedHeaders) {
          return (
            /**
            * @param {?} name
            * @return {?}
            */
            function (name) {
              if (name) {
                return parsedHeaders[name.toLowerCase()] || void 0;
              }

              return parsedHeaders;
            }
          );
        }
        /**
         * @protected
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_xhrTransport",
        value: function _xhrTransport(item) {
          var _this22 = this;

          /** @type {?} */
          var that = this;
          /** @type {?} */

          var xhr = item._xhr = new XMLHttpRequest();
          /** @type {?} */

          var sendable;

          this._onBeforeUploadItem(item);

          if (typeof item._file.size !== 'number') {
            throw new TypeError('The file specified is no longer valid');
          }

          if (!this.options.disableMultipart) {
            sendable = new FormData();

            this._onBuildItemForm(item, sendable);
            /** @type {?} */


            var appendFile =
            /**
            * @return {?}
            */
            function appendFile() {
              return sendable.append(item.alias, item._file, item.file.name);
            };

            if (!this.options.parametersBeforeFiles) {
              appendFile();
            } // For AWS, Additional Parameters must come BEFORE Files


            if (this.options.additionalParameter !== undefined) {
              Object.keys(this.options.additionalParameter).forEach(
              /**
              * @param {?} key
              * @return {?}
              */
              function (key) {
                /** @type {?} */
                var paramVal = _this22.options.additionalParameter[key]; // Allow an additional parameter to include the filename

                if (typeof paramVal === 'string' && paramVal.indexOf('{{file_name}}') >= 0) {
                  paramVal = paramVal.replace('{{file_name}}', item.file.name);
                }

                sendable.append(key, paramVal);
              });
            }

            if (this.options.parametersBeforeFiles) {
              appendFile();
            }
          } else {
            sendable = this.options.formatDataFunction(item);
          }

          xhr.upload.onprogress =
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            /** @type {?} */
            var progress = Math.round(event.lengthComputable ? event.loaded * 100 / event.total : 0);

            _this22._onProgressItem(item, progress);
          };

          xhr.onload =
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var headers = _this22._parseHeaders(xhr.getAllResponseHeaders());
            /** @type {?} */


            var response = _this22._transformResponse(xhr.response, headers);
            /** @type {?} */


            var gist = _this22._isSuccessCode(xhr.status) ? 'Success' : 'Error';
            /** @type {?} */

            var method = '_on' + gist + 'Item';

            /** @type {?} */
            _this22[method](item, response, xhr.status, headers);

            _this22._onCompleteItem(item, response, xhr.status, headers);
          };

          xhr.onerror =
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var headers = _this22._parseHeaders(xhr.getAllResponseHeaders());
            /** @type {?} */


            var response = _this22._transformResponse(xhr.response, headers);

            _this22._onErrorItem(item, response, xhr.status, headers);

            _this22._onCompleteItem(item, response, xhr.status, headers);
          };

          xhr.onabort =
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var headers = _this22._parseHeaders(xhr.getAllResponseHeaders());
            /** @type {?} */


            var response = _this22._transformResponse(xhr.response, headers);

            _this22._onCancelItem(item, response, xhr.status, headers);

            _this22._onCompleteItem(item, response, xhr.status, headers);
          };

          xhr.open(item.method, item.url, true);
          xhr.withCredentials = item.withCredentials;

          if (this.options.headers) {
            var _iterator3 = _createForOfIteratorHelper(this.options.headers),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var header = _step3.value;
                xhr.setRequestHeader(header.name, header.value);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }

          if (item.headers.length) {
            var _iterator4 = _createForOfIteratorHelper(item.headers),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var _header = _step4.value;
                xhr.setRequestHeader(_header.name, _header.value);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }

          if (this.authToken) {
            xhr.setRequestHeader(this.authTokenHeader, this.authToken);
          }

          xhr.onreadystatechange =
          /**
          * @return {?}
          */
          function () {
            if (xhr.readyState == XMLHttpRequest.DONE) {
              that.response.emit(xhr.responseText);
            }
          };

          if (this.options.formatDataFunctionIsAsync) {
            sendable.then(
            /**
            * @param {?} result
            * @return {?}
            */
            function (result) {
              return xhr.send(JSON.stringify(result));
            });
          } else {
            xhr.send(sendable);
          }

          this._render();
        }
        /**
         * @protected
         * @param {?=} value
         * @return {?}
         */

      }, {
        key: "_getTotalProgress",
        value: function _getTotalProgress() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

          if (this.options.removeAfterUpload) {
            return value;
          }
          /** @type {?} */


          var notUploaded = this.getNotUploadedItems().length;
          /** @type {?} */

          var uploaded = notUploaded ? this.queue.length - notUploaded : this.queue.length;
          /** @type {?} */

          var ratio = 100 / this.queue.length;
          /** @type {?} */

          var current = value * ratio / 100;
          return Math.round(uploaded * ratio + current);
        }
        /**
         * @protected
         * @param {?} filters
         * @return {?}
         */

      }, {
        key: "_getFilters",
        value: function _getFilters(filters) {
          if (!filters) {
            return this.options.filters;
          }

          if (Array.isArray(filters)) {
            return filters;
          }

          if (typeof filters === 'string') {
            /** @type {?} */
            var names = filters.match(/[^\s,]+/g);
            return this.options.filters.filter(
            /**
            * @param {?} filter
            * @return {?}
            */
            function (filter) {
              return names.indexOf(filter.name) !== -1;
            });
          }

          return this.options.filters;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_render",
        value: function _render() {
          return void 0;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_queueLimitFilter",
        value: function _queueLimitFilter() {
          return this.options.queueLimit === undefined || this.queue.length < this.options.queueLimit;
        }
        /**
         * @protected
         * @param {?} file
         * @param {?} filters
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "_isValidFile",
        value: function _isValidFile(file, filters, options) {
          var _this23 = this;

          this._failFilterIndex = -1;
          return !filters.length ? true : filters.every(
          /**
          * @param {?} filter
          * @return {?}
          */
          function (filter) {
            _this23._failFilterIndex++;
            return filter.fn.call(_this23, file, options);
          });
        }
        /**
         * @protected
         * @param {?} status
         * @return {?}
         */

      }, {
        key: "_isSuccessCode",
        value: function _isSuccessCode(status) {
          return status >= 200 && status < 300 || status === 304;
        }
        /**
         * @protected
         * @param {?} response
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_transformResponse",
        value: function _transformResponse(response, headers) {
          return response;
        }
        /**
         * @protected
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_parseHeaders",
        value: function _parseHeaders(headers) {
          /** @type {?} */
          var parsed = {};
          /** @type {?} */

          var key;
          /** @type {?} */

          var val;
          /** @type {?} */

          var i;

          if (!headers) {
            return parsed;
          }

          headers.split('\n').map(
          /**
          * @param {?} line
          * @return {?}
          */
          function (line) {
            i = line.indexOf(':');
            key = line.slice(0, i).trim().toLowerCase();
            val = line.slice(i + 1).trim();

            if (key) {
              parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
            }
          });
          return parsed;
        }
        /**
         * @protected
         * @param {?} item
         * @param {?} filter
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "_onWhenAddingFileFailed",
        value: function _onWhenAddingFileFailed(item, filter, options) {
          this.onWhenAddingFileFailed(item, filter, options);
        }
        /**
         * @protected
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_onAfterAddingFile",
        value: function _onAfterAddingFile(item) {
          this.onAfterAddingFile(item);
        }
        /**
         * @protected
         * @param {?} items
         * @return {?}
         */

      }, {
        key: "_onAfterAddingAll",
        value: function _onAfterAddingAll(items) {
          this.onAfterAddingAll(items);
        }
        /**
         * @protected
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_onBeforeUploadItem",
        value: function _onBeforeUploadItem(item) {
          item._onBeforeUpload();

          this.onBeforeUploadItem(item);
        }
        /**
         * @protected
         * @param {?} item
         * @param {?} form
         * @return {?}
         */

      }, {
        key: "_onBuildItemForm",
        value: function _onBuildItemForm(item, form) {
          item._onBuildForm(form);

          this.onBuildItemForm(item, form);
        }
        /**
         * @protected
         * @param {?} item
         * @param {?} progress
         * @return {?}
         */

      }, {
        key: "_onProgressItem",
        value: function _onProgressItem(item, progress) {
          /** @type {?} */
          var total = this._getTotalProgress(progress);

          this.progress = total;

          item._onProgress(progress);

          this.onProgressItem(item, progress);
          this.onProgressAll(total);

          this._render();
        }
        /**
         * @protected
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onSuccessItem",
        value: function _onSuccessItem(item, response, status, headers) {
          item._onSuccess(response, status, headers);

          this.onSuccessItem(item, response, status, headers);
        }
        /**
         * @protected
         * @param {?} item
         * @param {?} response
         * @param {?} status
         * @param {?} headers
         * @return {?}
         */

      }, {
        key: "_onCancelItem",
        value: function _onCancelItem(item, response, status, headers) {
          item._onCancel(response, status, headers);

          this.onCancelItem(item, response, status, headers);
        }
      }]);

      return FileUploader;
    }();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var FileSelectDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       */
      function FileSelectDirective(element) {
        _classCallCheck(this, FileSelectDirective);

        this.onFileSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.element = element;
      }
      /**
       * @return {?}
       */


      _createClass(FileSelectDirective, [{
        key: "getOptions",
        value: function getOptions() {
          return this.uploader.options;
        }
        /**
         * @return {?}
         */

      }, {
        key: "getFilters",
        value: function getFilters() {
          return {};
        }
        /**
         * @return {?}
         */

      }, {
        key: "isEmptyAfterSelection",
        value: function isEmptyAfterSelection() {
          return !!this.element.nativeElement.attributes.multiple;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onChange",
        value: function onChange() {
          /** @type {?} */
          var files = this.element.nativeElement.files;
          /** @type {?} */

          var options = this.getOptions();
          /** @type {?} */

          var filters = this.getFilters();
          this.uploader.addToQueue(files, options, filters);
          this.onFileSelected.emit(files);

          if (this.isEmptyAfterSelection()) {
            this.element.nativeElement.value = '';
          }
        }
      }]);

      return FileSelectDirective;
    }();

    FileSelectDirective.ɵfac = function FileSelectDirective_Factory(t) {
      return new (t || FileSelectDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]));
    };

    FileSelectDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
      type: FileSelectDirective,
      selectors: [["", "ng2FileSelect", ""]],
      hostBindings: function FileSelectDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function FileSelectDirective_change_HostBindingHandler() {
            return ctx.onChange();
          });
        }
      },
      inputs: {
        uploader: "uploader"
      },
      outputs: {
        onFileSelected: "onFileSelected"
      }
    });
    /** @nocollapse */

    FileSelectDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }];
    };

    FileSelectDirective.propDecorators = {
      uploader: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      onFileSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      onChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
        args: ['change']
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](FileSelectDirective, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
        args: [{
          selector: '[ng2FileSelect]'
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
        }];
      }, {
        onFileSelected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        onChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ['change']
        }],
        uploader: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var FileDropDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       */
      function FileDropDirective(element) {
        _classCallCheck(this, FileDropDirective);

        this.fileOver = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.onFileDrop = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.element = element;
      }
      /**
       * @return {?}
       */


      _createClass(FileDropDirective, [{
        key: "getOptions",
        value: function getOptions() {
          return this.uploader.options;
        }
        /**
         * @return {?}
         */

      }, {
        key: "getFilters",
        value: function getFilters() {
          return {};
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDrop",
        value: function onDrop(event) {
          /** @type {?} */
          var transfer = this._getTransfer(event);

          if (!transfer) {
            return;
          }
          /** @type {?} */


          var options = this.getOptions();
          /** @type {?} */

          var filters = this.getFilters();

          this._preventAndStop(event);

          this.uploader.addToQueue(transfer.files, options, filters);
          this.fileOver.emit(false);
          this.onFileDrop.emit(transfer.files);
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragOver",
        value: function onDragOver(event) {
          /** @type {?} */
          var transfer = this._getTransfer(event);

          if (!this._haveFiles(transfer.types)) {
            return;
          }

          transfer.dropEffect = 'copy';

          this._preventAndStop(event);

          this.fileOver.emit(true);
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragLeave",
        value: function onDragLeave(event) {
          if (
          /** @type {?} */
          this.element) {
            if (event.currentTarget ===
            /** @type {?} */
            this.element[0]) {
              return;
            }
          }

          this._preventAndStop(event);

          this.fileOver.emit(false);
        }
        /**
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_getTransfer",
        value: function _getTransfer(event) {
          return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer; // jQuery fix;
        }
        /**
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_preventAndStop",
        value: function _preventAndStop(event) {
          event.preventDefault();
          event.stopPropagation();
        }
        /**
         * @protected
         * @param {?} types
         * @return {?}
         */

      }, {
        key: "_haveFiles",
        value: function _haveFiles(types) {
          if (!types) {
            return false;
          }

          if (types.indexOf) {
            return types.indexOf('Files') !== -1;
          } else if (types.contains) {
            return types.contains('Files');
          } else {
            return false;
          }
        }
      }]);

      return FileDropDirective;
    }();

    FileDropDirective.ɵfac = function FileDropDirective_Factory(t) {
      return new (t || FileDropDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]));
    };

    FileDropDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
      type: FileDropDirective,
      selectors: [["", "ng2FileDrop", ""]],
      hostBindings: function FileDropDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("drop", function FileDropDirective_drop_HostBindingHandler($event) {
            return ctx.onDrop($event);
          })("dragover", function FileDropDirective_dragover_HostBindingHandler($event) {
            return ctx.onDragOver($event);
          })("dragleave", function FileDropDirective_dragleave_HostBindingHandler($event) {
            return ctx.onDragLeave($event);
          });
        }
      },
      inputs: {
        uploader: "uploader"
      },
      outputs: {
        fileOver: "fileOver",
        onFileDrop: "onFileDrop"
      }
    });
    /** @nocollapse */

    FileDropDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }];
    };

    FileDropDirective.propDecorators = {
      uploader: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      fileOver: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      onFileDrop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      onDrop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
        args: ['drop', ['$event']]
      }],
      onDragOver: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
        args: ['dragover', ['$event']]
      }],
      onDragLeave: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
        args: ['dragleave', ['$event']]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](FileDropDirective, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
        args: [{
          selector: '[ng2FileDrop]'
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
        }];
      }, {
        fileOver: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        onFileDrop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        onDrop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ['drop', ['$event']]
        }],
        onDragOver: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ['dragover', ['$event']]
        }],
        onDragLeave: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"],
          args: ['dragleave', ['$event']]
        }],
        uploader: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var FileUploadModule = function FileUploadModule() {
      _classCallCheck(this, FileUploadModule);
    };

    FileUploadModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: FileUploadModule
    });
    FileUploadModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function FileUploadModule_Factory(t) {
        return new (t || FileUploadModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"]]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](FileUploadModule, {
        declarations: function declarations() {
          return [FileDropDirective, FileSelectDirective];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"]];
        },
        exports: function exports() {
          return [FileDropDirective, FileSelectDirective];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](FileUploadModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"]],
          declarations: [FileDropDirective, FileSelectDirective],
          exports: [FileDropDirective, FileSelectDirective]
        }]
      }], null, null);
    })();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    //# sourceMappingURL=ng2-file-upload.js.map

    /***/

  },

  /***/
  "./node_modules/ng2-smart-table/__ivy_ngcc__/fesm2015/ng2-smart-table.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/ng2-smart-table/__ivy_ngcc__/fesm2015/ng2-smart-table.js ***!
    \*******************************************************************************/

  /*! exports provided: Cell, DefaultEditor, DefaultFilter, LocalDataSource, Ng2SmartTableComponent, Ng2SmartTableModule, ServerDataSource, ɵa, ɵb, ɵba, ɵbb, ɵbc, ɵbd, ɵbe, ɵbf, ɵbg, ɵbh, ɵbi, ɵbj, ɵbk, ɵbl, ɵbm, ɵbn, ɵbo, ɵbp, ɵbq, ɵc, ɵd, ɵe, ɵf, ɵg, ɵh, ɵi, ɵj, ɵk, ɵl, ɵm, ɵn, ɵo, ɵp, ɵq, ɵr, ɵs, ɵt, ɵu, ɵv, ɵw, ɵx, ɵy, ɵz */

  /***/
  function node_modulesNg2SmartTable__ivy_ngcc__Fesm2015Ng2SmartTableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Cell", function () {
      return Cell;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DefaultEditor", function () {
      return DefaultEditor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DefaultFilter", function () {
      return DefaultFilter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LocalDataSource", function () {
      return LocalDataSource;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Ng2SmartTableComponent", function () {
      return Ng2SmartTableComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Ng2SmartTableModule", function () {
      return Ng2SmartTableModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ServerDataSource", function () {
      return ServerDataSource;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return CellModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return CellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵba", function () {
      return TbodyEditDeleteComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbb", function () {
      return TbodyCustomComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbc", function () {
      return Ng2SmartTableTbodyComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbd", function () {
      return THeadModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbe", function () {
      return ActionsComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbf", function () {
      return ActionsTitleComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbg", function () {
      return AddButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbh", function () {
      return CheckboxSelectAllComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbi", function () {
      return ColumnTitleComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbj", function () {
      return TitleComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbk", function () {
      return TheadFitlersRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbl", function () {
      return TheadFormRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbm", function () {
      return TheadTitlesRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbn", function () {
      return Ng2SmartTableTheadComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbo", function () {
      return Row;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbp", function () {
      return DataSet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbq", function () {
      return DataSource;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵc", function () {
      return EditCellDefault;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵd", function () {
      return CustomEditComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵe", function () {
      return DefaultEditComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵf", function () {
      return EditCellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵg", function () {
      return CheckboxEditorComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵh", function () {
      return CompleterEditorComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵi", function () {
      return InputEditorComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵj", function () {
      return SelectEditorComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵk", function () {
      return TextareaEditorComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵl", function () {
      return CustomViewComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵm", function () {
      return ViewCellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵn", function () {
      return FilterModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵo", function () {
      return FilterDefault;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵp", function () {
      return FilterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵq", function () {
      return DefaultFilterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵr", function () {
      return CustomFilterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵs", function () {
      return CheckboxFilterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵt", function () {
      return CompleterFilterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵu", function () {
      return InputFilterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵv", function () {
      return SelectFilterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵw", function () {
      return PagerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵx", function () {
      return PagerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵy", function () {
      return TBodyModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵz", function () {
      return TbodyCreateCancelComponent;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js");
    /* harmony import */


    var ng2_completer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ng2-completer */
    "./node_modules/ng2-completer/__ivy_ngcc__/esm2015/ng2-completer.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var lodash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! lodash */
    "./node_modules/lodash/lodash.js");
    /* harmony import */


    var lodash__WEBPACK_IMPORTED_MODULE_5___default =
    /*#__PURE__*/
    __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_5__);
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _angular_common_http__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/common/http */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js");
    /**
     * Extending object that entered in first argument.
     *
     * Returns extended object or false if have no target object or incorrect type.
     *
     * If you wish to clone source object (without modify it), just use empty new
     * object as first argument, like this:
     *   deepExtend({}, yourObj_1, [yourObj_N]);
     */


    function CellComponent_table_cell_view_mode_0_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "table-cell-view-mode", 2);
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r0.cell);
      }
    }

    function CellComponent_table_cell_edit_mode_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "table-cell-edit-mode", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("edited", function CellComponent_table_cell_edit_mode_1_Template_table_cell_edit_mode_edited_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r2.onEdited($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r1.cell)("inputClass", ctx_r1.inputClass);
      }
    }

    var _c0 = ["dynamicTarget"];

    function CustomEditComponent_ng_template_0_Template(rf, ctx) {}

    function DefaultEditComponent_select_editor_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "select-editor", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("onClick", function DefaultEditComponent_select_editor_1_Template_select_editor_onClick_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6);

          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r5.onClick($event);
        })("onEdited", function DefaultEditComponent_select_editor_1_Template_select_editor_onEdited_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6);

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r7.onEdited($event);
        })("onStopEditing", function DefaultEditComponent_select_editor_1_Template_select_editor_onStopEditing_0_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6);

          var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r8.onStopEditing();
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r0.cell)("inputClass", ctx_r0.inputClass);
      }
    }

    function DefaultEditComponent_textarea_editor_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "textarea-editor", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("onClick", function DefaultEditComponent_textarea_editor_2_Template_textarea_editor_onClick_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

          var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r9.onClick($event);
        })("onEdited", function DefaultEditComponent_textarea_editor_2_Template_textarea_editor_onEdited_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

          var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r11.onEdited($event);
        })("onStopEditing", function DefaultEditComponent_textarea_editor_2_Template_textarea_editor_onStopEditing_0_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

          var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r12.onStopEditing();
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r1.cell)("inputClass", ctx_r1.inputClass);
      }
    }

    function DefaultEditComponent_checkbox_editor_3_Template(rf, ctx) {
      if (rf & 1) {
        var _r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "checkbox-editor", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("onClick", function DefaultEditComponent_checkbox_editor_3_Template_checkbox_editor_onClick_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r14);

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r13.onClick($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r2.cell)("inputClass", ctx_r2.inputClass);
      }
    }

    function DefaultEditComponent_completer_editor_4_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "completer-editor", 7);
      }

      if (rf & 2) {
        var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r3.cell);
      }
    }

    function DefaultEditComponent_input_editor_5_Template(rf, ctx) {
      if (rf & 1) {
        var _r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "input-editor", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("onClick", function DefaultEditComponent_input_editor_5_Template_input_editor_onClick_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r16);

          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r15.onClick($event);
        })("onEdited", function DefaultEditComponent_input_editor_5_Template_input_editor_onEdited_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r16);

          var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r17.onEdited($event);
        })("onStopEditing", function DefaultEditComponent_input_editor_5_Template_input_editor_onStopEditing_0_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r16);

          var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r18.onStopEditing();
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r4.cell)("inputClass", ctx_r4.inputClass);
      }
    }

    function EditCellComponent_table_cell_custom_editor_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "table-cell-custom-editor", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("edited", function EditCellComponent_table_cell_custom_editor_1_Template_table_cell_custom_editor_edited_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r2.onEdited($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r0.cell)("inputClass", ctx_r0.inputClass);
      }
    }

    function EditCellComponent_table_cell_default_editor_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "table-cell-default-editor", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("edited", function EditCellComponent_table_cell_default_editor_2_Template_table_cell_default_editor_edited_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r4.onEdited($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r1.cell)("inputClass", ctx_r1.inputClass);
      }
    }

    function SelectEditorComponent_option_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "option", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var option_r1 = ctx.$implicit;

        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", option_r1.value)("selected", option_r1.value === ctx_r0.cell.getValue());

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", option_r1.title, " ");
      }
    }

    function CustomViewComponent_ng_template_0_Template(rf, ctx) {}

    function ViewCellComponent_custom_view_component_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "custom-view-component", 4);
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", ctx_r0.cell);
      }
    }

    function ViewCellComponent_div_2_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 5);
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx_r1.cell.getValue(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
      }
    }

    function ViewCellComponent_div_3_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r2.cell.getValue());
      }
    }

    function FilterComponent_div_0_custom_table_filter_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "custom-table-filter", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("filter", function FilterComponent_div_0_custom_table_filter_1_Template_custom_table_filter_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r4);

          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          return ctx_r3.onFilter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("query", ctx_r1.query)("column", ctx_r1.column)("source", ctx_r1.source)("inputClass", ctx_r1.inputClass);
      }
    }

    function FilterComponent_div_0_default_table_filter_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "default-table-filter", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("filter", function FilterComponent_div_0_default_table_filter_2_Template_default_table_filter_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6);

          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          return ctx_r5.onFilter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("query", ctx_r2.query)("column", ctx_r2.column)("source", ctx_r2.source)("inputClass", ctx_r2.inputClass);
      }
    }

    function FilterComponent_div_0_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, FilterComponent_div_0_custom_table_filter_1_Template, 1, 4, "custom-table-filter", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, FilterComponent_div_0_default_table_filter_2_Template, 1, 4, "default-table-filter", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx_r0.column.getFilterType());

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "custom");
      }
    }

    function DefaultFilterComponent_select_filter_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "select-filter", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("filter", function DefaultFilterComponent_select_filter_1_Template_select_filter_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r4.onFilter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("query", ctx_r0.query)("ngClass", ctx_r0.inputClass)("column", ctx_r0.column);
      }
    }

    function DefaultFilterComponent_checkbox_filter_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "checkbox-filter", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("filter", function DefaultFilterComponent_checkbox_filter_2_Template_checkbox_filter_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r7);

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r6.onFilter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("query", ctx_r1.query)("ngClass", ctx_r1.inputClass)("column", ctx_r1.column);
      }
    }

    function DefaultFilterComponent_completer_filter_3_Template(rf, ctx) {
      if (rf & 1) {
        var _r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "completer-filter", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("filter", function DefaultFilterComponent_completer_filter_3_Template_completer_filter_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r9);

          var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r8.onFilter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("query", ctx_r2.query)("ngClass", ctx_r2.inputClass)("column", ctx_r2.column);
      }
    }

    function DefaultFilterComponent_input_filter_4_Template(rf, ctx) {
      if (rf & 1) {
        var _r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "input-filter", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("filter", function DefaultFilterComponent_input_filter_4_Template_input_filter_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r11);

          var ctx_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r10.onFilter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("query", ctx_r3.query)("ngClass", ctx_r3.inputClass)("column", ctx_r3.column);
      }
    }

    function CustomFilterComponent_ng_template_0_Template(rf, ctx) {}

    function CheckboxFilterComponent_a_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CheckboxFilterComponent_a_1_Template_a_click_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r1.resetFilter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        var tmp_0_0 = null;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](((tmp_0_0 = ctx_r0.column.getFilterConfig()) == null ? null : tmp_0_0.resetText) || "reset");
      }
    }

    var _c1 = ["inputControl"];

    function SelectFilterComponent_option_4_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "option", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var option_r2 = ctx.$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", option_r2.value);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", option_r2.title, " ");
      }
    }

    function PagerComponent_nav_0_li_14_span_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 14);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 7);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](3, "(current)");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var page_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", page_r3, " ");
      }
    }

    function PagerComponent_nav_0_li_14_a_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 15);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PagerComponent_nav_0_li_14_a_2_Template_a_click_0_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r9);

          var page_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          return ctx_r7.paginate(page_r3);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var page_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](page_r3);
      }
    }

    var _c2 = function _c2(a0) {
      return {
        active: a0
      };
    };

    function PagerComponent_nav_0_li_14_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "li", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PagerComponent_nav_0_li_14_span_1_Template, 4, 1, "span", 12);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, PagerComponent_nav_0_li_14_a_2_Template, 2, 1, "a", 13);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var page_r3 = ctx.$implicit;

        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](3, _c2, ctx_r2.getPage() == page_r3));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r2.getPage() == page_r3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r2.getPage() != page_r3);
      }
    }

    var _c3 = function _c3(a0) {
      return {
        disabled: a0
      };
    };

    function PagerComponent_nav_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nav", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ul", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "li", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "a", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PagerComponent_nav_0_Template_a_click_3_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

          var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r11.getPage() == 1 ? false : ctx_r11.paginate(1);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "span", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](5, "\xAB");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "span", 7);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](7, "First");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](8, "li", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](9, "a", 8);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PagerComponent_nav_0_Template_a_click_9_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r13.getPage() == 1 ? false : ctx_r13.prev();
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](10, "span", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](11, "<");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](12, "span", 7);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](13, "Prev");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](14, PagerComponent_nav_0_li_14_Template, 3, 5, "li", 9);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](15, "li", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](16, "a", 10);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PagerComponent_nav_0_Template_a_click_16_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

          var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r14.getPage() == ctx_r14.getLast() ? false : ctx_r14.next();
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](17, "span", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](18, ">");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](19, "span", 7);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](20, "Next");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](21, "li", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](22, "a", 11);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PagerComponent_nav_0_Template_a_click_22_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r15.getPage() == ctx_r15.getLast() ? false : ctx_r15.paginate(ctx_r15.getLast());
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](23, "span", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](24, "\xBB");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](25, "span", 7);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](26, "Last");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](5, _c3, ctx_r0.getPage() == 1));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](7, _c3, ctx_r0.getPage() == 1));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.getPages());

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](9, _c3, ctx_r0.getPage() == ctx_r0.getLast()));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](11, _c3, ctx_r0.getPage() == ctx_r0.getLast()));
      }
    }

    function PagerComponent_nav_1_option_4_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "option", 20);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var item_r17 = ctx.$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("value", item_r17);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](item_r17);
      }
    }

    function PagerComponent_nav_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nav", 16);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "label", 17);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2, " Per Page: ");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "select", 18);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("change", function PagerComponent_nav_1_Template_select_change_3_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r19);

          var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r18.onChangePerPage($event);
        })("ngModelChange", function PagerComponent_nav_1_Template_select_ngModelChange_3_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r19);

          var ctx_r20 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r20.currentPerPage = $event;
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, PagerComponent_nav_1_option_4_Template, 2, 2, "option", 19);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx_r1.currentPerPage);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r1.perPageSelect);
      }
    }

    var _c4 = ["ng2-st-tbody", ""];

    function Ng2SmartTableTbodyComponent_tr_0_td_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function Ng2SmartTableTbodyComponent_tr_0_td_1_Template_td_click_0_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r11);

          var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r9.multipleSelectRow.emit(row_r2);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "input", 7);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", row_r2.isSelected);
      }
    }

    function Ng2SmartTableTbodyComponent_tr_0_td_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 8);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-st-tbody-custom", 9);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("custom", function Ng2SmartTableTbodyComponent_tr_0_td_2_Template_ng2_st_tbody_custom_custom_1_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r14);

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          return ctx_r13.custom.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "ng2-st-tbody-edit-delete", 10);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("edit", function Ng2SmartTableTbodyComponent_tr_0_td_2_Template_ng2_st_tbody_edit_delete_edit_2_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r14);

          var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r15.edit.emit(row_r2);
        })("delete", function Ng2SmartTableTbodyComponent_tr_0_td_2_Template_ng2_st_tbody_edit_delete_delete_2_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r14);

          var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r17["delete"].emit(row_r2);
        })("editRowSelect", function Ng2SmartTableTbodyComponent_tr_0_td_2_Template_ng2_st_tbody_edit_delete_editRowSelect_2_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r14);

          var ctx_r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          return ctx_r19.editRowSelect.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r4.grid)("row", row_r2)("source", ctx_r4.source);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r4.grid)("deleteConfirm", ctx_r4.deleteConfirm)("editConfirm", ctx_r4.editConfirm)("row", row_r2)("source", ctx_r4.source);
      }
    }

    function Ng2SmartTableTbodyComponent_tr_0_td_3_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 8);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "ng2-st-tbody-create-cancel", 11);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r5.grid)("row", row_r2)("editConfirm", ctx_r5.editConfirm);
      }
    }

    function Ng2SmartTableTbodyComponent_tr_0_td_4_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "ng2-smart-table-cell", 12);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var cell_r22 = ctx.$implicit;

        var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", cell_r22)("grid", ctx_r6.grid)("row", row_r2)("isNew", false)("mode", ctx_r6.mode)("editConfirm", ctx_r6.editConfirm)("inputClass", ctx_r6.editInputClass)("isInEditing", row_r2.isInEditing);
      }
    }

    function Ng2SmartTableTbodyComponent_tr_0_td_5_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 8);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "ng2-st-tbody-create-cancel", 11);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r7.grid)("row", row_r2)("editConfirm", ctx_r7.editConfirm);
      }
    }

    function Ng2SmartTableTbodyComponent_tr_0_td_6_Template(rf, ctx) {
      if (rf & 1) {
        var _r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 8);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-st-tbody-custom", 9);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("custom", function Ng2SmartTableTbodyComponent_tr_0_td_6_Template_ng2_st_tbody_custom_custom_1_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r26);

          var ctx_r25 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          return ctx_r25.custom.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "ng2-st-tbody-edit-delete", 10);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("edit", function Ng2SmartTableTbodyComponent_tr_0_td_6_Template_ng2_st_tbody_edit_delete_edit_2_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r26);

          var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r27 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r27.edit.emit(row_r2);
        })("delete", function Ng2SmartTableTbodyComponent_tr_0_td_6_Template_ng2_st_tbody_edit_delete_delete_2_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r26);

          var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r29 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r29["delete"].emit(row_r2);
        })("editRowSelect", function Ng2SmartTableTbodyComponent_tr_0_td_6_Template_ng2_st_tbody_edit_delete_editRowSelect_2_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r26);

          var ctx_r31 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          return ctx_r31.editRowSelect.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var row_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

        var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r8.grid)("row", row_r2)("source", ctx_r8.source);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r8.grid)("deleteConfirm", ctx_r8.deleteConfirm)("editConfirm", ctx_r8.editConfirm)("row", row_r2)("source", ctx_r8.source);
      }
    }

    var _c5 = function _c5(a0) {
      return {
        selected: a0
      };
    };

    function Ng2SmartTableTbodyComponent_tr_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r34 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "tr", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function Ng2SmartTableTbodyComponent_tr_0_Template_tr_click_0_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r34);

          var row_r2 = ctx.$implicit;

          var ctx_r33 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r33.userSelectRow.emit(row_r2);
        })("mouseover", function Ng2SmartTableTbodyComponent_tr_0_Template_tr_mouseover_0_listener() {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r34);

          var row_r2 = ctx.$implicit;

          var ctx_r35 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r35.rowHover.emit(row_r2);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, Ng2SmartTableTbodyComponent_tr_0_td_1_Template, 2, 1, "td", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, Ng2SmartTableTbodyComponent_tr_0_td_2_Template, 3, 8, "td", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, Ng2SmartTableTbodyComponent_tr_0_td_3_Template, 2, 3, "td", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, Ng2SmartTableTbodyComponent_tr_0_td_4_Template, 2, 8, "td", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, Ng2SmartTableTbodyComponent_tr_0_td_5_Template, 2, 3, "td", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, Ng2SmartTableTbodyComponent_tr_0_td_6_Template, 3, 8, "td", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var row_r2 = ctx.$implicit;

        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("className", ctx_r0.rowClassFunction(row_r2))("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](8, _c5, row_r2.isSelected));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r0.isMultiSelectVisible);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !row_r2.isInEditing && ctx_r0.showActionColumnLeft);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", row_r2.isInEditing && ctx_r0.showActionColumnLeft);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.getVisibleCells(row_r2.cells));

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", row_r2.isInEditing && ctx_r0.showActionColumnRight);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !row_r2.isInEditing && ctx_r0.showActionColumnRight);
      }
    }

    function Ng2SmartTableTbodyComponent_tr_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "tr");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "td");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("colspan", ctx_r1.tableColumnsCount);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", ctx_r1.noDataMessage, " ");
      }
    }

    function TbodyEditDeleteComponent_a_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TbodyEditDeleteComponent_a_0_Template_a_click_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r2.onEdit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx_r0.editRowButtonContent, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
      }
    }

    function TbodyEditDeleteComponent_a_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TbodyEditDeleteComponent_a_1_Template_a_click_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r4.onDelete($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx_r1.deleteRowButtonContent, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
      }
    }

    function TbodyCustomComponent_a_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TbodyCustomComponent_a_0_Template_a_click_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var action_r1 = ctx.$implicit;

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r2.onCustom(action_r1, $event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var action_r1 = ctx.$implicit;

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", action_r1.title, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
      }
    }

    var _c6 = ["ng2-st-thead", ""];

    function Ng2SmartTableTheadComponent_tr_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "tr", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("sort", function Ng2SmartTableTheadComponent_tr_0_Template_tr_sort_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r4);

          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r3.sort.emit($event);
        })("selectAllRows", function Ng2SmartTableTheadComponent_tr_0_Template_tr_selectAllRows_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r4);

          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r5.selectAllRows.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r0.grid)("isAllSelected", ctx_r0.isAllSelected)("source", ctx_r0.source);
      }
    }

    function Ng2SmartTableTheadComponent_tr_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "tr", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("create", function Ng2SmartTableTheadComponent_tr_1_Template_tr_create_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r7);

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r6.create.emit($event);
        })("filter", function Ng2SmartTableTheadComponent_tr_1_Template_tr_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r7);

          var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r8.filter.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r1.grid)("source", ctx_r1.source);
      }
    }

    function Ng2SmartTableTheadComponent_tr_2_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tr", 5);
      }

      if (rf & 2) {
        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r2.grid)("createConfirm", ctx_r2.createConfirm);
      }
    }

    var _c7 = ["ng2-st-actions-title", ""];
    var _c8 = ["ng2-st-add-button", ""];

    function AddButtonComponent_a_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function AddButtonComponent_a_0_Template_a_click_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r1.onAdd($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx_r0.addNewButtonContent, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
      }
    }

    var _c9 = ["ng2-st-checkbox-select-all", ""];

    function TitleComponent_a_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 2);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TitleComponent_a_0_Template_a_click_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r2._sort($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx_r0.currentDirection);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", ctx_r0.column.title, " ");
      }
    }

    function TitleComponent_span_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r1.column.title);
      }
    }

    var _c10 = ["ng2-st-thead-filters-row", ""];

    function TheadFitlersRowComponent_th_0_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "th");
      }
    }

    function TheadFitlersRowComponent_th_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "th", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("create", function TheadFitlersRowComponent_th_1_Template_th_create_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r4.create.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r1.grid);
      }
    }

    function TheadFitlersRowComponent_th_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "th");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-smart-table-filter", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("filter", function TheadFitlersRowComponent_th_2_Template_ng2_smart_table_filter_filter_1_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r8);

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r7.filter.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var column_r6 = ctx.$implicit;

        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("ng2-smart-th ", column_r6.id, "");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("source", ctx_r2.source)("column", column_r6)("inputClass", ctx_r2.filterInputClass);
      }
    }

    function TheadFitlersRowComponent_th_3_Template(rf, ctx) {
      if (rf & 1) {
        var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "th", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("create", function TheadFitlersRowComponent_th_3_Template_th_create_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

          var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r9.create.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r3.grid)("source", ctx_r3.source);
      }
    }

    var _c11 = ["ng2-st-thead-form-row", ""];

    function TheadFormRowComponent_td_0_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "td");
      }
    }

    function TheadFormRowComponent_td_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-st-actions", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("create", function TheadFormRowComponent_td_1_Template_ng2_st_actions_create_1_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r4.onCreate($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r1.grid);
      }
    }

    function TheadFormRowComponent_td_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-smart-table-cell", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("edited", function TheadFormRowComponent_td_2_Template_ng2_smart_table_cell_edited_1_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r8);

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r7.onCreate($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var cell_r6 = ctx.$implicit;

        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cell", cell_r6)("grid", ctx_r2.grid)("isNew", true)("createConfirm", ctx_r2.createConfirm)("inputClass", ctx_r2.addInputClass)("isInEditing", ctx_r2.grid.getNewRow().isInEditing);
      }
    }

    function TheadFormRowComponent_td_3_Template(rf, ctx) {
      if (rf & 1) {
        var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "td", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-st-actions", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("create", function TheadFormRowComponent_td_3_Template_ng2_st_actions_create_1_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

          var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r9.onCreate($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r3.grid);
      }
    }

    var _c12 = ["ng2-st-thead-titles-row", ""];

    function TheadTitlesRowComponent_th_0_Template(rf, ctx) {
      if (rf & 1) {
        var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "th", 3);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TheadTitlesRowComponent_th_0_Template_th_click_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r4.selectAllRows.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r0.grid)("source", ctx_r0.source)("isAllSelected", ctx_r0.isAllSelected);
      }
    }

    function TheadTitlesRowComponent_th_1_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "th", 4);
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r1.grid);
      }
    }

    function TheadTitlesRowComponent_th_2_Template(rf, ctx) {
      if (rf & 1) {
        var _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "th", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-st-column-title", 6);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("sort", function TheadTitlesRowComponent_th_2_Template_ng2_st_column_title_sort_1_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r8);

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r7.sort.emit($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var column_r6 = ctx.$implicit;

        var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("ng2-smart-th ", column_r6.id, "");

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("width", column_r6.width);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", column_r6["class"]);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("source", ctx_r2.source)("column", column_r6);
      }
    }

    function TheadTitlesRowComponent_th_3_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "th", 4);
      }

      if (rf & 2) {
        var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r3.grid);
      }
    }

    function Ng2SmartTableComponent_thead_1_Template(rf, ctx) {
      if (rf & 1) {
        var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "thead", 4);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("create", function Ng2SmartTableComponent_thead_1_Template_thead_create_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r2.create.emit($event);
        })("selectAllRows", function Ng2SmartTableComponent_thead_1_Template_thead_selectAllRows_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r4.onSelectAllRows($event);
        })("sort", function Ng2SmartTableComponent_thead_1_Template_thead_sort_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r5.sort($event);
        })("filter", function Ng2SmartTableComponent_thead_1_Template_thead_filter_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r6.filter($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx_r0.grid)("isAllSelected", ctx_r0.isAllSelected)("source", ctx_r0.source)("createConfirm", ctx_r0.createConfirm);
      }
    }

    function Ng2SmartTableComponent_ng2_smart_table_pager_3_Template(rf, ctx) {
      if (rf & 1) {
        var _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ng2-smart-table-pager", 5);

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("changePage", function Ng2SmartTableComponent_ng2_smart_table_pager_3_Template_ng2_smart_table_pager_changePage_0_listener($event) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r8);

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          return ctx_r7.changePage($event);
        });

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      }

      if (rf & 2) {
        var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("source", ctx_r1.source)("perPageSelect", ctx_r1.perPageSelect);
      }
    }

    var deepExtend = function deepExtend() {
      for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }

      if (arguments.length < 1 || typeof arguments[0] !== 'object') {
        return false;
      }

      if (arguments.length < 2) {
        return arguments[0];
      }

      var target = arguments[0]; // convert arguments to array and cut off target object

      var args = Array.prototype.slice.call(arguments, 1);
      var val, src;
      args.forEach(function (obj) {
        // skip argument if it is array or isn't object
        if (typeof obj !== 'object' || Array.isArray(obj)) {
          return;
        }

        Object.keys(obj).forEach(function (key) {
          src = target[key]; // source value

          val = obj[key]; // new value
          // recursion prevention

          if (val === target) {
            return;
            /**
             * if new value isn't object then just overwrite by new value
             * instead of extending.
             */
          } else if (typeof val !== 'object' || val === null) {
            target[key] = val;
            return; // just clone arrays (and recursive clone objects inside)
          } else if (Array.isArray(val)) {
            target[key] = Object(lodash__WEBPACK_IMPORTED_MODULE_5__["cloneDeep"])(val);
            return; // overwrite by new value if source isn't object or array
          } else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return; // source value and new value is objects both, extending...
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    };

    var Deferred = function Deferred() {
      var _this24 = this;

      _classCallCheck(this, Deferred);

      this.promise = new Promise(function (resolve, reject) {
        _this24.resolve = resolve;
        _this24.reject = reject;
      });
    }; // getDeepFromObject({result: {data: 1}}, 'result.data', 2); // returns 1


    function getDeepFromObject() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var name = arguments.length > 1 ? arguments[1] : undefined;
      var defaultValue = arguments.length > 2 ? arguments[2] : undefined;
      var keys = name.split('.'); // clone the object

      var level = deepExtend({}, object);
      keys.forEach(function (k) {
        if (level && typeof level[k] !== 'undefined') {
          level = level[k];
        }
      });
      return typeof level === 'undefined' ? defaultValue : level;
    }

    function getPageForRowIndex(index, perPage) {
      // we need to add 1 to convert 0-based index to 1-based page number.
      return Math.floor(index / perPage) + 1;
    }

    function prepareValue(value) {
      return value;
    }

    var Cell =
    /*#__PURE__*/
    function () {
      function Cell(value, row, column, dataSet) {
        _classCallCheck(this, Cell);

        this.value = value;
        this.row = row;
        this.column = column;
        this.dataSet = dataSet;
        this.newValue = '';
        this.newValue = value;
      }

      _createClass(Cell, [{
        key: "getColumn",
        value: function getColumn() {
          return this.column;
        }
      }, {
        key: "getRow",
        value: function getRow() {
          return this.row;
        }
      }, {
        key: "getValue",
        value: function getValue() {
          var valid = this.column.getValuePrepareFunction() instanceof Function;
          var prepare = valid ? this.column.getValuePrepareFunction() : Cell.PREPARE;
          return prepare.call(null, this.value, this.row.getData(), this);
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.newValue = value;
        }
      }, {
        key: "getId",
        value: function getId() {
          return this.getColumn().id;
        }
      }, {
        key: "getTitle",
        value: function getTitle() {
          return this.getColumn().title;
        }
      }, {
        key: "isEditable",
        value: function isEditable() {
          if (this.getRow().index === -1) {
            return this.getColumn().isAddable;
          } else {
            return this.getColumn().isEditable;
          }
        }
      }]);

      return Cell;
    }();

    Cell.PREPARE = prepareValue;

    var Row =
    /*#__PURE__*/
    function () {
      function Row(index, data, _dataSet) {
        _classCallCheck(this, Row);

        this.index = index;
        this.data = data;
        this._dataSet = _dataSet;
        this.isSelected = false;
        this.isInEditing = false;
        this.cells = [];
        this.process();
      }

      _createClass(Row, [{
        key: "getCell",
        value: function getCell(column) {
          return this.cells.find(function (el) {
            return el.getColumn() === column;
          });
        }
      }, {
        key: "getCells",
        value: function getCells() {
          return this.cells;
        }
      }, {
        key: "getData",
        value: function getData() {
          return this.data;
        }
      }, {
        key: "getIsSelected",
        value: function getIsSelected() {
          return this.isSelected;
        }
      }, {
        key: "getNewData",
        value: function getNewData() {
          var values = Object.assign({}, this.data);
          this.getCells().forEach(function (cell) {
            return values[cell.getColumn().id] = cell.newValue;
          });
          return values;
        }
      }, {
        key: "setData",
        value: function setData(data) {
          this.data = data;
          this.process();
        }
      }, {
        key: "process",
        value: function process() {
          var _this25 = this;

          this.cells = [];

          this._dataSet.getColumns().forEach(function (column) {
            var cell = _this25.createCell(column);

            _this25.cells.push(cell);
          });
        }
      }, {
        key: "createCell",
        value: function createCell(column) {
          var defValue = column.settings.defaultValue ? column.settings.defaultValue : '';
          var value = typeof this.data[column.id] === 'undefined' ? defValue : this.data[column.id];
          return new Cell(value, this, column, this._dataSet);
        }
      }]);

      return Row;
    }();

    var Column =
    /*#__PURE__*/
    function () {
      function Column(id, settings, dataSet) {
        _classCallCheck(this, Column);

        this.id = id;
        this.settings = settings;
        this.dataSet = dataSet;
        this.title = '';
        this.type = '';
        this["class"] = '';
        this.width = '';
        this.hide = false;
        this.isSortable = false;
        this.isEditable = true;
        this.isAddable = true;
        this.isFilterable = false;
        this.sortDirection = '';
        this.defaultSortDirection = '';
        this.editor = {
          type: '',
          config: {},
          component: null
        };
        this.filter = {
          type: '',
          config: {},
          component: null
        };
        this.renderComponent = null;
        this.process();
      }

      _createClass(Column, [{
        key: "getOnComponentInitFunction",
        value: function getOnComponentInitFunction() {
          return this.onComponentInitFunction;
        }
      }, {
        key: "getCompareFunction",
        value: function getCompareFunction() {
          return this.compareFunction;
        }
      }, {
        key: "getValuePrepareFunction",
        value: function getValuePrepareFunction() {
          return this.valuePrepareFunction;
        }
      }, {
        key: "getFilterFunction",
        value: function getFilterFunction() {
          return this.filterFunction;
        }
      }, {
        key: "getConfig",
        value: function getConfig() {
          return this.editor && this.editor.config;
        }
      }, {
        key: "getFilterType",
        value: function getFilterType() {
          return this.filter && this.filter.type;
        }
      }, {
        key: "getFilterConfig",
        value: function getFilterConfig() {
          return this.filter && this.filter.config;
        }
      }, {
        key: "process",
        value: function process() {
          this.title = this.settings['title'];
          this["class"] = this.settings['class'];
          this.width = this.settings['width'];
          this.hide = !!this.settings['hide'];
          this.type = this.prepareType();
          this.editor = this.settings['editor'];
          this.filter = this.settings['filter'];
          this.renderComponent = this.settings['renderComponent'];
          this.isFilterable = typeof this.settings['filter'] === 'undefined' ? true : !!this.settings['filter'];
          this.defaultSortDirection = ['asc', 'desc'].indexOf(this.settings['sortDirection']) !== -1 ? this.settings['sortDirection'] : '';
          this.isSortable = typeof this.settings['sort'] === 'undefined' ? true : !!this.settings['sort'];
          this.isEditable = typeof this.settings['editable'] === 'undefined' ? true : !!this.settings['editable'];
          this.isAddable = typeof this.settings['addable'] === 'undefined' ? true : !!this.settings['addable'];
          this.sortDirection = this.prepareSortDirection();
          this.compareFunction = this.settings['compareFunction'];
          this.valuePrepareFunction = this.settings['valuePrepareFunction'];
          this.filterFunction = this.settings['filterFunction'];
          this.onComponentInitFunction = this.settings['onComponentInitFunction'];
        }
      }, {
        key: "prepareType",
        value: function prepareType() {
          return this.settings['type'] || this.determineType();
        }
      }, {
        key: "prepareSortDirection",
        value: function prepareSortDirection() {
          return this.settings['sort'] === 'desc' ? 'desc' : 'asc';
        }
      }, {
        key: "determineType",
        value: function determineType() {
          // TODO: determine type by data
          return 'text';
        }
      }]);

      return Column;
    }();

    var DataSet =
    /*#__PURE__*/
    function () {
      function DataSet() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var columnSettings = arguments.length > 1 ? arguments[1] : undefined;

        _classCallCheck(this, DataSet);

        this.columnSettings = columnSettings;
        this.data = [];
        this.columns = [];
        this.rows = [];
        this.createColumns(columnSettings);
        this.setData(data);
        this.createNewRow();
      }

      _createClass(DataSet, [{
        key: "setData",
        value: function setData(data) {
          this.data = data;
          this.createRows();
        }
      }, {
        key: "getColumns",
        value: function getColumns() {
          return this.columns;
        }
      }, {
        key: "getRows",
        value: function getRows() {
          return this.rows;
        }
      }, {
        key: "getFirstRow",
        value: function getFirstRow() {
          return this.rows[0];
        }
      }, {
        key: "getLastRow",
        value: function getLastRow() {
          return this.rows[this.rows.length - 1];
        }
      }, {
        key: "findRowByData",
        value: function findRowByData(data) {
          return this.rows.find(function (row) {
            return row.getData() === data;
          });
        }
      }, {
        key: "deselectAll",
        value: function deselectAll() {
          this.rows.forEach(function (row) {
            row.isSelected = false;
          }); // we need to clear selectedRow field because no one row selected

          this.selectedRow = undefined;
        }
      }, {
        key: "selectRow",
        value: function selectRow(row) {
          var previousIsSelected = row.isSelected;
          this.deselectAll();
          row.isSelected = !previousIsSelected;
          this.selectedRow = row;
          return this.selectedRow;
        }
      }, {
        key: "multipleSelectRow",
        value: function multipleSelectRow(row) {
          row.isSelected = !row.isSelected;
          this.selectedRow = row;
          return this.selectedRow;
        }
      }, {
        key: "selectPreviousRow",
        value: function selectPreviousRow() {
          if (this.rows.length > 0) {
            var index = this.selectedRow ? this.selectedRow.index : 0;

            if (index > this.rows.length - 1) {
              index = this.rows.length - 1;
            }

            this.selectRow(this.rows[index]);
            return this.selectedRow;
          }
        }
      }, {
        key: "selectFirstRow",
        value: function selectFirstRow() {
          if (this.rows.length > 0) {
            this.selectRow(this.rows[0]);
            return this.selectedRow;
          }
        }
      }, {
        key: "selectLastRow",
        value: function selectLastRow() {
          if (this.rows.length > 0) {
            this.selectRow(this.rows[this.rows.length - 1]);
            return this.selectedRow;
          }
        }
      }, {
        key: "selectRowByIndex",
        value: function selectRowByIndex(index) {
          var rowsLength = this.rows.length;

          if (rowsLength === 0) {
            return;
          }

          if (!index) {
            this.selectFirstRow();
            return this.selectedRow;
          }

          if (index > 0 && index < rowsLength) {
            this.selectRow(this.rows[index]);
            return this.selectedRow;
          } // we need to deselect all rows if we got an incorrect index


          this.deselectAll();
        }
      }, {
        key: "willSelectFirstRow",
        value: function willSelectFirstRow() {
          this.willSelect = 'first';
        }
      }, {
        key: "willSelectLastRow",
        value: function willSelectLastRow() {
          this.willSelect = 'last';
        }
      }, {
        key: "select",
        value: function select(selectedRowIndex) {
          if (this.getRows().length === 0) {
            return;
          }

          if (this.willSelect) {
            if (this.willSelect === 'first') {
              this.selectFirstRow();
            }

            if (this.willSelect === 'last') {
              this.selectLastRow();
            }

            this.willSelect = '';
          } else {
            this.selectRowByIndex(selectedRowIndex);
          }

          return this.selectedRow;
        }
      }, {
        key: "createNewRow",
        value: function createNewRow() {
          this.newRow = new Row(-1, {}, this);
          this.newRow.isInEditing = true;
        }
        /**
         * Create columns by mapping from the settings
         * @param settings
         * @private
         */

      }, {
        key: "createColumns",
        value: function createColumns(settings) {
          for (var id in settings) {
            if (settings.hasOwnProperty(id)) {
              this.columns.push(new Column(id, settings[id], this));
            }
          }
        }
        /**
         * Create rows based on current data prepared in data source
         * @private
         */

      }, {
        key: "createRows",
        value: function createRows() {
          var _this26 = this;

          this.rows = [];
          this.data.forEach(function (el, index) {
            _this26.rows.push(new Row(index, el, _this26));
          });
        }
      }]);

      return DataSet;
    }();

    var Grid =
    /*#__PURE__*/
    function () {
      function Grid(source, settings) {
        _classCallCheck(this, Grid);

        this.createFormShown = false;
        this.onSelectRowSource = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.onDeselectRowSource = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.setSettings(settings);
        this.setSource(source);
      }

      _createClass(Grid, [{
        key: "detach",
        value: function detach() {
          if (this.sourceOnChangedSubscription) {
            this.sourceOnChangedSubscription.unsubscribe();
          }

          if (this.sourceOnUpdatedSubscription) {
            this.sourceOnUpdatedSubscription.unsubscribe();
          }
        }
      }, {
        key: "showActionColumn",
        value: function showActionColumn(position) {
          return this.isCurrentActionsPosition(position) && this.isActionsVisible();
        }
      }, {
        key: "isCurrentActionsPosition",
        value: function isCurrentActionsPosition(position) {
          return position == this.getSetting('actions.position');
        }
      }, {
        key: "isActionsVisible",
        value: function isActionsVisible() {
          return this.getSetting('actions.add') || this.getSetting('actions.edit') || this.getSetting('actions.delete') || this.getSetting('actions.custom').length;
        }
      }, {
        key: "isMultiSelectVisible",
        value: function isMultiSelectVisible() {
          return this.getSetting('selectMode') === 'multi';
        }
      }, {
        key: "getNewRow",
        value: function getNewRow() {
          return this.dataSet.newRow;
        }
      }, {
        key: "setSettings",
        value: function setSettings(settings) {
          this.settings = settings;
          this.dataSet = new DataSet([], this.getSetting('columns'));

          if (this.source) {
            this.source.refresh();
          }
        }
      }, {
        key: "getDataSet",
        value: function getDataSet() {
          return this.dataSet;
        }
      }, {
        key: "setSource",
        value: function setSource(source) {
          var _this27 = this;

          this.source = this.prepareSource(source);
          this.detach();
          this.sourceOnChangedSubscription = this.source.onChanged().subscribe(function (changes) {
            return _this27.processDataChange(changes);
          });
          this.sourceOnUpdatedSubscription = this.source.onUpdated().subscribe(function (data) {
            var changedRow = _this27.dataSet.findRowByData(data);

            changedRow.setData(data);
          });
        }
      }, {
        key: "getSetting",
        value: function getSetting(name, defaultValue) {
          return getDeepFromObject(this.settings, name, defaultValue);
        }
      }, {
        key: "getColumns",
        value: function getColumns() {
          return this.dataSet.getColumns();
        }
      }, {
        key: "getRows",
        value: function getRows() {
          return this.dataSet.getRows();
        }
      }, {
        key: "selectRow",
        value: function selectRow(row) {
          this.dataSet.selectRow(row);
        }
      }, {
        key: "multipleSelectRow",
        value: function multipleSelectRow(row) {
          this.dataSet.multipleSelectRow(row);
        }
      }, {
        key: "onSelectRow",
        value: function onSelectRow() {
          return this.onSelectRowSource.asObservable();
        }
      }, {
        key: "onDeselectRow",
        value: function onDeselectRow() {
          return this.onDeselectRowSource.asObservable();
        }
      }, {
        key: "edit",
        value: function edit(row) {
          row.isInEditing = true;
        }
      }, {
        key: "create",
        value: function create(row, confirmEmitter) {
          var _this28 = this;

          var deferred = new Deferred();
          deferred.promise.then(function (newData) {
            newData = newData ? newData : row.getNewData();

            if (deferred.resolve.skipAdd) {
              _this28.createFormShown = false;
            } else {
              _this28.source.prepend(newData).then(function () {
                _this28.createFormShown = false;

                _this28.dataSet.createNewRow();
              });
            }
          })["catch"](function (err) {// doing nothing
          });

          if (this.getSetting('add.confirmCreate')) {
            confirmEmitter.emit({
              newData: row.getNewData(),
              source: this.source,
              confirm: deferred
            });
          } else {
            deferred.resolve();
          }
        }
      }, {
        key: "save",
        value: function save(row, confirmEmitter) {
          var _this29 = this;

          var deferred = new Deferred();
          deferred.promise.then(function (newData) {
            newData = newData ? newData : row.getNewData();

            if (deferred.resolve.skipEdit) {
              row.isInEditing = false;
            } else {
              _this29.source.update(row.getData(), newData).then(function () {
                row.isInEditing = false;
              });
            }
          })["catch"](function (err) {// doing nothing
          });

          if (this.getSetting('edit.confirmSave')) {
            confirmEmitter.emit({
              data: row.getData(),
              newData: row.getNewData(),
              source: this.source,
              confirm: deferred
            });
          } else {
            deferred.resolve();
          }
        }
      }, {
        key: "delete",
        value: function _delete(row, confirmEmitter) {
          var _this30 = this;

          var deferred = new Deferred();
          deferred.promise.then(function () {
            _this30.source.remove(row.getData());
          })["catch"](function (err) {// doing nothing
          });

          if (this.getSetting('delete.confirmDelete')) {
            confirmEmitter.emit({
              data: row.getData(),
              source: this.source,
              confirm: deferred
            });
          } else {
            deferred.resolve();
          }
        }
      }, {
        key: "processDataChange",
        value: function processDataChange(changes) {
          if (this.shouldProcessChange(changes)) {
            this.dataSet.setData(changes['elements']);

            if (this.getSetting('selectMode') !== 'multi') {
              var row = this.determineRowToSelect(changes);

              if (row) {
                this.onSelectRowSource.next(row);
              } else {
                this.onDeselectRowSource.next(null);
              }
            }
          }
        }
      }, {
        key: "shouldProcessChange",
        value: function shouldProcessChange(changes) {
          if (['filter', 'sort', 'page', 'remove', 'refresh', 'load', 'paging'].indexOf(changes['action']) !== -1) {
            return true;
          } else if (['prepend', 'append'].indexOf(changes['action']) !== -1 && !this.getSetting('pager.display')) {
            return true;
          }

          return false;
        }
        /**
         * @breaking-change 1.8.0
         * Need to add `| null` in return type
         *
         * TODO: move to selectable? Separate directive
         */

      }, {
        key: "determineRowToSelect",
        value: function determineRowToSelect(changes) {
          if (['load', 'page', 'filter', 'sort', 'refresh'].indexOf(changes['action']) !== -1) {
            return this.dataSet.select(this.getRowIndexToSelect());
          }

          if (this.shouldSkipSelection()) {
            return null;
          }

          if (changes['action'] === 'remove') {
            if (changes['elements'].length === 0) {
              // we have to store which one to select as the data will be reloaded
              this.dataSet.willSelectLastRow();
            } else {
              return this.dataSet.selectPreviousRow();
            }
          }

          if (changes['action'] === 'append') {
            // we have to store which one to select as the data will be reloaded
            this.dataSet.willSelectLastRow();
          }

          if (changes['action'] === 'add') {
            return this.dataSet.selectFirstRow();
          }

          if (changes['action'] === 'update') {
            return this.dataSet.selectFirstRow();
          }

          if (changes['action'] === 'prepend') {
            // we have to store which one to select as the data will be reloaded
            this.dataSet.willSelectFirstRow();
          }

          return null;
        }
      }, {
        key: "prepareSource",
        value: function prepareSource(source) {
          var initialSource = this.getInitialSort();

          if (initialSource && initialSource['field'] && initialSource['direction']) {
            source.setSort([initialSource], false);
          }

          if (this.getSetting('pager.display') === true) {
            source.setPaging(this.getPageToSelect(source), this.getSetting('pager.perPage'), false);
          }

          source.refresh();
          return source;
        }
      }, {
        key: "getInitialSort",
        value: function getInitialSort() {
          var sortConf = {};
          this.getColumns().forEach(function (column) {
            if (column.isSortable && column.defaultSortDirection) {
              sortConf['field'] = column.id;
              sortConf['direction'] = column.defaultSortDirection;
              sortConf['compare'] = column.getCompareFunction();
            }
          });
          return sortConf;
        }
      }, {
        key: "getSelectedRows",
        value: function getSelectedRows() {
          return this.dataSet.getRows().filter(function (r) {
            return r.isSelected;
          });
        }
      }, {
        key: "selectAllRows",
        value: function selectAllRows(status) {
          this.dataSet.getRows().forEach(function (r) {
            return r.isSelected = status;
          });
        }
      }, {
        key: "getFirstRow",
        value: function getFirstRow() {
          return this.dataSet.getFirstRow();
        }
      }, {
        key: "getLastRow",
        value: function getLastRow() {
          return this.dataSet.getLastRow();
        }
      }, {
        key: "getSelectionInfo",
        value: function getSelectionInfo() {
          var switchPageToSelectedRowPage = this.getSetting('switchPageToSelectedRowPage');
          var selectedRowIndex = Number(this.getSetting('selectedRowIndex', 0)) || 0;

          var _this$getSetting = this.getSetting('pager'),
              perPage = _this$getSetting.perPage,
              page = _this$getSetting.page;

          return {
            perPage: perPage,
            page: page,
            selectedRowIndex: selectedRowIndex,
            switchPageToSelectedRowPage: switchPageToSelectedRowPage
          };
        }
      }, {
        key: "getRowIndexToSelect",
        value: function getRowIndexToSelect() {
          var _this$getSelectionInf = this.getSelectionInfo(),
              switchPageToSelectedRowPage = _this$getSelectionInf.switchPageToSelectedRowPage,
              selectedRowIndex = _this$getSelectionInf.selectedRowIndex,
              perPage = _this$getSelectionInf.perPage;

          var dataAmount = this.source.count();
          /**
           * source - contains all table data
           * dataSet - contains data for current page
           * selectedRowIndex - contains index for data in all data
           *
           * because of that, we need to count index for a specific row in page
           * if
           * `switchPageToSelectedRowPage` - we need to change page automatically
           * `selectedRowIndex < dataAmount && selectedRowIndex >= 0` - index points to existing data
           * (if index points to non-existing data and we calculate index for current page - we will get wrong selected row.
           *  if we return index witch not points to existing data - no line will be highlighted)
           */

          return switchPageToSelectedRowPage && selectedRowIndex < dataAmount && selectedRowIndex >= 0 ? selectedRowIndex % perPage : selectedRowIndex;
        }
      }, {
        key: "getPageToSelect",
        value: function getPageToSelect(source) {
          var _this$getSelectionInf2 = this.getSelectionInfo(),
              switchPageToSelectedRowPage = _this$getSelectionInf2.switchPageToSelectedRowPage,
              selectedRowIndex = _this$getSelectionInf2.selectedRowIndex,
              perPage = _this$getSelectionInf2.perPage,
              page = _this$getSelectionInf2.page;

          var pageToSelect = Math.max(1, page);

          if (switchPageToSelectedRowPage && selectedRowIndex >= 0) {
            pageToSelect = getPageForRowIndex(selectedRowIndex, perPage);
          }

          var maxPageAmount = Math.ceil(source.count() / perPage);
          return maxPageAmount ? Math.min(pageToSelect, maxPageAmount) : pageToSelect;
        }
      }, {
        key: "shouldSkipSelection",
        value: function shouldSkipSelection() {
          /**
           * For backward compatibility when using `selectedRowIndex` with non-number values - ignored.
           *
           * Therefore, in order to select a row after some changes,
           * the `selectedRowIndex` value must be invalid or >= 0 (< 0 means that no row is selected).
           *
           * `Number(value)` returns `NaN` on all invalid cases, and comparisons with `NaN` always return `false`.
           *
           * !!! We should skip a row only in cases when `selectedRowIndex` < 0
           * because when < 0 all lines must be deselected
           */
          var selectedRowIndex = Number(this.getSetting('selectedRowIndex'));
          return selectedRowIndex < 0;
        }
      }]);

      return Grid;
    }();

    var CellComponent =
    /*#__PURE__*/
    function () {
      function CellComponent() {
        _classCallCheck(this, CellComponent);

        this.inputClass = '';
        this.mode = 'inline';
        this.isInEditing = false;
        this.edited = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(CellComponent, [{
        key: "onEdited",
        value: function onEdited(event) {
          if (this.isNew) {
            this.grid.create(this.grid.getNewRow(), this.createConfirm);
          } else {
            this.grid.save(this.row, this.editConfirm);
          }
        }
      }]);

      return CellComponent;
    }();

    CellComponent.ɵfac = function CellComponent_Factory(t) {
      return new (t || CellComponent)();
    };

    CellComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CellComponent,
      selectors: [["ng2-smart-table-cell"]],
      inputs: {
        inputClass: "inputClass",
        mode: "mode",
        isInEditing: "isInEditing",
        grid: "grid",
        row: "row",
        editConfirm: "editConfirm",
        createConfirm: "createConfirm",
        isNew: "isNew",
        cell: "cell"
      },
      outputs: {
        edited: "edited"
      },
      decls: 2,
      vars: 2,
      consts: [[3, "cell", 4, "ngIf"], [3, "cell", "inputClass", "edited", 4, "ngIf"], [3, "cell"], [3, "cell", "inputClass", "edited"]],
      template: function CellComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, CellComponent_table_cell_view_mode_0_Template, 1, 1, "table-cell-view-mode", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CellComponent_table_cell_edit_mode_1_Template, 1, 2, "table-cell-edit-mode", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.isInEditing);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isInEditing);
        }
      },
      directives: function directives() {
        return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], ViewCellComponent, EditCellComponent];
      },
      encapsulation: 2
    });
    CellComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      row: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      editConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      createConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      isNew: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      inputClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      mode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      isInEditing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      edited: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CellComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-smart-table-cell',
          template: "\n    <table-cell-view-mode *ngIf=\"!isInEditing\" [cell]=\"cell\"></table-cell-view-mode>\n    <table-cell-edit-mode *ngIf=\"isInEditing\" [cell]=\"cell\"\n                          [inputClass]=\"inputClass\"\n                          (edited)=\"onEdited($event)\">\n    </table-cell-edit-mode>\n  "
        }]
      }], function () {
        return [];
      }, {
        inputClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        mode: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        isInEditing: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        edited: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        row: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        editConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        createConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        isNew: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        cell: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var EditCellDefault =
    /*#__PURE__*/
    function () {
      function EditCellDefault() {
        _classCallCheck(this, EditCellDefault);

        this.inputClass = '';
        this.edited = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(EditCellDefault, [{
        key: "onEdited",
        value: function onEdited(event) {
          this.edited.next(event);
          return false;
        }
      }, {
        key: "onStopEditing",
        value: function onStopEditing() {
          this.cell.getRow().isInEditing = false;
          return false;
        }
      }, {
        key: "onClick",
        value: function onClick(event) {
          event.stopPropagation();
        }
      }]);

      return EditCellDefault;
    }();

    EditCellDefault.ɵfac = function EditCellDefault_Factory(t) {
      return new (t || EditCellDefault)();
    };

    EditCellDefault.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: EditCellDefault,
      selectors: [["ng-component"]],
      inputs: {
        inputClass: "inputClass",
        cell: "cell"
      },
      outputs: {
        edited: "edited"
      },
      decls: 0,
      vars: 0,
      template: function EditCellDefault_Template(rf, ctx) {},
      encapsulation: 2
    });
    EditCellDefault.propDecorators = {
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      inputClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      edited: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](EditCellDefault, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          template: ''
        }]
      }], function () {
        return [];
      }, {
        inputClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        edited: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        cell: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var CustomEditComponent =
    /*#__PURE__*/
    function (_EditCellDefault) {
      _inherits(CustomEditComponent, _EditCellDefault);

      var _super5 = _createSuper(CustomEditComponent);

      function CustomEditComponent(resolver) {
        var _this31;

        _classCallCheck(this, CustomEditComponent);

        _this31 = _super5.call(this);
        _this31.resolver = resolver;
        return _this31;
      }

      _createClass(CustomEditComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          var _this32 = this;

          if (this.cell && !this.customComponent) {
            var componentFactory = this.resolver.resolveComponentFactory(this.cell.getColumn().editor.component);
            this.customComponent = this.dynamicTarget.createComponent(componentFactory); // set @Inputs and @Outputs of custom component

            this.customComponent.instance.cell = this.cell;
            this.customComponent.instance.inputClass = this.inputClass;
            this.customComponent.instance.onStopEditing.subscribe(function () {
              return _this32.onStopEditing();
            });
            this.customComponent.instance.onEdited.subscribe(function (event) {
              return _this32.onEdited(event);
            });
            this.customComponent.instance.onClick.subscribe(function (event) {
              return _this32.onClick(event);
            });
          }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.customComponent) {
            this.customComponent.destroy();
          }
        }
      }]);

      return CustomEditComponent;
    }(EditCellDefault);

    CustomEditComponent.ɵfac = function CustomEditComponent_Factory(t) {
      return new (t || CustomEditComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]));
    };

    CustomEditComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CustomEditComponent,
      selectors: [["table-cell-custom-editor"]],
      viewQuery: function CustomEditComponent_Query(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstaticViewQuery"](_c0, true, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.dynamicTarget = _t.first);
        }
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 2,
      vars: 0,
      consts: [["dynamicTarget", ""]],
      template: function CustomEditComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, CustomEditComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
        }
      },
      encapsulation: 2
    });

    CustomEditComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]
      }];
    };

    CustomEditComponent.propDecorators = {
      dynamicTarget: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
        args: ['dynamicTarget', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"],
          "static": true
        }]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CustomEditComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'table-cell-custom-editor',
          template: "\n    <ng-template #dynamicTarget></ng-template>\n  "
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]
        }];
      }, {
        dynamicTarget: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
          args: ['dynamicTarget', {
            read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"],
            "static": true
          }]
        }]
      });
    })();

    var DefaultEditComponent =
    /*#__PURE__*/
    function (_EditCellDefault2) {
      _inherits(DefaultEditComponent, _EditCellDefault2);

      var _super6 = _createSuper(DefaultEditComponent);

      function DefaultEditComponent() {
        _classCallCheck(this, DefaultEditComponent);

        return _super6.call(this);
      }

      _createClass(DefaultEditComponent, [{
        key: "getEditorType",
        value: function getEditorType() {
          return this.cell.getColumn().editor && this.cell.getColumn().editor.type;
        }
      }]);

      return DefaultEditComponent;
    }(EditCellDefault);

    DefaultEditComponent.ɵfac = function DefaultEditComponent_Factory(t) {
      return new (t || DefaultEditComponent)();
    };

    DefaultEditComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: DefaultEditComponent,
      selectors: [["table-cell-default-editor"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 6,
      vars: 5,
      consts: [[3, "ngSwitch"], [3, "cell", "inputClass", "onClick", "onEdited", "onStopEditing", 4, "ngSwitchCase"], [3, "cell", "inputClass", "onClick", 4, "ngSwitchCase"], [3, "cell", 4, "ngSwitchCase"], [3, "cell", "inputClass", "onClick", "onEdited", "onStopEditing", 4, "ngSwitchDefault"], [3, "cell", "inputClass", "onClick", "onEdited", "onStopEditing"], [3, "cell", "inputClass", "onClick"], [3, "cell"]],
      template: function DefaultEditComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, DefaultEditComponent_select_editor_1_Template, 1, 2, "select-editor", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, DefaultEditComponent_textarea_editor_2_Template, 1, 2, "textarea-editor", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, DefaultEditComponent_checkbox_editor_3_Template, 1, 2, "checkbox-editor", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, DefaultEditComponent_completer_editor_4_Template, 1, 1, "completer-editor", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, DefaultEditComponent_input_editor_5_Template, 1, 2, "input-editor", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx.getEditorType());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "list");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "textarea");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "checkbox");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "completer");
        }
      },
      directives: function directives() {
        return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchDefault"], SelectEditorComponent, TextareaEditorComponent, CheckboxEditorComponent, CompleterEditorComponent, InputEditorComponent];
      },
      encapsulation: 2
    });

    DefaultEditComponent.ctorParameters = function () {
      return [];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DefaultEditComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'table-cell-default-editor',
          template: "<div [ngSwitch]=\"getEditorType()\">\n    <select-editor *ngSwitchCase=\"'list'\"\n                   [cell]=\"cell\"\n                   [inputClass]=\"inputClass\"\n                   (onClick)=\"onClick($event)\"\n                   (onEdited)=\"onEdited($event)\"\n                   (onStopEditing)=\"onStopEditing()\">\n    </select-editor>\n\n    <textarea-editor *ngSwitchCase=\"'textarea'\"\n                     [cell]=\"cell\"\n                     [inputClass]=\"inputClass\"\n                     (onClick)=\"onClick($event)\"\n                     (onEdited)=\"onEdited($event)\"\n                     (onStopEditing)=\"onStopEditing()\">\n    </textarea-editor>\n\n    <checkbox-editor *ngSwitchCase=\"'checkbox'\"\n                     [cell]=\"cell\"\n                     [inputClass]=\"inputClass\"\n                     (onClick)=\"onClick($event)\">\n    </checkbox-editor>\n\n    <completer-editor *ngSwitchCase=\"'completer'\"\n                      [cell]=\"cell\">\n    </completer-editor>\n\n    <input-editor *ngSwitchDefault\n                  [cell]=\"cell\"\n                  [inputClass]=\"inputClass\"\n                  (onClick)=\"onClick($event)\"\n                  (onEdited)=\"onEdited($event)\"\n                  (onStopEditing)=\"onStopEditing()\">\n    </input-editor>\n</div>"
        }]
      }], function () {
        return [];
      }, null);
    })();

    var EditCellComponent =
    /*#__PURE__*/
    function () {
      function EditCellComponent() {
        _classCallCheck(this, EditCellComponent);

        this.inputClass = '';
        this.edited = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(EditCellComponent, [{
        key: "onEdited",
        value: function onEdited(event) {
          this.edited.next(event);
          return false;
        }
      }, {
        key: "getEditorType",
        value: function getEditorType() {
          return this.cell.getColumn().editor && this.cell.getColumn().editor.type;
        }
      }]);

      return EditCellComponent;
    }();

    EditCellComponent.ɵfac = function EditCellComponent_Factory(t) {
      return new (t || EditCellComponent)();
    };

    EditCellComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: EditCellComponent,
      selectors: [["table-cell-edit-mode"]],
      inputs: {
        inputClass: "inputClass",
        cell: "cell"
      },
      outputs: {
        edited: "edited"
      },
      decls: 3,
      vars: 2,
      consts: [[3, "ngSwitch"], [3, "cell", "inputClass", "edited", 4, "ngSwitchCase"], [3, "cell", "inputClass", "edited", 4, "ngSwitchDefault"], [3, "cell", "inputClass", "edited"]],
      template: function EditCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, EditCellComponent_table_cell_custom_editor_1_Template, 1, 2, "table-cell-custom-editor", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, EditCellComponent_table_cell_default_editor_2_Template, 1, 2, "table-cell-default-editor", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx.getEditorType());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "custom");
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchDefault"], CustomEditComponent, DefaultEditComponent],
      encapsulation: 2
    });
    EditCellComponent.propDecorators = {
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      inputClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      edited: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](EditCellComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'table-cell-edit-mode',
          template: "\n      <div [ngSwitch]=\"getEditorType()\">\n        <table-cell-custom-editor *ngSwitchCase=\"'custom'\"\n                                  [cell]=\"cell\"\n                                  [inputClass]=\"inputClass\"\n                                  (edited)=\"onEdited($event)\">\n        </table-cell-custom-editor>\n        <table-cell-default-editor *ngSwitchDefault\n                                  [cell]=\"cell\"\n                                  [inputClass]=\"inputClass\"\n                                  (edited)=\"onEdited($event)\">\n        </table-cell-default-editor>\n      </div>\n    "
        }]
      }], function () {
        return [];
      }, {
        inputClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        edited: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        cell: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var DefaultEditor = function DefaultEditor() {
      _classCallCheck(this, DefaultEditor);

      this.onStopEditing = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      this.onEdited = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      this.onClick = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    };

    DefaultEditor.ɵfac = function DefaultEditor_Factory(t) {
      return new (t || DefaultEditor)();
    };

    DefaultEditor.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: DefaultEditor,
      selectors: [["ng-component"]],
      inputs: {
        cell: "cell",
        inputClass: "inputClass"
      },
      outputs: {
        onStopEditing: "onStopEditing",
        onEdited: "onEdited",
        onClick: "onClick"
      },
      decls: 0,
      vars: 0,
      template: function DefaultEditor_Template(rf, ctx) {},
      encapsulation: 2
    });
    DefaultEditor.propDecorators = {
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      inputClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      onStopEditing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      onEdited: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DefaultEditor, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          template: ''
        }]
      }], function () {
        return [];
      }, {
        onStopEditing: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        onEdited: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        onClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        cell: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        inputClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var CheckboxEditorComponent =
    /*#__PURE__*/
    function (_DefaultEditor) {
      _inherits(CheckboxEditorComponent, _DefaultEditor);

      var _super7 = _createSuper(CheckboxEditorComponent);

      function CheckboxEditorComponent() {
        _classCallCheck(this, CheckboxEditorComponent);

        return _super7.call(this);
      }

      _createClass(CheckboxEditorComponent, [{
        key: "onChange",
        value: function onChange(event) {
          var trueVal = this.cell.getColumn().getConfig() && this.cell.getColumn().getConfig()["true"] || true;
          var falseVal = this.cell.getColumn().getConfig() && this.cell.getColumn().getConfig()["false"] || false;
          this.cell.newValue = event.target.checked ? trueVal : falseVal;
        }
      }]);

      return CheckboxEditorComponent;
    }(DefaultEditor);

    CheckboxEditorComponent.ɵfac = function CheckboxEditorComponent_Factory(t) {
      return new (t || CheckboxEditorComponent)();
    };

    CheckboxEditorComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CheckboxEditorComponent,
      selectors: [["checkbox-editor"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 1,
      vars: 4,
      consts: [["type", "checkbox", 1, "form-control", 3, "ngClass", "name", "disabled", "checked", "click", "change"]],
      template: function CheckboxEditorComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "input", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CheckboxEditorComponent_Template_input_click_0_listener($event) {
            return ctx.onClick.emit($event);
          })("change", function CheckboxEditorComponent_Template_input_change_0_listener($event) {
            return ctx.onChange($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var tmp_3_0 = null;
          var currVal_3 = ctx.cell.getValue() == (((tmp_3_0 = ctx.cell.getColumn().getConfig()) == null ? null : tmp_3_0["true"]) || true);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx.inputClass)("name", ctx.cell.getId())("disabled", !ctx.cell.isEditable())("checked", currVal_3);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"]],
      styles: ["[_nghost-%COMP%]   input[_ngcontent-%COMP%], [_nghost-%COMP%]   textarea[_ngcontent-%COMP%]{line-height:normal;padding:.375em .75em;width:100%}"]
    });

    CheckboxEditorComponent.ctorParameters = function () {
      return [];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CheckboxEditorComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'checkbox-editor',
          template: "\n    <input [ngClass]=\"inputClass\"\n           type=\"checkbox\"\n           class=\"form-control\"\n           [name]=\"cell.getId()\"\n           [disabled]=\"!cell.isEditable()\"\n           [checked]=\"cell.getValue() == (cell.getColumn().getConfig()?.true || true)\"\n           (click)=\"onClick.emit($event)\"\n           (change)=\"onChange($event)\">\n    ",
          styles: [":host input,:host textarea{line-height:normal;padding:.375em .75em;width:100%}"]
        }]
      }], function () {
        return [];
      }, null);
    })();

    var CompleterEditorComponent =
    /*#__PURE__*/
    function (_DefaultEditor2) {
      _inherits(CompleterEditorComponent, _DefaultEditor2);

      var _super8 = _createSuper(CompleterEditorComponent);

      function CompleterEditorComponent(completerService) {
        var _this33;

        _classCallCheck(this, CompleterEditorComponent);

        _this33 = _super8.call(this);
        _this33.completerService = completerService;
        _this33.completerStr = '';
        return _this33;
      }

      _createClass(CompleterEditorComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          if (this.cell.getColumn().editor && this.cell.getColumn().editor.type === 'completer') {
            var config = this.cell.getColumn().getConfig().completer;
            config.dataService = this.completerService.local(config.data, config.searchFields, config.titleField);
            config.dataService.descriptionField(config.descriptionField);
          }
        }
      }, {
        key: "onEditedCompleter",
        value: function onEditedCompleter(event) {
          this.cell.newValue = event.title;
          return false;
        }
      }]);

      return CompleterEditorComponent;
    }(DefaultEditor);

    CompleterEditorComponent.ɵfac = function CompleterEditorComponent_Factory(t) {
      return new (t || CompleterEditorComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterService"]));
    };

    CompleterEditorComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CompleterEditorComponent,
      selectors: [["completer-editor"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 1,
      vars: 5,
      consts: [[3, "ngModel", "dataService", "minSearchLength", "pause", "placeholder", "ngModelChange", "selected"]],
      template: function CompleterEditorComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ng2-completer", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function CompleterEditorComponent_Template_ng2_completer_ngModelChange_0_listener($event) {
            return ctx.completerStr = $event;
          })("selected", function CompleterEditorComponent_Template_ng2_completer_selected_0_listener($event) {
            return ctx.onEditedCompleter($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx.completerStr)("dataService", ctx.cell.getColumn().getConfig().completer.dataService)("minSearchLength", ctx.cell.getColumn().getConfig().completer.minSearchLength || 0)("pause", ctx.cell.getColumn().getConfig().completer.pause || 0)("placeholder", ctx.cell.getColumn().getConfig().completer.placeholder || "Start typing...");
        }
      },
      directives: [ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterCmp"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"]],
      encapsulation: 2
    });

    CompleterEditorComponent.ctorParameters = function () {
      return [{
        type: ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterService"]
      }];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CompleterEditorComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'completer-editor',
          template: "\n    <ng2-completer [(ngModel)]=\"completerStr\"\n                   [dataService]=\"cell.getColumn().getConfig().completer.dataService\"\n                   [minSearchLength]=\"cell.getColumn().getConfig().completer.minSearchLength || 0\"\n                   [pause]=\"cell.getColumn().getConfig().completer.pause || 0\"\n                   [placeholder]=\"cell.getColumn().getConfig().completer.placeholder || 'Start typing...'\"\n                   (selected)=\"onEditedCompleter($event)\">\n    </ng2-completer>\n    "
        }]
      }], function () {
        return [{
          type: ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterService"]
        }];
      }, null);
    })();

    var InputEditorComponent =
    /*#__PURE__*/
    function (_DefaultEditor3) {
      _inherits(InputEditorComponent, _DefaultEditor3);

      var _super9 = _createSuper(InputEditorComponent);

      function InputEditorComponent() {
        _classCallCheck(this, InputEditorComponent);

        return _super9.call(this);
      }

      return InputEditorComponent;
    }(DefaultEditor);

    InputEditorComponent.ɵfac = function InputEditorComponent_Factory(t) {
      return new (t || InputEditorComponent)();
    };

    InputEditorComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: InputEditorComponent,
      selectors: [["input-editor"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 1,
      vars: 5,
      consts: [[1, "form-control", 3, "ngClass", "ngModel", "name", "placeholder", "disabled", "ngModelChange", "click", "keydown.enter", "keydown.esc"]],
      template: function InputEditorComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "input", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function InputEditorComponent_Template_input_ngModelChange_0_listener($event) {
            return ctx.cell.newValue = $event;
          })("click", function InputEditorComponent_Template_input_click_0_listener($event) {
            return ctx.onClick.emit($event);
          })("keydown.enter", function InputEditorComponent_Template_input_keydown_enter_0_listener($event) {
            return ctx.onEdited.emit($event);
          })("keydown.esc", function InputEditorComponent_Template_input_keydown_esc_0_listener() {
            return ctx.onStopEditing.emit();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx.inputClass)("ngModel", ctx.cell.newValue)("name", ctx.cell.getId())("placeholder", ctx.cell.getTitle())("disabled", !ctx.cell.isEditable());
        }
      },
      directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["DefaultValueAccessor"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"]],
      styles: ["[_nghost-%COMP%]   input[_ngcontent-%COMP%], [_nghost-%COMP%]   textarea[_ngcontent-%COMP%]{line-height:normal;padding:.375em .75em;width:100%}"]
    });

    InputEditorComponent.ctorParameters = function () {
      return [];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](InputEditorComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'input-editor',
          template: "\n    <input [ngClass]=\"inputClass\"\n           class=\"form-control\"\n           [(ngModel)]=\"cell.newValue\"\n           [name]=\"cell.getId()\"\n           [placeholder]=\"cell.getTitle()\"\n           [disabled]=\"!cell.isEditable()\"\n           (click)=\"onClick.emit($event)\"\n           (keydown.enter)=\"onEdited.emit($event)\"\n           (keydown.esc)=\"onStopEditing.emit()\">\n    ",
          styles: [":host input,:host textarea{line-height:normal;padding:.375em .75em;width:100%}"]
        }]
      }], function () {
        return [];
      }, null);
    })();

    var SelectEditorComponent =
    /*#__PURE__*/
    function (_DefaultEditor4) {
      _inherits(SelectEditorComponent, _DefaultEditor4);

      var _super10 = _createSuper(SelectEditorComponent);

      function SelectEditorComponent() {
        _classCallCheck(this, SelectEditorComponent);

        return _super10.call(this);
      }

      return SelectEditorComponent;
    }(DefaultEditor);

    SelectEditorComponent.ɵfac = function SelectEditorComponent_Factory(t) {
      return new (t || SelectEditorComponent)();
    };

    SelectEditorComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: SelectEditorComponent,
      selectors: [["select-editor"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 2,
      vars: 5,
      consts: [[1, "form-control", 3, "ngClass", "ngModel", "name", "disabled", "ngModelChange", "click", "keydown.enter", "keydown.esc"], [3, "value", "selected", 4, "ngFor", "ngForOf"], [3, "value", "selected"]],
      template: function SelectEditorComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "select", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function SelectEditorComponent_Template_select_ngModelChange_0_listener($event) {
            return ctx.cell.newValue = $event;
          })("click", function SelectEditorComponent_Template_select_click_0_listener($event) {
            return ctx.onClick.emit($event);
          })("keydown.enter", function SelectEditorComponent_Template_select_keydown_enter_0_listener($event) {
            return ctx.onEdited.emit($event);
          })("keydown.esc", function SelectEditorComponent_Template_select_keydown_esc_0_listener() {
            return ctx.onStopEditing.emit();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, SelectEditorComponent_option_1_Template, 2, 3, "option", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var tmp_4_0 = null;
          var currVal_4 = (tmp_4_0 = ctx.cell.getColumn().getConfig()) == null ? null : tmp_4_0.list;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx.inputClass)("ngModel", ctx.cell.newValue)("name", ctx.cell.getId())("disabled", !ctx.cell.isEditable());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", currVal_4);
        }
      },
      directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["SelectControlValueAccessor"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgSelectOption"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ɵangular_packages_forms_forms_x"]],
      encapsulation: 2
    });

    SelectEditorComponent.ctorParameters = function () {
      return [];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](SelectEditorComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'select-editor',
          template: "\n    <select [ngClass]=\"inputClass\"\n            class=\"form-control\"\n            [(ngModel)]=\"cell.newValue\"\n            [name]=\"cell.getId()\"\n            [disabled]=\"!cell.isEditable()\"\n            (click)=\"onClick.emit($event)\"\n            (keydown.enter)=\"onEdited.emit($event)\"\n            (keydown.esc)=\"onStopEditing.emit()\">\n\n        <option *ngFor=\"let option of cell.getColumn().getConfig()?.list\" [value]=\"option.value\"\n                [selected]=\"option.value === cell.getValue()\">{{ option.title }}\n        </option>\n    </select>\n    "
        }]
      }], function () {
        return [];
      }, null);
    })();

    var TextareaEditorComponent =
    /*#__PURE__*/
    function (_DefaultEditor5) {
      _inherits(TextareaEditorComponent, _DefaultEditor5);

      var _super11 = _createSuper(TextareaEditorComponent);

      function TextareaEditorComponent() {
        _classCallCheck(this, TextareaEditorComponent);

        return _super11.call(this);
      }

      return TextareaEditorComponent;
    }(DefaultEditor);

    TextareaEditorComponent.ɵfac = function TextareaEditorComponent_Factory(t) {
      return new (t || TextareaEditorComponent)();
    };

    TextareaEditorComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TextareaEditorComponent,
      selectors: [["textarea-editor"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 2,
      vars: 5,
      consts: [[1, "form-control", 3, "ngClass", "ngModel", "name", "disabled", "placeholder", "ngModelChange", "click", "keydown.enter", "keydown.esc"]],
      template: function TextareaEditorComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "textarea", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function TextareaEditorComponent_Template_textarea_ngModelChange_0_listener($event) {
            return ctx.cell.newValue = $event;
          })("click", function TextareaEditorComponent_Template_textarea_click_0_listener($event) {
            return ctx.onClick.emit($event);
          })("keydown.enter", function TextareaEditorComponent_Template_textarea_keydown_enter_0_listener($event) {
            return ctx.onEdited.emit($event);
          })("keydown.esc", function TextareaEditorComponent_Template_textarea_keydown_esc_0_listener() {
            return ctx.onStopEditing.emit();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1, "    ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx.inputClass)("ngModel", ctx.cell.newValue)("name", ctx.cell.getId())("disabled", !ctx.cell.isEditable())("placeholder", ctx.cell.getTitle());
        }
      },
      directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["DefaultValueAccessor"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"]],
      styles: ["[_nghost-%COMP%]   input[_ngcontent-%COMP%], [_nghost-%COMP%]   textarea[_ngcontent-%COMP%]{line-height:normal;padding:.375em .75em;width:100%}"]
    });

    TextareaEditorComponent.ctorParameters = function () {
      return [];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TextareaEditorComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'textarea-editor',
          template: "\n    <textarea [ngClass]=\"inputClass\"\n              class=\"form-control\"\n              [(ngModel)]=\"cell.newValue\"\n              [name]=\"cell.getId()\"\n              [disabled]=\"!cell.isEditable()\"\n              [placeholder]=\"cell.getTitle()\"\n              (click)=\"onClick.emit($event)\"\n              (keydown.enter)=\"onEdited.emit($event)\"\n              (keydown.esc)=\"onStopEditing.emit()\">\n    </textarea>\n    ",
          styles: [":host input,:host textarea{line-height:normal;padding:.375em .75em;width:100%}"]
        }]
      }], function () {
        return [];
      }, null);
    })();

    var CustomViewComponent =
    /*#__PURE__*/
    function () {
      function CustomViewComponent(resolver) {
        _classCallCheck(this, CustomViewComponent);

        this.resolver = resolver;
      }

      _createClass(CustomViewComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          if (this.cell && !this.customComponent) {
            this.createCustomComponent();
            this.callOnComponentInit();
            this.patchInstance();
          }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.customComponent) {
            this.customComponent.destroy();
          }
        }
      }, {
        key: "createCustomComponent",
        value: function createCustomComponent() {
          var componentFactory = this.resolver.resolveComponentFactory(this.cell.getColumn().renderComponent);
          this.customComponent = this.dynamicTarget.createComponent(componentFactory);
        }
      }, {
        key: "callOnComponentInit",
        value: function callOnComponentInit() {
          var onComponentInitFunction = this.cell.getColumn().getOnComponentInitFunction();
          onComponentInitFunction && onComponentInitFunction(this.customComponent.instance);
        }
      }, {
        key: "patchInstance",
        value: function patchInstance() {
          Object.assign(this.customComponent.instance, this.getPatch());
        }
      }, {
        key: "getPatch",
        value: function getPatch() {
          return {
            value: this.cell.getValue(),
            rowData: this.cell.getRow().getData()
          };
        }
      }]);

      return CustomViewComponent;
    }();

    CustomViewComponent.ɵfac = function CustomViewComponent_Factory(t) {
      return new (t || CustomViewComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]));
    };

    CustomViewComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CustomViewComponent,
      selectors: [["custom-view-component"]],
      viewQuery: function CustomViewComponent_Query(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstaticViewQuery"](_c0, true, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.dynamicTarget = _t.first);
        }
      },
      inputs: {
        cell: "cell"
      },
      decls: 2,
      vars: 0,
      consts: [["dynamicTarget", ""]],
      template: function CustomViewComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, CustomViewComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
        }
      },
      encapsulation: 2
    });

    CustomViewComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]
      }];
    };

    CustomViewComponent.propDecorators = {
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      dynamicTarget: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
        args: ['dynamicTarget', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"],
          "static": true
        }]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CustomViewComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'custom-view-component',
          template: "\n    <ng-template #dynamicTarget></ng-template>\n  "
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]
        }];
      }, {
        cell: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        dynamicTarget: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
          args: ['dynamicTarget', {
            read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"],
            "static": true
          }]
        }]
      });
    })();

    var ViewCellComponent = function ViewCellComponent() {
      _classCallCheck(this, ViewCellComponent);
    };

    ViewCellComponent.ɵfac = function ViewCellComponent_Factory(t) {
      return new (t || ViewCellComponent)();
    };

    ViewCellComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: ViewCellComponent,
      selectors: [["table-cell-view-mode"]],
      inputs: {
        cell: "cell"
      },
      decls: 4,
      vars: 3,
      consts: [[3, "ngSwitch"], [3, "cell", 4, "ngSwitchCase"], [3, "innerHTML", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "cell"], [3, "innerHTML"]],
      template: function ViewCellComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, ViewCellComponent_custom_view_component_1_Template, 1, 1, "custom-view-component", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, ViewCellComponent_div_2_Template, 1, 1, "div", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, ViewCellComponent_div_3_Template, 2, 1, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx.cell.getColumn().type);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "custom");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "html");
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchDefault"], CustomViewComponent],
      encapsulation: 2,
      changeDetection: 0
    });
    ViewCellComponent.propDecorators = {
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](ViewCellComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'table-cell-view-mode',
          changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
          template: "\n    <div [ngSwitch]=\"cell.getColumn().type\">\n        <custom-view-component *ngSwitchCase=\"'custom'\" [cell]=\"cell\"></custom-view-component>\n        <div *ngSwitchCase=\"'html'\" [innerHTML]=\"cell.getValue()\"></div>\n        <div *ngSwitchDefault>{{ cell.getValue() }}</div>\n    </div>\n    "
        }]
      }], null, {
        cell: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var CELL_COMPONENTS = [CellComponent, EditCellDefault, DefaultEditor, CustomEditComponent, DefaultEditComponent, EditCellComponent, CheckboxEditorComponent, CompleterEditorComponent, InputEditorComponent, SelectEditorComponent, TextareaEditorComponent, CustomViewComponent, ViewCellComponent];

    var CellModule = function CellModule() {
      _classCallCheck(this, CellModule);
    };

    CellModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: CellModule
    });
    CellModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function CellModule_Factory(t) {
        return new (t || CellModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], ng2_completer__WEBPACK_IMPORTED_MODULE_3__["Ng2CompleterModule"]]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](CellModule, {
        declarations: function declarations() {
          return [CellComponent, EditCellDefault, DefaultEditor, CustomEditComponent, DefaultEditComponent, EditCellComponent, CheckboxEditorComponent, CompleterEditorComponent, InputEditorComponent, SelectEditorComponent, TextareaEditorComponent, CustomViewComponent, ViewCellComponent];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], ng2_completer__WEBPACK_IMPORTED_MODULE_3__["Ng2CompleterModule"]];
        },
        exports: function exports() {
          return [CellComponent, EditCellDefault, DefaultEditor, CustomEditComponent, DefaultEditComponent, EditCellComponent, CheckboxEditorComponent, CompleterEditorComponent, InputEditorComponent, SelectEditorComponent, TextareaEditorComponent, CustomViewComponent, ViewCellComponent];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CellModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], ng2_completer__WEBPACK_IMPORTED_MODULE_3__["Ng2CompleterModule"]],
          declarations: [].concat(CELL_COMPONENTS),
          exports: [].concat(CELL_COMPONENTS)
        }]
      }], null, null);
    })();

    var DataSource =
    /*#__PURE__*/
    function () {
      function DataSource() {
        _classCallCheck(this, DataSource);

        this.onChangedSource = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.onAddedSource = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.onUpdatedSource = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.onRemovedSource = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
      }

      _createClass(DataSource, [{
        key: "refresh",
        value: function refresh() {
          this.emitOnChanged('refresh');
        }
      }, {
        key: "load",
        value: function load(data) {
          this.emitOnChanged('load');
          return Promise.resolve();
        }
      }, {
        key: "onChanged",
        value: function onChanged() {
          return this.onChangedSource.asObservable();
        }
      }, {
        key: "onAdded",
        value: function onAdded() {
          return this.onAddedSource.asObservable();
        }
      }, {
        key: "onUpdated",
        value: function onUpdated() {
          return this.onUpdatedSource.asObservable();
        }
      }, {
        key: "onRemoved",
        value: function onRemoved() {
          return this.onRemovedSource.asObservable();
        }
      }, {
        key: "prepend",
        value: function prepend(element) {
          this.emitOnAdded(element);
          this.emitOnChanged('prepend');
          return Promise.resolve();
        }
      }, {
        key: "append",
        value: function append(element) {
          this.emitOnAdded(element);
          this.emitOnChanged('append');
          return Promise.resolve();
        }
      }, {
        key: "add",
        value: function add(element) {
          this.emitOnAdded(element);
          this.emitOnChanged('add');
          return Promise.resolve();
        }
      }, {
        key: "remove",
        value: function remove(element) {
          this.emitOnRemoved(element);
          this.emitOnChanged('remove');
          return Promise.resolve();
        }
      }, {
        key: "update",
        value: function update(element, values) {
          this.emitOnUpdated(element);
          this.emitOnChanged('update');
          return Promise.resolve();
        }
      }, {
        key: "empty",
        value: function empty() {
          this.emitOnChanged('empty');
          return Promise.resolve();
        }
      }, {
        key: "setSort",
        value: function setSort(conf, doEmit) {
          if (doEmit) {
            this.emitOnChanged('sort');
          }
        }
      }, {
        key: "setFilter",
        value: function setFilter(conf, andOperator, doEmit) {
          if (doEmit) {
            this.emitOnChanged('filter');
          }
        }
      }, {
        key: "addFilter",
        value: function addFilter(fieldConf, andOperator, doEmit) {
          if (doEmit) {
            this.emitOnChanged('filter');
          }
        }
      }, {
        key: "setPaging",
        value: function setPaging(page, perPage, doEmit) {
          if (doEmit) {
            this.emitOnChanged('paging');
          }
        }
      }, {
        key: "setPage",
        value: function setPage(page, doEmit) {
          if (doEmit) {
            this.emitOnChanged('page');
          }
        }
      }, {
        key: "emitOnRemoved",
        value: function emitOnRemoved(element) {
          this.onRemovedSource.next(element);
        }
      }, {
        key: "emitOnUpdated",
        value: function emitOnUpdated(element) {
          this.onUpdatedSource.next(element);
        }
      }, {
        key: "emitOnAdded",
        value: function emitOnAdded(element) {
          this.onAddedSource.next(element);
        }
      }, {
        key: "emitOnChanged",
        value: function emitOnChanged(action) {
          var _this34 = this;

          this.getElements().then(function (elements) {
            return _this34.onChangedSource.next({
              action: action,
              elements: elements,
              paging: _this34.getPaging(),
              filter: _this34.getFilter(),
              sort: _this34.getSort()
            });
          });
        }
      }]);

      return DataSource;
    }();

    var FilterDefault =
    /*#__PURE__*/
    function () {
      function FilterDefault() {
        _classCallCheck(this, FilterDefault);

        this.inputClass = '';
        this.filter = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.query = '';
      }

      _createClass(FilterDefault, [{
        key: "onFilter",
        value: function onFilter(query) {
          this.source.addFilter({
            field: this.column.id,
            search: query,
            filter: this.column.getFilterFunction()
          });
        }
      }]);

      return FilterDefault;
    }();

    FilterDefault.ɵfac = function FilterDefault_Factory(t) {
      return new (t || FilterDefault)();
    };

    FilterDefault.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: FilterDefault,
      selectors: [["ng-component"]],
      inputs: {
        inputClass: "inputClass",
        column: "column",
        source: "source"
      },
      outputs: {
        filter: "filter"
      },
      decls: 0,
      vars: 0,
      template: function FilterDefault_Template(rf, ctx) {},
      encapsulation: 2
    });
    FilterDefault.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      inputClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      filter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](FilterDefault, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          template: ''
        }]
      }], function () {
        return [];
      }, {
        inputClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        filter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        column: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var FilterComponent =
    /*#__PURE__*/
    function (_FilterDefault) {
      _inherits(FilterComponent, _FilterDefault);

      var _super12 = _createSuper(FilterComponent);

      function FilterComponent() {
        var _this35;

        _classCallCheck(this, FilterComponent);

        _this35 = _super12.apply(this, arguments);
        _this35.query = '';
        return _this35;
      }

      _createClass(FilterComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          var _this36 = this;

          if (changes.source) {
            if (!changes.source.firstChange) {
              this.dataChangedSub.unsubscribe();
            }

            this.dataChangedSub = this.source.onChanged().subscribe(function (dataChanges) {
              var filterConf = _this36.source.getFilter();

              if (filterConf && filterConf.filters && filterConf.filters.length === 0) {
                _this36.query = ''; // add a check for existing filters an set the query if one exists for this column
                // this covers instances where the filter is set by user code while maintaining existing functionality
              } else if (filterConf && filterConf.filters && filterConf.filters.length > 0) {
                filterConf.filters.forEach(function (k, v) {
                  if (k.field == _this36.column.id) {
                    _this36.query = k.search;
                  }
                });
              }
            });
          }
        }
      }]);

      return FilterComponent;
    }(FilterDefault);

    FilterComponent.ɵfac = function FilterComponent_Factory(t) {
      return ɵFilterComponent_BaseFactory(t || FilterComponent);
    };

    FilterComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: FilterComponent,
      selectors: [["ng2-smart-table-filter"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 1,
      vars: 1,
      consts: [["class", "ng2-smart-filter", 3, "ngSwitch", 4, "ngIf"], [1, "ng2-smart-filter", 3, "ngSwitch"], [3, "query", "column", "source", "inputClass", "filter", 4, "ngSwitchCase"], [3, "query", "column", "source", "inputClass", "filter", 4, "ngSwitchDefault"], [3, "query", "column", "source", "inputClass", "filter"]],
      template: function FilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, FilterComponent_div_0_Template, 3, 2, "div", 0);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.column.isFilterable);
        }
      },
      directives: function directives() {
        return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchDefault"], CustomFilterComponent, DefaultFilterComponent];
      },
      styles: ["[_nghost-%COMP%]   .ng2-smart-filter[_ngcontent-%COMP%]     input, [_nghost-%COMP%]   .ng2-smart-filter[_ngcontent-%COMP%]     select{font-weight:400;line-height:normal;padding:.375em .75em;width:100%}[_nghost-%COMP%]   .ng2-smart-filter[_ngcontent-%COMP%]     input[type=search]{box-sizing:inherit}[_nghost-%COMP%]   .ng2-smart-filter[_ngcontent-%COMP%]     .completer-dropdown-holder, [_nghost-%COMP%]   .ng2-smart-filter[_ngcontent-%COMP%]     a{font-weight:400}"]
    });

    var ɵFilterComponent_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](FilterComponent);
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](FilterComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-smart-table-filter',
          template: "\n      <div class=\"ng2-smart-filter\" *ngIf=\"column.isFilterable\" [ngSwitch]=\"column.getFilterType()\">\n        <custom-table-filter *ngSwitchCase=\"'custom'\"\n                             [query]=\"query\"\n                             [column]=\"column\"\n                             [source]=\"source\"\n                             [inputClass]=\"inputClass\"\n                             (filter)=\"onFilter($event)\">\n        </custom-table-filter>\n        <default-table-filter *ngSwitchDefault\n                              [query]=\"query\"\n                              [column]=\"column\"\n                              [source]=\"source\"\n                              [inputClass]=\"inputClass\"\n                              (filter)=\"onFilter($event)\">\n        </default-table-filter>\n      </div>\n    ",
          styles: [":host .ng2-smart-filter ::ng-deep input,:host .ng2-smart-filter ::ng-deep select{font-weight:400;line-height:normal;padding:.375em .75em;width:100%}:host .ng2-smart-filter ::ng-deep input[type=search]{box-sizing:inherit}:host .ng2-smart-filter ::ng-deep .completer-dropdown-holder,:host .ng2-smart-filter ::ng-deep a{font-weight:400}"]
        }]
      }], null, null);
    })();

    var DefaultFilterComponent =
    /*#__PURE__*/
    function (_FilterDefault2) {
      _inherits(DefaultFilterComponent, _FilterDefault2);

      var _super13 = _createSuper(DefaultFilterComponent);

      function DefaultFilterComponent() {
        _classCallCheck(this, DefaultFilterComponent);

        return _super13.apply(this, arguments);
      }

      return DefaultFilterComponent;
    }(FilterDefault);

    DefaultFilterComponent.ɵfac = function DefaultFilterComponent_Factory(t) {
      return ɵDefaultFilterComponent_BaseFactory(t || DefaultFilterComponent);
    };

    DefaultFilterComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: DefaultFilterComponent,
      selectors: [["default-table-filter"]],
      inputs: {
        query: "query"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 5,
      vars: 4,
      consts: [[3, "ngSwitch"], [3, "query", "ngClass", "column", "filter", 4, "ngSwitchCase"], [3, "query", "ngClass", "column", "filter", 4, "ngSwitchDefault"], [3, "query", "ngClass", "column", "filter"]],
      template: function DefaultFilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0, 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, DefaultFilterComponent_select_filter_1_Template, 1, 3, "select-filter", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, DefaultFilterComponent_checkbox_filter_2_Template, 1, 3, "checkbox-filter", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, DefaultFilterComponent_completer_filter_3_Template, 1, 3, "completer-filter", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, DefaultFilterComponent_input_filter_4_Template, 1, 3, "input-filter", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx.column.getFilterType());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "list");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "checkbox");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "completer");
        }
      },
      directives: function directives() {
        return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchDefault"], SelectFilterComponent, _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], CheckboxFilterComponent, CompleterFilterComponent, InputFilterComponent];
      },
      encapsulation: 2
    });
    DefaultFilterComponent.propDecorators = {
      query: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }]
    };

    var ɵDefaultFilterComponent_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](DefaultFilterComponent);
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DefaultFilterComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'default-table-filter',
          template: "\n    <ng-container [ngSwitch]=\"column.getFilterType()\">\n      <select-filter *ngSwitchCase=\"'list'\"\n                     [query]=\"query\"\n                     [ngClass]=\"inputClass\"\n                     [column]=\"column\"\n                     (filter)=\"onFilter($event)\">\n      </select-filter>\n      <checkbox-filter *ngSwitchCase=\"'checkbox'\"\n                       [query]=\"query\"\n                       [ngClass]=\"inputClass\"\n                       [column]=\"column\"\n                       (filter)=\"onFilter($event)\">\n      </checkbox-filter>\n      <completer-filter *ngSwitchCase=\"'completer'\"\n                        [query]=\"query\"\n                        [ngClass]=\"inputClass\"\n                        [column]=\"column\"\n                        (filter)=\"onFilter($event)\">\n      </completer-filter>\n      <input-filter *ngSwitchDefault\n                    [query]=\"query\"\n                    [ngClass]=\"inputClass\"\n                    [column]=\"column\"\n                    (filter)=\"onFilter($event)\">\n      </input-filter>\n    </ng-container>\n  "
        }]
      }], null, {
        query: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var CustomFilterComponent =
    /*#__PURE__*/
    function (_FilterDefault3) {
      _inherits(CustomFilterComponent, _FilterDefault3);

      var _super14 = _createSuper(CustomFilterComponent);

      function CustomFilterComponent(resolver) {
        var _this37;

        _classCallCheck(this, CustomFilterComponent);

        _this37 = _super14.call(this);
        _this37.resolver = resolver;
        return _this37;
      }

      _createClass(CustomFilterComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          var _this38 = this;

          if (this.column && !this.customComponent) {
            var componentFactory = this.resolver.resolveComponentFactory(this.column.filter.component);
            this.customComponent = this.dynamicTarget.createComponent(componentFactory); // set @Inputs and @Outputs of custom component

            this.customComponent.instance.query = this.query;
            this.customComponent.instance.column = this.column;
            this.customComponent.instance.source = this.source;
            this.customComponent.instance.inputClass = this.inputClass;
            this.customComponent.instance.filter.subscribe(function (event) {
              return _this38.onFilter(event);
            });
          }

          if (this.customComponent) {
            this.customComponent.instance.ngOnChanges(changes);
          }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.customComponent) {
            this.customComponent.destroy();
          }
        }
      }]);

      return CustomFilterComponent;
    }(FilterDefault);

    CustomFilterComponent.ɵfac = function CustomFilterComponent_Factory(t) {
      return new (t || CustomFilterComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]));
    };

    CustomFilterComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CustomFilterComponent,
      selectors: [["custom-table-filter"]],
      viewQuery: function CustomFilterComponent_Query(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstaticViewQuery"](_c0, true, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.dynamicTarget = _t.first);
        }
      },
      inputs: {
        query: "query"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 2,
      vars: 0,
      consts: [["dynamicTarget", ""]],
      template: function CustomFilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, CustomFilterComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
        }
      },
      encapsulation: 2
    });

    CustomFilterComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]
      }];
    };

    CustomFilterComponent.propDecorators = {
      query: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      dynamicTarget: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
        args: ['dynamicTarget', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"],
          "static": true
        }]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CustomFilterComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'custom-table-filter',
          template: "<ng-template #dynamicTarget></ng-template>"
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]
        }];
      }, {
        query: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        dynamicTarget: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
          args: ['dynamicTarget', {
            read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"],
            "static": true
          }]
        }]
      });
    })();

    var DefaultFilter =
    /*#__PURE__*/
    function () {
      function DefaultFilter() {
        _classCallCheck(this, DefaultFilter);

        this.delay = 300;
        this.filter = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(DefaultFilter, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.changesSubscription) {
            this.changesSubscription.unsubscribe();
          }
        }
      }, {
        key: "setFilter",
        value: function setFilter() {
          this.filter.emit(this.query);
        }
      }]);

      return DefaultFilter;
    }();

    DefaultFilter.ɵfac = function DefaultFilter_Factory(t) {
      return new (t || DefaultFilter)();
    };

    DefaultFilter.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: DefaultFilter,
      selectors: [["ng-component"]],
      inputs: {
        query: "query",
        inputClass: "inputClass",
        column: "column"
      },
      outputs: {
        filter: "filter"
      },
      decls: 0,
      vars: 0,
      template: function DefaultFilter_Template(rf, ctx) {},
      encapsulation: 2
    });
    DefaultFilter.propDecorators = {
      query: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      inputClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      filter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DefaultFilter, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          template: ''
        }]
      }], function () {
        return [];
      }, {
        filter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        query: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        inputClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        column: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var CheckboxFilterComponent =
    /*#__PURE__*/
    function (_DefaultFilter) {
      _inherits(CheckboxFilterComponent, _DefaultFilter);

      var _super15 = _createSuper(CheckboxFilterComponent);

      function CheckboxFilterComponent() {
        var _this39;

        _classCallCheck(this, CheckboxFilterComponent);

        _this39 = _super15.call(this);
        _this39.filterActive = false;
        _this39.inputControl = new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControl"]();
        return _this39;
      }

      _createClass(CheckboxFilterComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this40 = this;

          this.changesSubscription = this.inputControl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["debounceTime"])(this.delay)).subscribe(function (checked) {
            _this40.filterActive = true;
            var trueVal = _this40.column.getFilterConfig() && _this40.column.getFilterConfig()["true"] || true;
            var falseVal = _this40.column.getFilterConfig() && _this40.column.getFilterConfig()["false"] || false;
            _this40.query = checked ? trueVal : falseVal;

            _this40.setFilter();
          });
        }
      }, {
        key: "resetFilter",
        value: function resetFilter(event) {
          event.preventDefault();
          this.query = '';
          this.inputControl.setValue(false, {
            emitEvent: false
          });
          this.filterActive = false;
          this.setFilter();
        }
      }]);

      return CheckboxFilterComponent;
    }(DefaultFilter);

    CheckboxFilterComponent.ɵfac = function CheckboxFilterComponent_Factory(t) {
      return new (t || CheckboxFilterComponent)();
    };

    CheckboxFilterComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CheckboxFilterComponent,
      selectors: [["checkbox-filter"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 2,
      vars: 3,
      consts: [["type", "checkbox", 1, "form-control", 3, "formControl", "ngClass"], ["href", "#", 3, "click", 4, "ngIf"], ["href", "#", 3, "click"]],
      template: function CheckboxFilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "input", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CheckboxFilterComponent_a_1_Template, 2, 1, "a", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("formControl", ctx.inputControl)("ngClass", ctx.inputClass);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.filterActive);
        }
      },
      directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["CheckboxControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlDirective"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"]],
      encapsulation: 2
    });

    CheckboxFilterComponent.ctorParameters = function () {
      return [];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CheckboxFilterComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'checkbox-filter',
          template: "\n    <input type=\"checkbox\" [formControl]=\"inputControl\" [ngClass]=\"inputClass\" class=\"form-control\">\n    <a href=\"#\" *ngIf=\"filterActive\"\n                (click)=\"resetFilter($event)\">{{column.getFilterConfig()?.resetText || 'reset'}}</a>\n  "
        }]
      }], function () {
        return [];
      }, null);
    })();

    var CompleterFilterComponent =
    /*#__PURE__*/
    function (_DefaultFilter2) {
      _inherits(CompleterFilterComponent, _DefaultFilter2);

      var _super16 = _createSuper(CompleterFilterComponent);

      function CompleterFilterComponent(completerService) {
        var _this41;

        _classCallCheck(this, CompleterFilterComponent);

        _this41 = _super16.call(this);
        _this41.completerService = completerService;
        _this41.completerContent = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        return _this41;
      }

      _createClass(CompleterFilterComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this42 = this;

          var config = this.column.getFilterConfig().completer;
          config.dataService = this.completerService.local(config.data, config.searchFields, config.titleField);
          config.dataService.descriptionField(config.descriptionField);
          this.changesSubscription = this.completerContent.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(function (ev) {
            return ev && ev.title || ev || '';
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["debounceTime"])(this.delay)).subscribe(function (search) {
            _this42.query = search;

            _this42.setFilter();
          });
        }
      }, {
        key: "inputTextChanged",
        value: function inputTextChanged(event) {
          // workaround to trigger the search event when the home/end buttons are clicked
          // when this happens the [(ngModel)]="query" is set to "" but the (selected) method is not called
          // so here it gets called manually
          if (event === '') {
            this.completerContent.next(event);
          }
        }
      }]);

      return CompleterFilterComponent;
    }(DefaultFilter);

    CompleterFilterComponent.ɵfac = function CompleterFilterComponent_Factory(t) {
      return new (t || CompleterFilterComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterService"]));
    };

    CompleterFilterComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CompleterFilterComponent,
      selectors: [["completer-filter"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 1,
      vars: 5,
      consts: [[3, "ngModel", "dataService", "minSearchLength", "pause", "placeholder", "ngModelChange", "selected"]],
      template: function CompleterFilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ng2-completer", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function CompleterFilterComponent_Template_ng2_completer_ngModelChange_0_listener($event) {
            return ctx.query = $event;
          })("ngModelChange", function CompleterFilterComponent_Template_ng2_completer_ngModelChange_0_listener($event) {
            return ctx.inputTextChanged($event);
          })("selected", function CompleterFilterComponent_Template_ng2_completer_selected_0_listener($event) {
            return ctx.completerContent.next($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx.query)("dataService", ctx.column.getFilterConfig().completer.dataService)("minSearchLength", ctx.column.getFilterConfig().completer.minSearchLength || 0)("pause", ctx.column.getFilterConfig().completer.pause || 0)("placeholder", ctx.column.getFilterConfig().completer.placeholder || "Start typing...");
        }
      },
      directives: [ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterCmp"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"]],
      encapsulation: 2
    });

    CompleterFilterComponent.ctorParameters = function () {
      return [{
        type: ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterService"]
      }];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CompleterFilterComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'completer-filter',
          template: "\n    <ng2-completer [(ngModel)]=\"query\"\n                   (ngModelChange)=\"inputTextChanged($event)\"\n                   [dataService]=\"column.getFilterConfig().completer.dataService\"\n                   [minSearchLength]=\"column.getFilterConfig().completer.minSearchLength || 0\"\n                   [pause]=\"column.getFilterConfig().completer.pause || 0\"\n                   [placeholder]=\"column.getFilterConfig().completer.placeholder || 'Start typing...'\"\n                   (selected)=\"completerContent.next($event)\">\n    </ng2-completer>\n  "
        }]
      }], function () {
        return [{
          type: ng2_completer__WEBPACK_IMPORTED_MODULE_3__["CompleterService"]
        }];
      }, null);
    })();

    var InputFilterComponent =
    /*#__PURE__*/
    function (_DefaultFilter3) {
      _inherits(InputFilterComponent, _DefaultFilter3);

      var _super17 = _createSuper(InputFilterComponent);

      function InputFilterComponent() {
        var _this43;

        _classCallCheck(this, InputFilterComponent);

        _this43 = _super17.call(this);
        _this43.inputControl = new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControl"]();
        return _this43;
      }

      _createClass(InputFilterComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this44 = this;

          if (this.query) {
            this.inputControl.setValue(this.query);
          }

          this.inputControl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["debounceTime"])(this.delay)).subscribe(function (value) {
            _this44.query = _this44.inputControl.value;

            _this44.setFilter();
          });
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (changes.query) {
            this.inputControl.setValue(this.query);
          }
        }
      }]);

      return InputFilterComponent;
    }(DefaultFilter);

    InputFilterComponent.ɵfac = function InputFilterComponent_Factory(t) {
      return new (t || InputFilterComponent)();
    };

    InputFilterComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: InputFilterComponent,
      selectors: [["input-filter"]],
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 1,
      vars: 3,
      consts: [["type", "text", 1, "form-control", 3, "ngClass", "formControl", "placeholder"]],
      template: function InputFilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "input", 0);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("placeholder", ctx.column.title);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx.inputClass)("formControl", ctx.inputControl);
        }
      },
      directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["DefaultValueAccessor"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlDirective"]],
      encapsulation: 2
    });

    InputFilterComponent.ctorParameters = function () {
      return [];
    };
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](InputFilterComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'input-filter',
          template: "\n    <input\n      [ngClass]=\"inputClass\"\n      [formControl]=\"inputControl\"\n      class=\"form-control\"\n      type=\"text\"\n      placeholder=\"{{ column.title }}\"/>\n  "
        }]
      }], function () {
        return [];
      }, null);
    })();

    var SelectFilterComponent =
    /*#__PURE__*/
    function (_DefaultFilter4) {
      _inherits(SelectFilterComponent, _DefaultFilter4);

      var _super18 = _createSuper(SelectFilterComponent);

      function SelectFilterComponent() {
        _classCallCheck(this, SelectFilterComponent);

        return _super18.call(this);
      }

      _createClass(SelectFilterComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this45 = this;

          this.inputControl.valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["skip"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["distinctUntilChanged"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["debounceTime"])(this.delay)).subscribe(function (value) {
            return _this45.setFilter();
          });
        }
      }]);

      return SelectFilterComponent;
    }(DefaultFilter);

    SelectFilterComponent.ɵfac = function SelectFilterComponent_Factory(t) {
      return new (t || SelectFilterComponent)();
    };

    SelectFilterComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: SelectFilterComponent,
      selectors: [["select-filter"]],
      viewQuery: function SelectFilterComponent_Query(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstaticViewQuery"](_c1, true, _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"]);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.inputControl = _t.first);
        }
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
      decls: 5,
      vars: 4,
      consts: [[1, "form-control", 3, "ngClass", "ngModel", "ngModelChange"], ["inputControl", ""], ["value", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]],
      template: function SelectFilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "select", 0, 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function SelectFilterComponent_Template_select_ngModelChange_0_listener($event) {
            return ctx.query = $event;
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "option", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, SelectFilterComponent_option_4_Template, 2, 2, "option", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", ctx.inputClass)("ngModel", ctx.query);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx.column.getFilterConfig().selectText);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.column.getFilterConfig().list);
        }
      },
      directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["SelectControlValueAccessor"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgSelectOption"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ɵangular_packages_forms_forms_x"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"]],
      encapsulation: 2
    });

    SelectFilterComponent.ctorParameters = function () {
      return [];
    };

    SelectFilterComponent.propDecorators = {
      inputControl: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
        args: ['inputControl', {
          read: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"],
          "static": true
        }]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](SelectFilterComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'select-filter',
          template: "\n    <select [ngClass]=\"inputClass\"\n            class=\"form-control\"\n            #inputControl\n            [(ngModel)]=\"query\">\n\n        <option value=\"\">{{ column.getFilterConfig().selectText }}</option>\n        <option *ngFor=\"let option of column.getFilterConfig().list\" [value]=\"option.value\">\n          {{ option.title }}\n        </option>\n    </select>\n  "
        }]
      }], function () {
        return [];
      }, {
        inputControl: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
          args: ['inputControl', {
            read: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"],
            "static": true
          }]
        }]
      });
    })();

    var FILTER_COMPONENTS = [FilterDefault, DefaultFilter, FilterComponent, DefaultFilterComponent, CustomFilterComponent, CheckboxFilterComponent, CompleterFilterComponent, InputFilterComponent, SelectFilterComponent];

    var FilterModule = function FilterModule() {
      _classCallCheck(this, FilterModule);
    };

    FilterModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: FilterModule
    });
    FilterModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function FilterModule_Factory(t) {
        return new (t || FilterModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], ng2_completer__WEBPACK_IMPORTED_MODULE_3__["Ng2CompleterModule"]]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](FilterModule, {
        declarations: function declarations() {
          return [FilterDefault, DefaultFilter, FilterComponent, DefaultFilterComponent, CustomFilterComponent, CheckboxFilterComponent, CompleterFilterComponent, InputFilterComponent, SelectFilterComponent];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], ng2_completer__WEBPACK_IMPORTED_MODULE_3__["Ng2CompleterModule"]];
        },
        exports: function exports() {
          return [FilterDefault, DefaultFilter, FilterComponent, DefaultFilterComponent, CustomFilterComponent, CheckboxFilterComponent, CompleterFilterComponent, InputFilterComponent, SelectFilterComponent];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](FilterModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], ng2_completer__WEBPACK_IMPORTED_MODULE_3__["Ng2CompleterModule"]],
          declarations: [].concat(FILTER_COMPONENTS),
          exports: [].concat(FILTER_COMPONENTS)
        }]
      }], null, null);
    })();

    var PagerComponent =
    /*#__PURE__*/
    function () {
      function PagerComponent() {
        _classCallCheck(this, PagerComponent);

        this.perPageSelect = [];
        this.changePage = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.count = 0;
      }

      _createClass(PagerComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          var _this46 = this;

          if (changes.source) {
            if (!changes.source.firstChange) {
              this.dataChangedSub.unsubscribe();
            }

            this.dataChangedSub = this.source.onChanged().subscribe(function (dataChanges) {
              _this46.page = _this46.source.getPaging().page;
              _this46.perPage = _this46.source.getPaging().perPage;
              _this46.currentPerPage = _this46.perPage;
              _this46.count = _this46.source.count();

              if (_this46.isPageOutOfBounce()) {
                _this46.source.setPage(--_this46.page);
              }

              _this46.processPageChange(dataChanges);

              _this46.initPages();
            });
          }
        }
        /**
         * We change the page here depending on the action performed against data source
         * if a new element was added to the end of the table - then change the page to the last
         * if a new element was added to the beginning of the table - then to the first page
         * @param changes
         */

      }, {
        key: "processPageChange",
        value: function processPageChange(changes) {
          if (changes['action'] === 'prepend') {
            this.source.setPage(1);
          }

          if (changes['action'] === 'append') {
            this.source.setPage(this.getLast());
          }
        }
      }, {
        key: "shouldShow",
        value: function shouldShow() {
          return this.source.count() > this.perPage;
        }
      }, {
        key: "paginate",
        value: function paginate(page) {
          this.source.setPage(page);
          this.page = page;
          this.changePage.emit({
            page: page
          });
          return false;
        }
      }, {
        key: "next",
        value: function next() {
          return this.paginate(this.getPage() + 1);
        }
      }, {
        key: "prev",
        value: function prev() {
          return this.paginate(this.getPage() - 1);
        }
      }, {
        key: "getPage",
        value: function getPage() {
          return this.page;
        }
      }, {
        key: "getPages",
        value: function getPages() {
          return this.pages;
        }
      }, {
        key: "getLast",
        value: function getLast() {
          return Math.ceil(this.count / this.perPage);
        }
      }, {
        key: "isPageOutOfBounce",
        value: function isPageOutOfBounce() {
          return this.page * this.perPage >= this.count + this.perPage && this.page > 1;
        }
      }, {
        key: "initPages",
        value: function initPages() {
          var pagesCount = this.getLast();
          var showPagesCount = 4;
          showPagesCount = pagesCount < showPagesCount ? pagesCount : showPagesCount;
          this.pages = [];

          if (this.shouldShow()) {
            var middleOne = Math.ceil(showPagesCount / 2);
            middleOne = this.page >= middleOne ? this.page : middleOne;
            var lastOne = middleOne + Math.floor(showPagesCount / 2);
            lastOne = lastOne >= pagesCount ? pagesCount : lastOne;
            var firstOne = lastOne - showPagesCount + 1;

            for (var i = firstOne; i <= lastOne; i++) {
              this.pages.push(i);
            }
          }
        }
      }, {
        key: "onChangePerPage",
        value: function onChangePerPage(event) {
          if (this.currentPerPage) {
            if (typeof this.currentPerPage === 'string' && this.currentPerPage.toLowerCase() === 'all') {
              this.source.getPaging().perPage = null;
            } else {
              this.source.getPaging().perPage = this.currentPerPage * 1;
              this.source.refresh();
            }

            this.initPages();
          }
        }
      }]);

      return PagerComponent;
    }();

    PagerComponent.ɵfac = function PagerComponent_Factory(t) {
      return new (t || PagerComponent)();
    };

    PagerComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: PagerComponent,
      selectors: [["ng2-smart-table-pager"]],
      inputs: {
        perPageSelect: "perPageSelect",
        source: "source"
      },
      outputs: {
        changePage: "changePage"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 2,
      vars: 2,
      consts: [["class", "ng2-smart-pagination-nav", 4, "ngIf"], ["class", "ng2-smart-pagination-per-page", 4, "ngIf"], [1, "ng2-smart-pagination-nav"], [1, "ng2-smart-pagination", "pagination"], [1, "ng2-smart-page-item", "page-item", 3, "ngClass"], ["href", "#", "aria-label", "First", 1, "ng2-smart-page-link", "page-link", 3, "click"], ["aria-hidden", "true"], [1, "sr-only"], ["href", "#", "aria-label", "Prev", 1, "ng2-smart-page-link", "page-link", "page-link-prev", 3, "click"], ["class", "ng2-smart-page-item page-item", 3, "ngClass", 4, "ngFor", "ngForOf"], ["href", "#", "aria-label", "Next", 1, "ng2-smart-page-link", "page-link", "page-link-next", 3, "click"], ["href", "#", "aria-label", "Last", 1, "ng2-smart-page-link", "page-link", 3, "click"], ["class", "ng2-smart-page-link page-link", 4, "ngIf"], ["class", "ng2-smart-page-link page-link", "href", "#", 3, "click", 4, "ngIf"], [1, "ng2-smart-page-link", "page-link"], ["href", "#", 1, "ng2-smart-page-link", "page-link", 3, "click"], [1, "ng2-smart-pagination-per-page"], ["for", "per-page"], ["id", "per-page", 3, "ngModel", "change", "ngModelChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]],
      template: function PagerComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PagerComponent_nav_0_Template, 27, 13, "nav", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PagerComponent_nav_1_Template, 5, 2, "nav", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.shouldShow());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.perPageSelect && ctx.perPageSelect.length > 0);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["SelectControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgSelectOption"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ɵangular_packages_forms_forms_x"]],
      styles: [".ng2-smart-pagination[_ngcontent-%COMP%]{display:inline-flex;font-size:.875em;padding:0}.ng2-smart-pagination[_ngcontent-%COMP%]   .sr-only[_ngcontent-%COMP%]{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ng2-smart-pagination[_ngcontent-%COMP%]   .ng2-smart-page-item[_ngcontent-%COMP%]{display:inline}.ng2-smart-pagination[_ngcontent-%COMP%]   .page-link-next[_ngcontent-%COMP%], .ng2-smart-pagination[_ngcontent-%COMP%]   .page-link-prev[_ngcontent-%COMP%]{font-size:10px}[_nghost-%COMP%]{display:flex;justify-content:space-between}[_nghost-%COMP%]   label[_ngcontent-%COMP%], [_nghost-%COMP%]   select[_ngcontent-%COMP%]{margin:1rem 0 1rem 1rem}[_nghost-%COMP%]   label[_ngcontent-%COMP%]{line-height:2.5rem}"]
    });
    PagerComponent.propDecorators = {
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      perPageSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      changePage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](PagerComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-smart-table-pager',
          template: "\n    <nav *ngIf=\"shouldShow()\" class=\"ng2-smart-pagination-nav\">\n      <ul class=\"ng2-smart-pagination pagination\">\n        <li class=\"ng2-smart-page-item page-item\" [ngClass]=\"{disabled: getPage() == 1}\">\n          <a class=\"ng2-smart-page-link page-link\" href=\"#\"\n          (click)=\"getPage() == 1 ? false : paginate(1)\" aria-label=\"First\">\n            <span aria-hidden=\"true\">&laquo;</span>\n            <span class=\"sr-only\">First</span>\n          </a>\n        </li>\n        <li class=\"ng2-smart-page-item page-item\" [ngClass]=\"{disabled: getPage() == 1}\">\n          <a class=\"ng2-smart-page-link page-link page-link-prev\" href=\"#\"\n             (click)=\"getPage() == 1 ? false : prev()\" aria-label=\"Prev\">\n            <span aria-hidden=\"true\">&lt;</span>\n            <span class=\"sr-only\">Prev</span>\n          </a>\n        </li>\n        <li class=\"ng2-smart-page-item page-item\"\n        [ngClass]=\"{active: getPage() == page}\" *ngFor=\"let page of getPages()\">\n          <span class=\"ng2-smart-page-link page-link\"\n          *ngIf=\"getPage() == page\">{{ page }} <span class=\"sr-only\">(current)</span></span>\n          <a class=\"ng2-smart-page-link page-link\" href=\"#\"\n          (click)=\"paginate(page)\" *ngIf=\"getPage() != page\">{{ page }}</a>\n        </li>\n\n        <li class=\"ng2-smart-page-item page-item\"\n            [ngClass]=\"{disabled: getPage() == getLast()}\">\n          <a class=\"ng2-smart-page-link page-link page-link-next\" href=\"#\"\n             (click)=\"getPage() == getLast() ? false : next()\" aria-label=\"Next\">\n            <span aria-hidden=\"true\">&gt;</span>\n            <span class=\"sr-only\">Next</span>\n          </a>\n        </li>\n        \n        <li class=\"ng2-smart-page-item page-item\"\n        [ngClass]=\"{disabled: getPage() == getLast()}\">\n          <a class=\"ng2-smart-page-link page-link\" href=\"#\"\n          (click)=\"getPage() == getLast() ? false : paginate(getLast())\" aria-label=\"Last\">\n            <span aria-hidden=\"true\">&raquo;</span>\n            <span class=\"sr-only\">Last</span>\n          </a>\n        </li>\n      </ul>\n    </nav>\n    \n    <nav *ngIf=\"perPageSelect && perPageSelect.length > 0\" class=\"ng2-smart-pagination-per-page\">\n      <label for=\"per-page\">\n        Per Page:\n      </label>\n      <select (change)=\"onChangePerPage($event)\" [(ngModel)]=\"currentPerPage\" id=\"per-page\">\n        <option *ngFor=\"let item of perPageSelect\" [value]=\"item\">{{ item }}</option>\n      </select>\n    </nav>\n  ",
          styles: [".ng2-smart-pagination{display:inline-flex;font-size:.875em;padding:0}.ng2-smart-pagination .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ng2-smart-pagination .ng2-smart-page-item{display:inline}.ng2-smart-pagination .page-link-next,.ng2-smart-pagination .page-link-prev{font-size:10px}:host{display:flex;justify-content:space-between}:host label,:host select{margin:1rem 0 1rem 1rem}:host label{line-height:2.5rem}"]
        }]
      }], function () {
        return [];
      }, {
        perPageSelect: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        changePage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var PagerModule = function PagerModule() {
      _classCallCheck(this, PagerModule);
    };

    PagerModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: PagerModule
    });
    PagerModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function PagerModule_Factory(t) {
        return new (t || PagerModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"]]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](PagerModule, {
        declarations: function declarations() {
          return [PagerComponent];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"]];
        },
        exports: function exports() {
          return [PagerComponent];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](PagerModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"]],
          declarations: [PagerComponent],
          exports: [PagerComponent]
        }]
      }], null, null);
    })();

    var Ng2SmartTableTbodyComponent =
    /*#__PURE__*/
    function () {
      function Ng2SmartTableTbodyComponent() {
        _classCallCheck(this, Ng2SmartTableTbodyComponent);

        this.save = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.cancel = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.edit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this["delete"] = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.custom = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.edited = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.userSelectRow = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.editRowSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.multipleSelectRow = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.rowHover = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(Ng2SmartTableTbodyComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
          this.showActionColumnLeft = this.grid.showActionColumn('left');
          this.mode = this.grid.getSetting('mode');
          this.editInputClass = this.grid.getSetting('edit.inputClass');
          this.showActionColumnRight = this.grid.showActionColumn('right');
          this.isActionAdd = this.grid.getSetting('actions.add');
          this.isActionEdit = this.grid.getSetting('actions.edit');
          this.isActionDelete = this.grid.getSetting('actions.delete');
          this.noDataMessage = this.grid.getSetting('noDataMessage');
        }
      }, {
        key: "getVisibleCells",
        value: function getVisibleCells(cells) {
          return (cells || []).filter(function (cell) {
            return !cell.getColumn().hide;
          });
        }
      }, {
        key: "tableColumnsCount",
        get: function get() {
          var actionColumns = this.isActionAdd || this.isActionEdit || this.isActionDelete ? 1 : 0;
          return this.grid.getColumns().length + actionColumns;
        }
      }]);

      return Ng2SmartTableTbodyComponent;
    }();

    Ng2SmartTableTbodyComponent.ɵfac = function Ng2SmartTableTbodyComponent_Factory(t) {
      return new (t || Ng2SmartTableTbodyComponent)();
    };

    Ng2SmartTableTbodyComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: Ng2SmartTableTbodyComponent,
      selectors: [["", "ng2-st-tbody", ""]],
      inputs: {
        grid: "grid",
        source: "source",
        deleteConfirm: "deleteConfirm",
        editConfirm: "editConfirm",
        rowClassFunction: "rowClassFunction"
      },
      outputs: {
        save: "save",
        cancel: "cancel",
        edit: "edit",
        "delete": "delete",
        custom: "custom",
        edited: "edited",
        userSelectRow: "userSelectRow",
        editRowSelect: "editRowSelect",
        multipleSelectRow: "multipleSelectRow",
        rowHover: "rowHover"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      attrs: _c4,
      decls: 2,
      vars: 2,
      consts: [["class", "ng2-smart-row", 3, "className", "ngClass", "click", "mouseover", 4, "ngFor", "ngForOf"], [4, "ngIf"], [1, "ng2-smart-row", 3, "className", "ngClass", "click", "mouseover"], ["class", "ng2-smart-actions ng2-smart-action-multiple-select", 3, "click", 4, "ngIf"], ["class", "ng2-smart-actions", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "ng2-smart-actions", "ng2-smart-action-multiple-select", 3, "click"], ["type", "checkbox", 1, "form-control", 3, "ngModel"], [1, "ng2-smart-actions"], [3, "grid", "row", "source", "custom"], [3, "grid", "deleteConfirm", "editConfirm", "row", "source", "edit", "delete", "editRowSelect"], [3, "grid", "row", "editConfirm"], [3, "cell", "grid", "row", "isNew", "mode", "editConfirm", "inputClass", "isInEditing"]],
      template: function Ng2SmartTableTbodyComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, Ng2SmartTableTbodyComponent_tr_0_Template, 7, 10, "tr", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, Ng2SmartTableTbodyComponent_tr_1_Template, 3, 2, "tr", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.grid.getRows());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.grid.getRows().length == 0);
        }
      },
      directives: function directives() {
        return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["CheckboxControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"], TbodyCustomComponent, TbodyEditDeleteComponent, TbodyCreateCancelComponent, CellComponent];
      },
      styles: ["[_nghost-%COMP%]   .ng2-smart-row.selected[_ngcontent-%COMP%]{background:rgba(0,0,0,.05)}[_nghost-%COMP%]   .ng2-smart-row[_ngcontent-%COMP%]   .ng2-smart-actions.ng2-smart-action-multiple-select[_ngcontent-%COMP%]{text-align:center}[_nghost-%COMP%]     ng2-st-tbody-create-cancel a:first-child, [_nghost-%COMP%]     ng2-st-tbody-edit-delete a:first-child{margin-right:.25rem}"]
    });
    Ng2SmartTableTbodyComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      deleteConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      editConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      rowClassFunction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      save: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      cancel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      edit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      "delete": [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      custom: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      edited: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      userSelectRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      editRowSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      multipleSelectRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      rowHover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](Ng2SmartTableTbodyComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-tbody]',
          template: "<tr *ngFor=\"let row of grid.getRows()\" (click)=\"userSelectRow.emit(row)\" (mouseover)=\"rowHover.emit(row)\" class=\"ng2-smart-row\" [className]=\"rowClassFunction(row)\" [ngClass]=\"{selected: row.isSelected}\">\n  <td *ngIf=\"isMultiSelectVisible\" class=\"ng2-smart-actions ng2-smart-action-multiple-select\" (click)=\"multipleSelectRow.emit(row)\">\n    <input type=\"checkbox\" class=\"form-control\" [ngModel]=\"row.isSelected\">\n  </td>\n  <td *ngIf=\"!row.isInEditing && showActionColumnLeft\" class=\"ng2-smart-actions\">\n    <ng2-st-tbody-custom [grid]=\"grid\" (custom)=\"custom.emit($event)\" [row]=\"row\" [source]=\"source\"></ng2-st-tbody-custom>\n\n    <ng2-st-tbody-edit-delete [grid]=\"grid\"\n                              [deleteConfirm]=\"deleteConfirm\"\n                              [editConfirm]=\"editConfirm\"\n                              (edit)=\"edit.emit(row)\"\n                              (delete)=\"delete.emit(row)\"\n                              (editRowSelect)=\"editRowSelect.emit($event)\"\n                              [row]=\"row\"\n                              [source]=\"source\">\n    </ng2-st-tbody-edit-delete>\n  </td>\n   <td *ngIf=\"row.isInEditing && showActionColumnLeft\"  class=\"ng2-smart-actions\">\n    <ng2-st-tbody-create-cancel [grid]=\"grid\" [row]=\"row\" [editConfirm]=\"editConfirm\"></ng2-st-tbody-create-cancel>\n  </td>\n  <td *ngFor=\"let cell of getVisibleCells(row.cells)\">\n    <ng2-smart-table-cell [cell]=\"cell\"\n                          [grid]=\"grid\"\n                          [row]=\"row\"\n                          [isNew]=\"false\"\n                          [mode]=\"mode\"\n                          [editConfirm]=\"editConfirm\"\n                          [inputClass]=\"editInputClass\"\n                          [isInEditing]=\"row.isInEditing\">\n    </ng2-smart-table-cell>\n  </td>\n\n  <td *ngIf=\"row.isInEditing && showActionColumnRight\"  class=\"ng2-smart-actions\">\n    <ng2-st-tbody-create-cancel [grid]=\"grid\" [row]=\"row\" [editConfirm]=\"editConfirm\"></ng2-st-tbody-create-cancel>\n  </td>\n\n  <td *ngIf=\"!row.isInEditing && showActionColumnRight\" class=\"ng2-smart-actions\">\n    <ng2-st-tbody-custom [grid]=\"grid\" (custom)=\"custom.emit($event)\" [row]=\"row\" [source]=\"source\"></ng2-st-tbody-custom>\n\n    <ng2-st-tbody-edit-delete [grid]=\"grid\"\n                              [deleteConfirm]=\"deleteConfirm\"\n                              [editConfirm]=\"editConfirm\"\n                              [row]=\"row\"\n                              [source]=\"source\"\n                              (edit)=\"edit.emit(row)\"\n                              (delete)=\"delete.emit(row)\"\n                              (editRowSelect)=\"editRowSelect.emit($event)\">\n    </ng2-st-tbody-edit-delete>\n  </td>\n</tr>\n\n<tr *ngIf=\"grid.getRows().length == 0\">\n  <td [attr.colspan]=\"tableColumnsCount\">\n    {{ noDataMessage }}\n  </td>\n</tr>\n",
          styles: [":host .ng2-smart-row.selected{background:rgba(0,0,0,.05)}:host .ng2-smart-row .ng2-smart-actions.ng2-smart-action-multiple-select{text-align:center}:host ::ng-deep ng2-st-tbody-create-cancel a:first-child,:host ::ng-deep ng2-st-tbody-edit-delete a:first-child{margin-right:.25rem}"]
        }]
      }], function () {
        return [];
      }, {
        save: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        cancel: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        edit: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        "delete": [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        custom: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        edited: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        userSelectRow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        editRowSelect: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        multipleSelectRow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        rowHover: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        deleteConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        editConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        rowClassFunction: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TbodyCreateCancelComponent =
    /*#__PURE__*/
    function () {
      function TbodyCreateCancelComponent() {
        _classCallCheck(this, TbodyCreateCancelComponent);
      }

      _createClass(TbodyCreateCancelComponent, [{
        key: "onSave",
        value: function onSave(event) {
          event.preventDefault();
          event.stopPropagation();
          this.grid.save(this.row, this.editConfirm);
        }
      }, {
        key: "onCancelEdit",
        value: function onCancelEdit(event) {
          event.preventDefault();
          event.stopPropagation();
          this.row.isInEditing = false;
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.saveButtonContent = this.grid.getSetting('edit.saveButtonContent');
          this.cancelButtonContent = this.grid.getSetting('edit.cancelButtonContent');
        }
      }]);

      return TbodyCreateCancelComponent;
    }();

    TbodyCreateCancelComponent.ɵfac = function TbodyCreateCancelComponent_Factory(t) {
      return new (t || TbodyCreateCancelComponent)();
    };

    TbodyCreateCancelComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TbodyCreateCancelComponent,
      selectors: [["ng2-st-tbody-create-cancel"]],
      inputs: {
        grid: "grid",
        row: "row",
        editConfirm: "editConfirm"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 2,
      vars: 2,
      consts: [["href", "#", 1, "ng2-smart-action", "ng2-smart-action-edit-save", 3, "innerHTML", "click"], ["href", "#", 1, "ng2-smart-action", "ng2-smart-action-edit-cancel", 3, "innerHTML", "click"]],
      template: function TbodyCreateCancelComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TbodyCreateCancelComponent_Template_a_click_0_listener($event) {
            return ctx.onSave($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TbodyCreateCancelComponent_Template_a_click_1_listener($event) {
            return ctx.onCancelEdit($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx.saveButtonContent, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx.cancelButtonContent, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
        }
      },
      encapsulation: 2
    });
    TbodyCreateCancelComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      row: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      editConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TbodyCreateCancelComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-st-tbody-create-cancel',
          template: "\n    <a href=\"#\" class=\"ng2-smart-action ng2-smart-action-edit-save\"\n        [innerHTML]=\"saveButtonContent\" (click)=\"onSave($event)\"></a>\n    <a href=\"#\" class=\"ng2-smart-action ng2-smart-action-edit-cancel\"\n        [innerHTML]=\"cancelButtonContent\" (click)=\"onCancelEdit($event)\"></a>\n  "
        }]
      }], null, {
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        row: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        editConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TbodyEditDeleteComponent =
    /*#__PURE__*/
    function () {
      function TbodyEditDeleteComponent() {
        _classCallCheck(this, TbodyEditDeleteComponent);

        this.edit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this["delete"] = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.editRowSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(TbodyEditDeleteComponent, [{
        key: "onEdit",
        value: function onEdit(event) {
          event.preventDefault();
          event.stopPropagation();
          this.editRowSelect.emit(this.row);

          if (this.grid.getSetting('mode') === 'external') {
            this.edit.emit({
              data: this.row.getData(),
              source: this.source
            });
          } else {
            this.grid.edit(this.row);
          }
        }
      }, {
        key: "onDelete",
        value: function onDelete(event) {
          event.preventDefault();
          event.stopPropagation();

          if (this.grid.getSetting('mode') === 'external') {
            this["delete"].emit({
              data: this.row.getData(),
              source: this.source
            });
          } else {
            this.grid["delete"](this.row, this.deleteConfirm);
          }
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.isActionEdit = this.grid.getSetting('actions.edit');
          this.isActionDelete = this.grid.getSetting('actions.delete');
          this.editRowButtonContent = this.grid.getSetting('edit.editButtonContent');
          this.deleteRowButtonContent = this.grid.getSetting('delete.deleteButtonContent');
        }
      }]);

      return TbodyEditDeleteComponent;
    }();

    TbodyEditDeleteComponent.ɵfac = function TbodyEditDeleteComponent_Factory(t) {
      return new (t || TbodyEditDeleteComponent)();
    };

    TbodyEditDeleteComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TbodyEditDeleteComponent,
      selectors: [["ng2-st-tbody-edit-delete"]],
      inputs: {
        grid: "grid",
        row: "row",
        source: "source",
        deleteConfirm: "deleteConfirm",
        editConfirm: "editConfirm"
      },
      outputs: {
        edit: "edit",
        "delete": "delete",
        editRowSelect: "editRowSelect"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 2,
      vars: 2,
      consts: [["href", "#", "class", "ng2-smart-action ng2-smart-action-edit-edit", 3, "innerHTML", "click", 4, "ngIf"], ["href", "#", "class", "ng2-smart-action ng2-smart-action-delete-delete", 3, "innerHTML", "click", 4, "ngIf"], ["href", "#", 1, "ng2-smart-action", "ng2-smart-action-edit-edit", 3, "innerHTML", "click"], ["href", "#", 1, "ng2-smart-action", "ng2-smart-action-delete-delete", 3, "innerHTML", "click"]],
      template: function TbodyEditDeleteComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TbodyEditDeleteComponent_a_0_Template, 1, 1, "a", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TbodyEditDeleteComponent_a_1_Template, 1, 1, "a", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isActionEdit);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isActionDelete);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"]],
      encapsulation: 2,
      changeDetection: 0
    });
    TbodyEditDeleteComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      row: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      deleteConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      editConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      edit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      "delete": [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      editRowSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TbodyEditDeleteComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-st-tbody-edit-delete',
          changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
          template: "\n    <a href=\"#\" *ngIf=\"isActionEdit\" class=\"ng2-smart-action ng2-smart-action-edit-edit\"\n        [innerHTML]=\"editRowButtonContent\" (click)=\"onEdit($event)\"></a>\n    <a href=\"#\" *ngIf=\"isActionDelete\" class=\"ng2-smart-action ng2-smart-action-delete-delete\"\n        [innerHTML]=\"deleteRowButtonContent\" (click)=\"onDelete($event)\"></a>\n  "
        }]
      }], function () {
        return [];
      }, {
        edit: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        "delete": [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        editRowSelect: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        row: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        deleteConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        editConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TbodyCustomComponent =
    /*#__PURE__*/
    function () {
      function TbodyCustomComponent() {
        _classCallCheck(this, TbodyCustomComponent);

        this.custom = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(TbodyCustomComponent, [{
        key: "onCustom",
        value: function onCustom(action, event) {
          event.preventDefault();
          event.stopPropagation();
          this.custom.emit({
            action: action.name,
            data: this.row.getData(),
            source: this.source
          });
        }
      }]);

      return TbodyCustomComponent;
    }();

    TbodyCustomComponent.ɵfac = function TbodyCustomComponent_Factory(t) {
      return new (t || TbodyCustomComponent)();
    };

    TbodyCustomComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TbodyCustomComponent,
      selectors: [["ng2-st-tbody-custom"]],
      inputs: {
        grid: "grid",
        row: "row",
        source: "source"
      },
      outputs: {
        custom: "custom"
      },
      decls: 1,
      vars: 1,
      consts: [["href", "#", "class", "ng2-smart-action ng2-smart-action-custom-custom", 3, "innerHTML", "click", 4, "ngFor", "ngForOf"], ["href", "#", 1, "ng2-smart-action", "ng2-smart-action-custom-custom", 3, "innerHTML", "click"]],
      template: function TbodyCustomComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TbodyCustomComponent_a_0_Template, 1, 1, "a", 0);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.grid.getSetting("actions.custom"));
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"]],
      encapsulation: 2,
      changeDetection: 0
    });
    TbodyCustomComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      row: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      custom: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TbodyCustomComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-st-tbody-custom',
          changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
          template: "\n      <a *ngFor=\"let action of grid.getSetting('actions.custom')\" href=\"#\"\n         class=\"ng2-smart-action ng2-smart-action-custom-custom\" \n         [innerHTML]=\"action.title\"\n         (click)=\"onCustom(action, $event)\"></a>\n        "
        }]
      }], function () {
        return [];
      }, {
        custom: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        row: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TBODY_COMPONENTS = [TbodyCreateCancelComponent, TbodyEditDeleteComponent, TbodyCustomComponent, Ng2SmartTableTbodyComponent];

    var TBodyModule = function TBodyModule() {
      _classCallCheck(this, TBodyModule);
    };

    TBodyModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: TBodyModule
    });
    TBodyModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function TBodyModule_Factory(t) {
        return new (t || TBodyModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], CellModule]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TBodyModule, {
        declarations: function declarations() {
          return [TbodyCreateCancelComponent, TbodyEditDeleteComponent, TbodyCustomComponent, Ng2SmartTableTbodyComponent];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], CellModule];
        },
        exports: function exports() {
          return [TbodyCreateCancelComponent, TbodyEditDeleteComponent, TbodyCustomComponent, Ng2SmartTableTbodyComponent];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TBodyModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], CellModule],
          declarations: [].concat(TBODY_COMPONENTS),
          exports: [].concat(TBODY_COMPONENTS)
        }]
      }], null, null);
    })();

    var Ng2SmartTableTheadComponent =
    /*#__PURE__*/
    function () {
      function Ng2SmartTableTheadComponent() {
        _classCallCheck(this, Ng2SmartTableTheadComponent);

        this.sort = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.selectAllRows = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.create = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.filter = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(Ng2SmartTableTheadComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.isHideHeader = this.grid.getSetting('hideHeader');
          this.isHideSubHeader = this.grid.getSetting('hideSubHeader');
        }
      }]);

      return Ng2SmartTableTheadComponent;
    }();

    Ng2SmartTableTheadComponent.ɵfac = function Ng2SmartTableTheadComponent_Factory(t) {
      return new (t || Ng2SmartTableTheadComponent)();
    };

    Ng2SmartTableTheadComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: Ng2SmartTableTheadComponent,
      selectors: [["", "ng2-st-thead", ""]],
      inputs: {
        grid: "grid",
        source: "source",
        isAllSelected: "isAllSelected",
        createConfirm: "createConfirm"
      },
      outputs: {
        sort: "sort",
        selectAllRows: "selectAllRows",
        create: "create",
        filter: "filter"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      attrs: _c6,
      decls: 3,
      vars: 3,
      consts: [["ng2-st-thead-titles-row", "", "class", "ng2-smart-titles", 3, "grid", "isAllSelected", "source", "sort", "selectAllRows", 4, "ngIf"], ["ng2-st-thead-filters-row", "", "class", "ng2-smart-filters", 3, "grid", "source", "create", "filter", 4, "ngIf"], ["ng2-st-thead-form-row", "", 3, "grid", "createConfirm", 4, "ngIf"], ["ng2-st-thead-titles-row", "", 1, "ng2-smart-titles", 3, "grid", "isAllSelected", "source", "sort", "selectAllRows"], ["ng2-st-thead-filters-row", "", 1, "ng2-smart-filters", 3, "grid", "source", "create", "filter"], ["ng2-st-thead-form-row", "", 3, "grid", "createConfirm"]],
      template: function Ng2SmartTableTheadComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, Ng2SmartTableTheadComponent_tr_0_Template, 1, 3, "tr", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, Ng2SmartTableTheadComponent_tr_1_Template, 1, 2, "tr", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, Ng2SmartTableTheadComponent_tr_2_Template, 1, 2, "tr", 2);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.isHideHeader);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.isHideSubHeader);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.grid.createFormShown);
        }
      },
      directives: function directives() {
        return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], TheadTitlesRowComponent, TheadFitlersRowComponent, TheadFormRowComponent];
      },
      encapsulation: 2
    });
    Ng2SmartTableTheadComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      isAllSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      createConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      sort: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      selectAllRows: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      create: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      filter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](Ng2SmartTableTheadComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-thead]',
          template: "<tr ng2-st-thead-titles-row *ngIf=\"!isHideHeader\"\n                            class=\"ng2-smart-titles\"\n                            [grid]=\"grid\"\n                            [isAllSelected]=\"isAllSelected\"\n                            [source]=\"source\"\n                            (sort)=\"sort.emit($event)\"\n                            (selectAllRows)=\"selectAllRows.emit($event)\">\n</tr>\n\n<tr ng2-st-thead-filters-row *ngIf=\"!isHideSubHeader\"\n                              class=\"ng2-smart-filters\"\n                              [grid]=\"grid\"\n                              [source]=\"source\"\n                              (create)=\"create.emit($event)\"\n                              (filter)=\"filter.emit($event)\">\n</tr>\n\n<tr ng2-st-thead-form-row *ngIf=\"grid.createFormShown\"\n                          [grid]=\"grid\"\n                          [createConfirm]=\"createConfirm\">\n</tr>\n"
        }]
      }], function () {
        return [];
      }, {
        sort: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        selectAllRows: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        create: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        filter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        isAllSelected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        createConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var ActionsComponent =
    /*#__PURE__*/
    function () {
      function ActionsComponent() {
        _classCallCheck(this, ActionsComponent);

        this.create = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(ActionsComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.createButtonContent = this.grid.getSetting('add.createButtonContent');
          this.cancelButtonContent = this.grid.getSetting('add.cancelButtonContent');
        }
      }]);

      return ActionsComponent;
    }();

    ActionsComponent.ɵfac = function ActionsComponent_Factory(t) {
      return new (t || ActionsComponent)();
    };

    ActionsComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: ActionsComponent,
      selectors: [["ng2-st-actions"]],
      inputs: {
        grid: "grid"
      },
      outputs: {
        create: "create"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 2,
      vars: 2,
      consts: [["href", "#", 1, "ng2-smart-action", "ng2-smart-action-add-create", 3, "innerHTML", "click"], ["href", "#", 1, "ng2-smart-action", "ng2-smart-action-add-cancel", 3, "innerHTML", "click"]],
      template: function ActionsComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function ActionsComponent_Template_a_click_0_listener($event) {
            $event.preventDefault();
            return ctx.create.emit($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function ActionsComponent_Template_a_click_1_listener($event) {
            $event.preventDefault();
            return ctx.grid.createFormShown = false;
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx.createButtonContent, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("innerHTML", ctx.cancelButtonContent, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
        }
      },
      encapsulation: 2
    });
    ActionsComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      create: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](ActionsComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-st-actions',
          template: "\n    <a href=\"#\" class=\"ng2-smart-action ng2-smart-action-add-create\"\n        [innerHTML]=\"createButtonContent\"\n        (click)=\"$event.preventDefault();create.emit($event)\"></a>\n    <a href=\"#\" class=\"ng2-smart-action ng2-smart-action-add-cancel\"\n        [innerHTML]=\"cancelButtonContent\"\n        (click)=\"$event.preventDefault();grid.createFormShown = false;\"></a>\n  "
        }]
      }], function () {
        return [];
      }, {
        create: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var ActionsTitleComponent =
    /*#__PURE__*/
    function () {
      function ActionsTitleComponent(ref) {
        _classCallCheck(this, ActionsTitleComponent);

        this.ref = ref;
      }

      _createClass(ActionsTitleComponent, [{
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.ref.nativeElement.classList.add('ng2-smart-actions');
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.actionsColumnTitle = this.grid.getSetting('actions.columnTitle');
        }
      }]);

      return ActionsTitleComponent;
    }();

    ActionsTitleComponent.ɵfac = function ActionsTitleComponent_Factory(t) {
      return new (t || ActionsTitleComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]));
    };

    ActionsTitleComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: ActionsTitleComponent,
      selectors: [["", "ng2-st-actions-title", ""]],
      inputs: {
        grid: "grid"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      attrs: _c7,
      decls: 2,
      vars: 1,
      consts: [[1, "ng2-smart-title"]],
      template: function ActionsTitleComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx.actionsColumnTitle);
        }
      },
      encapsulation: 2
    });

    ActionsTitleComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }];
    };

    ActionsTitleComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](ActionsTitleComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-actions-title]',
          template: "\n    <div class=\"ng2-smart-title\">{{ actionsColumnTitle }}</div>\n  "
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
        }];
      }, {
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var AddButtonComponent =
    /*#__PURE__*/
    function () {
      function AddButtonComponent(ref) {
        _classCallCheck(this, AddButtonComponent);

        this.ref = ref;
        this.create = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(AddButtonComponent, [{
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.ref.nativeElement.classList.add('ng2-smart-actions-title', 'ng2-smart-actions-title-add');
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.isActionAdd = this.grid.getSetting('actions.add');
          this.addNewButtonContent = this.grid.getSetting('add.addButtonContent');
        }
      }, {
        key: "onAdd",
        value: function onAdd(event) {
          event.preventDefault();
          event.stopPropagation();

          if (this.grid.getSetting('mode') === 'external') {
            this.create.emit({
              source: this.source
            });
          } else {
            this.grid.createFormShown = true;
          }
        }
      }]);

      return AddButtonComponent;
    }();

    AddButtonComponent.ɵfac = function AddButtonComponent_Factory(t) {
      return new (t || AddButtonComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]));
    };

    AddButtonComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: AddButtonComponent,
      selectors: [["", "ng2-st-add-button", ""]],
      inputs: {
        grid: "grid",
        source: "source"
      },
      outputs: {
        create: "create"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      attrs: _c8,
      decls: 1,
      vars: 1,
      consts: [["href", "#", "class", "ng2-smart-action ng2-smart-action-add-add", 3, "innerHTML", "click", 4, "ngIf"], ["href", "#", 1, "ng2-smart-action", "ng2-smart-action-add-add", 3, "innerHTML", "click"]],
      template: function AddButtonComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, AddButtonComponent_a_0_Template, 1, 1, "a", 0);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isActionAdd);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"]],
      encapsulation: 2
    });

    AddButtonComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }];
    };

    AddButtonComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      create: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AddButtonComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-add-button]',
          template: "\n    <a *ngIf=\"isActionAdd\" href=\"#\" class=\"ng2-smart-action ng2-smart-action-add-add\"\n        [innerHTML]=\"addNewButtonContent\" (click)=\"onAdd($event)\"></a>\n  "
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
        }];
      }, {
        create: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var CheckboxSelectAllComponent = function CheckboxSelectAllComponent() {
      _classCallCheck(this, CheckboxSelectAllComponent);
    };

    CheckboxSelectAllComponent.ɵfac = function CheckboxSelectAllComponent_Factory(t) {
      return new (t || CheckboxSelectAllComponent)();
    };

    CheckboxSelectAllComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: CheckboxSelectAllComponent,
      selectors: [["", "ng2-st-checkbox-select-all", ""]],
      inputs: {
        grid: "grid",
        source: "source",
        isAllSelected: "isAllSelected"
      },
      attrs: _c9,
      decls: 1,
      vars: 1,
      consts: [["type", "checkbox", 3, "ngModel"]],
      template: function CheckboxSelectAllComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "input", 0);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx.isAllSelected);
        }
      },
      directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["CheckboxControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"]],
      encapsulation: 2
    });
    CheckboxSelectAllComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      isAllSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CheckboxSelectAllComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-checkbox-select-all]',
          template: "\n    <input type=\"checkbox\" [ngModel]=\"isAllSelected\">\n  "
        }]
      }], null, {
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        isAllSelected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var ColumnTitleComponent = function ColumnTitleComponent() {
      _classCallCheck(this, ColumnTitleComponent);

      this.sort = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    };

    ColumnTitleComponent.ɵfac = function ColumnTitleComponent_Factory(t) {
      return new (t || ColumnTitleComponent)();
    };

    ColumnTitleComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: ColumnTitleComponent,
      selectors: [["ng2-st-column-title"]],
      inputs: {
        column: "column",
        source: "source"
      },
      outputs: {
        sort: "sort"
      },
      decls: 2,
      vars: 2,
      consts: [[1, "ng2-smart-title"], [3, "source", "column", "sort"]],
      template: function ColumnTitleComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "ng2-smart-table-title", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("sort", function ColumnTitleComponent_Template_ng2_smart_table_title_sort_1_listener($event) {
            return ctx.sort.emit($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("source", ctx.source)("column", ctx.column);
        }
      },
      directives: function directives() {
        return [TitleComponent];
      },
      encapsulation: 2
    });
    ColumnTitleComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      sort: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](ColumnTitleComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-st-column-title',
          template: "\n    <div class=\"ng2-smart-title\">\n      <ng2-smart-table-title [source]=\"source\" [column]=\"column\" (sort)=\"sort.emit($event)\"></ng2-smart-table-title>\n    </div>\n  "
        }]
      }], function () {
        return [];
      }, {
        sort: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        column: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TitleComponent =
    /*#__PURE__*/
    function () {
      function TitleComponent() {
        _classCallCheck(this, TitleComponent);

        this.currentDirection = '';
        this.sort = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(TitleComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          var _this47 = this;

          if (changes.source) {
            if (!changes.source.firstChange) {
              this.dataChangedSub.unsubscribe();
            }

            this.dataChangedSub = this.source.onChanged().subscribe(function (dataChanges) {
              var sortConf = _this47.source.getSort();

              if (sortConf.length > 0 && sortConf[0]['field'] === _this47.column.id) {
                _this47.currentDirection = sortConf[0]['direction'];
              } else {
                _this47.currentDirection = '';
              }

              sortConf.forEach(function (fieldConf) {});
            });
          }
        }
      }, {
        key: "_sort",
        value: function _sort(event) {
          event.preventDefault();
          this.changeSortDirection();
          this.source.setSort([{
            field: this.column.id,
            direction: this.currentDirection,
            compare: this.column.getCompareFunction()
          }]);
          this.sort.emit(null);
        }
      }, {
        key: "changeSortDirection",
        value: function changeSortDirection() {
          if (this.currentDirection) {
            var newDirection = this.currentDirection === 'asc' ? 'desc' : 'asc';
            this.currentDirection = newDirection;
          } else {
            this.currentDirection = this.column.sortDirection;
          }

          return this.currentDirection;
        }
      }]);

      return TitleComponent;
    }();

    TitleComponent.ɵfac = function TitleComponent_Factory(t) {
      return new (t || TitleComponent)();
    };

    TitleComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TitleComponent,
      selectors: [["ng2-smart-table-title"]],
      inputs: {
        column: "column",
        source: "source"
      },
      outputs: {
        sort: "sort"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 2,
      vars: 2,
      consts: [["href", "#", "class", "ng2-smart-sort-link sort", 3, "ngClass", "click", 4, "ngIf"], ["class", "ng2-smart-sort", 4, "ngIf"], ["href", "#", 1, "ng2-smart-sort-link", "sort", 3, "ngClass", "click"], [1, "ng2-smart-sort"]],
      template: function TitleComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TitleComponent_a_0_Template, 2, 2, "a", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TitleComponent_span_1_Template, 2, 1, "span", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.column.isSortable);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.column.isSortable);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"]],
      styles: ["a.sort.asc[_ngcontent-%COMP%], a.sort.desc[_ngcontent-%COMP%]{font-weight:700}a.sort.asc[_ngcontent-%COMP%]:after, a.sort.desc[_ngcontent-%COMP%]:after{border:4px solid transparent;border-bottom-color:rgba(0,0,0,.3);content:\"\";display:inline-block;height:0;margin-bottom:2px;width:0}a.sort.desc[_ngcontent-%COMP%]:after{margin-bottom:-2px;transform:rotate(-180deg)}"]
    });
    TitleComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      sort: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TitleComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-smart-table-title',
          template: "\n    <a href=\"#\" *ngIf=\"column.isSortable\"\n                (click)=\"_sort($event)\"\n                class=\"ng2-smart-sort-link sort\"\n                [ngClass]=\"currentDirection\">\n      {{ column.title }}\n    </a>\n    <span class=\"ng2-smart-sort\" *ngIf=\"!column.isSortable\">{{ column.title }}</span>\n  ",
          styles: ["a.sort.asc,a.sort.desc{font-weight:700}a.sort.asc:after,a.sort.desc:after{border:4px solid transparent;border-bottom-color:rgba(0,0,0,.3);content:\"\";display:inline-block;height:0;margin-bottom:2px;width:0}a.sort.desc:after{margin-bottom:-2px;transform:rotate(-180deg)}"]
        }]
      }], function () {
        return [];
      }, {
        sort: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        column: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TheadFitlersRowComponent =
    /*#__PURE__*/
    function () {
      function TheadFitlersRowComponent() {
        _classCallCheck(this, TheadFitlersRowComponent);

        this.create = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.filter = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(TheadFitlersRowComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
          this.showActionColumnLeft = this.grid.showActionColumn('left');
          this.showActionColumnRight = this.grid.showActionColumn('right');
          this.filterInputClass = this.grid.getSetting('filter.inputClass');
        }
      }, {
        key: "getVisibleColumns",
        value: function getVisibleColumns(columns) {
          return (columns || []).filter(function (column) {
            return !column.hide;
          });
        }
      }]);

      return TheadFitlersRowComponent;
    }();

    TheadFitlersRowComponent.ɵfac = function TheadFitlersRowComponent_Factory(t) {
      return new (t || TheadFitlersRowComponent)();
    };

    TheadFitlersRowComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TheadFitlersRowComponent,
      selectors: [["", "ng2-st-thead-filters-row", ""]],
      inputs: {
        grid: "grid",
        source: "source"
      },
      outputs: {
        create: "create",
        filter: "filter"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      attrs: _c10,
      decls: 4,
      vars: 4,
      consts: [[4, "ngIf"], ["ng2-st-add-button", "", 3, "grid", "create", 4, "ngIf"], [3, "class", 4, "ngFor", "ngForOf"], ["ng2-st-add-button", "", 3, "grid", "source", "create", 4, "ngIf"], ["ng2-st-add-button", "", 3, "grid", "create"], [3, "source", "column", "inputClass", "filter"], ["ng2-st-add-button", "", 3, "grid", "source", "create"]],
      template: function TheadFitlersRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TheadFitlersRowComponent_th_0_Template, 1, 0, "th", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TheadFitlersRowComponent_th_1_Template, 1, 1, "th", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, TheadFitlersRowComponent_th_2_Template, 2, 6, "th", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, TheadFitlersRowComponent_th_3_Template, 1, 2, "th", 3);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isMultiSelectVisible);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showActionColumnLeft);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.getVisibleColumns(ctx.grid.getColumns()));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showActionColumnRight);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], AddButtonComponent, FilterComponent],
      encapsulation: 2
    });
    TheadFitlersRowComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      create: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      filter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TheadFitlersRowComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-thead-filters-row]',
          template: "\n    <th *ngIf=\"isMultiSelectVisible\"></th>\n    <th ng2-st-add-button *ngIf=\"showActionColumnLeft\"\n                          [grid]=\"grid\"\n                          (create)=\"create.emit($event)\">\n    </th>\n    <th *ngFor=\"let column of getVisibleColumns(grid.getColumns())\" class=\"ng2-smart-th {{ column.id }}\">\n      <ng2-smart-table-filter [source]=\"source\"\n                              [column]=\"column\"\n                              [inputClass]=\"filterInputClass\"\n                              (filter)=\"filter.emit($event)\">\n      </ng2-smart-table-filter>\n    </th>\n    <th ng2-st-add-button *ngIf=\"showActionColumnRight\"\n                          [grid]=\"grid\"\n                          [source]=\"source\"\n                          (create)=\"create.emit($event)\">\n    </th>\n  "
        }]
      }], function () {
        return [];
      }, {
        create: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        filter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TheadFormRowComponent =
    /*#__PURE__*/
    function () {
      function TheadFormRowComponent() {
        _classCallCheck(this, TheadFormRowComponent);

        this.create = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(TheadFormRowComponent, [{
        key: "onCreate",
        value: function onCreate(event) {
          event.stopPropagation();
          this.grid.create(this.grid.getNewRow(), this.createConfirm);
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
          this.showActionColumnLeft = this.grid.showActionColumn('left');
          this.showActionColumnRight = this.grid.showActionColumn('right');
          this.addInputClass = this.grid.getSetting('add.inputClass');
        }
      }, {
        key: "getVisibleCells",
        value: function getVisibleCells(cells) {
          return (cells || []).filter(function (cell) {
            return !cell.getColumn().hide;
          });
        }
      }]);

      return TheadFormRowComponent;
    }();

    TheadFormRowComponent.ɵfac = function TheadFormRowComponent_Factory(t) {
      return new (t || TheadFormRowComponent)();
    };

    TheadFormRowComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TheadFormRowComponent,
      selectors: [["", "ng2-st-thead-form-row", ""]],
      inputs: {
        grid: "grid",
        row: "row",
        createConfirm: "createConfirm"
      },
      outputs: {
        create: "create"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      attrs: _c11,
      decls: 4,
      vars: 3,
      consts: [[4, "ngIf"], ["class", "ng2-smart-actions", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "ng2-smart-actions"], [3, "grid", "create"], [3, "cell", "grid", "isNew", "createConfirm", "inputClass", "isInEditing", "edited"]],
      template: function TheadFormRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TheadFormRowComponent_td_0_Template, 1, 0, "td", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TheadFormRowComponent_td_1_Template, 2, 1, "td", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, TheadFormRowComponent_td_2_Template, 2, 6, "td", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, TheadFormRowComponent_td_3_Template, 2, 1, "td", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showActionColumnLeft);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.getVisibleCells(ctx.grid.getNewRow().getCells()));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showActionColumnRight);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], ActionsComponent, CellComponent],
      encapsulation: 2
    });
    TheadFormRowComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      row: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      createConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      create: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TheadFormRowComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-thead-form-row]',
          template: "\n      <td *ngIf=\"\"></td>\n      <td  *ngIf=\"showActionColumnLeft\"  class=\"ng2-smart-actions\">\n        <ng2-st-actions [grid]=\"grid\" (create)=\"onCreate($event)\"></ng2-st-actions>\n      </td>\n      <td *ngFor=\"let cell of getVisibleCells(grid.getNewRow().getCells())\">\n        <ng2-smart-table-cell [cell]=\"cell\"\n                              [grid]=\"grid\"\n                              [isNew]=\"true\"\n                              [createConfirm]=\"createConfirm\"\n                              [inputClass]=\"addInputClass\"\n                              [isInEditing]=\"grid.getNewRow().isInEditing\"\n                              (edited)=\"onCreate($event)\">\n        </ng2-smart-table-cell>\n      </td>\n      <td  *ngIf=\"showActionColumnRight\"  class=\"ng2-smart-actions\">\n        <ng2-st-actions [grid]=\"grid\" (create)=\"onCreate($event)\"></ng2-st-actions>\n      </td>\n  "
        }]
      }], function () {
        return [];
      }, {
        create: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        row: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        createConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var TheadTitlesRowComponent =
    /*#__PURE__*/
    function () {
      function TheadTitlesRowComponent() {
        _classCallCheck(this, TheadTitlesRowComponent);

        this.sort = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.selectAllRows = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
      }

      _createClass(TheadTitlesRowComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.isMultiSelectVisible = this.grid.isMultiSelectVisible();
          this.showActionColumnLeft = this.grid.showActionColumn('left');
          this.showActionColumnRight = this.grid.showActionColumn('right');
        }
      }, {
        key: "getVisibleColumns",
        value: function getVisibleColumns(columns) {
          return (columns || []).filter(function (column) {
            return !column.hide;
          });
        }
      }]);

      return TheadTitlesRowComponent;
    }();

    TheadTitlesRowComponent.ɵfac = function TheadTitlesRowComponent_Factory(t) {
      return new (t || TheadTitlesRowComponent)();
    };

    TheadTitlesRowComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: TheadTitlesRowComponent,
      selectors: [["", "ng2-st-thead-titles-row", ""]],
      inputs: {
        grid: "grid",
        isAllSelected: "isAllSelected",
        source: "source"
      },
      outputs: {
        sort: "sort",
        selectAllRows: "selectAllRows"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      attrs: _c12,
      decls: 4,
      vars: 4,
      consts: [["ng2-st-checkbox-select-all", "", 3, "grid", "source", "isAllSelected", "click", 4, "ngIf"], ["ng2-st-actions-title", "", 3, "grid", 4, "ngIf"], [3, "class", "ngClass", "width", 4, "ngFor", "ngForOf"], ["ng2-st-checkbox-select-all", "", 3, "grid", "source", "isAllSelected", "click"], ["ng2-st-actions-title", "", 3, "grid"], [3, "ngClass"], [3, "source", "column", "sort"]],
      template: function TheadTitlesRowComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TheadTitlesRowComponent_th_0_Template, 1, 3, "th", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TheadTitlesRowComponent_th_1_Template, 1, 1, "th", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, TheadTitlesRowComponent_th_2_Template, 2, 8, "th", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, TheadTitlesRowComponent_th_3_Template, 1, 1, "th", 1);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isMultiSelectVisible);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showActionColumnLeft);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.getVisibleColumns(ctx.grid.getColumns()));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showActionColumnRight);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], CheckboxSelectAllComponent, ActionsTitleComponent, _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], ColumnTitleComponent],
      encapsulation: 2
    });
    TheadTitlesRowComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      isAllSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      sort: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      selectAllRows: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](TheadTitlesRowComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: '[ng2-st-thead-titles-row]',
          template: "\n    <th ng2-st-checkbox-select-all *ngIf=\"isMultiSelectVisible\"\n                                   [grid]=\"grid\"\n                                   [source]=\"source\"\n                                   [isAllSelected]=\"isAllSelected\"\n                                   (click)=\"selectAllRows.emit($event)\">\n    </th>\n    <th ng2-st-actions-title *ngIf=\"showActionColumnLeft\" [grid]=\"grid\"></th>\n    <th *ngFor=\"let column of getVisibleColumns(grid.getColumns())\"\n        class=\"ng2-smart-th {{ column.id }}\"\n        [ngClass]=\"column.class\"\n        [style.width]=\"column.width\">\n      <ng2-st-column-title [source]=\"source\" [column]=\"column\" (sort)=\"sort.emit($event)\"></ng2-st-column-title>\n    </th>\n    <th ng2-st-actions-title *ngIf=\"showActionColumnRight\" [grid]=\"grid\"></th>\n  "
        }]
      }], function () {
        return [];
      }, {
        sort: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        selectAllRows: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        grid: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        isAllSelected: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var THEAD_COMPONENTS = [ActionsComponent, ActionsTitleComponent, AddButtonComponent, CheckboxSelectAllComponent, ColumnTitleComponent, TitleComponent, TheadFitlersRowComponent, TheadFormRowComponent, TheadTitlesRowComponent, Ng2SmartTableTheadComponent];

    var THeadModule = function THeadModule() {
      _classCallCheck(this, THeadModule);
    };

    THeadModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: THeadModule
    });
    THeadModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function THeadModule_Factory(t) {
        return new (t || THeadModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], FilterModule, CellModule]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](THeadModule, {
        declarations: function declarations() {
          return [ActionsComponent, ActionsTitleComponent, AddButtonComponent, CheckboxSelectAllComponent, ColumnTitleComponent, TitleComponent, TheadFitlersRowComponent, TheadFormRowComponent, TheadTitlesRowComponent, Ng2SmartTableTheadComponent];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], FilterModule, CellModule];
        },
        exports: function exports() {
          return [ActionsComponent, ActionsTitleComponent, AddButtonComponent, CheckboxSelectAllComponent, ColumnTitleComponent, TitleComponent, TheadFitlersRowComponent, TheadFormRowComponent, TheadTitlesRowComponent, Ng2SmartTableTheadComponent];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](THeadModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], FilterModule, CellModule],
          declarations: [].concat(THEAD_COMPONENTS),
          exports: [].concat(THEAD_COMPONENTS)
        }]
      }], null, null);
    })();

    function compareValues(direction, a, b) {
      if (a < b) {
        return -1 * direction;
      }

      if (a > b) {
        return direction;
      }

      return 0;
    }

    var LocalSorter =
    /*#__PURE__*/
    function () {
      function LocalSorter() {
        _classCallCheck(this, LocalSorter);
      }

      _createClass(LocalSorter, null, [{
        key: "sort",
        value: function sort(data, field, direction, customCompare) {
          var dir = direction === 'asc' ? 1 : -1;
          var compare = customCompare ? customCompare : compareValues;
          return data.sort(function (a, b) {
            return compare.call(null, dir, a[field], b[field]);
          });
        }
      }]);

      return LocalSorter;
    }();

    function filterValues(value, search) {
      return value.toString().toLowerCase().includes(search.toString().toLowerCase());
    }

    var LocalFilter =
    /*#__PURE__*/
    function () {
      function LocalFilter() {
        _classCallCheck(this, LocalFilter);
      }

      _createClass(LocalFilter, null, [{
        key: "filter",
        value: function filter(data, field, search, customFilter) {
          var filter = customFilter ? customFilter : filterValues;
          return data.filter(function (el) {
            var value = typeof el[field] === 'undefined' || el[field] === null ? '' : el[field];
            return filter.call(null, value, search);
          });
        }
      }]);

      return LocalFilter;
    }();

    var LocalPager =
    /*#__PURE__*/
    function () {
      function LocalPager() {
        _classCallCheck(this, LocalPager);
      }

      _createClass(LocalPager, null, [{
        key: "paginate",
        value: function paginate(data, page, perPage) {
          return data.slice(perPage * (page - 1), perPage * page);
        }
      }]);

      return LocalPager;
    }();

    var LocalDataSource =
    /*#__PURE__*/
    function (_DataSource) {
      _inherits(LocalDataSource, _DataSource);

      var _super19 = _createSuper(LocalDataSource);

      function LocalDataSource() {
        var _this48;

        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        _classCallCheck(this, LocalDataSource);

        _this48 = _super19.call(this);
        _this48.data = [];
        _this48.filteredAndSorted = [];
        _this48.sortConf = [];
        _this48.filterConf = {
          filters: [],
          andOperator: true
        };
        _this48.pagingConf = {};
        _this48.data = data;
        return _this48;
      }

      _createClass(LocalDataSource, [{
        key: "load",
        value: function load(data) {
          this.data = data;
          return _get(_getPrototypeOf(LocalDataSource.prototype), "load", this).call(this, data);
        }
      }, {
        key: "prepend",
        value: function prepend(element) {
          this.reset(true);
          this.data.unshift(element);
          return _get(_getPrototypeOf(LocalDataSource.prototype), "prepend", this).call(this, element);
        }
      }, {
        key: "append",
        value: function append(element) {
          this.reset(true);
          this.data.push(element);
          return _get(_getPrototypeOf(LocalDataSource.prototype), "append", this).call(this, element);
        }
      }, {
        key: "add",
        value: function add(element) {
          this.data.push(element);
          return _get(_getPrototypeOf(LocalDataSource.prototype), "add", this).call(this, element);
        }
      }, {
        key: "remove",
        value: function remove(element) {
          this.data = this.data.filter(function (el) {
            return el !== element;
          });
          return _get(_getPrototypeOf(LocalDataSource.prototype), "remove", this).call(this, element);
        }
      }, {
        key: "update",
        value: function update(element, values) {
          var _this49 = this;

          return new Promise(function (resolve, reject) {
            _this49.find(element).then(function (found) {
              found = deepExtend(found, values);

              _get(_getPrototypeOf(LocalDataSource.prototype), "update", _this49).call(_this49, found, values).then(resolve)["catch"](reject);
            })["catch"](reject);
          });
        }
      }, {
        key: "find",
        value: function find(element) {
          var found = this.data.find(function (el) {
            return el === element;
          });

          if (found) {
            return Promise.resolve(found);
          }

          return Promise.reject(new Error('Element was not found in the dataset'));
        }
      }, {
        key: "getElements",
        value: function getElements() {
          var data = this.data.slice(0);
          return Promise.resolve(this.prepareData(data));
        }
      }, {
        key: "getFilteredAndSorted",
        value: function getFilteredAndSorted() {
          var data = this.data.slice(0);
          this.prepareData(data);
          return Promise.resolve(this.filteredAndSorted);
        }
      }, {
        key: "getAll",
        value: function getAll() {
          var data = this.data.slice(0);
          return Promise.resolve(data);
        }
      }, {
        key: "reset",
        value: function reset() {
          var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (silent) {
            this.filterConf = {
              filters: [],
              andOperator: true
            };
            this.sortConf = [];
            this.pagingConf['page'] = 1;
          } else {
            this.setFilter([], true, false);
            this.setSort([], false);
            this.setPage(1);
          }
        }
      }, {
        key: "empty",
        value: function empty() {
          this.data = [];
          return _get(_getPrototypeOf(LocalDataSource.prototype), "empty", this).call(this);
        }
      }, {
        key: "count",
        value: function count() {
          return this.filteredAndSorted.length;
        }
        /**
         *
         * Array of conf objects
         * [
         *  {field: string, direction: asc|desc|null, compare: Function|null},
         * ]
         * @param conf
         * @param doEmit
         * @returns {LocalDataSource}
         */

      }, {
        key: "setSort",
        value: function setSort(conf) {
          var doEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (conf !== null) {
            conf.forEach(function (fieldConf) {
              if (!fieldConf['field'] || typeof fieldConf['direction'] === 'undefined') {
                throw new Error('Sort configuration object is not valid');
              }
            });
            this.sortConf = conf;
          }

          _get(_getPrototypeOf(LocalDataSource.prototype), "setSort", this).call(this, conf, doEmit);

          return this;
        }
        /**
         *
         * Array of conf objects
         * [
         *  {field: string, search: string, filter: Function|null},
         * ]
         * @param conf
         * @param andOperator
         * @param doEmit
         * @returns {LocalDataSource}
         */

      }, {
        key: "setFilter",
        value: function setFilter(conf) {
          var _this50 = this;

          var andOperator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var doEmit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          if (conf && conf.length > 0) {
            conf.forEach(function (fieldConf) {
              _this50.addFilter(fieldConf, andOperator, false);
            });
          } else {
            this.filterConf = {
              filters: [],
              andOperator: true
            };
          }

          this.filterConf.andOperator = andOperator;
          this.pagingConf['page'] = 1;

          _get(_getPrototypeOf(LocalDataSource.prototype), "setFilter", this).call(this, conf, andOperator, doEmit);

          return this;
        }
      }, {
        key: "addFilter",
        value: function addFilter(fieldConf) {
          var _this51 = this;

          var andOperator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var doEmit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          if (!fieldConf['field'] || typeof fieldConf['search'] === 'undefined') {
            throw new Error('Filter configuration object is not valid');
          }

          var found = false;
          this.filterConf.filters.forEach(function (currentFieldConf, index) {
            if (currentFieldConf['field'] === fieldConf['field']) {
              _this51.filterConf.filters[index] = fieldConf;
              found = true;
            }
          });

          if (!found) {
            this.filterConf.filters.push(fieldConf);
          }

          this.filterConf.andOperator = andOperator;

          _get(_getPrototypeOf(LocalDataSource.prototype), "addFilter", this).call(this, fieldConf, andOperator, doEmit);

          return this;
        }
      }, {
        key: "setPaging",
        value: function setPaging(page, perPage) {
          var doEmit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          this.pagingConf['page'] = page;
          this.pagingConf['perPage'] = perPage;

          _get(_getPrototypeOf(LocalDataSource.prototype), "setPaging", this).call(this, page, perPage, doEmit);

          return this;
        }
      }, {
        key: "setPage",
        value: function setPage(page) {
          var doEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          this.pagingConf['page'] = page;

          _get(_getPrototypeOf(LocalDataSource.prototype), "setPage", this).call(this, page, doEmit);

          return this;
        }
      }, {
        key: "getSort",
        value: function getSort() {
          return this.sortConf;
        }
      }, {
        key: "getFilter",
        value: function getFilter() {
          return this.filterConf;
        }
      }, {
        key: "getPaging",
        value: function getPaging() {
          return this.pagingConf;
        }
      }, {
        key: "prepareData",
        value: function prepareData(data) {
          data = this.filter(data);
          data = this.sort(data);
          this.filteredAndSorted = data.slice(0);
          return this.paginate(data);
        }
      }, {
        key: "sort",
        value: function sort(data) {
          if (this.sortConf) {
            this.sortConf.forEach(function (fieldConf) {
              data = LocalSorter.sort(data, fieldConf['field'], fieldConf['direction'], fieldConf['compare']);
            });
          }

          return data;
        } // TODO: refactor?

      }, {
        key: "filter",
        value: function filter(data) {
          if (this.filterConf.filters) {
            if (this.filterConf.andOperator) {
              this.filterConf.filters.forEach(function (fieldConf) {
                if (fieldConf['search'].length > 0) {
                  data = LocalFilter.filter(data, fieldConf['field'], fieldConf['search'], fieldConf['filter']);
                }
              });
            } else {
              var mergedData = [];
              this.filterConf.filters.forEach(function (fieldConf) {
                if (fieldConf['search'].length > 0) {
                  mergedData = mergedData.concat(LocalFilter.filter(data, fieldConf['field'], fieldConf['search'], fieldConf['filter']));
                }
              }); // remove non unique items

              data = mergedData.filter(function (elem, pos, arr) {
                return arr.indexOf(elem) === pos;
              });
            }
          }

          return data;
        }
      }, {
        key: "paginate",
        value: function paginate(data) {
          if (this.pagingConf && this.pagingConf['page'] && this.pagingConf['perPage']) {
            data = LocalPager.paginate(data, this.pagingConf['page'], this.pagingConf['perPage']);
          }

          return data;
        }
      }]);

      return LocalDataSource;
    }(DataSource);

    var Ng2SmartTableComponent =
    /*#__PURE__*/
    function () {
      function Ng2SmartTableComponent() {
        _classCallCheck(this, Ng2SmartTableComponent);

        this.settings = {};
        this.rowSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.rowDeselect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.userRowSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this["delete"] = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.edit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.create = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.custom = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.deleteConfirm = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.editConfirm = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.createConfirm = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.rowHover = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.defaultSettings = {
          mode: 'inline',
          selectMode: 'single',

          /**
           * Points to an element in all data
           *
           * when < 0 all lines must be deselected
           */
          selectedRowIndex: 0,
          switchPageToSelectedRowPage: false,
          hideHeader: false,
          hideSubHeader: false,
          actions: {
            columnTitle: 'Actions',
            add: true,
            edit: true,
            "delete": true,
            custom: [],
            position: 'left'
          },
          filter: {
            inputClass: ''
          },
          edit: {
            inputClass: '',
            editButtonContent: 'Edit',
            saveButtonContent: 'Update',
            cancelButtonContent: 'Cancel',
            confirmSave: false
          },
          add: {
            inputClass: '',
            addButtonContent: 'Add New',
            createButtonContent: 'Create',
            cancelButtonContent: 'Cancel',
            confirmCreate: false
          },
          "delete": {
            deleteButtonContent: 'Delete',
            confirmDelete: false
          },
          attr: {
            id: '',
            "class": ''
          },
          noDataMessage: 'No data found',
          columns: {},
          pager: {
            display: true,
            page: 1,
            perPage: 10
          },
          rowClassFunction: function rowClassFunction() {
            return '';
          }
        };
        this.isAllSelected = false;
        this.destroyed$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
      }

      _createClass(Ng2SmartTableComponent, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (this.grid) {
            if (changes['settings']) {
              this.grid.setSettings(this.prepareSettings());
            }

            if (changes['source']) {
              this.source = this.prepareSource();
              this.grid.setSource(this.source);
            }
          } else {
            this.initGrid();
          }

          this.tableId = this.grid.getSetting('attr.id');
          this.tableClass = this.grid.getSetting('attr.class');
          this.isHideHeader = this.grid.getSetting('hideHeader');
          this.isHideSubHeader = this.grid.getSetting('hideSubHeader');
          this.isPagerDisplay = this.grid.getSetting('pager.display');
          this.isPagerDisplay = this.grid.getSetting('pager.display');
          this.perPageSelect = this.grid.getSetting('pager.perPageSelect');
          this.rowClassFunction = this.grid.getSetting('rowClassFunction');
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroyed$.next();
        }
      }, {
        key: "selectRow",
        value: function selectRow(index) {
          var switchPageToSelectedRowPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.grid.getSetting('switchPageToSelectedRowPage');

          if (!this.grid) {
            return;
          }

          this.grid.settings.selectedRowIndex = index;

          if (this.isIndexOutOfRange(index)) {
            // we need to deselect all rows if we got an incorrect index
            this.deselectAllRows();
            return;
          }

          if (switchPageToSelectedRowPage) {
            var source = this.source;
            var paging = source.getPaging();
            var page = getPageForRowIndex(index, paging.perPage);
            index = index % paging.perPage;
            this.grid.settings.selectedRowIndex = index;

            if (page !== paging.page) {
              source.setPage(page);
              return;
            }
          }

          var row = this.grid.getRows()[index];

          if (row) {
            this.onSelectRow(row);
          } else {
            // we need to deselect all rows if we got an incorrect index
            this.deselectAllRows();
          }
        }
      }, {
        key: "deselectAllRows",
        value: function deselectAllRows() {
          this.grid.dataSet.deselectAll();
          this.emitDeselectRow(null);
        }
      }, {
        key: "editRowSelect",
        value: function editRowSelect(row) {
          if (this.grid.getSetting('selectMode') === 'multi') {
            this.onMultipleSelectRow(row);
          } else {
            this.onSelectRow(row);
          }
        }
      }, {
        key: "onUserSelectRow",
        value: function onUserSelectRow(row) {
          if (this.grid.getSetting('selectMode') !== 'multi') {
            this.grid.selectRow(row);
            this.emitUserSelectRow(row);
            this.emitSelectRow(row);
          }
        }
      }, {
        key: "onRowHover",
        value: function onRowHover(row) {
          this.rowHover.emit(row);
        }
      }, {
        key: "multipleSelectRow",
        value: function multipleSelectRow(row) {
          this.grid.multipleSelectRow(row);
          this.emitUserSelectRow(row);
          this.emitSelectRow(row);
        }
      }, {
        key: "onSelectAllRows",
        value: function onSelectAllRows($event) {
          this.isAllSelected = !this.isAllSelected;
          this.grid.selectAllRows(this.isAllSelected);
          this.emitUserSelectRow(null);
          this.emitSelectRow(null);
        }
      }, {
        key: "onSelectRow",
        value: function onSelectRow(row) {
          this.grid.selectRow(row);
          this.emitSelectRow(row);
        }
      }, {
        key: "onMultipleSelectRow",
        value: function onMultipleSelectRow(row) {
          this.emitSelectRow(row);
        }
      }, {
        key: "initGrid",
        value: function initGrid() {
          this.source = this.prepareSource();
          this.grid = new Grid(this.source, this.prepareSettings());
          this.subscribeToOnSelectRow();
          this.subscribeToOnDeselectRow();
        }
      }, {
        key: "prepareSource",
        value: function prepareSource() {
          if (this.source instanceof DataSource) {
            return this.source;
          } else if (this.source instanceof Array) {
            return new LocalDataSource(this.source);
          }

          return new LocalDataSource();
        }
      }, {
        key: "prepareSettings",
        value: function prepareSettings() {
          return deepExtend({}, this.defaultSettings, this.settings);
        }
      }, {
        key: "changePage",
        value: function changePage($event) {
          this.resetAllSelector();
        }
      }, {
        key: "sort",
        value: function sort($event) {
          this.resetAllSelector();
        }
      }, {
        key: "filter",
        value: function filter($event) {
          this.resetAllSelector();
        }
      }, {
        key: "resetAllSelector",
        value: function resetAllSelector() {
          this.isAllSelected = false;
        }
      }, {
        key: "emitUserSelectRow",
        value: function emitUserSelectRow(row) {
          var selectedRows = this.grid.getSelectedRows();
          this.userRowSelect.emit({
            data: row ? row.getData() : null,
            isSelected: row ? row.getIsSelected() : null,
            source: this.source,
            selected: selectedRows && selectedRows.length ? selectedRows.map(function (r) {
              return r.getData();
            }) : []
          });
        }
      }, {
        key: "emitSelectRow",
        value: function emitSelectRow(row) {
          var data = {
            data: row ? row.getData() : null,
            isSelected: row ? row.getIsSelected() : null,
            source: this.source
          };
          this.rowSelect.emit(data);

          if (!(row === null || row === void 0 ? void 0 : row.isSelected)) {
            this.rowDeselect.emit(data);
          }
        }
      }, {
        key: "emitDeselectRow",
        value: function emitDeselectRow(row) {
          this.rowDeselect.emit({
            data: row ? row.getData() : null,
            isSelected: row ? row.getIsSelected() : null,
            source: this.source
          });
        }
      }, {
        key: "isIndexOutOfRange",
        value: function isIndexOutOfRange(index) {
          var _a;

          var dataAmount = (_a = this.source) === null || _a === void 0 ? void 0 : _a.count();
          return index < 0 || typeof dataAmount === 'number' && index >= dataAmount;
        }
      }, {
        key: "subscribeToOnSelectRow",
        value: function subscribeToOnSelectRow() {
          var _this52 = this;

          if (this.onSelectRowSubscription) {
            this.onSelectRowSubscription.unsubscribe();
          }

          this.onSelectRowSubscription = this.grid.onSelectRow().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this.destroyed$)).subscribe(function (row) {
            _this52.emitSelectRow(row);
          });
        }
      }, {
        key: "subscribeToOnDeselectRow",
        value: function subscribeToOnDeselectRow() {
          var _this53 = this;

          if (this.onDeselectRowSubscription) {
            this.onDeselectRowSubscription.unsubscribe();
          }

          this.onDeselectRowSubscription = this.grid.onDeselectRow().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this.destroyed$)).subscribe(function (row) {
            _this53.emitDeselectRow(row);
          });
        }
      }]);

      return Ng2SmartTableComponent;
    }();

    Ng2SmartTableComponent.ɵfac = function Ng2SmartTableComponent_Factory(t) {
      return new (t || Ng2SmartTableComponent)();
    };

    Ng2SmartTableComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
      type: Ng2SmartTableComponent,
      selectors: [["ng2-smart-table"]],
      inputs: {
        settings: "settings",
        source: "source"
      },
      outputs: {
        rowSelect: "rowSelect",
        rowDeselect: "rowDeselect",
        userRowSelect: "userRowSelect",
        "delete": "delete",
        edit: "edit",
        create: "create",
        custom: "custom",
        deleteConfirm: "deleteConfirm",
        editConfirm: "editConfirm",
        createConfirm: "createConfirm",
        rowHover: "rowHover"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
      decls: 4,
      vars: 9,
      consts: [[3, "id", "ngClass"], ["ng2-st-thead", "", 3, "grid", "isAllSelected", "source", "createConfirm", "create", "selectAllRows", "sort", "filter", 4, "ngIf"], ["ng2-st-tbody", "", 3, "grid", "source", "deleteConfirm", "editConfirm", "rowClassFunction", "edit", "delete", "custom", "userSelectRow", "editRowSelect", "multipleSelectRow", "rowHover"], [3, "source", "perPageSelect", "changePage", 4, "ngIf"], ["ng2-st-thead", "", 3, "grid", "isAllSelected", "source", "createConfirm", "create", "selectAllRows", "sort", "filter"], [3, "source", "perPageSelect", "changePage"]],
      template: function Ng2SmartTableComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "table", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, Ng2SmartTableComponent_thead_1_Template, 1, 4, "thead", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "tbody", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("edit", function Ng2SmartTableComponent_Template_tbody_edit_2_listener($event) {
            return ctx.edit.emit($event);
          })("delete", function Ng2SmartTableComponent_Template_tbody_delete_2_listener($event) {
            return ctx["delete"].emit($event);
          })("custom", function Ng2SmartTableComponent_Template_tbody_custom_2_listener($event) {
            return ctx.custom.emit($event);
          })("userSelectRow", function Ng2SmartTableComponent_Template_tbody_userSelectRow_2_listener($event) {
            return ctx.onUserSelectRow($event);
          })("editRowSelect", function Ng2SmartTableComponent_Template_tbody_editRowSelect_2_listener($event) {
            return ctx.editRowSelect($event);
          })("multipleSelectRow", function Ng2SmartTableComponent_Template_tbody_multipleSelectRow_2_listener($event) {
            return ctx.multipleSelectRow($event);
          })("rowHover", function Ng2SmartTableComponent_Template_tbody_rowHover_2_listener($event) {
            return ctx.onRowHover($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, Ng2SmartTableComponent_ng2_smart_table_pager_3_Template, 1, 2, "ng2-smart-table-pager", 3);
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx.tableId)("ngClass", ctx.tableClass);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.isHideHeader || !ctx.isHideSubHeader);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("grid", ctx.grid)("source", ctx.source)("deleteConfirm", ctx.deleteConfirm)("editConfirm", ctx.editConfirm)("rowClassFunction", ctx.rowClassFunction);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isPagerDisplay);
        }
      },
      directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], Ng2SmartTableTbodyComponent, Ng2SmartTableTheadComponent, PagerComponent],
      styles: ["[_nghost-%COMP%]{font-size:1rem}[_nghost-%COMP%]     *{box-sizing:border-box}[_nghost-%COMP%]     button, [_nghost-%COMP%]     input, [_nghost-%COMP%]     optgroup, [_nghost-%COMP%]     select, [_nghost-%COMP%]     textarea{color:inherit;font:inherit;margin:0}[_nghost-%COMP%]     table{border-collapse:collapse;border-spacing:0;display:table;line-height:1.5em;max-width:100%;overflow:auto;width:100%;word-break:normal;word-break:keep-all}[_nghost-%COMP%]     table tr th{font-weight:700}[_nghost-%COMP%]     table tr section{font-size:.75em;font-weight:700}[_nghost-%COMP%]     table tr td, [_nghost-%COMP%]     table tr th{font-size:.875em;margin:0;padding:.5em 1em}[_nghost-%COMP%]     a{color:#1e6bb8;text-decoration:none}[_nghost-%COMP%]     a:hover{text-decoration:underline}"]
    });
    Ng2SmartTableComponent.propDecorators = {
      source: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      settings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      rowSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      rowDeselect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      userRowSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      "delete": [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      edit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      create: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      custom: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      deleteConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      editConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      createConfirm: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      rowHover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](Ng2SmartTableComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
          selector: 'ng2-smart-table',
          template: "<table [id]=\"tableId\" [ngClass]=\"tableClass\">\n\n  <thead ng2-st-thead *ngIf=\"!isHideHeader || !isHideSubHeader\"\n                      [grid]=\"grid\"\n                      [isAllSelected]=\"isAllSelected\"\n                      [source]=\"source\"\n                      [createConfirm]=\"createConfirm\"\n                      (create)=\"create.emit($event)\"\n                      (selectAllRows)=\"onSelectAllRows($event)\"\n                      (sort)=\"sort($event)\"\n                      (filter)=\"filter($event)\">\n  </thead>\n\n  <tbody ng2-st-tbody [grid]=\"grid\"\n                      [source]=\"source\"\n                      [deleteConfirm]=\"deleteConfirm\"\n                      [editConfirm]=\"editConfirm\"\n                      [rowClassFunction]=\"rowClassFunction\"\n                      (edit)=\"edit.emit($event)\"\n                      (delete)=\"delete.emit($event)\"\n                      (custom)=\"custom.emit($event)\"\n                      (userSelectRow)=\"onUserSelectRow($event)\"\n                      (editRowSelect)=\"editRowSelect($event)\"\n                      (multipleSelectRow)=\"multipleSelectRow($event)\"\n                      (rowHover)=\"onRowHover($event)\">\n  </tbody>\n\n</table>\n\n<ng2-smart-table-pager *ngIf=\"isPagerDisplay\"\n                        [source]=\"source\"\n                        [perPageSelect]=\"perPageSelect\"\n                        (changePage)=\"changePage($event)\">\n</ng2-smart-table-pager>\n",
          styles: [":host{font-size:1rem}:host ::ng-deep *{box-sizing:border-box}:host ::ng-deep button,:host ::ng-deep input,:host ::ng-deep optgroup,:host ::ng-deep select,:host ::ng-deep textarea{color:inherit;font:inherit;margin:0}:host ::ng-deep table{border-collapse:collapse;border-spacing:0;display:table;line-height:1.5em;max-width:100%;overflow:auto;width:100%;word-break:normal;word-break:keep-all}:host ::ng-deep table tr th{font-weight:700}:host ::ng-deep table tr section{font-size:.75em;font-weight:700}:host ::ng-deep table tr td,:host ::ng-deep table tr th{font-size:.875em;margin:0;padding:.5em 1em}:host ::ng-deep a{color:#1e6bb8;text-decoration:none}:host ::ng-deep a:hover{text-decoration:underline}"]
        }]
      }], function () {
        return [];
      }, {
        settings: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        rowSelect: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        rowDeselect: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        userRowSelect: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        "delete": [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        edit: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        create: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        custom: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        deleteConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        editConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        createConfirm: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        rowHover: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        source: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }]
      });
    })();

    var Ng2SmartTableModule = function Ng2SmartTableModule() {
      _classCallCheck(this, Ng2SmartTableModule);
    };

    Ng2SmartTableModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
      type: Ng2SmartTableModule
    });
    Ng2SmartTableModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
      factory: function Ng2SmartTableModule_Factory(t) {
        return new (t || Ng2SmartTableModule)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], CellModule, FilterModule, PagerModule, TBodyModule, THeadModule]]
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](Ng2SmartTableModule, {
        declarations: function declarations() {
          return [Ng2SmartTableComponent];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], CellModule, FilterModule, PagerModule, TBodyModule, THeadModule];
        },
        exports: function exports() {
          return [Ng2SmartTableComponent];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](Ng2SmartTableModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], CellModule, FilterModule, PagerModule, TBodyModule, THeadModule],
          declarations: [Ng2SmartTableComponent],
          exports: [Ng2SmartTableComponent]
        }]
      }], null, null);
    })();

    var ServerSourceConf = function ServerSourceConf() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$endPoint = _ref.endPoint,
          endPoint = _ref$endPoint === void 0 ? '' : _ref$endPoint,
          _ref$sortFieldKey = _ref.sortFieldKey,
          sortFieldKey = _ref$sortFieldKey === void 0 ? '' : _ref$sortFieldKey,
          _ref$sortDirKey = _ref.sortDirKey,
          sortDirKey = _ref$sortDirKey === void 0 ? '' : _ref$sortDirKey,
          _ref$pagerPageKey = _ref.pagerPageKey,
          pagerPageKey = _ref$pagerPageKey === void 0 ? '' : _ref$pagerPageKey,
          _ref$pagerLimitKey = _ref.pagerLimitKey,
          pagerLimitKey = _ref$pagerLimitKey === void 0 ? '' : _ref$pagerLimitKey,
          _ref$filterFieldKey = _ref.filterFieldKey,
          filterFieldKey = _ref$filterFieldKey === void 0 ? '' : _ref$filterFieldKey,
          _ref$totalKey = _ref.totalKey,
          totalKey = _ref$totalKey === void 0 ? '' : _ref$totalKey,
          _ref$dataKey = _ref.dataKey,
          dataKey = _ref$dataKey === void 0 ? '' : _ref$dataKey;

      _classCallCheck(this, ServerSourceConf);

      this.endPoint = endPoint ? endPoint : '';
      this.sortFieldKey = sortFieldKey ? sortFieldKey : ServerSourceConf.SORT_FIELD_KEY;
      this.sortDirKey = sortDirKey ? sortDirKey : ServerSourceConf.SORT_DIR_KEY;
      this.pagerPageKey = pagerPageKey ? pagerPageKey : ServerSourceConf.PAGER_PAGE_KEY;
      this.pagerLimitKey = pagerLimitKey ? pagerLimitKey : ServerSourceConf.PAGER_LIMIT_KEY;
      this.filterFieldKey = filterFieldKey ? filterFieldKey : ServerSourceConf.FILTER_FIELD_KEY;
      this.totalKey = totalKey ? totalKey : ServerSourceConf.TOTAL_KEY;
      this.dataKey = dataKey ? dataKey : ServerSourceConf.DATA_KEY;
    };

    ServerSourceConf.SORT_FIELD_KEY = '_sort';
    ServerSourceConf.SORT_DIR_KEY = '_order';
    ServerSourceConf.PAGER_PAGE_KEY = '_page';
    ServerSourceConf.PAGER_LIMIT_KEY = '_limit';
    ServerSourceConf.FILTER_FIELD_KEY = '#field#_like';
    ServerSourceConf.TOTAL_KEY = 'x-total-count';
    ServerSourceConf.DATA_KEY = '';

    var ServerDataSource =
    /*#__PURE__*/
    function (_LocalDataSource) {
      _inherits(ServerDataSource, _LocalDataSource);

      var _super20 = _createSuper(ServerDataSource);

      function ServerDataSource(http) {
        var _this54;

        var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, ServerDataSource);

        _this54 = _super20.call(this);
        _this54.http = http;
        _this54.lastRequestCount = 0;
        _this54.conf = new ServerSourceConf(conf);

        if (!_this54.conf.endPoint) {
          throw new Error('At least endPoint must be specified as a configuration of the server data source.');
        }

        return _this54;
      }

      _createClass(ServerDataSource, [{
        key: "count",
        value: function count() {
          return this.lastRequestCount;
        }
      }, {
        key: "getElements",
        value: function getElements() {
          var _this55 = this;

          return this.requestElements().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(function (res) {
            _this55.lastRequestCount = _this55.extractTotalFromResponse(res);
            _this55.data = _this55.extractDataFromResponse(res);
            return _this55.data;
          })).toPromise();
        }
        /**
         * Extracts array of data from server response
         * @param res
         * @returns {any}
         */

      }, {
        key: "extractDataFromResponse",
        value: function extractDataFromResponse(res) {
          var rawData = res.body;
          var data = !!this.conf.dataKey ? getDeepFromObject(rawData, this.conf.dataKey, []) : rawData;

          if (data instanceof Array) {
            return data;
          }

          throw new Error("Data must be an array.\n    Please check that data extracted from the server response by the key '".concat(this.conf.dataKey, "' exists and is array."));
        }
        /**
         * Extracts total rows count from the server response
         * Looks for the count in the heders first, then in the response body
         * @param res
         * @returns {any}
         */

      }, {
        key: "extractTotalFromResponse",
        value: function extractTotalFromResponse(res) {
          if (res.headers.has(this.conf.totalKey)) {
            return +res.headers.get(this.conf.totalKey);
          } else {
            var rawData = res.body;
            return getDeepFromObject(rawData, this.conf.totalKey, 0);
          }
        }
      }, {
        key: "requestElements",
        value: function requestElements() {
          var httpParams = this.createRequesParams();
          return this.http.get(this.conf.endPoint, {
            params: httpParams,
            observe: 'response'
          });
        }
      }, {
        key: "createRequesParams",
        value: function createRequesParams() {
          var httpParams = new _angular_common_http__WEBPACK_IMPORTED_MODULE_7__["HttpParams"]();
          httpParams = this.addSortRequestParams(httpParams);
          httpParams = this.addFilterRequestParams(httpParams);
          return this.addPagerRequestParams(httpParams);
        }
      }, {
        key: "addSortRequestParams",
        value: function addSortRequestParams(httpParams) {
          var _this56 = this;

          if (this.sortConf) {
            this.sortConf.forEach(function (fieldConf) {
              httpParams = httpParams.set(_this56.conf.sortFieldKey, fieldConf.field);
              httpParams = httpParams.set(_this56.conf.sortDirKey, fieldConf.direction.toUpperCase());
            });
          }

          return httpParams;
        }
      }, {
        key: "addFilterRequestParams",
        value: function addFilterRequestParams(httpParams) {
          var _this57 = this;

          if (this.filterConf.filters) {
            this.filterConf.filters.forEach(function (fieldConf) {
              if (fieldConf['search']) {
                httpParams = httpParams.set(_this57.conf.filterFieldKey.replace('#field#', fieldConf['field']), fieldConf['search']);
              }
            });
          }

          return httpParams;
        }
      }, {
        key: "addPagerRequestParams",
        value: function addPagerRequestParams(httpParams) {
          if (this.pagingConf && this.pagingConf['page'] && this.pagingConf['perPage']) {
            httpParams = httpParams.set(this.conf.pagerPageKey, this.pagingConf['page']);
            httpParams = httpParams.set(this.conf.pagerLimitKey, this.pagingConf['perPage']);
          }

          return httpParams;
        }
      }]);

      return ServerDataSource;
    }(LocalDataSource);
    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=ng2-smart-table.js.map

    /***/

  },

  /***/
  "./node_modules/punycode/punycode.js":
  /*!*******************************************!*\
    !*** ./node_modules/punycode/punycode.js ***!
    \*******************************************/

  /*! no static exports found */

  /***/
  function node_modulesPunycodePunycodeJs(module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */
    (function (module) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*! https://mths.be/punycode v1.3.2 by @mathias */


      ;

      (function (root) {
        /** Detect free variables */
        var freeExports = true && exports && !exports.nodeType && exports;
        var freeModule = true && module && !module.nodeType && module;
        var freeGlobal = typeof global == 'object' && global;

        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }
        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */


        var punycode,

        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647,
            // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            // 0x80
        delimiter = '-',
            // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            // RFC 3490 separators

        /** Error messages */
        errors = {
          'overflow': 'Overflow: input needs wider integers to process',
          'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
          'invalid-input': 'Invalid input'
        },

        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,

        /** Temporary variable */
        key;
        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */

        function error(type) {
          throw RangeError(errors[type]);
        }
        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */


        function map(array, fn) {
          var length = array.length;
          var result = [];

          while (length--) {
            result[length] = fn(array[length]);
          }

          return result;
        }
        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */


        function mapDomain(string, fn) {
          var parts = string.split('@');
          var result = '';

          if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
          } // Avoid `split(regex)` for IE8 compatibility. See #17.


          string = string.replace(regexSeparators, '\x2E');
          var labels = string.split('.');
          var encoded = map(labels, fn).join('.');
          return result + encoded;
        }
        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */


        function ucs2decode(string) {
          var output = [],
              counter = 0,
              length = string.length,
              value,
              extra;

          while (counter < length) {
            value = string.charCodeAt(counter++);

            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
              // high surrogate, and there is a next character
              extra = string.charCodeAt(counter++);

              if ((extra & 0xFC00) == 0xDC00) {
                // low surrogate
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
              } else {
                // unmatched surrogate; only append this code unit, in case the next
                // code unit is the high surrogate of a surrogate pair
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }

          return output;
        }
        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */


        function ucs2encode(array) {
          return map(array, function (value) {
            var output = '';

            if (value > 0xFFFF) {
              value -= 0x10000;
              output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
              value = 0xDC00 | value & 0x3FF;
            }

            output += stringFromCharCode(value);
            return output;
          }).join('');
        }
        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */


        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }

          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }

          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }

          return base;
        }
        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */


        function digitToBasic(digit, flag) {
          //  0..25 map to ASCII a..z or A..Z
          // 26..35 map to ASCII 0..9
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * http://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */


        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);

          for (;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }

          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */


        function decode(input) {
          // Don't use UCS-2
          var output = [],
              inputLength = input.length,
              out,
              i = 0,
              n = initialN,
              bias = initialBias,
              basic,
              j,
              index,
              oldi,
              w,
              k,
              digit,
              t,

          /** Cached calculation results */
          baseMinusT; // Handle the basic code points: let `basic` be the number of input code
          // points before the last delimiter, or `0` if there is none, then copy
          // the first basic code points to the output.

          basic = input.lastIndexOf(delimiter);

          if (basic < 0) {
            basic = 0;
          }

          for (j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
              error('not-basic');
            }

            output.push(input.charCodeAt(j));
          } // Main decoding loop: start just after the last delimiter if any basic code
          // points were copied; start at the beginning otherwise.


          for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)
          /* no final expression */
          {
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for (oldi = i, w = 1, k = base;;
            /* no condition */
            k += base) {
              if (index >= inputLength) {
                error('invalid-input');
              }

              digit = basicToDigit(input.charCodeAt(index++));

              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error('overflow');
              }

              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (digit < t) {
                break;
              }

              baseMinusT = base - t;

              if (w > floor(maxInt / baseMinusT)) {
                error('overflow');
              }

              w *= baseMinusT;
            }

            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:

            if (floor(i / out) > maxInt - n) {
              error('overflow');
            }

            n += floor(i / out);
            i %= out; // Insert `n` at position `i` of the output

            output.splice(i++, 0, n);
          }

          return ucs2encode(output);
        }
        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */


        function encode(input) {
          var n,
              delta,
              handledCPCount,
              basicLength,
              bias,
              j,
              m,
              q,
              k,
              t,
              currentValue,
              output = [],

          /** `inputLength` will hold the number of code points in `input`. */
          inputLength,

          /** Cached calculation results */
          handledCPCountPlusOne,
              baseMinusT,
              qMinusT; // Convert the input in UCS-2 to Unicode

          input = ucs2decode(input); // Cache the length

          inputLength = input.length; // Initialize the state

          n = initialN;
          delta = 0;
          bias = initialBias; // Handle the basic code points

          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];

            if (currentValue < 0x80) {
              output.push(stringFromCharCode(currentValue));
            }
          }

          handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
          // `basicLength` is the number of basic code points.
          // Finish the basic string - if it is not empty - with a delimiter

          if (basicLength) {
            output.push(delimiter);
          } // Main encoding loop:


          while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];

              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow


            handledCPCountPlusOne = handledCPCount + 1;

            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error('overflow');
            }

            delta += (m - n) * handledCPCountPlusOne;
            n = m;

            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];

              if (currentValue < n && ++delta > maxInt) {
                error('overflow');
              }

              if (currentValue == n) {
                // Represent delta as a generalized variable-length integer
                for (q = delta, k = base;;
                /* no condition */
                k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                  if (q < t) {
                    break;
                  }

                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }

                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }

            ++delta;
            ++n;
          }

          return output.join('');
        }
        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */


        function toUnicode(input) {
          return mapDomain(input, function (string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */


        function toASCII(input) {
          return mapDomain(input, function (string) {
            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
          });
        }
        /*--------------------------------------------------------------------------*/

        /** Define the public API */


        punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          'version': '1.3.2',

          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          'ucs2': {
            'decode': ucs2decode,
            'encode': ucs2encode
          },
          'decode': decode,
          'encode': encode,
          'toASCII': toASCII,
          'toUnicode': toUnicode
        };
        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:

        if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return punycode;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
      })(this);
      /* WEBPACK VAR INJECTION */

    }).call(this, __webpack_require__(
    /*! ./../webpack/buildin/module.js */
    "./node_modules/webpack/buildin/module.js")(module));
    /***/
  },

  /***/
  "./node_modules/querystring/decode.js":
  /*!********************************************!*\
    !*** ./node_modules/querystring/decode.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesQuerystringDecodeJs(module, exports, __webpack_require__) {
    "use strict"; // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    module.exports = function (qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }

      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1000;

      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }

      var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }

      return obj;
    };
    /***/

  },

  /***/
  "./node_modules/querystring/encode.js":
  /*!********************************************!*\
    !*** ./node_modules/querystring/encode.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesQuerystringEncodeJs(module, exports, __webpack_require__) {
    "use strict"; // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    var stringifyPrimitive = function stringifyPrimitive(v) {
      switch (typeof v) {
        case 'string':
          return v;

        case 'boolean':
          return v ? 'true' : 'false';

        case 'number':
          return isFinite(v) ? v : '';

        default:
          return '';
      }
    };

    module.exports = function (obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';

      if (obj === null) {
        obj = undefined;
      }

      if (typeof obj === 'object') {
        return Object.keys(obj).map(function (k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

          if (Array.isArray(obj[k])) {
            return obj[k].map(function (v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }

      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    /***/

  },

  /***/
  "./node_modules/querystring/index.js":
  /*!*******************************************!*\
    !*** ./node_modules/querystring/index.js ***!
    \*******************************************/

  /*! no static exports found */

  /***/
  function node_modulesQuerystringIndexJs(module, exports, __webpack_require__) {
    "use strict";

    exports.decode = exports.parse = __webpack_require__(
    /*! ./decode */
    "./node_modules/querystring/decode.js");
    exports.encode = exports.stringify = __webpack_require__(
    /*! ./encode */
    "./node_modules/querystring/encode.js");
    /***/
  },

  /***/
  "./node_modules/url/url.js":
  /*!*********************************!*\
    !*** ./node_modules/url/url.js ***!
    \*********************************/

  /*! no static exports found */

  /***/
  function node_modulesUrlUrlJs(module, exports, __webpack_require__) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    var punycode = __webpack_require__(
    /*! punycode */
    "./node_modules/punycode/punycode.js");

    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    exports.Url = Url;

    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    } // Reference: RFC 3986, RFC 1808, RFC 2396
    // define these here so at least they only have to be
    // compiled once on the first module load.


    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,
        // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
        // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
        // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
        hostEndingChars = ['/', '?', '#'],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
        // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
        // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
        querystring = __webpack_require__(
    /*! querystring */
    "./node_modules/querystring/index.js");

    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && isObject(url) && url instanceof Url) return url;
      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }

    Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
      if (!isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }

      var rest = url; // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"

      rest = rest.trim();
      var proto = protocolPattern.exec(rest);

      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      } // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.


      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';

        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }

      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c
        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.
        // find the first instance of any hostEndingChars
        var hostEnd = -1;

        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        } // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.


        var auth, atSign;

        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        } // Now we have a portion which is definitely the auth.
        // Pull that off.


        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        } // the host is the remaining to the left of the first non-host char


        hostEnd = -1;

        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        } // if we still have not hit it, then the entire thing is a host.


        if (hostEnd === -1) hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd); // pull out port.

        this.parseHost(); // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.

        this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.

        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);

          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;

            if (!part.match(hostnamePartPattern)) {
              var newpart = '';

              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              } // we test again with ASCII char only


              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);

                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }

                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }

                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        } else {
          // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
          // IDNA Support: Returns a puny coded representation of "domain".
          // It only converts the part of the domain name that
          // has non ASCII characters. I.e. it dosent matter if
          // you call it with a domain that already is in ASCII.
          var domainArray = this.hostname.split('.');
          var newOut = [];

          for (var i = 0; i < domainArray.length; ++i) {
            var s = domainArray[i];
            newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
          }

          this.hostname = newOut.join('.');
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host; // strip [ and ] from the hostname
        // the host field still retains them, though

        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);

          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      } // now rest is set to the post-host stuff.
      // chop off any delim chars.


      if (!unsafeProtocol[lowerProto]) {
        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          var esc = encodeURIComponent(ae);

          if (esc === ae) {
            esc = escape(ae);
          }

          rest = rest.split(ae).join(esc);
        }
      } // chop off from the tail first.


      var hash = rest.indexOf('#');

      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }

      var qm = rest.indexOf('?');

      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);

        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }

        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
      }

      if (rest) this.pathname = rest;

      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = '/';
      } //to support http.request


      if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
      } // finally, reconstruct the href based on what has been validated.


      this.href = this.format();
      return this;
    }; // format a parsed object into a url string


    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (isString(obj)) obj = urlParse(obj);
      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
      return obj.format();
    }

    Url.prototype.format = function () {
      var auth = this.auth || '';

      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }

      var protocol = this.protocol || '',
          pathname = this.pathname || '',
          hash = this.hash || '',
          host = false,
          query = '';

      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

        if (this.port) {
          host += ':' + this.port;
        }
      }

      if (this.query && isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }

      var search = this.search || query && '?' + query || '';
      if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.

      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;
      pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');
      return protocol + host + pathname + search + hash;
    };

    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }

    Url.prototype.resolve = function (relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };

    function urlResolveObject(source, relative) {
      if (!source) return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }

    Url.prototype.resolveObject = function (relative) {
      if (isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }

      var result = new Url();
      Object.keys(this).forEach(function (k) {
        result[k] = this[k];
      }, this); // hash is always overridden, no matter what.
      // even href="" will remove it.

      result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

      if (relative.href === '') {
        result.href = result.format();
        return result;
      } // hrefs like //foo/bar always cut to the protocol.


      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        Object.keys(relative).forEach(function (k) {
          if (k !== 'protocol') result[k] = relative[k];
        }); //urlParse appends trailing / to urls like http://www.example.com

        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
      }

      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          Object.keys(relative).forEach(function (k) {
            result[k] = relative[k];
          });
          result.href = result.format();
          return result;
        }

        result.protocol = relative.protocol;

        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');

          while (relPath.length && !(relative.host = relPath.shift())) {
            ;
          }

          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }

        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port; // to support http.request

        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }

        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }

      var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
          isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
          mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
          removeAllDots = mustEndAbs,
          srcPath = result.pathname && result.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.

      if (psychotic) {
        result.hostname = '';
        result.port = null;

        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
        }

        result.host = '';

        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;

          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
          }

          relative.host = null;
        }

        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }

      if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === '' ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath; // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
          //this especialy happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }

        result.search = relative.search;
        result.query = relative.query; //to support http.request

        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }

        result.href = result.format();
        return result;
      }

      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null; //to support http.request

        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }

        result.href = result.format();
        return result;
      } // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.


      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0

      var up = 0;

      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];

        if (last == '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      } // if the path is allowed to go above the root, restore leading ..s


      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }

      if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }

      if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
        srcPath.push('');
      }

      var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }

      mustEndAbs = mustEndAbs || result.host && srcPath.length;

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }

      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      } //to support request.http


      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
      }

      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };

    Url.prototype.parseHost = function () {
      var host = this.host;
      var port = portPattern.exec(host);

      if (port) {
        port = port[0];

        if (port !== ':') {
          this.port = port.substr(1);
        }

        host = host.substr(0, host.length - port.length);
      }

      if (host) this.hostname = host;
    };

    function isString(arg) {
      return typeof arg === "string";
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }
    /***/

  },

  /***/
  "./node_modules/util/node_modules/inherits/inherits_browser.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesUtilNode_modulesInheritsInherits_browserJs(module, exports) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    /***/

  },

  /***/
  "./node_modules/util/support/isBufferBrowser.js":
  /*!******************************************************!*\
    !*** ./node_modules/util/support/isBufferBrowser.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesUtilSupportIsBufferBrowserJs(module, exports) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
    };
    /***/

  },

  /***/
  "./node_modules/util/util.js":
  /*!***********************************!*\
    !*** ./node_modules/util/util.js ***!
    \***********************************/

  /*! no static exports found */

  /***/
  function node_modulesUtilUtilJs(module, exports, __webpack_require__) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};

      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }

      return descriptors;
    };

    var formatRegExp = /%[sdj%]/g;

    exports.format = function (f) {
      if (!isString(f)) {
        var objects = [];

        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }

        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%';
        if (i >= len) return x;

        switch (x) {
          case '%s':
            return String(args[i++]);

          case '%d':
            return Number(args[i++]);

          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }

          default:
            return x;
        }
      });

      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }

      return str;
    }; // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.


    exports.deprecate = function (fn, msg) {
      if (typeof process !== 'undefined' && process.noDeprecation === true) {
        return fn;
      } // Allow for deprecating things in the process of starting up.


      if (typeof process === 'undefined') {
        return function () {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }

      var warned = false;

      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }

          warned = true;
        }

        return fn.apply(this, arguments);
      }

      return deprecated;
    };

    var debugs = {};
    var debugEnviron;

    exports.debuglog = function (set) {
      if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();

      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;

          debugs[set] = function () {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function () {};
        }
      }

      return debugs[set];
    };
    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */

    /* legacy: obj, showHidden, depth, colors*/


    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      }; // legacy...

      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];

      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      } // set default options


      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    }; // Don't use 'blue' not visible on cmd.exe

    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };

    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);

        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }

        return ret;
      } // Primitive types cannot have properties


      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      } // Look up the keys of the object.


      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      } // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      } // Some type of object without properties can be shortcutted.


      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}']; // Make Array say that they are Array

      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      } // Make functions say that they are functions


      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      } // Make RegExps say that they are RegExps


      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      } // Make dates with properties first say the date


      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      } // Make error with message first say the error


      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    } // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.


    function isArray(ar) {
      return Array.isArray(ar);
    }

    exports.isArray = isArray;

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    exports.isBoolean = isBoolean;

    function isNull(arg) {
      return arg === null;
    }

    exports.isNull = isNull;

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    exports.isNullOrUndefined = isNullOrUndefined;

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    exports.isNumber = isNumber;

    function isString(arg) {
      return typeof arg === 'string';
    }

    exports.isString = isString;

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }

    exports.isSymbol = isSymbol;

    function isUndefined(arg) {
      return arg === void 0;
    }

    exports.isUndefined = isUndefined;

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    exports.isRegExp = isRegExp;

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    exports.isObject = isObject;

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    exports.isDate = isDate;

    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    exports.isError = isError;

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    exports.isFunction = isFunction;

    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
      typeof arg === 'undefined';
    }

    exports.isPrimitive = isPrimitive;
    exports.isBuffer = __webpack_require__(
    /*! ./support/isBuffer */
    "./node_modules/util/support/isBufferBrowser.js");

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }

    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    } // log is just a thin wrapper to console.log that prepends a timestamp


    exports.log = function () {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * The Function.prototype.inherits from lang.js rewritten as a standalone
     * function (not on Function.prototype). NOTE: If this file is to be loaded
     * during bootstrapping this function needs to be rewritten using some native
     * functions as prototype setup using normal JavaScript does not work as
     * expected during bootstrapping (see mirror.js in r114903).
     *
     * @param {function} ctor Constructor function which needs to inherit the
     *     prototype.
     * @param {function} superCtor Constructor function to inherit prototype from.
     */


    exports.inherits = __webpack_require__(
    /*! inherits */
    "./node_modules/util/node_modules/inherits/inherits_browser.js");

    exports._extend = function (origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;

      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }

      return origin;
    };

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

    exports.promisify = function promisify(original) {
      if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];

        if (typeof fn !== 'function') {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }

        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }

      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];

        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        args.push(function (err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });

        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }

        return promise;
      }

      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };

    exports.promisify.custom = kCustomPromisifiedSymbol;

    function callbackifyOnRejected(reason, cb) {
      // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
      // Because `null` is a special error value in callbacks which means "no error
      // occurred", we error-wrap so the callback consumer can distinguish between
      // "the promise rejected with null" or "the promise fulfilled with undefined".
      if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
      }

      return cb(reason);
    }

    function callbackify(original) {
      if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
      } // We DO NOT return the promise as it gives the user a false sense that
      // the promise is actually somehow related to the callback's execution
      // and that the callback throwing will reject the promise.


      function callbackified() {
        var args = [];

        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        var maybeCb = args.pop();

        if (typeof maybeCb !== 'function') {
          throw new TypeError('The last argument must be of type Function');
        }

        var self = this;

        var cb = function cb() {
          return maybeCb.apply(self, arguments);
        }; // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)


        original.apply(this, args).then(function (ret) {
          process.nextTick(cb, null, ret);
        }, function (rej) {
          process.nextTick(callbackifyOnRejected, rej, cb);
        });
      }

      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }

    exports.callbackify = callbackify;
    /***/
  },

  /***/
  "./node_modules/webpack/buildin/module.js":
  /*!***********************************!*\
    !*** (webpack)/buildin/module.js ***!
    \***********************************/

  /*! no static exports found */

  /***/
  function node_modulesWebpackBuildinModuleJs(module, exports) {
    module.exports = function (module) {
      if (!module.webpackPolyfill) {
        module.deprecate = function () {};

        module.paths = []; // module.parent = undefined by default

        if (!module.children) module.children = [];
        Object.defineProperty(module, "loaded", {
          enumerable: true,
          get: function get() {
            return module.l;
          }
        });
        Object.defineProperty(module, "id", {
          enumerable: true,
          get: function get() {
            return module.i;
          }
        });
        module.webpackPolyfill = 1;
      }

      return module;
    };
    /***/

  },

  /***/
  "./src/app/public/services/s3.service.ts":
  /*!***********************************************!*\
    !*** ./src/app/public/services/s3.service.ts ***!
    \***********************************************/

  /*! exports provided: S3Service */

  /***/
  function srcAppPublicServicesS3ServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "S3Service", function () {
      return S3Service;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var aws_sdk_clients_s3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! aws-sdk/clients/s3 */
    "./node_modules/aws-sdk/clients/s3.js");
    /* harmony import */


    var aws_sdk_clients_s3__WEBPACK_IMPORTED_MODULE_2___default =
    /*#__PURE__*/
    __webpack_require__.n(aws_sdk_clients_s3__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var _main_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./main.service */
    "./src/app/public/services/main.service.ts");

    var S3Service =
    /*#__PURE__*/
    function () {
      function S3Service(mainService) {
        _classCallCheck(this, S3Service);

        this.mainService = mainService;
        /** Backend path that retrieves S3 credentials */

        this.S3_CREDENTIALS_API = 'credentials/s3-credentials';
        /** S3 Bucket name */

        this.S3_BUCKET = 'persing';
        /** S3 bucket region */

        this.S3_BUCKET_REGION = 'us-east-1';
        /** S3 bucket ACL */

        this.S3_BUCKET_ACL = 'public-read';
      }
      /**
       * Method that uploads a file in amazon S3
       * @param param0 File: File the is going to be uploaded / Key: Path used to store the file ->(next line)
       * / Callback: callback that handles S3 response
       */


      _createClass(S3Service, [{
        key: "uploadFile",
        value: function uploadFile(_ref2) {
          var file = _ref2.file,
              key = _ref2.key,
              callback = _ref2.callback;
          return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0,
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee() {
            var _this58 = this;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.getS3Credentials().then(function (response) {
                      var contentType = file.type;
                      _this58.bucket = new aws_sdk_clients_s3__WEBPACK_IMPORTED_MODULE_2__({
                        accessKeyId: response.accessKeyId,
                        secretAccessKey: response.secretAccessKey,
                        region: _this58.S3_BUCKET_REGION
                      });
                      var params = {
                        Bucket: _this58.S3_BUCKET,
                        Key: key,
                        Body: file,
                        ACL: _this58.S3_BUCKET_ACL,
                        ContentType: contentType
                      };
                      var options = {
                        // Part Size of 10mb
                        partSize: 10 * 1024 * 1024,
                        queueSize: 1,
                        // Give the owner of the bucket full control
                        ACL: _this58.S3_BUCKET_ACL
                      };

                      _this58.bucket.upload(params, options, callback);
                    });

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
        }
        /**
         * Deletes an object from S3.
         * @param param0
         */

      }, {
        key: "deleteFileS3",
        value: function deleteFileS3(_ref3) {
          var key = _ref3.key,
              callback = _ref3.callback;
          return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0,
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee2() {
            var _this59 = this;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this.getS3Credentials().then(function (response) {
                      _this59.bucket = new aws_sdk_clients_s3__WEBPACK_IMPORTED_MODULE_2__({
                        accessKeyId: response.accessKeyId,
                        secretAccessKey: response.secretAccessKey,
                        region: _this59.S3_BUCKET_REGION
                      });
                      var params = {
                        Bucket: _this59.S3_BUCKET,
                        Key: key
                      };

                      _this59.bucket.deleteObject(params, callback);
                    });

                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
        }
        /**
         * Copies an s3 object from one path to another
         */

      }, {
        key: "copyObject",
        value: function copyObject(_ref4) {
          var sourcePath = _ref4.sourcePath,
              newKey = _ref4.newKey,
              callback = _ref4.callback;
          return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0,
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee3() {
            var _this60 = this;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    this.getS3Credentials().then(function (response) {
                      _this60.bucket = new aws_sdk_clients_s3__WEBPACK_IMPORTED_MODULE_2__({
                        accessKeyId: response.accessKeyId,
                        secretAccessKey: response.secretAccessKey,
                        region: _this60.S3_BUCKET_REGION
                      });
                      var params = {
                        Bucket: _this60.S3_BUCKET,
                        CopySource: "".concat(_this60.S3_BUCKET, "/").concat(sourcePath),
                        Key: newKey
                      };

                      _this60.bucket.copyObject(params, callback);
                    });

                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
        }
        /**
         * Generates a random key
         */

      }, {
        key: "generateKey",
        value: function generateKey() {
          var result = '';
          var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          var charactersLength = characters.length;

          for (var i = 0; i < 15; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
          }

          return result;
        }
        /**
         * Retrieves s3 api credentials from the backend
         * @return Observable
         */

      }, {
        key: "getS3Credentials",
        value: function getS3Credentials() {
          return this.mainService.get({
            api: this.S3_CREDENTIALS_API
          });
        }
      }]);

      return S3Service;
    }();

    S3Service.ɵfac = function S3Service_Factory(t) {
      return new (t || S3Service)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_main_service__WEBPACK_IMPORTED_MODULE_3__["MainService"]));
    };

    S3Service.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
      token: S3Service,
      factory: S3Service.ɵfac,
      providedIn: 'root'
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](S3Service, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
        args: [{
          providedIn: 'root'
        }]
      }], function () {
        return [{
          type: _main_service__WEBPACK_IMPORTED_MODULE_3__["MainService"]
        }];
      }, null);
    })();
    /***/

  },

  /***/
  4:
  /*!********************!*\
    !*** fs (ignored) ***!
    \********************/

  /*! no static exports found */

  /***/
  function _(module, exports) {
    /* (ignored) */

    /***/
  }
}]);
//# sourceMappingURL=default~auth-auth-module~public-public-module-es5.js.map